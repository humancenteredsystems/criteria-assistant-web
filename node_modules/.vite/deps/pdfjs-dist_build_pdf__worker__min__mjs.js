import "./chunk-X34TS6PR.js";

// node_modules/pdfjs-dist/build/pdf.worker.min.mjs
var e = !("object" != typeof process || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && "browser" !== process.type);
var t = [1e-3, 0, 0, 1e-3, 0, 0];
var a = 1.35;
var r = 0.35;
var i = 0.25925925925925924;
var n = 1;
var s = 2;
var o = 4;
var c = 8;
var l = 16;
var h = 64;
var u = 128;
var d = 256;
var f = "pdfjs_internal_editor_";
var g = 3;
var p = 9;
var m = 13;
var b = 15;
var y = 101;
var w = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 };
var x = 0;
var S = 4;
var k = 1;
var C = 2;
var v = 3;
var F = 1;
var T = 2;
var O = 3;
var M = 4;
var D = 5;
var R = 6;
var N = 7;
var E = 8;
var L = 9;
var j = 10;
var _ = 11;
var U = 12;
var X = 13;
var q = 14;
var H = 15;
var W = 16;
var z = 17;
var $ = 20;
var G = "Group";
var V = "R";
var K = 1;
var J = 2;
var Y = 4;
var Z = 16;
var Q = 32;
var ee = 128;
var te = 512;
var ae = 1;
var re = 2;
var ie = 4096;
var ne = 8192;
var se = 32768;
var oe = 65536;
var ce = 131072;
var le = 1048576;
var he = 2097152;
var ue = 8388608;
var de = 16777216;
var fe = 1;
var ge = 2;
var pe = 3;
var me = 4;
var be = 5;
var ye = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" };
var we = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" };
var xe = { O: "PageOpen", C: "PageClose" };
var Se = 1;
var Ae = 5;
var ke = 1;
var Ce = 2;
var ve = 3;
var Fe = 4;
var Ie = 5;
var Te = 6;
var Oe = 7;
var Me = 8;
var De = 9;
var Be = 10;
var Re = 11;
var Ne = 12;
var Ee = 13;
var Pe = 14;
var Le = 15;
var je = 16;
var _e = 17;
var Ue = 18;
var Xe = 19;
var qe = 20;
var He = 21;
var We = 22;
var ze = 23;
var $e = 24;
var Ge = 25;
var Ve = 26;
var Ke = 27;
var Je = 28;
var Ye = 29;
var Ze = 30;
var Qe = 31;
var et = 32;
var tt = 33;
var at = 34;
var rt = 35;
var it = 36;
var nt = 37;
var st = 38;
var ot = 39;
var ct = 40;
var lt = 41;
var ht = 42;
var ut = 43;
var dt = 44;
var ft = 45;
var gt = 46;
var pt = 47;
var mt = 48;
var bt = 49;
var yt = 50;
var wt = 51;
var xt = 52;
var St = 53;
var At = 54;
var kt = 55;
var Ct = 56;
var vt = 57;
var Ft = 58;
var It = 59;
var Tt = 60;
var Ot = 61;
var Mt = 62;
var Dt = 63;
var Bt = 64;
var Rt = 65;
var Nt = 66;
var Et = 67;
var Pt = 68;
var Lt = 69;
var jt = 70;
var _t = 71;
var Ut = 72;
var Xt = 73;
var qt = 74;
var Ht = 75;
var Wt = 76;
var zt = 77;
var $t = 80;
var Gt = 81;
var Vt = 83;
var Kt = 84;
var Jt = 85;
var Yt = 86;
var Zt = 87;
var Qt = 88;
var ea = 89;
var ta = 90;
var aa = 91;
var ra = 92;
var ia = 93;
var na = 94;
var sa = 0;
var oa = 1;
var ca = 2;
var la = 3;
var ha = 1;
var ua = 2;
var da = Se;
function getVerbosityLevel() {
  return da;
}
function info(e2) {
  da >= Ae && console.log(`Info: ${e2}`);
}
function warn(e2) {
  da >= Se && console.log(`Warning: ${e2}`);
}
function unreachable(e2) {
  throw new Error(e2);
}
function assert(e2, t2) {
  e2 || unreachable(t2);
}
function createValidAbsoluteUrl(e2, t2 = null, a2 = null) {
  if (!e2) return null;
  if (a2 && "string" == typeof e2) {
    if (a2.addDefaultProtocol && e2.startsWith("www.")) {
      const t3 = e2.match(/\./g);
      t3?.length >= 2 && (e2 = `http://${e2}`);
    }
    if (a2.tryConvertEncoding) try {
      e2 = stringToUTF8String(e2);
    } catch {
    }
  }
  const r2 = t2 ? URL.parse(e2, t2) : URL.parse(e2);
  return (function _isValidProtocol(e3) {
    switch (e3?.protocol) {
      case "http:":
      case "https:":
      case "ftp:":
      case "mailto:":
      case "tel:":
        return true;
      default:
        return false;
    }
  })(r2) ? r2 : null;
}
function shadow(e2, t2, a2, r2 = false) {
  Object.defineProperty(e2, t2, { value: a2, enumerable: !r2, configurable: true, writable: false });
  return a2;
}
var fa = (function BaseExceptionClosure() {
  function BaseException(e2, t2) {
    this.message = e2;
    this.name = t2;
  }
  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
})();
var PasswordException = class extends fa {
  constructor(e2, t2) {
    super(e2, "PasswordException");
    this.code = t2;
  }
};
var UnknownErrorException = class extends fa {
  constructor(e2, t2) {
    super(e2, "UnknownErrorException");
    this.details = t2;
  }
};
var InvalidPDFException = class extends fa {
  constructor(e2) {
    super(e2, "InvalidPDFException");
  }
};
var ResponseException = class extends fa {
  constructor(e2, t2, a2) {
    super(e2, "ResponseException");
    this.status = t2;
    this.missing = a2;
  }
};
var FormatError = class extends fa {
  constructor(e2) {
    super(e2, "FormatError");
  }
};
var AbortException = class extends fa {
  constructor(e2) {
    super(e2, "AbortException");
  }
};
function bytesToString(e2) {
  "object" == typeof e2 && void 0 !== e2?.length || unreachable("Invalid argument for bytesToString");
  const t2 = e2.length, a2 = 8192;
  if (t2 < a2) return String.fromCharCode.apply(null, e2);
  const r2 = [];
  for (let i2 = 0; i2 < t2; i2 += a2) {
    const n2 = Math.min(i2 + a2, t2), s2 = e2.subarray(i2, n2);
    r2.push(String.fromCharCode.apply(null, s2));
  }
  return r2.join("");
}
function stringToBytes(e2) {
  "string" != typeof e2 && unreachable("Invalid argument for stringToBytes");
  const t2 = e2.length, a2 = new Uint8Array(t2);
  for (let r2 = 0; r2 < t2; ++r2) a2[r2] = 255 & e2.charCodeAt(r2);
  return a2;
}
function string32(e2) {
  return String.fromCharCode(e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2);
}
function objectSize(e2) {
  return Object.keys(e2).length;
}
var FeatureTest = class {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", (function isLittleEndian() {
      const e2 = new Uint8Array(4);
      e2[0] = 1;
      return 1 === new Uint32Array(e2.buffer, 0, 1)[0];
    })());
  }
  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", (function isEvalSupported() {
      try {
        new Function("");
        return true;
      } catch {
        return false;
      }
    })());
  }
  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
  }
  static get isImageDecoderSupported() {
    return shadow(this, "isImageDecoderSupported", "undefined" != typeof ImageDecoder);
  }
  static get platform() {
    const { platform: e2, userAgent: t2 } = navigator;
    return shadow(this, "platform", { isAndroid: t2.includes("Android"), isLinux: e2.includes("Linux"), isMac: e2.includes("Mac"), isWindows: e2.includes("Win"), isFirefox: t2.includes("Firefox") });
  }
  static get isCSSRoundSupported() {
    return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
  }
};
var ga = Array.from(Array(256).keys(), ((e2) => e2.toString(16).padStart(2, "0")));
var Util = class {
  static makeHexColor(e2, t2, a2) {
    return `#${ga[e2]}${ga[t2]}${ga[a2]}`;
  }
  static scaleMinMax(e2, t2) {
    let a2;
    if (e2[0]) {
      if (e2[0] < 0) {
        a2 = t2[0];
        t2[0] = t2[2];
        t2[2] = a2;
      }
      t2[0] *= e2[0];
      t2[2] *= e2[0];
      if (e2[3] < 0) {
        a2 = t2[1];
        t2[1] = t2[3];
        t2[3] = a2;
      }
      t2[1] *= e2[3];
      t2[3] *= e2[3];
    } else {
      a2 = t2[0];
      t2[0] = t2[1];
      t2[1] = a2;
      a2 = t2[2];
      t2[2] = t2[3];
      t2[3] = a2;
      if (e2[1] < 0) {
        a2 = t2[1];
        t2[1] = t2[3];
        t2[3] = a2;
      }
      t2[1] *= e2[1];
      t2[3] *= e2[1];
      if (e2[2] < 0) {
        a2 = t2[0];
        t2[0] = t2[2];
        t2[2] = a2;
      }
      t2[0] *= e2[2];
      t2[2] *= e2[2];
    }
    t2[0] += e2[4];
    t2[1] += e2[5];
    t2[2] += e2[4];
    t2[3] += e2[5];
  }
  static transform(e2, t2) {
    return [e2[0] * t2[0] + e2[2] * t2[1], e2[1] * t2[0] + e2[3] * t2[1], e2[0] * t2[2] + e2[2] * t2[3], e2[1] * t2[2] + e2[3] * t2[3], e2[0] * t2[4] + e2[2] * t2[5] + e2[4], e2[1] * t2[4] + e2[3] * t2[5] + e2[5]];
  }
  static applyTransform(e2, t2, a2 = 0) {
    const r2 = e2[a2], i2 = e2[a2 + 1];
    e2[a2] = r2 * t2[0] + i2 * t2[2] + t2[4];
    e2[a2 + 1] = r2 * t2[1] + i2 * t2[3] + t2[5];
  }
  static applyTransformToBezier(e2, t2, a2 = 0) {
    const r2 = t2[0], i2 = t2[1], n2 = t2[2], s2 = t2[3], o2 = t2[4], c2 = t2[5];
    for (let t3 = 0; t3 < 6; t3 += 2) {
      const l2 = e2[a2 + t3], h2 = e2[a2 + t3 + 1];
      e2[a2 + t3] = l2 * r2 + h2 * n2 + o2;
      e2[a2 + t3 + 1] = l2 * i2 + h2 * s2 + c2;
    }
  }
  static applyInverseTransform(e2, t2) {
    const a2 = e2[0], r2 = e2[1], i2 = t2[0] * t2[3] - t2[1] * t2[2];
    e2[0] = (a2 * t2[3] - r2 * t2[2] + t2[2] * t2[5] - t2[4] * t2[3]) / i2;
    e2[1] = (-a2 * t2[1] + r2 * t2[0] + t2[4] * t2[1] - t2[5] * t2[0]) / i2;
  }
  static axialAlignedBoundingBox(e2, t2, a2) {
    const r2 = t2[0], i2 = t2[1], n2 = t2[2], s2 = t2[3], o2 = t2[4], c2 = t2[5], l2 = e2[0], h2 = e2[1], u2 = e2[2], d2 = e2[3];
    let f2 = r2 * l2 + o2, g2 = f2, p2 = r2 * u2 + o2, m2 = p2, b2 = s2 * h2 + c2, y2 = b2, w2 = s2 * d2 + c2, x2 = w2;
    if (0 !== i2 || 0 !== n2) {
      const e3 = i2 * l2, t3 = i2 * u2, a3 = n2 * h2, r3 = n2 * d2;
      f2 += a3;
      m2 += a3;
      p2 += r3;
      g2 += r3;
      b2 += e3;
      x2 += e3;
      w2 += t3;
      y2 += t3;
    }
    a2[0] = Math.min(a2[0], f2, p2, g2, m2);
    a2[1] = Math.min(a2[1], b2, w2, y2, x2);
    a2[2] = Math.max(a2[2], f2, p2, g2, m2);
    a2[3] = Math.max(a2[3], b2, w2, y2, x2);
  }
  static inverseTransform(e2) {
    const t2 = e2[0] * e2[3] - e2[1] * e2[2];
    return [e2[3] / t2, -e2[1] / t2, -e2[2] / t2, e2[0] / t2, (e2[2] * e2[5] - e2[4] * e2[3]) / t2, (e2[4] * e2[1] - e2[5] * e2[0]) / t2];
  }
  static singularValueDecompose2dScale(e2, t2) {
    const a2 = e2[0], r2 = e2[1], i2 = e2[2], n2 = e2[3], s2 = a2 ** 2 + r2 ** 2, o2 = a2 * i2 + r2 * n2, c2 = i2 ** 2 + n2 ** 2, l2 = (s2 + c2) / 2, h2 = Math.sqrt(l2 ** 2 - (s2 * c2 - o2 ** 2));
    t2[0] = Math.sqrt(l2 + h2 || 1);
    t2[1] = Math.sqrt(l2 - h2 || 1);
  }
  static normalizeRect(e2) {
    const t2 = e2.slice(0);
    if (e2[0] > e2[2]) {
      t2[0] = e2[2];
      t2[2] = e2[0];
    }
    if (e2[1] > e2[3]) {
      t2[1] = e2[3];
      t2[3] = e2[1];
    }
    return t2;
  }
  static intersect(e2, t2) {
    const a2 = Math.max(Math.min(e2[0], e2[2]), Math.min(t2[0], t2[2])), r2 = Math.min(Math.max(e2[0], e2[2]), Math.max(t2[0], t2[2]));
    if (a2 > r2) return null;
    const i2 = Math.max(Math.min(e2[1], e2[3]), Math.min(t2[1], t2[3])), n2 = Math.min(Math.max(e2[1], e2[3]), Math.max(t2[1], t2[3]));
    return i2 > n2 ? null : [a2, i2, r2, n2];
  }
  static pointBoundingBox(e2, t2, a2) {
    a2[0] = Math.min(a2[0], e2);
    a2[1] = Math.min(a2[1], t2);
    a2[2] = Math.max(a2[2], e2);
    a2[3] = Math.max(a2[3], t2);
  }
  static rectBoundingBox(e2, t2, a2, r2, i2) {
    i2[0] = Math.min(i2[0], e2, a2);
    i2[1] = Math.min(i2[1], t2, r2);
    i2[2] = Math.max(i2[2], e2, a2);
    i2[3] = Math.max(i2[3], t2, r2);
  }
  static #e(e2, t2, a2, r2, i2, n2, s2, o2, c2, l2) {
    if (c2 <= 0 || c2 >= 1) return;
    const h2 = 1 - c2, u2 = c2 * c2, d2 = u2 * c2, f2 = h2 * (h2 * (h2 * e2 + 3 * c2 * t2) + 3 * u2 * a2) + d2 * r2, g2 = h2 * (h2 * (h2 * i2 + 3 * c2 * n2) + 3 * u2 * s2) + d2 * o2;
    l2[0] = Math.min(l2[0], f2);
    l2[1] = Math.min(l2[1], g2);
    l2[2] = Math.max(l2[2], f2);
    l2[3] = Math.max(l2[3], g2);
  }
  static #t(e2, t2, a2, r2, i2, n2, s2, o2, c2, l2, h2, u2) {
    if (Math.abs(c2) < 1e-12) {
      Math.abs(l2) >= 1e-12 && this.#e(e2, t2, a2, r2, i2, n2, s2, o2, -h2 / l2, u2);
      return;
    }
    const d2 = l2 ** 2 - 4 * h2 * c2;
    if (d2 < 0) return;
    const f2 = Math.sqrt(d2), g2 = 2 * c2;
    this.#e(e2, t2, a2, r2, i2, n2, s2, o2, (-l2 + f2) / g2, u2);
    this.#e(e2, t2, a2, r2, i2, n2, s2, o2, (-l2 - f2) / g2, u2);
  }
  static bezierBoundingBox(e2, t2, a2, r2, i2, n2, s2, o2, c2) {
    c2[0] = Math.min(c2[0], e2, s2);
    c2[1] = Math.min(c2[1], t2, o2);
    c2[2] = Math.max(c2[2], e2, s2);
    c2[3] = Math.max(c2[3], t2, o2);
    this.#t(e2, a2, i2, s2, t2, r2, n2, o2, 3 * (3 * (a2 - i2) - e2 + s2), 6 * (e2 - 2 * a2 + i2), 3 * (a2 - e2), c2);
    this.#t(e2, a2, i2, s2, t2, r2, n2, o2, 3 * (3 * (r2 - n2) - t2 + o2), 6 * (t2 - 2 * r2 + n2), 3 * (r2 - t2), c2);
  }
};
var pa = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
function stringToPDFString(e2, t2 = false) {
  if (e2[0] >= "ï") {
    let a3;
    if ("þ" === e2[0] && "ÿ" === e2[1]) {
      a3 = "utf-16be";
      e2.length % 2 == 1 && (e2 = e2.slice(0, -1));
    } else if ("ÿ" === e2[0] && "þ" === e2[1]) {
      a3 = "utf-16le";
      e2.length % 2 == 1 && (e2 = e2.slice(0, -1));
    } else "ï" === e2[0] && "»" === e2[1] && "¿" === e2[2] && (a3 = "utf-8");
    if (a3) try {
      const r2 = new TextDecoder(a3, { fatal: true }), i2 = stringToBytes(e2), n2 = r2.decode(i2);
      return t2 || !n2.includes("\x1B") ? n2 : n2.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "");
    } catch (e3) {
      warn(`stringToPDFString: "${e3}".`);
    }
  }
  const a2 = [];
  for (let r2 = 0, i2 = e2.length; r2 < i2; r2++) {
    const n2 = e2.charCodeAt(r2);
    if (!t2 && 27 === n2) {
      for (; ++r2 < i2 && 27 !== e2.charCodeAt(r2); ) ;
      continue;
    }
    const s2 = pa[n2];
    a2.push(s2 ? String.fromCharCode(s2) : e2.charAt(r2));
  }
  return a2.join("");
}
function stringToUTF8String(e2) {
  return decodeURIComponent(escape(e2));
}
function utf8StringToString(e2) {
  return unescape(encodeURIComponent(e2));
}
function isArrayEqual(e2, t2) {
  if (e2.length !== t2.length) return false;
  for (let a2 = 0, r2 = e2.length; a2 < r2; a2++) if (e2[a2] !== t2[a2]) return false;
  return true;
}
function getModificationDate(e2 = /* @__PURE__ */ new Date()) {
  e2 instanceof Date || (e2 = new Date(e2));
  return [e2.getUTCFullYear().toString(), (e2.getUTCMonth() + 1).toString().padStart(2, "0"), e2.getUTCDate().toString().padStart(2, "0"), e2.getUTCHours().toString().padStart(2, "0"), e2.getUTCMinutes().toString().padStart(2, "0"), e2.getUTCSeconds().toString().padStart(2, "0")].join("");
}
var ma = null;
var ba = null;
function MathClamp(e2, t2, a2) {
  return Math.min(Math.max(e2, t2), a2);
}
function toHexUtil(e2) {
  return Uint8Array.prototype.toHex ? e2.toHex() : Array.from(e2, ((e3) => ga[e3])).join("");
}
"function" != typeof Promise.try && (Promise.try = function(e2, ...t2) {
  return new Promise(((a2) => {
    a2(e2(...t2));
  }));
});
"function" != typeof Math.sumPrecise && (Math.sumPrecise = function(e2) {
  return e2.reduce(((e3, t2) => e3 + t2), 0);
});
var ya = Symbol("CIRCULAR_REF");
var wa = Symbol("EOF");
var xa = /* @__PURE__ */ Object.create(null);
var Sa = /* @__PURE__ */ Object.create(null);
var Aa = /* @__PURE__ */ Object.create(null);
var Name = class _Name {
  constructor(e2) {
    this.name = e2;
  }
  static get(e2) {
    return Sa[e2] ||= new _Name(e2);
  }
};
var Cmd = class _Cmd {
  constructor(e2) {
    this.cmd = e2;
  }
  static get(e2) {
    return xa[e2] ||= new _Cmd(e2);
  }
};
var ka = function nonSerializableClosure() {
  return ka;
};
var Dict = class _Dict {
  constructor(e2 = null) {
    this._map = /* @__PURE__ */ new Map();
    this.xref = e2;
    this.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = ka;
  }
  assignXref(e2) {
    this.xref = e2;
  }
  get size() {
    return this._map.size;
  }
  get(e2, t2, a2) {
    let r2 = this._map.get(e2);
    if (void 0 === r2 && void 0 !== t2) {
      r2 = this._map.get(t2);
      void 0 === r2 && void 0 !== a2 && (r2 = this._map.get(a2));
    }
    return r2 instanceof Ref && this.xref ? this.xref.fetch(r2, this.suppressEncryption) : r2;
  }
  async getAsync(e2, t2, a2) {
    let r2 = this._map.get(e2);
    if (void 0 === r2 && void 0 !== t2) {
      r2 = this._map.get(t2);
      void 0 === r2 && void 0 !== a2 && (r2 = this._map.get(a2));
    }
    return r2 instanceof Ref && this.xref ? this.xref.fetchAsync(r2, this.suppressEncryption) : r2;
  }
  getArray(e2, t2, a2) {
    let r2 = this._map.get(e2);
    if (void 0 === r2 && void 0 !== t2) {
      r2 = this._map.get(t2);
      void 0 === r2 && void 0 !== a2 && (r2 = this._map.get(a2));
    }
    r2 instanceof Ref && this.xref && (r2 = this.xref.fetch(r2, this.suppressEncryption));
    if (Array.isArray(r2)) {
      r2 = r2.slice();
      for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) r2[e3] instanceof Ref && this.xref && (r2[e3] = this.xref.fetch(r2[e3], this.suppressEncryption));
    }
    return r2;
  }
  getRaw(e2) {
    return this._map.get(e2);
  }
  getKeys() {
    return [...this._map.keys()];
  }
  getRawValues() {
    return [...this._map.values()];
  }
  set(e2, t2) {
    this._map.set(e2, t2);
  }
  setIfNotExists(e2, t2) {
    this.has(e2) || this.set(e2, t2);
  }
  setIfNumber(e2, t2) {
    "number" == typeof t2 && this.set(e2, t2);
  }
  setIfArray(e2, t2) {
    (Array.isArray(t2) || ArrayBuffer.isView(t2)) && this.set(e2, t2);
  }
  setIfDefined(e2, t2) {
    null != t2 && this.set(e2, t2);
  }
  setIfName(e2, t2) {
    "string" == typeof t2 ? this.set(e2, Name.get(t2)) : t2 instanceof Name && this.set(e2, t2);
  }
  has(e2) {
    return this._map.has(e2);
  }
  *[Symbol.iterator]() {
    for (const [e2, t2] of this._map) yield [e2, t2 instanceof Ref && this.xref ? this.xref.fetch(t2, this.suppressEncryption) : t2];
  }
  static get empty() {
    const e2 = new _Dict(null);
    e2.set = (e3, t2) => {
      unreachable("Should not call `set` on the empty dictionary.");
    };
    return shadow(this, "empty", e2);
  }
  static merge({ xref: e2, dictArray: t2, mergeSubDicts: a2 = false }) {
    const r2 = new _Dict(e2), i2 = /* @__PURE__ */ new Map();
    for (const e3 of t2) if (e3 instanceof _Dict) for (const [t3, r3] of e3._map) {
      let e4 = i2.get(t3);
      if (void 0 === e4) {
        e4 = [];
        i2.set(t3, e4);
      } else if (!(a2 && r3 instanceof _Dict)) continue;
      e4.push(r3);
    }
    for (const [t3, a3] of i2) {
      if (1 === a3.length || !(a3[0] instanceof _Dict)) {
        r2._map.set(t3, a3[0]);
        continue;
      }
      const i3 = new _Dict(e2);
      for (const e3 of a3) for (const [t4, a4] of e3._map) i3._map.has(t4) || i3._map.set(t4, a4);
      i3.size > 0 && r2._map.set(t3, i3);
    }
    i2.clear();
    return r2.size > 0 ? r2 : _Dict.empty;
  }
  clone() {
    const e2 = new _Dict(this.xref);
    for (const t2 of this.getKeys()) e2.set(t2, this.getRaw(t2));
    return e2;
  }
  delete(e2) {
    delete this._map[e2];
  }
};
var Ref = class _Ref {
  constructor(e2, t2) {
    this.num = e2;
    this.gen = t2;
  }
  toString() {
    return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
  }
  static fromString(e2) {
    const t2 = Aa[e2];
    if (t2) return t2;
    const a2 = /^(\d+)R(\d*)$/.exec(e2);
    return a2 && "0" !== a2[1] ? Aa[e2] = new _Ref(parseInt(a2[1]), a2[2] ? parseInt(a2[2]) : 0) : null;
  }
  static get(e2, t2) {
    const a2 = 0 === t2 ? `${e2}R` : `${e2}R${t2}`;
    return Aa[a2] ||= new _Ref(e2, t2);
  }
};
var RefSet = class {
  constructor(e2 = null) {
    this._set = new Set(e2?._set);
  }
  has(e2) {
    return this._set.has(e2.toString());
  }
  put(e2) {
    this._set.add(e2.toString());
  }
  remove(e2) {
    this._set.delete(e2.toString());
  }
  [Symbol.iterator]() {
    return this._set.values();
  }
  clear() {
    this._set.clear();
  }
};
var RefSetCache = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._map.size;
  }
  get(e2) {
    return this._map.get(e2.toString());
  }
  has(e2) {
    return this._map.has(e2.toString());
  }
  put(e2, t2) {
    this._map.set(e2.toString(), t2);
  }
  putAlias(e2, t2) {
    this._map.set(e2.toString(), this.get(t2));
  }
  [Symbol.iterator]() {
    return this._map.values();
  }
  clear() {
    this._map.clear();
  }
  *values() {
    yield* this._map.values();
  }
  *items() {
    for (const [e2, t2] of this._map) yield [Ref.fromString(e2), t2];
  }
};
function isName(e2, t2) {
  return e2 instanceof Name && (void 0 === t2 || e2.name === t2);
}
function isCmd(e2, t2) {
  return e2 instanceof Cmd && (void 0 === t2 || e2.cmd === t2);
}
function isDict(e2, t2) {
  return e2 instanceof Dict && (void 0 === t2 || isName(e2.get("Type"), t2));
}
function isRefsEqual(e2, t2) {
  return e2.num === t2.num && e2.gen === t2.gen;
}
var BaseStream = class {
  get length() {
    unreachable("Abstract getter `length` accessed");
  }
  get isEmpty() {
    unreachable("Abstract getter `isEmpty` accessed");
  }
  get isDataLoaded() {
    return shadow(this, "isDataLoaded", true);
  }
  getByte() {
    unreachable("Abstract method `getByte` called");
  }
  getBytes(e2) {
    unreachable("Abstract method `getBytes` called");
  }
  async getImageData(e2, t2) {
    return this.getBytes(e2, t2);
  }
  async asyncGetBytes() {
    unreachable("Abstract method `asyncGetBytes` called");
  }
  get isAsync() {
    return false;
  }
  get isAsyncDecoder() {
    return false;
  }
  get canAsyncDecodeImageFromBuffer() {
    return false;
  }
  async getTransferableImage() {
    return null;
  }
  peekByte() {
    const e2 = this.getByte();
    -1 !== e2 && this.pos--;
    return e2;
  }
  peekBytes(e2) {
    const t2 = this.getBytes(e2);
    this.pos -= t2.length;
    return t2;
  }
  getUint16() {
    const e2 = this.getByte(), t2 = this.getByte();
    return -1 === e2 || -1 === t2 ? -1 : (e2 << 8) + t2;
  }
  getInt32() {
    return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
  }
  getByteRange(e2, t2) {
    unreachable("Abstract method `getByteRange` called");
  }
  getString(e2) {
    return bytesToString(this.getBytes(e2));
  }
  skip(e2) {
    this.pos += e2 || 1;
  }
  reset() {
    unreachable("Abstract method `reset` called");
  }
  moveStart() {
    unreachable("Abstract method `moveStart` called");
  }
  makeSubStream(e2, t2, a2 = null) {
    unreachable("Abstract method `makeSubStream` called");
  }
  getBaseStreams() {
    return null;
  }
};
var Ca = /^[1-9]\.\d$/;
var va = 2 ** 31 - 1;
var Fa = [1, 0, 0, 1, 0, 0];
var Ia = ["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"];
var Ta = ["ExtGState", "Font", "Properties", "XObject"];
function getLookupTableFactory(e2) {
  let t2;
  return function() {
    if (e2) {
      t2 = /* @__PURE__ */ Object.create(null);
      e2(t2);
      e2 = null;
    }
    return t2;
  };
}
var MissingDataException = class extends fa {
  constructor(e2, t2) {
    super(`Missing data [${e2}, ${t2})`, "MissingDataException");
    this.begin = e2;
    this.end = t2;
  }
};
var ParserEOFException = class extends fa {
  constructor(e2) {
    super(e2, "ParserEOFException");
  }
};
var XRefEntryException = class extends fa {
  constructor(e2) {
    super(e2, "XRefEntryException");
  }
};
var XRefParseException = class extends fa {
  constructor(e2) {
    super(e2, "XRefParseException");
  }
};
function arrayBuffersToBytes(e2) {
  const t2 = e2.length;
  if (0 === t2) return new Uint8Array(0);
  if (1 === t2) return new Uint8Array(e2[0]);
  let a2 = 0;
  for (let r3 = 0; r3 < t2; r3++) a2 += e2[r3].byteLength;
  const r2 = new Uint8Array(a2);
  let i2 = 0;
  for (let a3 = 0; a3 < t2; a3++) {
    const t3 = new Uint8Array(e2[a3]);
    r2.set(t3, i2);
    i2 += t3.byteLength;
  }
  return r2;
}
async function fetchBinaryData(e2) {
  const t2 = await fetch(e2);
  if (!t2.ok) throw new Error(`Failed to fetch file "${e2}" with "${t2.statusText}".`);
  return new Uint8Array(await t2.arrayBuffer());
}
function getInheritableProperty({ dict: e2, key: t2, getArray: a2 = false, stopWhenFound: r2 = true }) {
  let i2;
  const n2 = new RefSet();
  for (; e2 instanceof Dict && (!e2.objId || !n2.has(e2.objId)); ) {
    e2.objId && n2.put(e2.objId);
    const s2 = a2 ? e2.getArray(t2) : e2.get(t2);
    if (void 0 !== s2) {
      if (r2) return s2;
      (i2 ||= []).push(s2);
    }
    e2 = e2.get("Parent");
  }
  return i2;
}
var Oa = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
function toRomanNumerals(e2, t2 = false) {
  assert(Number.isInteger(e2) && e2 > 0, "The number should be a positive integer.");
  const a2 = "M".repeat(e2 / 1e3 | 0) + Oa[e2 % 1e3 / 100 | 0] + Oa[10 + (e2 % 100 / 10 | 0)] + Oa[20 + e2 % 10];
  return t2 ? a2.toLowerCase() : a2;
}
function log2(e2) {
  return e2 > 0 ? Math.ceil(Math.log2(e2)) : 0;
}
function readInt8(e2, t2) {
  return e2[t2] << 24 >> 24;
}
function readInt16(e2, t2) {
  return (e2[t2] << 24 | e2[t2 + 1] << 16) >> 16;
}
function readUint16(e2, t2) {
  return e2[t2] << 8 | e2[t2 + 1];
}
function readUint32(e2, t2) {
  return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
}
function isWhiteSpace(e2) {
  return 32 === e2 || 9 === e2 || 13 === e2 || 10 === e2;
}
function isNumberArray(e2, t2) {
  return Array.isArray(e2) ? (null === t2 || e2.length === t2) && e2.every(((e3) => "number" == typeof e3)) : ArrayBuffer.isView(e2) && !(e2 instanceof BigInt64Array || e2 instanceof BigUint64Array) && (null === t2 || e2.length === t2);
}
function lookupMatrix(e2, t2) {
  return isNumberArray(e2, 6) ? e2 : t2;
}
function lookupRect(e2, t2) {
  return isNumberArray(e2, 4) ? e2 : t2;
}
function lookupNormalRect(e2, t2) {
  return isNumberArray(e2, 4) ? Util.normalizeRect(e2) : t2;
}
function parseXFAPath(e2) {
  const t2 = /(.+)\[(\d+)\]$/;
  return e2.split(".").map(((e3) => {
    const a2 = e3.match(t2);
    return a2 ? { name: a2[1], pos: parseInt(a2[2], 10) } : { name: e3, pos: 0 };
  }));
}
function escapePDFName(e2) {
  const t2 = [];
  let a2 = 0;
  for (let r2 = 0, i2 = e2.length; r2 < i2; r2++) {
    const i3 = e2.charCodeAt(r2);
    if (i3 < 33 || i3 > 126 || 35 === i3 || 40 === i3 || 41 === i3 || 60 === i3 || 62 === i3 || 91 === i3 || 93 === i3 || 123 === i3 || 125 === i3 || 47 === i3 || 37 === i3) {
      a2 < r2 && t2.push(e2.substring(a2, r2));
      t2.push(`#${i3.toString(16)}`);
      a2 = r2 + 1;
    }
  }
  if (0 === t2.length) return e2;
  a2 < e2.length && t2.push(e2.substring(a2, e2.length));
  return t2.join("");
}
function escapeString(e2) {
  return e2.replaceAll(/([()\\\n\r])/g, ((e3) => "\n" === e3 ? "\\n" : "\r" === e3 ? "\\r" : `\\${e3}`));
}
function _collectJS(e2, t2, a2, r2) {
  if (!e2) return;
  let i2 = null;
  if (e2 instanceof Ref) {
    if (r2.has(e2)) return;
    i2 = e2;
    r2.put(i2);
    e2 = t2.fetch(e2);
  }
  if (Array.isArray(e2)) for (const i3 of e2) _collectJS(i3, t2, a2, r2);
  else if (e2 instanceof Dict) {
    if (isName(e2.get("S"), "JavaScript")) {
      const t3 = e2.get("JS");
      let r3;
      t3 instanceof BaseStream ? r3 = t3.getString() : "string" == typeof t3 && (r3 = t3);
      r3 &&= stringToPDFString(r3, true).replaceAll("\0", "");
      r3 && a2.push(r3.trim());
    }
    _collectJS(e2.getRaw("Next"), t2, a2, r2);
  }
  i2 && r2.remove(i2);
}
function collectActions(e2, t2, a2) {
  const r2 = /* @__PURE__ */ Object.create(null), i2 = getInheritableProperty({ dict: t2, key: "AA", stopWhenFound: false });
  if (i2) for (let t3 = i2.length - 1; t3 >= 0; t3--) {
    const n2 = i2[t3];
    if (n2 instanceof Dict) for (const t4 of n2.getKeys()) {
      const i3 = a2[t4];
      if (!i3) continue;
      const s2 = [];
      _collectJS(n2.getRaw(t4), e2, s2, new RefSet());
      s2.length > 0 && (r2[i3] = s2);
    }
  }
  if (t2.has("A")) {
    const a3 = [];
    _collectJS(t2.get("A"), e2, a3, new RefSet());
    a3.length > 0 && (r2.Action = a3);
  }
  return objectSize(r2) > 0 ? r2 : null;
}
var Ma = { 60: "&lt;", 62: "&gt;", 38: "&amp;", 34: "&quot;", 39: "&apos;" };
function* codePointIter(e2) {
  for (let t2 = 0, a2 = e2.length; t2 < a2; t2++) {
    const a3 = e2.codePointAt(t2);
    a3 > 55295 && (a3 < 57344 || a3 > 65533) && t2++;
    yield a3;
  }
}
function encodeToXmlString(e2) {
  const t2 = [];
  let a2 = 0;
  for (let r2 = 0, i2 = e2.length; r2 < i2; r2++) {
    const i3 = e2.codePointAt(r2);
    if (32 <= i3 && i3 <= 126) {
      const n2 = Ma[i3];
      if (n2) {
        a2 < r2 && t2.push(e2.substring(a2, r2));
        t2.push(n2);
        a2 = r2 + 1;
      }
    } else {
      a2 < r2 && t2.push(e2.substring(a2, r2));
      t2.push(`&#x${i3.toString(16).toUpperCase()};`);
      i3 > 55295 && (i3 < 57344 || i3 > 65533) && r2++;
      a2 = r2 + 1;
    }
  }
  if (0 === t2.length) return e2;
  a2 < e2.length && t2.push(e2.substring(a2, e2.length));
  return t2.join("");
}
function validateFontName(e2, t2 = false) {
  const a2 = /^("|').*("|')$/.exec(e2);
  if (a2 && a2[1] === a2[2]) {
    if (new RegExp(`[^\\\\]${a2[1]}`).test(e2.slice(1, -1))) {
      t2 && warn(`FontFamily contains unescaped ${a2[1]}: ${e2}.`);
      return false;
    }
  } else for (const a3 of e2.split(/[ \t]+/)) if (/^(\d|(-(\d|-)))/.test(a3) || !/^[\w-\\]+$/.test(a3)) {
    t2 && warn(`FontFamily contains invalid <custom-ident>: ${e2}.`);
    return false;
  }
  return true;
}
function validateCSSFont(e2) {
  const t2 = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), { fontFamily: a2, fontWeight: r2, italicAngle: i2 } = e2;
  if (!validateFontName(a2, true)) return false;
  const n2 = r2 ? r2.toString() : "";
  e2.fontWeight = t2.has(n2) ? n2 : "400";
  const s2 = parseFloat(i2);
  e2.italicAngle = isNaN(s2) || s2 < -90 || s2 > 90 ? "14" : i2.toString();
  return true;
}
function recoverJsURL(e2) {
  const t2 = new RegExp("^\\s*(" + ["app.launchURL", "window.open", "xfa.host.gotoURL"].join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(e2);
  return t2?.[2] ? { url: t2[2], newWindow: "app.launchURL" === t2[1] && "true" === t2[3] } : null;
}
function numberToString(e2) {
  if (Number.isInteger(e2)) return e2.toString();
  const t2 = Math.round(100 * e2);
  return t2 % 100 == 0 ? (t2 / 100).toString() : t2 % 10 == 0 ? e2.toFixed(1) : e2.toFixed(2);
}
function getNewAnnotationsMap(e2) {
  if (!e2) return null;
  const t2 = /* @__PURE__ */ new Map();
  for (const [a2, r2] of e2) {
    if (!a2.startsWith(f)) continue;
    let e3 = t2.get(r2.pageIndex);
    if (!e3) {
      e3 = [];
      t2.set(r2.pageIndex, e3);
    }
    e3.push(r2);
  }
  return t2.size > 0 ? t2 : null;
}
function stringToAsciiOrUTF16BE(e2) {
  return null == e2 || (function isAscii(e3) {
    if ("string" != typeof e3) return false;
    return !e3 || /^[\x00-\x7F]*$/.test(e3);
  })(e2) ? e2 : stringToUTF16String(e2, true);
}
function stringToUTF16HexString(e2) {
  const t2 = [];
  for (let a2 = 0, r2 = e2.length; a2 < r2; a2++) {
    const r3 = e2.charCodeAt(a2);
    t2.push(ga[r3 >> 8 & 255], ga[255 & r3]);
  }
  return t2.join("");
}
function stringToUTF16String(e2, t2 = false) {
  const a2 = [];
  t2 && a2.push("þÿ");
  for (let t3 = 0, r2 = e2.length; t3 < r2; t3++) {
    const r3 = e2.charCodeAt(t3);
    a2.push(String.fromCharCode(r3 >> 8 & 255), String.fromCharCode(255 & r3));
  }
  return a2.join("");
}
function getRotationMatrix(e2, t2, a2) {
  switch (e2) {
    case 90:
      return [0, 1, -1, 0, t2, 0];
    case 180:
      return [-1, 0, 0, -1, t2, a2];
    case 270:
      return [0, -1, 1, 0, 0, a2];
    default:
      throw new Error("Invalid rotation");
  }
}
function getSizeInBytes(e2) {
  return Math.ceil(Math.ceil(Math.log2(1 + e2)) / 8);
}
var QCMS = class {
  static #a = null;
  static _memory = null;
  static _mustAddAlpha = false;
  static _destBuffer = null;
  static _destOffset = 0;
  static _destLength = 0;
  static _cssColor = "";
  static _makeHexColor = null;
  static get _memoryArray() {
    const e2 = this.#a;
    return e2?.byteLength ? e2 : this.#a = new Uint8Array(this._memory.buffer);
  }
};
var Da;
var Ba = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
"undefined" != typeof TextDecoder && Ba.decode();
var Ra = null;
function getUint8ArrayMemory0() {
  null !== Ra && 0 !== Ra.byteLength || (Ra = new Uint8Array(Da.memory.buffer));
  return Ra;
}
var Na = 0;
function passArray8ToWasm0(e2, t2) {
  const a2 = t2(1 * e2.length, 1) >>> 0;
  getUint8ArrayMemory0().set(e2, a2 / 1);
  Na = e2.length;
  return a2;
}
var Ea = Object.freeze({ RGB8: 0, 0: "RGB8", RGBA8: 1, 1: "RGBA8", BGRA8: 2, 2: "BGRA8", Gray8: 3, 3: "Gray8", GrayA8: 4, 4: "GrayA8", CMYK: 5, 5: "CMYK" });
var Pa = Object.freeze({ Perceptual: 0, 0: "Perceptual", RelativeColorimetric: 1, 1: "RelativeColorimetric", Saturation: 2, 2: "Saturation", AbsoluteColorimetric: 3, 3: "AbsoluteColorimetric" });
function __wbg_get_imports() {
  const e2 = { wbg: {} };
  e2.wbg.__wbg_copyresult_b08ee7d273f295dd = function(e3, t2) {
    !(function copy_result(e4, t3) {
      const { _mustAddAlpha: a2, _destBuffer: r2, _destOffset: i2, _destLength: n2, _memoryArray: s2 } = QCMS;
      if (t3 !== n2) if (a2) for (let a3 = e4, n3 = e4 + t3, o2 = i2; a3 < n3; a3 += 3, o2 += 4) {
        r2[o2] = s2[a3];
        r2[o2 + 1] = s2[a3 + 1];
        r2[o2 + 2] = s2[a3 + 2];
        r2[o2 + 3] = 255;
      }
      else for (let a3 = e4, n3 = e4 + t3, o2 = i2; a3 < n3; a3 += 3, o2 += 4) {
        r2[o2] = s2[a3];
        r2[o2 + 1] = s2[a3 + 1];
        r2[o2 + 2] = s2[a3 + 2];
      }
      else r2.set(s2.subarray(e4, e4 + t3), i2);
    })(e3 >>> 0, t2 >>> 0);
  };
  e2.wbg.__wbg_copyrgb_d60ce17bb05d9b67 = function(e3) {
    !(function copy_rgb(e4) {
      const { _destBuffer: t2, _destOffset: a2, _memoryArray: r2 } = QCMS;
      t2[a2] = r2[e4];
      t2[a2 + 1] = r2[e4 + 1];
      t2[a2 + 2] = r2[e4 + 2];
    })(e3 >>> 0);
  };
  e2.wbg.__wbg_makecssRGB_893bf0cd9fdb302d = function(e3) {
    !(function make_cssRGB(e4) {
      const { _memoryArray: t2 } = QCMS;
      QCMS._cssColor = QCMS._makeHexColor(t2[e4], t2[e4 + 1], t2[e4 + 2]);
    })(e3 >>> 0);
  };
  e2.wbg.__wbindgen_init_externref_table = function() {
    const e3 = Da.__wbindgen_export_0, t2 = e3.grow(4);
    e3.set(0, void 0);
    e3.set(t2 + 0, void 0);
    e3.set(t2 + 1, null);
    e3.set(t2 + 2, true);
    e3.set(t2 + 3, false);
  };
  e2.wbg.__wbindgen_throw = function(e3, t2) {
    throw new Error((function getStringFromWasm0(e4, t3) {
      e4 >>>= 0;
      return Ba.decode(getUint8ArrayMemory0().subarray(e4, e4 + t3));
    })(e3, t2));
  };
  return e2;
}
function __wbg_finalize_init(e2, t2) {
  Da = e2.exports;
  __wbg_init.__wbindgen_wasm_module = t2;
  Ra = null;
  Da.__wbindgen_start();
  return Da;
}
async function __wbg_init(e2) {
  if (void 0 !== Da) return Da;
  void 0 !== e2 && (Object.getPrototypeOf(e2) === Object.prototype ? { module_or_path: e2 } = e2 : console.warn("using deprecated parameters for the initialization function; pass a single object instead"));
  const t2 = __wbg_get_imports();
  ("string" == typeof e2 || "function" == typeof Request && e2 instanceof Request || "function" == typeof URL && e2 instanceof URL) && (e2 = fetch(e2));
  const { instance: a2, module: r2 } = await (async function __wbg_load(e3, t3) {
    if ("function" == typeof Response && e3 instanceof Response) {
      if ("function" == typeof WebAssembly.instantiateStreaming) try {
        return await WebAssembly.instantiateStreaming(e3, t3);
      } catch (t4) {
        if ("application/wasm" == e3.headers.get("Content-Type")) throw t4;
        console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", t4);
      }
      const a3 = await e3.arrayBuffer();
      return await WebAssembly.instantiate(a3, t3);
    }
    {
      const a3 = await WebAssembly.instantiate(e3, t3);
      return a3 instanceof WebAssembly.Instance ? { instance: a3, module: e3 } : a3;
    }
  })(await e2, t2);
  return __wbg_finalize_init(a2, r2);
}
var ColorSpace = class _ColorSpace {
  static #r = new Uint8ClampedArray(3);
  constructor(e2, t2) {
    this.name = e2;
    this.numComps = t2;
  }
  getRgb(e2, t2, a2 = new Uint8ClampedArray(3)) {
    this.getRgbItem(e2, t2, a2, 0);
    return a2;
  }
  getRgbHex(e2, t2) {
    const a2 = this.getRgb(e2, t2, _ColorSpace.#r);
    return Util.makeHexColor(a2[0], a2[1], a2[2]);
  }
  getRgbItem(e2, t2, a2, r2) {
    unreachable("Should not call ColorSpace.getRgbItem");
  }
  getRgbBuffer(e2, t2, a2, r2, i2, n2, s2) {
    unreachable("Should not call ColorSpace.getRgbBuffer");
  }
  getOutputLength(e2, t2) {
    unreachable("Should not call ColorSpace.getOutputLength");
  }
  isPassthrough(e2) {
    return false;
  }
  isDefaultDecode(e2, t2) {
    return _ColorSpace.isDefaultDecode(e2, this.numComps);
  }
  fillRgb(e2, t2, a2, r2, i2, n2, s2, o2, c2) {
    const l2 = t2 * a2;
    let h2 = null;
    const u2 = 1 << s2, d2 = a2 !== i2 || t2 !== r2;
    if (this.isPassthrough(s2)) h2 = o2;
    else if (1 === this.numComps && l2 > u2 && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
      const t3 = s2 <= 8 ? new Uint8Array(u2) : new Uint16Array(u2);
      for (let e3 = 0; e3 < u2; e3++) t3[e3] = e3;
      const a3 = new Uint8ClampedArray(3 * u2);
      this.getRgbBuffer(t3, 0, u2, a3, 0, s2, 0);
      if (d2) {
        h2 = new Uint8Array(3 * l2);
        let e3 = 0;
        for (let t4 = 0; t4 < l2; ++t4) {
          const r3 = 3 * o2[t4];
          h2[e3++] = a3[r3];
          h2[e3++] = a3[r3 + 1];
          h2[e3++] = a3[r3 + 2];
        }
      } else {
        let t4 = 0;
        for (let r3 = 0; r3 < l2; ++r3) {
          const i3 = 3 * o2[r3];
          e2[t4++] = a3[i3];
          e2[t4++] = a3[i3 + 1];
          e2[t4++] = a3[i3 + 2];
          t4 += c2;
        }
      }
    } else if (d2) {
      h2 = new Uint8ClampedArray(3 * l2);
      this.getRgbBuffer(o2, 0, l2, h2, 0, s2, 0);
    } else this.getRgbBuffer(o2, 0, r2 * n2, e2, 0, s2, c2);
    if (h2) if (d2) !(function resizeRgbImage(e3, t3, a3, r3, i3, n3, s3) {
      s3 = 1 !== s3 ? 0 : s3;
      const o3 = a3 / i3, c3 = r3 / n3;
      let l3, h3 = 0;
      const u3 = new Uint16Array(i3), d3 = 3 * a3;
      for (let e4 = 0; e4 < i3; e4++) u3[e4] = 3 * Math.floor(e4 * o3);
      for (let a4 = 0; a4 < n3; a4++) {
        const r4 = Math.floor(a4 * c3) * d3;
        for (let a5 = 0; a5 < i3; a5++) {
          l3 = r4 + u3[a5];
          t3[h3++] = e3[l3++];
          t3[h3++] = e3[l3++];
          t3[h3++] = e3[l3++];
          h3 += s3;
        }
      }
    })(h2, e2, t2, a2, r2, i2, c2);
    else {
      let t3 = 0, a3 = 0;
      for (let i3 = 0, s3 = r2 * n2; i3 < s3; i3++) {
        e2[t3++] = h2[a3++];
        e2[t3++] = h2[a3++];
        e2[t3++] = h2[a3++];
        t3 += c2;
      }
    }
  }
  get usesZeroToOneRange() {
    return shadow(this, "usesZeroToOneRange", true);
  }
  static isDefaultDecode(e2, t2) {
    if (!Array.isArray(e2)) return true;
    if (2 * t2 !== e2.length) {
      warn("The decode map is not the correct length");
      return true;
    }
    for (let t3 = 0, a2 = e2.length; t3 < a2; t3 += 2) if (0 !== e2[t3] || 1 !== e2[t3 + 1]) return false;
    return true;
  }
};
var AlternateCS = class extends ColorSpace {
  constructor(e2, t2, a2) {
    super("Alternate", e2);
    this.base = t2;
    this.tintFn = a2;
    this.tmpBuf = new Float32Array(t2.numComps);
  }
  getRgbItem(e2, t2, a2, r2) {
    const i2 = this.tmpBuf;
    this.tintFn(e2, t2, i2, 0);
    this.base.getRgbItem(i2, 0, a2, r2);
  }
  getRgbBuffer(e2, t2, a2, r2, i2, n2, s2) {
    const o2 = this.tintFn, c2 = this.base, l2 = 1 / ((1 << n2) - 1), h2 = c2.numComps, u2 = c2.usesZeroToOneRange, d2 = (c2.isPassthrough(8) || !u2) && 0 === s2;
    let f2 = d2 ? i2 : 0;
    const g2 = d2 ? r2 : new Uint8ClampedArray(h2 * a2), p2 = this.numComps, m2 = new Float32Array(p2), b2 = new Float32Array(h2);
    let y2, w2;
    for (y2 = 0; y2 < a2; y2++) {
      for (w2 = 0; w2 < p2; w2++) m2[w2] = e2[t2++] * l2;
      o2(m2, 0, b2, 0);
      if (u2) for (w2 = 0; w2 < h2; w2++) g2[f2++] = 255 * b2[w2];
      else {
        c2.getRgbItem(b2, 0, g2, f2);
        f2 += h2;
      }
    }
    d2 || c2.getRgbBuffer(g2, 0, a2, r2, i2, 8, s2);
  }
  getOutputLength(e2, t2) {
    return this.base.getOutputLength(e2 * this.base.numComps / this.numComps, t2);
  }
};
var PatternCS = class extends ColorSpace {
  constructor(e2) {
    super("Pattern", null);
    this.base = e2;
  }
  isDefaultDecode(e2, t2) {
    unreachable("Should not call PatternCS.isDefaultDecode");
  }
};
var IndexedCS = class extends ColorSpace {
  constructor(e2, t2, a2) {
    super("Indexed", 1);
    this.base = e2;
    this.highVal = t2;
    const r2 = e2.numComps * (t2 + 1);
    this.lookup = new Uint8Array(r2);
    if (a2 instanceof BaseStream) {
      const e3 = a2.getBytes(r2);
      this.lookup.set(e3);
    } else {
      if ("string" != typeof a2) throw new FormatError(`IndexedCS - unrecognized lookup table: ${a2}`);
      for (let e3 = 0; e3 < r2; ++e3) this.lookup[e3] = 255 & a2.charCodeAt(e3);
    }
  }
  getRgbItem(e2, t2, a2, r2) {
    const { base: i2, highVal: n2, lookup: s2 } = this, o2 = MathClamp(Math.round(e2[t2]), 0, n2) * i2.numComps;
    i2.getRgbBuffer(s2, o2, 1, a2, r2, 8, 0);
  }
  getRgbBuffer(e2, t2, a2, r2, i2, n2, s2) {
    const { base: o2, highVal: c2, lookup: l2 } = this, { numComps: h2 } = o2, u2 = o2.getOutputLength(h2, s2);
    for (let n3 = 0; n3 < a2; ++n3) {
      const a3 = MathClamp(Math.round(e2[t2++]), 0, c2) * h2;
      o2.getRgbBuffer(l2, a3, 1, r2, i2, 8, s2);
      i2 += u2;
    }
  }
  getOutputLength(e2, t2) {
    return this.base.getOutputLength(e2 * this.base.numComps, t2);
  }
  isDefaultDecode(e2, t2) {
    if (!Array.isArray(e2)) return true;
    if (2 !== e2.length) {
      warn("Decode map length is not correct");
      return true;
    }
    if (!Number.isInteger(t2) || t2 < 1) {
      warn("Bits per component is not correct");
      return true;
    }
    return 0 === e2[0] && e2[1] === (1 << t2) - 1;
  }
};
var DeviceGrayCS = class extends ColorSpace {
  constructor() {
    super("DeviceGray", 1);
  }
  getRgbItem(e2, t2, a2, r2) {
    const i2 = 255 * e2[t2];
    a2[r2] = a2[r2 + 1] = a2[r2 + 2] = i2;
  }
  getRgbBuffer(e2, t2, a2, r2, i2, n2, s2) {
    const o2 = 255 / ((1 << n2) - 1);
    let c2 = t2, l2 = i2;
    for (let t3 = 0; t3 < a2; ++t3) {
      const t4 = o2 * e2[c2++];
      r2[l2++] = t4;
      r2[l2++] = t4;
      r2[l2++] = t4;
      l2 += s2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2);
  }
};
var DeviceRgbCS = class extends ColorSpace {
  constructor() {
    super("DeviceRGB", 3);
  }
  getRgbItem(e2, t2, a2, r2) {
    a2[r2] = 255 * e2[t2];
    a2[r2 + 1] = 255 * e2[t2 + 1];
    a2[r2 + 2] = 255 * e2[t2 + 2];
  }
  getRgbBuffer(e2, t2, a2, r2, i2, n2, s2) {
    if (8 === n2 && 0 === s2) {
      r2.set(e2.subarray(t2, t2 + 3 * a2), i2);
      return;
    }
    const o2 = 255 / ((1 << n2) - 1);
    let c2 = t2, l2 = i2;
    for (let t3 = 0; t3 < a2; ++t3) {
      r2[l2++] = o2 * e2[c2++];
      r2[l2++] = o2 * e2[c2++];
      r2[l2++] = o2 * e2[c2++];
      l2 += s2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2) / 3 | 0;
  }
  isPassthrough(e2) {
    return 8 === e2;
  }
};
var DeviceRgbaCS = class extends ColorSpace {
  constructor() {
    super("DeviceRGBA", 4);
  }
  getOutputLength(e2, t2) {
    return 4 * e2;
  }
  isPassthrough(e2) {
    return 8 === e2;
  }
  fillRgb(e2, t2, a2, r2, i2, n2, s2, o2, c2) {
    a2 !== i2 || t2 !== r2 ? (function resizeRgbaImage(e3, t3, a3, r3, i3, n3, s3) {
      const o3 = a3 / i3, c3 = r3 / n3;
      let l2 = 0;
      const h2 = new Uint16Array(i3);
      if (1 === s3) {
        for (let e4 = 0; e4 < i3; e4++) h2[e4] = Math.floor(e4 * o3);
        const r4 = new Uint32Array(e3.buffer), s4 = new Uint32Array(t3.buffer), u2 = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
        for (let e4 = 0; e4 < n3; e4++) {
          const t4 = r4.subarray(Math.floor(e4 * c3) * a3);
          for (let e5 = 0; e5 < i3; e5++) s4[l2++] |= t4[h2[e5]] & u2;
        }
      } else {
        const r4 = 4, s4 = a3 * r4;
        for (let e4 = 0; e4 < i3; e4++) h2[e4] = Math.floor(e4 * o3) * r4;
        for (let a4 = 0; a4 < n3; a4++) {
          const r5 = e3.subarray(Math.floor(a4 * c3) * s4);
          for (let e4 = 0; e4 < i3; e4++) {
            const a5 = h2[e4];
            t3[l2++] = r5[a5];
            t3[l2++] = r5[a5 + 1];
            t3[l2++] = r5[a5 + 2];
          }
        }
      }
    })(o2, e2, t2, a2, r2, i2, c2) : (function copyRgbaImage(e3, t3, a3) {
      if (1 === a3) {
        const a4 = new Uint32Array(e3.buffer), r3 = new Uint32Array(t3.buffer), i3 = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
        for (let e4 = 0, t4 = a4.length; e4 < t4; e4++) r3[e4] |= a4[e4] & i3;
      } else {
        let a4 = 0;
        for (let r3 = 0, i3 = e3.length; r3 < i3; r3 += 4) {
          t3[a4++] = e3[r3];
          t3[a4++] = e3[r3 + 1];
          t3[a4++] = e3[r3 + 2];
        }
      }
    })(o2, e2, c2);
  }
};
var DeviceCmykCS = class extends ColorSpace {
  constructor() {
    super("DeviceCMYK", 4);
  }
  #i(e2, t2, a2, r2, i2) {
    const n2 = e2[t2] * a2, s2 = e2[t2 + 1] * a2, o2 = e2[t2 + 2] * a2, c2 = e2[t2 + 3] * a2;
    r2[i2] = 255 + n2 * (-4.387332384609988 * n2 + 54.48615194189176 * s2 + 18.82290502165302 * o2 + 212.25662451639585 * c2 - 285.2331026137004) + s2 * (1.7149763477362134 * s2 - 5.6096736904047315 * o2 + -17.873870861415444 * c2 - 5.497006427196366) + o2 * (-2.5217340131683033 * o2 - 21.248923337353073 * c2 + 17.5119270841813) + c2 * (-21.86122147463605 * c2 - 189.48180835922747);
    r2[i2 + 1] = 255 + n2 * (8.841041422036149 * n2 + 60.118027045597366 * s2 + 6.871425592049007 * o2 + 31.159100130055922 * c2 - 79.2970844816548) + s2 * (-15.310361306967817 * s2 + 17.575251261109482 * o2 + 131.35250912493976 * c2 - 190.9453302588951) + o2 * (4.444339102852739 * o2 + 9.8632861493405 * c2 - 24.86741582555878) + c2 * (-20.737325471181034 * c2 - 187.80453709719578);
    r2[i2 + 2] = 255 + n2 * (0.8842522430003296 * n2 + 8.078677503112928 * s2 + 30.89978309703729 * o2 - 0.23883238689178934 * c2 - 14.183576799673286) + s2 * (10.49593273432072 * s2 + 63.02378494754052 * o2 + 50.606957656360734 * c2 - 112.23884253719248) + o2 * (0.03296041114873217 * o2 + 115.60384449646641 * c2 - 193.58209356861505) + c2 * (-22.33816807309886 * c2 - 180.12613974708367);
  }
  getRgbItem(e2, t2, a2, r2) {
    this.#i(e2, t2, 1, a2, r2);
  }
  getRgbBuffer(e2, t2, a2, r2, i2, n2, s2) {
    const o2 = 1 / ((1 << n2) - 1);
    for (let n3 = 0; n3 < a2; n3++) {
      this.#i(e2, t2, o2, r2, i2);
      t2 += 4;
      i2 += 3 + s2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 / 4 * (3 + t2) | 0;
  }
};
var CalGrayCS = class extends ColorSpace {
  constructor(e2, t2, a2) {
    super("CalGray", 1);
    if (!e2) throw new FormatError("WhitePoint missing - required for color space CalGray");
    [this.XW, this.YW, this.ZW] = e2;
    [this.XB, this.YB, this.ZB] = t2 || [0, 0, 0];
    this.G = a2 || 1;
    if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
      info(`Invalid BlackPoint for ${this.name}, falling back to default.`);
      this.XB = this.YB = this.ZB = 0;
    }
    0 === this.XB && 0 === this.YB && 0 === this.ZB || warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
    if (this.G < 1) {
      info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
      this.G = 1;
    }
  }
  #i(e2, t2, a2, r2, i2) {
    const n2 = (e2[t2] * i2) ** this.G, s2 = this.YW * n2, o2 = Math.max(295.8 * s2 ** 0.3333333333333333 - 40.8, 0);
    a2[r2] = o2;
    a2[r2 + 1] = o2;
    a2[r2 + 2] = o2;
  }
  getRgbItem(e2, t2, a2, r2) {
    this.#i(e2, t2, a2, r2, 1);
  }
  getRgbBuffer(e2, t2, a2, r2, i2, n2, s2) {
    const o2 = 1 / ((1 << n2) - 1);
    for (let n3 = 0; n3 < a2; ++n3) {
      this.#i(e2, t2, r2, i2, o2);
      t2 += 1;
      i2 += 3 + s2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2);
  }
};
var CalRGBCS = class _CalRGBCS extends ColorSpace {
  static #n = new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296]);
  static #s = new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867]);
  static #o = new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252]);
  static #c = new Float32Array([1, 1, 1]);
  static #l = new Float32Array(3);
  static #h = new Float32Array(3);
  static #u = new Float32Array(3);
  static #d = (24 / 116) ** 3 / 8;
  constructor(e2, t2, a2, r2) {
    super("CalRGB", 3);
    if (!e2) throw new FormatError("WhitePoint missing - required for color space CalRGB");
    const [i2, n2, s2] = this.whitePoint = e2, [o2, c2, l2] = this.blackPoint = t2 || new Float32Array(3);
    [this.GR, this.GG, this.GB] = a2 || new Float32Array([1, 1, 1]);
    [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = r2 || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    if (i2 < 0 || s2 < 0 || 1 !== n2) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    if (o2 < 0 || c2 < 0 || l2 < 0) {
      info(`Invalid BlackPoint for ${this.name} [${o2}, ${c2}, ${l2}], falling back to default.`);
      this.blackPoint = new Float32Array(3);
    }
    if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
      info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
      this.GR = this.GG = this.GB = 1;
    }
  }
  #f(e2, t2, a2) {
    a2[0] = e2[0] * t2[0] + e2[1] * t2[1] + e2[2] * t2[2];
    a2[1] = e2[3] * t2[0] + e2[4] * t2[1] + e2[5] * t2[2];
    a2[2] = e2[6] * t2[0] + e2[7] * t2[1] + e2[8] * t2[2];
  }
  #g(e2, t2, a2) {
    a2[0] = 1 * t2[0] / e2[0];
    a2[1] = 1 * t2[1] / e2[1];
    a2[2] = 1 * t2[2] / e2[2];
  }
  #p(e2, t2, a2) {
    a2[0] = 0.95047 * t2[0] / e2[0];
    a2[1] = 1 * t2[1] / e2[1];
    a2[2] = 1.08883 * t2[2] / e2[2];
  }
  #m(e2) {
    return e2 <= 31308e-7 ? MathClamp(12.92 * e2, 0, 1) : e2 >= 0.99554525 ? 1 : MathClamp(1.055 * e2 ** (1 / 2.4) - 0.055, 0, 1);
  }
  #b(e2) {
    return e2 < 0 ? -this.#b(-e2) : e2 > 8 ? ((e2 + 16) / 116) ** 3 : e2 * _CalRGBCS.#d;
  }
  #y(e2, t2, a2) {
    if (0 === e2[0] && 0 === e2[1] && 0 === e2[2]) {
      a2[0] = t2[0];
      a2[1] = t2[1];
      a2[2] = t2[2];
      return;
    }
    const r2 = this.#b(0), i2 = (1 - r2) / (1 - this.#b(e2[0])), n2 = 1 - i2, s2 = (1 - r2) / (1 - this.#b(e2[1])), o2 = 1 - s2, c2 = (1 - r2) / (1 - this.#b(e2[2])), l2 = 1 - c2;
    a2[0] = t2[0] * i2 + n2;
    a2[1] = t2[1] * s2 + o2;
    a2[2] = t2[2] * c2 + l2;
  }
  #w(e2, t2, a2) {
    if (1 === e2[0] && 1 === e2[2]) {
      a2[0] = t2[0];
      a2[1] = t2[1];
      a2[2] = t2[2];
      return;
    }
    const r2 = a2;
    this.#f(_CalRGBCS.#n, t2, r2);
    const i2 = _CalRGBCS.#l;
    this.#g(e2, r2, i2);
    this.#f(_CalRGBCS.#s, i2, a2);
  }
  #x(e2, t2, a2) {
    const r2 = a2;
    this.#f(_CalRGBCS.#n, t2, r2);
    const i2 = _CalRGBCS.#l;
    this.#p(e2, r2, i2);
    this.#f(_CalRGBCS.#s, i2, a2);
  }
  #i(e2, t2, a2, r2, i2) {
    const n2 = MathClamp(e2[t2] * i2, 0, 1), s2 = MathClamp(e2[t2 + 1] * i2, 0, 1), o2 = MathClamp(e2[t2 + 2] * i2, 0, 1), c2 = 1 === n2 ? 1 : n2 ** this.GR, l2 = 1 === s2 ? 1 : s2 ** this.GG, h2 = 1 === o2 ? 1 : o2 ** this.GB, u2 = this.MXA * c2 + this.MXB * l2 + this.MXC * h2, d2 = this.MYA * c2 + this.MYB * l2 + this.MYC * h2, f2 = this.MZA * c2 + this.MZB * l2 + this.MZC * h2, g2 = _CalRGBCS.#h;
    g2[0] = u2;
    g2[1] = d2;
    g2[2] = f2;
    const p2 = _CalRGBCS.#u;
    this.#w(this.whitePoint, g2, p2);
    const m2 = _CalRGBCS.#h;
    this.#y(this.blackPoint, p2, m2);
    const b2 = _CalRGBCS.#u;
    this.#x(_CalRGBCS.#c, m2, b2);
    const y2 = _CalRGBCS.#h;
    this.#f(_CalRGBCS.#o, b2, y2);
    a2[r2] = 255 * this.#m(y2[0]);
    a2[r2 + 1] = 255 * this.#m(y2[1]);
    a2[r2 + 2] = 255 * this.#m(y2[2]);
  }
  getRgbItem(e2, t2, a2, r2) {
    this.#i(e2, t2, a2, r2, 1);
  }
  getRgbBuffer(e2, t2, a2, r2, i2, n2, s2) {
    const o2 = 1 / ((1 << n2) - 1);
    for (let n3 = 0; n3 < a2; ++n3) {
      this.#i(e2, t2, r2, i2, o2);
      t2 += 3;
      i2 += 3 + s2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2) / 3 | 0;
  }
};
var LabCS = class extends ColorSpace {
  constructor(e2, t2, a2) {
    super("Lab", 3);
    if (!e2) throw new FormatError("WhitePoint missing - required for color space Lab");
    [this.XW, this.YW, this.ZW] = e2;
    [this.amin, this.amax, this.bmin, this.bmax] = a2 || [-100, 100, -100, 100];
    [this.XB, this.YB, this.ZB] = t2 || [0, 0, 0];
    if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError("Invalid WhitePoint components, no fallback available");
    if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
      info("Invalid BlackPoint, falling back to default");
      this.XB = this.YB = this.ZB = 0;
    }
    if (this.amin > this.amax || this.bmin > this.bmax) {
      info("Invalid Range, falling back to defaults");
      this.amin = -100;
      this.amax = 100;
      this.bmin = -100;
      this.bmax = 100;
    }
  }
  #S(e2) {
    return e2 >= 6 / 29 ? e2 ** 3 : 108 / 841 * (e2 - 4 / 29);
  }
  #A(e2, t2, a2, r2) {
    return a2 + e2 * (r2 - a2) / t2;
  }
  #i(e2, t2, a2, r2, i2) {
    let n2 = e2[t2], s2 = e2[t2 + 1], o2 = e2[t2 + 2];
    if (false !== a2) {
      n2 = this.#A(n2, a2, 0, 100);
      s2 = this.#A(s2, a2, this.amin, this.amax);
      o2 = this.#A(o2, a2, this.bmin, this.bmax);
    }
    s2 > this.amax ? s2 = this.amax : s2 < this.amin && (s2 = this.amin);
    o2 > this.bmax ? o2 = this.bmax : o2 < this.bmin && (o2 = this.bmin);
    const c2 = (n2 + 16) / 116, l2 = c2 + s2 / 500, h2 = c2 - o2 / 200, u2 = this.XW * this.#S(l2), d2 = this.YW * this.#S(c2), f2 = this.ZW * this.#S(h2);
    let g2, p2, m2;
    if (this.ZW < 1) {
      g2 = 3.1339 * u2 + -1.617 * d2 + -0.4906 * f2;
      p2 = -0.9785 * u2 + 1.916 * d2 + 0.0333 * f2;
      m2 = 0.072 * u2 + -0.229 * d2 + 1.4057 * f2;
    } else {
      g2 = 3.2406 * u2 + -1.5372 * d2 + -0.4986 * f2;
      p2 = -0.9689 * u2 + 1.8758 * d2 + 0.0415 * f2;
      m2 = 0.0557 * u2 + -0.204 * d2 + 1.057 * f2;
    }
    r2[i2] = 255 * Math.sqrt(g2);
    r2[i2 + 1] = 255 * Math.sqrt(p2);
    r2[i2 + 2] = 255 * Math.sqrt(m2);
  }
  getRgbItem(e2, t2, a2, r2) {
    this.#i(e2, t2, false, a2, r2);
  }
  getRgbBuffer(e2, t2, a2, r2, i2, n2, s2) {
    const o2 = (1 << n2) - 1;
    for (let n3 = 0; n3 < a2; n3++) {
      this.#i(e2, t2, o2, r2, i2);
      t2 += 3;
      i2 += 3 + s2;
    }
  }
  getOutputLength(e2, t2) {
    return e2 * (3 + t2) / 3 | 0;
  }
  isDefaultDecode(e2, t2) {
    return true;
  }
  get usesZeroToOneRange() {
    return shadow(this, "usesZeroToOneRange", false);
  }
};
function fetchSync(e2) {
  const t2 = new XMLHttpRequest();
  t2.open("GET", e2, false);
  t2.responseType = "arraybuffer";
  t2.send(null);
  return t2.response;
}
var IccColorSpace = class _IccColorSpace extends ColorSpace {
  #k;
  #C;
  static #v = true;
  static #F = null;
  static #I = new FinalizationRegistry(((e2) => {
    !(function qcms_drop_transformer(e3) {
      Da.qcms_drop_transformer(e3);
    })(e2);
  }));
  constructor(e2, t2, a2) {
    if (!_IccColorSpace.isUsable) throw new Error("No ICC color space support");
    super(t2, a2);
    let r2;
    switch (a2) {
      case 1:
        r2 = Ea.Gray8;
        this.#C = (e3, t3, a3) => (function qcms_convert_one(e4, t4, a4) {
          Da.qcms_convert_one(e4, t4, a4);
        })(this.#k, 255 * e3[t3], a3);
        break;
      case 3:
        r2 = Ea.RGB8;
        this.#C = (e3, t3, a3) => (function qcms_convert_three(e4, t4, a4, r3, i2) {
          Da.qcms_convert_three(e4, t4, a4, r3, i2);
        })(this.#k, 255 * e3[t3], 255 * e3[t3 + 1], 255 * e3[t3 + 2], a3);
        break;
      case 4:
        r2 = Ea.CMYK;
        this.#C = (e3, t3, a3) => (function qcms_convert_four(e4, t4, a4, r3, i2, n2) {
          Da.qcms_convert_four(e4, t4, a4, r3, i2, n2);
        })(this.#k, 255 * e3[t3], 255 * e3[t3 + 1], 255 * e3[t3 + 2], 255 * e3[t3 + 3], a3);
        break;
      default:
        throw new Error(`Unsupported number of components: ${a2}`);
    }
    this.#k = (function qcms_transformer_from_memory(e3, t3, a3) {
      const r3 = passArray8ToWasm0(e3, Da.__wbindgen_malloc), i2 = Na;
      return Da.qcms_transformer_from_memory(r3, i2, t3, a3) >>> 0;
    })(e2, r2, Pa.Perceptual);
    if (!this.#k) throw new Error("Failed to create ICC color space");
    _IccColorSpace.#I.register(this, this.#k);
  }
  getRgbHex(e2, t2) {
    this.#C(e2, t2, true);
    return QCMS._cssColor;
  }
  getRgbItem(e2, t2, a2, r2) {
    QCMS._destBuffer = a2;
    QCMS._destOffset = r2;
    QCMS._destLength = 3;
    this.#C(e2, t2, false);
    QCMS._destBuffer = null;
  }
  getRgbBuffer(e2, t2, a2, r2, i2, n2, s2) {
    e2 = e2.subarray(t2, t2 + a2 * this.numComps);
    if (8 !== n2) {
      const t3 = 255 / ((1 << n2) - 1);
      for (let a3 = 0, r3 = e2.length; a3 < r3; a3++) e2[a3] *= t3;
    }
    QCMS._mustAddAlpha = s2 && r2.buffer === e2.buffer;
    QCMS._destBuffer = r2;
    QCMS._destOffset = i2;
    QCMS._destLength = a2 * (3 + s2);
    !(function qcms_convert_array(e3, t3) {
      const a3 = passArray8ToWasm0(t3, Da.__wbindgen_malloc), r3 = Na;
      Da.qcms_convert_array(e3, a3, r3);
    })(this.#k, e2);
    QCMS._mustAddAlpha = false;
    QCMS._destBuffer = null;
  }
  getOutputLength(e2, t2) {
    return e2 / this.numComps * (3 + t2) | 0;
  }
  static setOptions({ useWasm: e2, useWorkerFetch: t2, wasmUrl: a2 }) {
    if (t2) {
      this.#v = e2;
      this.#F = a2;
    } else this.#v = false;
  }
  static get isUsable() {
    let e2 = false;
    if (this.#v) if (this.#F) try {
      this._module = (function initSync(e3) {
        if (void 0 !== Da) return Da;
        void 0 !== e3 && (Object.getPrototypeOf(e3) === Object.prototype ? { module: e3 } = e3 : console.warn("using deprecated parameters for `initSync()`; pass a single object instead"));
        const t2 = __wbg_get_imports();
        e3 instanceof WebAssembly.Module || (e3 = new WebAssembly.Module(e3));
        return __wbg_finalize_init(new WebAssembly.Instance(e3, t2), e3);
      })({ module: fetchSync(`${this.#F}qcms_bg.wasm`) });
      e2 = !!this._module;
      QCMS._memory = this._module.memory;
      QCMS._makeHexColor = Util.makeHexColor;
    } catch (e3) {
      warn(`ICCBased color space: "${e3}".`);
    }
    else warn("No ICC color space support due to missing `wasmUrl` API option");
    return shadow(this, "isUsable", e2);
  }
};
var CmykICCBasedCS = class _CmykICCBasedCS extends IccColorSpace {
  static #T;
  constructor() {
    super(new Uint8Array(fetchSync(`${_CmykICCBasedCS.#T}CGATS001Compat-v2-micro.icc`)), "DeviceCMYK", 4);
  }
  static setOptions({ iccUrl: e2 }) {
    this.#T = e2;
  }
  static get isUsable() {
    let e2 = false;
    IccColorSpace.isUsable && (this.#T ? e2 = true : warn("No CMYK ICC profile support due to missing `iccUrl` API option"));
    return shadow(this, "isUsable", e2);
  }
};
var Stream = class _Stream extends BaseStream {
  constructor(e2, t2, a2, r2) {
    super();
    this.bytes = e2 instanceof Uint8Array ? e2 : new Uint8Array(e2);
    this.start = t2 || 0;
    this.pos = this.start;
    this.end = t2 + a2 || this.bytes.length;
    this.dict = r2;
  }
  get length() {
    return this.end - this.start;
  }
  get isEmpty() {
    return 0 === this.length;
  }
  getByte() {
    return this.pos >= this.end ? -1 : this.bytes[this.pos++];
  }
  getBytes(e2) {
    const t2 = this.bytes, a2 = this.pos, r2 = this.end;
    if (!e2) return t2.subarray(a2, r2);
    let i2 = a2 + e2;
    i2 > r2 && (i2 = r2);
    this.pos = i2;
    return t2.subarray(a2, i2);
  }
  getByteRange(e2, t2) {
    e2 < 0 && (e2 = 0);
    t2 > this.end && (t2 = this.end);
    return this.bytes.subarray(e2, t2);
  }
  reset() {
    this.pos = this.start;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(e2, t2, a2 = null) {
    return new _Stream(this.bytes.buffer, e2, t2, a2);
  }
};
var StringStream = class extends Stream {
  constructor(e2) {
    super(stringToBytes(e2));
  }
};
var NullStream = class extends Stream {
  constructor() {
    super(new Uint8Array(0));
  }
};
var ChunkedStream = class extends Stream {
  constructor(e2, t2, a2) {
    super(new Uint8Array(e2), 0, e2, null);
    this.chunkSize = t2;
    this._loadedChunks = /* @__PURE__ */ new Set();
    this.numChunks = Math.ceil(e2 / t2);
    this.manager = a2;
    this.progressiveDataLength = 0;
    this.lastSuccessfulEnsureByteChunk = -1;
  }
  getMissingChunks() {
    const e2 = [];
    for (let t2 = 0, a2 = this.numChunks; t2 < a2; ++t2) this._loadedChunks.has(t2) || e2.push(t2);
    return e2;
  }
  get numChunksLoaded() {
    return this._loadedChunks.size;
  }
  get isDataLoaded() {
    return this.numChunksLoaded === this.numChunks;
  }
  onReceiveData(e2, t2) {
    const a2 = this.chunkSize;
    if (e2 % a2 != 0) throw new Error(`Bad begin offset: ${e2}`);
    const r2 = e2 + t2.byteLength;
    if (r2 % a2 != 0 && r2 !== this.bytes.length) throw new Error(`Bad end offset: ${r2}`);
    this.bytes.set(new Uint8Array(t2), e2);
    const i2 = Math.floor(e2 / a2), n2 = Math.floor((r2 - 1) / a2) + 1;
    for (let e3 = i2; e3 < n2; ++e3) this._loadedChunks.add(e3);
  }
  onReceiveProgressiveData(e2) {
    let t2 = this.progressiveDataLength;
    const a2 = Math.floor(t2 / this.chunkSize);
    this.bytes.set(new Uint8Array(e2), t2);
    t2 += e2.byteLength;
    this.progressiveDataLength = t2;
    const r2 = t2 >= this.end ? this.numChunks : Math.floor(t2 / this.chunkSize);
    for (let e3 = a2; e3 < r2; ++e3) this._loadedChunks.add(e3);
  }
  ensureByte(e2) {
    if (e2 < this.progressiveDataLength) return;
    const t2 = Math.floor(e2 / this.chunkSize);
    if (!(t2 > this.numChunks) && t2 !== this.lastSuccessfulEnsureByteChunk) {
      if (!this._loadedChunks.has(t2)) throw new MissingDataException(e2, e2 + 1);
      this.lastSuccessfulEnsureByteChunk = t2;
    }
  }
  ensureRange(e2, t2) {
    if (e2 >= t2) return;
    if (t2 <= this.progressiveDataLength) return;
    const a2 = Math.floor(e2 / this.chunkSize);
    if (a2 > this.numChunks) return;
    const r2 = Math.min(Math.floor((t2 - 1) / this.chunkSize) + 1, this.numChunks);
    for (let i2 = a2; i2 < r2; ++i2) if (!this._loadedChunks.has(i2)) throw new MissingDataException(e2, t2);
  }
  nextEmptyChunk(e2) {
    const t2 = this.numChunks;
    for (let a2 = 0; a2 < t2; ++a2) {
      const r2 = (e2 + a2) % t2;
      if (!this._loadedChunks.has(r2)) return r2;
    }
    return null;
  }
  hasChunk(e2) {
    return this._loadedChunks.has(e2);
  }
  getByte() {
    const e2 = this.pos;
    if (e2 >= this.end) return -1;
    e2 >= this.progressiveDataLength && this.ensureByte(e2);
    return this.bytes[this.pos++];
  }
  getBytes(e2) {
    const t2 = this.bytes, a2 = this.pos, r2 = this.end;
    if (!e2) {
      r2 > this.progressiveDataLength && this.ensureRange(a2, r2);
      return t2.subarray(a2, r2);
    }
    let i2 = a2 + e2;
    i2 > r2 && (i2 = r2);
    i2 > this.progressiveDataLength && this.ensureRange(a2, i2);
    this.pos = i2;
    return t2.subarray(a2, i2);
  }
  getByteRange(e2, t2) {
    e2 < 0 && (e2 = 0);
    t2 > this.end && (t2 = this.end);
    t2 > this.progressiveDataLength && this.ensureRange(e2, t2);
    return this.bytes.subarray(e2, t2);
  }
  makeSubStream(e2, t2, a2 = null) {
    t2 ? e2 + t2 > this.progressiveDataLength && this.ensureRange(e2, e2 + t2) : e2 >= this.progressiveDataLength && this.ensureByte(e2);
    function ChunkedStreamSubstream() {
    }
    ChunkedStreamSubstream.prototype = Object.create(this);
    ChunkedStreamSubstream.prototype.getMissingChunks = function() {
      const e3 = this.chunkSize, t3 = Math.floor(this.start / e3), a3 = Math.floor((this.end - 1) / e3) + 1, r3 = [];
      for (let e4 = t3; e4 < a3; ++e4) this._loadedChunks.has(e4) || r3.push(e4);
      return r3;
    };
    Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", { get() {
      return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
    }, configurable: true });
    const r2 = new ChunkedStreamSubstream();
    r2.pos = r2.start = e2;
    r2.end = e2 + t2 || this.end;
    r2.dict = a2;
    return r2;
  }
  getBaseStreams() {
    return [this];
  }
};
var ChunkedStreamManager = class {
  constructor(e2, t2) {
    this.length = t2.length;
    this.chunkSize = t2.rangeChunkSize;
    this.stream = new ChunkedStream(this.length, this.chunkSize, this);
    this.pdfNetworkStream = e2;
    this.disableAutoFetch = t2.disableAutoFetch;
    this.msgHandler = t2.msgHandler;
    this.currRequestId = 0;
    this._chunksNeededByRequest = /* @__PURE__ */ new Map();
    this._requestsByChunk = /* @__PURE__ */ new Map();
    this._promisesByRequest = /* @__PURE__ */ new Map();
    this.progressiveDataLength = 0;
    this.aborted = false;
    this._loadedStreamCapability = Promise.withResolvers();
  }
  sendRequest(e2, t2) {
    const a2 = this.pdfNetworkStream.getRangeReader(e2, t2);
    a2.isStreamingSupported || (a2.onProgress = this.onProgress.bind(this));
    let r2 = [], i2 = 0;
    return new Promise(((e3, t3) => {
      const readChunk = ({ value: n2, done: s2 }) => {
        try {
          if (s2) {
            const t4 = arrayBuffersToBytes(r2);
            r2 = null;
            e3(t4);
            return;
          }
          i2 += n2.byteLength;
          a2.isStreamingSupported && this.onProgress({ loaded: i2 });
          r2.push(n2);
          a2.read().then(readChunk, t3);
        } catch (e4) {
          t3(e4);
        }
      };
      a2.read().then(readChunk, t3);
    })).then(((t3) => {
      this.aborted || this.onReceiveData({ chunk: t3, begin: e2 });
    }));
  }
  requestAllChunks(e2 = false) {
    if (!e2) {
      const e3 = this.stream.getMissingChunks();
      this._requestChunks(e3);
    }
    return this._loadedStreamCapability.promise;
  }
  _requestChunks(e2) {
    const t2 = this.currRequestId++, a2 = /* @__PURE__ */ new Set();
    this._chunksNeededByRequest.set(t2, a2);
    for (const t3 of e2) this.stream.hasChunk(t3) || a2.add(t3);
    if (0 === a2.size) return Promise.resolve();
    const r2 = Promise.withResolvers();
    this._promisesByRequest.set(t2, r2);
    const i2 = [];
    for (const e3 of a2) {
      let a3 = this._requestsByChunk.get(e3);
      if (!a3) {
        a3 = [];
        this._requestsByChunk.set(e3, a3);
        i2.push(e3);
      }
      a3.push(t2);
    }
    if (i2.length > 0) {
      const e3 = this.groupChunks(i2);
      for (const t3 of e3) {
        const e4 = t3.beginChunk * this.chunkSize, a3 = Math.min(t3.endChunk * this.chunkSize, this.length);
        this.sendRequest(e4, a3).catch(r2.reject);
      }
    }
    return r2.promise.catch(((e3) => {
      if (!this.aborted) throw e3;
    }));
  }
  getStream() {
    return this.stream;
  }
  requestRange(e2, t2) {
    t2 = Math.min(t2, this.length);
    const a2 = this.getBeginChunk(e2), r2 = this.getEndChunk(t2), i2 = [];
    for (let e3 = a2; e3 < r2; ++e3) i2.push(e3);
    return this._requestChunks(i2);
  }
  requestRanges(e2 = []) {
    const t2 = [];
    for (const a2 of e2) {
      const e3 = this.getBeginChunk(a2.begin), r2 = this.getEndChunk(a2.end);
      for (let a3 = e3; a3 < r2; ++a3) t2.includes(a3) || t2.push(a3);
    }
    t2.sort(((e3, t3) => e3 - t3));
    return this._requestChunks(t2);
  }
  groupChunks(e2) {
    const t2 = [];
    let a2 = -1, r2 = -1;
    for (let i2 = 0, n2 = e2.length; i2 < n2; ++i2) {
      const n3 = e2[i2];
      a2 < 0 && (a2 = n3);
      if (r2 >= 0 && r2 + 1 !== n3) {
        t2.push({ beginChunk: a2, endChunk: r2 + 1 });
        a2 = n3;
      }
      i2 + 1 === e2.length && t2.push({ beginChunk: a2, endChunk: n3 + 1 });
      r2 = n3;
    }
    return t2;
  }
  onProgress(e2) {
    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + e2.loaded, total: this.length });
  }
  onReceiveData(e2) {
    const t2 = e2.chunk, a2 = void 0 === e2.begin, r2 = a2 ? this.progressiveDataLength : e2.begin, i2 = r2 + t2.byteLength, n2 = Math.floor(r2 / this.chunkSize), s2 = i2 < this.length ? Math.floor(i2 / this.chunkSize) : Math.ceil(i2 / this.chunkSize);
    if (a2) {
      this.stream.onReceiveProgressiveData(t2);
      this.progressiveDataLength = i2;
    } else this.stream.onReceiveData(r2, t2);
    this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
    const o2 = [];
    for (let e3 = n2; e3 < s2; ++e3) {
      const t3 = this._requestsByChunk.get(e3);
      if (t3) {
        this._requestsByChunk.delete(e3);
        for (const a3 of t3) {
          const t4 = this._chunksNeededByRequest.get(a3);
          t4.has(e3) && t4.delete(e3);
          t4.size > 0 || o2.push(a3);
        }
      }
    }
    if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
      let e3;
      if (1 === this.stream.numChunksLoaded) {
        const t3 = this.stream.numChunks - 1;
        this.stream.hasChunk(t3) || (e3 = t3);
      } else e3 = this.stream.nextEmptyChunk(s2);
      Number.isInteger(e3) && this._requestChunks([e3]);
    }
    for (const e3 of o2) {
      const t3 = this._promisesByRequest.get(e3);
      this._promisesByRequest.delete(e3);
      t3.resolve();
    }
    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length });
  }
  onError(e2) {
    this._loadedStreamCapability.reject(e2);
  }
  getBeginChunk(e2) {
    return Math.floor(e2 / this.chunkSize);
  }
  getEndChunk(e2) {
    return Math.floor((e2 - 1) / this.chunkSize) + 1;
  }
  abort(e2) {
    this.aborted = true;
    this.pdfNetworkStream?.cancelAllRequests(e2);
    for (const t2 of this._promisesByRequest.values()) t2.reject(e2);
  }
};
function convertToRGBA(e2) {
  switch (e2.kind) {
    case k:
      return convertBlackAndWhiteToRGBA(e2);
    case C:
      return (function convertRGBToRGBA({ src: e3, srcPos: t2 = 0, dest: a2, destPos: r2 = 0, width: i2, height: n2 }) {
        let s2 = 0;
        const o2 = i2 * n2 * 3, c2 = o2 >> 2, l2 = new Uint32Array(e3.buffer, t2, c2);
        if (FeatureTest.isLittleEndian) {
          for (; s2 < c2 - 2; s2 += 3, r2 += 4) {
            const e4 = l2[s2], t3 = l2[s2 + 1], i3 = l2[s2 + 2];
            a2[r2] = 4278190080 | e4;
            a2[r2 + 1] = e4 >>> 24 | t3 << 8 | 4278190080;
            a2[r2 + 2] = t3 >>> 16 | i3 << 16 | 4278190080;
            a2[r2 + 3] = i3 >>> 8 | 4278190080;
          }
          for (let i3 = 4 * s2, n3 = t2 + o2; i3 < n3; i3 += 3) a2[r2++] = e3[i3] | e3[i3 + 1] << 8 | e3[i3 + 2] << 16 | 4278190080;
        } else {
          for (; s2 < c2 - 2; s2 += 3, r2 += 4) {
            const e4 = l2[s2], t3 = l2[s2 + 1], i3 = l2[s2 + 2];
            a2[r2] = 255 | e4;
            a2[r2 + 1] = e4 << 24 | t3 >>> 8 | 255;
            a2[r2 + 2] = t3 << 16 | i3 >>> 16 | 255;
            a2[r2 + 3] = i3 << 8 | 255;
          }
          for (let i3 = 4 * s2, n3 = t2 + o2; i3 < n3; i3 += 3) a2[r2++] = e3[i3] << 24 | e3[i3 + 1] << 16 | e3[i3 + 2] << 8 | 255;
        }
        return { srcPos: t2 + o2, destPos: r2 };
      })(e2);
  }
  return null;
}
function convertBlackAndWhiteToRGBA({ src: e2, srcPos: t2 = 0, dest: a2, width: r2, height: i2, nonBlackColor: n2 = 4294967295, inverseDecode: s2 = false }) {
  const o2 = FeatureTest.isLittleEndian ? 4278190080 : 255, [c2, l2] = s2 ? [n2, o2] : [o2, n2], h2 = r2 >> 3, u2 = 7 & r2, d2 = e2.length;
  a2 = new Uint32Array(a2.buffer);
  let f2 = 0;
  for (let r3 = 0; r3 < i2; r3++) {
    for (const r5 = t2 + h2; t2 < r5; t2++) {
      const r6 = t2 < d2 ? e2[t2] : 255;
      a2[f2++] = 128 & r6 ? l2 : c2;
      a2[f2++] = 64 & r6 ? l2 : c2;
      a2[f2++] = 32 & r6 ? l2 : c2;
      a2[f2++] = 16 & r6 ? l2 : c2;
      a2[f2++] = 8 & r6 ? l2 : c2;
      a2[f2++] = 4 & r6 ? l2 : c2;
      a2[f2++] = 2 & r6 ? l2 : c2;
      a2[f2++] = 1 & r6 ? l2 : c2;
    }
    if (0 === u2) continue;
    const r4 = t2 < d2 ? e2[t2++] : 255;
    for (let e3 = 0; e3 < u2; e3++) a2[f2++] = r4 & 1 << 7 - e3 ? l2 : c2;
  }
  return { srcPos: t2, destPos: f2 };
}
var ImageResizer = class _ImageResizer {
  static #O = 2048;
  static #M = FeatureTest.isImageDecoderSupported;
  constructor(e2, t2) {
    this._imgData = e2;
    this._isMask = t2;
  }
  static get canUseImageDecoder() {
    return shadow(this, "canUseImageDecoder", this.#M ? ImageDecoder.isTypeSupported("image/bmp") : Promise.resolve(false));
  }
  static needsToBeResized(e2, t2) {
    if (e2 <= this.#O && t2 <= this.#O) return false;
    const { MAX_DIM: a2 } = this;
    if (e2 > a2 || t2 > a2) return true;
    const r2 = e2 * t2;
    if (this._hasMaxArea) return r2 > this.MAX_AREA;
    if (r2 < this.#O ** 2) return false;
    if (this._areGoodDims(e2, t2)) {
      this.#O = Math.max(this.#O, Math.floor(Math.sqrt(e2 * t2)));
      return false;
    }
    this.#O = this._guessMax(this.#O, a2, 128, 0);
    return r2 > (this.MAX_AREA = this.#O ** 2);
  }
  static getReducePowerForJPX(e2, t2, a2) {
    const r2 = e2 * t2, i2 = 2 ** 30 / (4 * a2);
    if (!this.needsToBeResized(e2, t2)) return r2 > i2 ? Math.ceil(Math.log2(r2 / i2)) : 0;
    const { MAX_DIM: n2, MAX_AREA: s2 } = this, o2 = Math.max(e2 / n2, t2 / n2, Math.sqrt(r2 / Math.min(i2, s2)));
    return Math.ceil(Math.log2(o2));
  }
  static get MAX_DIM() {
    return shadow(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
  }
  static get MAX_AREA() {
    this._hasMaxArea = true;
    return shadow(this, "MAX_AREA", this._guessMax(this.#O, this.MAX_DIM, 128, 0) ** 2);
  }
  static set MAX_AREA(e2) {
    if (e2 >= 0) {
      this._hasMaxArea = true;
      shadow(this, "MAX_AREA", e2);
    }
  }
  static setOptions({ canvasMaxAreaInBytes: e2 = -1, isImageDecoderSupported: t2 = false }) {
    this._hasMaxArea || (this.MAX_AREA = e2 >> 2);
    this.#M = t2;
  }
  static _areGoodDims(e2, t2) {
    try {
      const a2 = new OffscreenCanvas(e2, t2), r2 = a2.getContext("2d");
      r2.fillRect(0, 0, 1, 1);
      const i2 = r2.getImageData(0, 0, 1, 1).data[3];
      a2.width = a2.height = 1;
      return 0 !== i2;
    } catch {
      return false;
    }
  }
  static _guessMax(e2, t2, a2, r2) {
    for (; e2 + a2 + 1 < t2; ) {
      const a3 = Math.floor((e2 + t2) / 2), i2 = r2 || a3;
      this._areGoodDims(a3, i2) ? e2 = a3 : t2 = a3;
    }
    return e2;
  }
  static async createImage(e2, t2 = false) {
    return new _ImageResizer(e2, t2)._createImage();
  }
  async _createImage() {
    const { _imgData: e2 } = this, { width: t2, height: a2 } = e2;
    if (t2 * a2 * 4 > va) {
      const e3 = this.#D();
      if (e3) return e3;
    }
    const r2 = this._encodeBMP();
    let i2, n2;
    if (await _ImageResizer.canUseImageDecoder) {
      i2 = new ImageDecoder({ data: r2, type: "image/bmp", preferAnimation: false, transfer: [r2.buffer] });
      n2 = i2.decode().catch(((e3) => {
        warn(`BMP image decoding failed: ${e3}`);
        return createImageBitmap(new Blob([this._encodeBMP().buffer], { type: "image/bmp" }));
      })).finally((() => {
        i2.close();
      }));
    } else n2 = createImageBitmap(new Blob([r2.buffer], { type: "image/bmp" }));
    const { MAX_AREA: s2, MAX_DIM: o2 } = _ImageResizer, c2 = Math.max(t2 / o2, a2 / o2, Math.sqrt(t2 * a2 / s2)), l2 = Math.max(c2, 2), h2 = Math.round(10 * (c2 + 1.25)) / 10 / l2, u2 = Math.floor(Math.log2(h2)), d2 = new Array(u2 + 2).fill(2);
    d2[0] = l2;
    d2.splice(-1, 1, h2 / (1 << u2));
    let f2 = t2, g2 = a2;
    const p2 = await n2;
    let m2 = p2.image || p2;
    for (const e3 of d2) {
      const t3 = f2, a3 = g2;
      f2 = Math.floor(f2 / e3) - 1;
      g2 = Math.floor(g2 / e3) - 1;
      const r3 = new OffscreenCanvas(f2, g2);
      r3.getContext("2d").drawImage(m2, 0, 0, t3, a3, 0, 0, f2, g2);
      m2.close();
      m2 = r3.transferToImageBitmap();
    }
    e2.data = null;
    e2.bitmap = m2;
    e2.width = f2;
    e2.height = g2;
    return e2;
  }
  #D() {
    const { _imgData: e2 } = this, { data: t2, width: a2, height: r2, kind: i2 } = e2, n2 = a2 * r2 * 4, s2 = Math.ceil(Math.log2(n2 / va)), o2 = a2 >> s2, c2 = r2 >> s2;
    let l2, h2 = r2;
    try {
      l2 = new Uint8Array(n2);
    } catch {
      let e3 = Math.floor(Math.log2(n2 + 1));
      for (; ; ) try {
        l2 = new Uint8Array(2 ** e3 - 1);
        break;
      } catch {
        e3 -= 1;
      }
      h2 = Math.floor((2 ** e3 - 1) / (4 * a2));
      const t3 = a2 * h2 * 4;
      t3 < l2.length && (l2 = new Uint8Array(t3));
    }
    const u2 = new Uint32Array(l2.buffer), d2 = new Uint32Array(o2 * c2);
    let f2 = 0, g2 = 0;
    const p2 = Math.ceil(r2 / h2), m2 = r2 % h2 == 0 ? r2 : r2 % h2;
    for (let e3 = 0; e3 < p2; e3++) {
      const r3 = e3 < p2 - 1 ? h2 : m2;
      ({ srcPos: f2 } = convertToRGBA({ kind: i2, src: t2, dest: u2, width: a2, height: r3, inverseDecode: this._isMask, srcPos: f2 }));
      for (let e4 = 0, t3 = r3 >> s2; e4 < t3; e4++) {
        const t4 = u2.subarray((e4 << s2) * a2);
        for (let e5 = 0; e5 < o2; e5++) d2[g2++] = t4[e5 << s2];
      }
    }
    if (_ImageResizer.needsToBeResized(o2, c2)) {
      e2.data = d2;
      e2.width = o2;
      e2.height = c2;
      e2.kind = v;
      return null;
    }
    const b2 = new OffscreenCanvas(o2, c2);
    b2.getContext("2d", { willReadFrequently: true }).putImageData(new ImageData(new Uint8ClampedArray(d2.buffer), o2, c2), 0, 0);
    e2.data = null;
    e2.bitmap = b2.transferToImageBitmap();
    e2.width = o2;
    e2.height = c2;
    return e2;
  }
  _encodeBMP() {
    const { width: e2, height: t2, kind: a2 } = this._imgData;
    let r2, i2 = this._imgData.data, n2 = new Uint8Array(0), s2 = n2, o2 = 0;
    switch (a2) {
      case k: {
        r2 = 1;
        n2 = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
        const a4 = e2 + 7 >> 3, s3 = a4 + 3 & -4;
        if (a4 !== s3) {
          const e3 = new Uint8Array(s3 * t2);
          let r3 = 0;
          for (let n3 = 0, o3 = t2 * a4; n3 < o3; n3 += a4, r3 += s3) e3.set(i2.subarray(n3, n3 + a4), r3);
          i2 = e3;
        }
        break;
      }
      case C:
        r2 = 24;
        if (3 & e2) {
          const a4 = 3 * e2, r3 = a4 + 3 & -4, n3 = r3 - a4, s3 = new Uint8Array(r3 * t2);
          let o3 = 0;
          for (let e3 = 0, r4 = t2 * a4; e3 < r4; e3 += a4) {
            const t3 = i2.subarray(e3, e3 + a4);
            for (let e4 = 0; e4 < a4; e4 += 3) {
              s3[o3++] = t3[e4 + 2];
              s3[o3++] = t3[e4 + 1];
              s3[o3++] = t3[e4];
            }
            o3 += n3;
          }
          i2 = s3;
        } else for (let e3 = 0, t3 = i2.length; e3 < t3; e3 += 3) {
          const t4 = i2[e3];
          i2[e3] = i2[e3 + 2];
          i2[e3 + 2] = t4;
        }
        break;
      case v:
        r2 = 32;
        o2 = 3;
        s2 = new Uint8Array(68);
        const a3 = new DataView(s2.buffer);
        if (FeatureTest.isLittleEndian) {
          a3.setUint32(0, 255, true);
          a3.setUint32(4, 65280, true);
          a3.setUint32(8, 16711680, true);
          a3.setUint32(12, 4278190080, true);
        } else {
          a3.setUint32(0, 4278190080, true);
          a3.setUint32(4, 16711680, true);
          a3.setUint32(8, 65280, true);
          a3.setUint32(12, 255, true);
        }
        break;
      default:
        throw new Error("invalid format");
    }
    let c2 = 0;
    const l2 = 40 + s2.length, h2 = 14 + l2 + n2.length + i2.length, u2 = new Uint8Array(h2), d2 = new DataView(u2.buffer);
    d2.setUint16(c2, 19778, true);
    c2 += 2;
    d2.setUint32(c2, h2, true);
    c2 += 4;
    d2.setUint32(c2, 0, true);
    c2 += 4;
    d2.setUint32(c2, 14 + l2 + n2.length, true);
    c2 += 4;
    d2.setUint32(c2, l2, true);
    c2 += 4;
    d2.setInt32(c2, e2, true);
    c2 += 4;
    d2.setInt32(c2, -t2, true);
    c2 += 4;
    d2.setUint16(c2, 1, true);
    c2 += 2;
    d2.setUint16(c2, r2, true);
    c2 += 2;
    d2.setUint32(c2, o2, true);
    c2 += 4;
    d2.setUint32(c2, 0, true);
    c2 += 4;
    d2.setInt32(c2, 0, true);
    c2 += 4;
    d2.setInt32(c2, 0, true);
    c2 += 4;
    d2.setUint32(c2, n2.length / 4, true);
    c2 += 4;
    d2.setUint32(c2, 0, true);
    c2 += 4;
    u2.set(s2, c2);
    c2 += s2.length;
    u2.set(n2, c2);
    c2 += n2.length;
    u2.set(i2, c2);
    return u2;
  }
};
var La = new Uint8Array(0);
var DecodeStream = class extends BaseStream {
  constructor(e2) {
    super();
    this._rawMinBufferLength = e2 || 0;
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = La;
    this.minBufferLength = 512;
    if (e2) for (; this.minBufferLength < e2; ) this.minBufferLength *= 2;
  }
  get isEmpty() {
    for (; !this.eof && 0 === this.bufferLength; ) this.readBlock();
    return 0 === this.bufferLength;
  }
  ensureBuffer(e2) {
    const t2 = this.buffer;
    if (e2 <= t2.byteLength) return t2;
    let a2 = this.minBufferLength;
    for (; a2 < e2; ) a2 *= 2;
    const r2 = new Uint8Array(a2);
    r2.set(t2);
    return this.buffer = r2;
  }
  getByte() {
    const e2 = this.pos;
    for (; this.bufferLength <= e2; ) {
      if (this.eof) return -1;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }
  getBytes(e2, t2 = null) {
    const a2 = this.pos;
    let r2;
    if (e2) {
      this.ensureBuffer(a2 + e2);
      r2 = a2 + e2;
      for (; !this.eof && this.bufferLength < r2; ) this.readBlock(t2);
      const i2 = this.bufferLength;
      r2 > i2 && (r2 = i2);
    } else {
      for (; !this.eof; ) this.readBlock(t2);
      r2 = this.bufferLength;
    }
    this.pos = r2;
    return this.buffer.subarray(a2, r2);
  }
  async getImageData(e2, t2) {
    if (!this.canAsyncDecodeImageFromBuffer) return this.isAsyncDecoder ? this.decodeImage(null, t2) : this.getBytes(e2, t2);
    const a2 = await this.stream.asyncGetBytes();
    return this.decodeImage(a2, t2);
  }
  reset() {
    this.pos = 0;
  }
  makeSubStream(e2, t2, a2 = null) {
    if (void 0 === t2) for (; !this.eof; ) this.readBlock();
    else {
      const a3 = e2 + t2;
      for (; this.bufferLength <= a3 && !this.eof; ) this.readBlock();
    }
    return new Stream(this.buffer, e2, t2, a2);
  }
  getBaseStreams() {
    return this.str ? this.str.getBaseStreams() : null;
  }
};
var StreamsSequenceStream = class extends DecodeStream {
  constructor(e2, t2 = null) {
    e2 = e2.filter(((e3) => e3 instanceof BaseStream));
    let a2 = 0;
    for (const t3 of e2) a2 += t3 instanceof DecodeStream ? t3._rawMinBufferLength : t3.length;
    super(a2);
    this.streams = e2;
    this._onError = t2;
  }
  readBlock() {
    const e2 = this.streams;
    if (0 === e2.length) {
      this.eof = true;
      return;
    }
    const t2 = e2.shift();
    let a2;
    try {
      a2 = t2.getBytes();
    } catch (e3) {
      if (this._onError) {
        this._onError(e3, t2.dict?.objId);
        return;
      }
      throw e3;
    }
    const r2 = this.bufferLength, i2 = r2 + a2.length;
    this.ensureBuffer(i2).set(a2, r2);
    this.bufferLength = i2;
  }
  getBaseStreams() {
    const e2 = [];
    for (const t2 of this.streams) {
      const a2 = t2.getBaseStreams();
      a2 && e2.push(...a2);
    }
    return e2.length > 0 ? e2 : null;
  }
};
var ColorSpaceUtils = class {
  static parse({ cs: e2, xref: t2, resources: a2 = null, pdfFunctionFactory: r2, globalColorSpaceCache: i2, localColorSpaceCache: n2, asyncIfNotCached: s2 = false }) {
    const o2 = { xref: t2, resources: a2, pdfFunctionFactory: r2, globalColorSpaceCache: i2, localColorSpaceCache: n2 };
    let c2, l2, h2;
    if (e2 instanceof Ref) {
      l2 = e2;
      const a3 = i2.getByRef(l2) || n2.getByRef(l2);
      if (a3) return a3;
      e2 = t2.fetch(e2);
    }
    if (e2 instanceof Name) {
      c2 = e2.name;
      const t3 = n2.getByName(c2);
      if (t3) return t3;
    }
    try {
      h2 = this.#B(e2, o2);
    } catch (e3) {
      if (s2 && !(e3 instanceof MissingDataException)) return Promise.reject(e3);
      throw e3;
    }
    if (c2 || l2) {
      n2.set(c2, l2, h2);
      l2 && i2.set(null, l2, h2);
    }
    return s2 ? Promise.resolve(h2) : h2;
  }
  static #R(e2, t2) {
    const { globalColorSpaceCache: a2 } = t2;
    let r2;
    if (e2 instanceof Ref) {
      r2 = e2;
      const t3 = a2.getByRef(r2);
      if (t3) return t3;
    }
    const i2 = this.#B(e2, t2);
    r2 && a2.set(null, r2, i2);
    return i2;
  }
  static #B(e2, t2) {
    const { xref: a2, resources: r2, pdfFunctionFactory: i2, globalColorSpaceCache: n2 } = t2;
    if ((e2 = a2.fetchIfRef(e2)) instanceof Name) switch (e2.name) {
      case "G":
      case "DeviceGray":
        return this.gray;
      case "RGB":
      case "DeviceRGB":
        return this.rgb;
      case "DeviceRGBA":
        return this.rgba;
      case "CMYK":
      case "DeviceCMYK":
        return this.cmyk;
      case "Pattern":
        return new PatternCS(null);
      default:
        if (r2 instanceof Dict) {
          const a3 = r2.get("ColorSpace");
          if (a3 instanceof Dict) {
            const r3 = a3.get(e2.name);
            if (r3) {
              if (r3 instanceof Name) return this.#B(r3, t2);
              e2 = r3;
              break;
            }
          }
        }
        warn(`Unrecognized ColorSpace: ${e2.name}`);
        return this.gray;
    }
    if (Array.isArray(e2)) {
      const r3 = a2.fetchIfRef(e2[0]).name;
      let s2, o2, c2, l2, h2, u2;
      switch (r3) {
        case "G":
        case "DeviceGray":
          return this.gray;
        case "RGB":
        case "DeviceRGB":
          return this.rgb;
        case "CMYK":
        case "DeviceCMYK":
          return this.cmyk;
        case "CalGray":
          s2 = a2.fetchIfRef(e2[1]);
          l2 = s2.getArray("WhitePoint");
          h2 = s2.getArray("BlackPoint");
          u2 = s2.get("Gamma");
          return new CalGrayCS(l2, h2, u2);
        case "CalRGB":
          s2 = a2.fetchIfRef(e2[1]);
          l2 = s2.getArray("WhitePoint");
          h2 = s2.getArray("BlackPoint");
          u2 = s2.getArray("Gamma");
          const d2 = s2.getArray("Matrix");
          return new CalRGBCS(l2, h2, u2, d2);
        case "ICCBased":
          const f2 = e2[1] instanceof Ref;
          if (f2) {
            const t3 = n2.getByRef(e2[1]);
            if (t3) return t3;
          }
          const g2 = a2.fetchIfRef(e2[1]), p2 = g2.dict;
          o2 = p2.get("N");
          if (IccColorSpace.isUsable) try {
            const t3 = new IccColorSpace(g2.getBytes(), "ICCBased", o2);
            f2 && n2.set(null, e2[1], t3);
            return t3;
          } catch (t3) {
            if (t3 instanceof MissingDataException) throw t3;
            warn(`ICCBased color space (${e2[1]}): "${t3}".`);
          }
          const m2 = p2.getRaw("Alternate");
          if (m2) {
            const e3 = this.#R(m2, t2);
            if (e3.numComps === o2) return e3;
            warn("ICCBased color space: Ignoring incorrect /Alternate entry.");
          }
          if (1 === o2) return this.gray;
          if (3 === o2) return this.rgb;
          if (4 === o2) return this.cmyk;
          break;
        case "Pattern":
          c2 = e2[1] || null;
          c2 && (c2 = this.#R(c2, t2));
          return new PatternCS(c2);
        case "I":
        case "Indexed":
          c2 = this.#R(e2[1], t2);
          const b2 = MathClamp(a2.fetchIfRef(e2[2]), 0, 255), y2 = a2.fetchIfRef(e2[3]);
          return new IndexedCS(c2, b2, y2);
        case "Separation":
        case "DeviceN":
          const w2 = a2.fetchIfRef(e2[1]);
          o2 = Array.isArray(w2) ? w2.length : 1;
          c2 = this.#R(e2[2], t2);
          const x2 = i2.create(e2[3]);
          return new AlternateCS(o2, c2, x2);
        case "Lab":
          s2 = a2.fetchIfRef(e2[1]);
          l2 = s2.getArray("WhitePoint");
          h2 = s2.getArray("BlackPoint");
          const S2 = s2.getArray("Range");
          return new LabCS(l2, h2, S2);
        default:
          warn(`Unimplemented ColorSpace object: ${r3}`);
          return this.gray;
      }
    }
    warn(`Unrecognized ColorSpace object: ${e2}`);
    return this.gray;
  }
  static get gray() {
    return shadow(this, "gray", new DeviceGrayCS());
  }
  static get rgb() {
    return shadow(this, "rgb", new DeviceRgbCS());
  }
  static get rgba() {
    return shadow(this, "rgba", new DeviceRgbaCS());
  }
  static get cmyk() {
    if (CmykICCBasedCS.isUsable) try {
      return shadow(this, "cmyk", new CmykICCBasedCS());
    } catch {
      warn("CMYK fallback: DeviceCMYK");
    }
    return shadow(this, "cmyk", new DeviceCmykCS());
  }
};
var JpegError = class extends fa {
  constructor(e2) {
    super(e2, "JpegError");
  }
};
var DNLMarkerError = class extends fa {
  constructor(e2, t2) {
    super(e2, "DNLMarkerError");
    this.scanLines = t2;
  }
};
var EOIMarkerError = class extends fa {
  constructor(e2) {
    super(e2, "EOIMarkerError");
  }
};
var ja = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
var _a = 4017;
var Ua = 799;
var Xa = 3406;
var qa = 2276;
var Ha = 1567;
var Wa = 3784;
var za = 5793;
var $a = 2896;
function buildHuffmanTable(e2, t2) {
  let a2, r2, i2 = 0, n2 = 16;
  for (; n2 > 0 && !e2[n2 - 1]; ) n2--;
  const s2 = [{ children: [], index: 0 }];
  let o2, c2 = s2[0];
  for (a2 = 0; a2 < n2; a2++) {
    for (r2 = 0; r2 < e2[a2]; r2++) {
      c2 = s2.pop();
      c2.children[c2.index] = t2[i2];
      for (; c2.index > 0; ) c2 = s2.pop();
      c2.index++;
      s2.push(c2);
      for (; s2.length <= a2; ) {
        s2.push(o2 = { children: [], index: 0 });
        c2.children[c2.index] = o2.children;
        c2 = o2;
      }
      i2++;
    }
    if (a2 + 1 < n2) {
      s2.push(o2 = { children: [], index: 0 });
      c2.children[c2.index] = o2.children;
      c2 = o2;
    }
  }
  return s2[0].children;
}
function getBlockBufferOffset(e2, t2, a2) {
  return 64 * ((e2.blocksPerLine + 1) * t2 + a2);
}
function decodeScan(e2, t2, a2, r2, i2, n2, s2, o2, c2, l2 = false) {
  const h2 = a2.mcusPerLine, u2 = a2.progressive, d2 = t2;
  let f2 = 0, g2 = 0;
  function readBit() {
    if (g2 > 0) {
      g2--;
      return f2 >> g2 & 1;
    }
    f2 = e2[t2++];
    if (255 === f2) {
      const r3 = e2[t2++];
      if (r3) {
        if (220 === r3 && l2) {
          const r4 = readUint16(e2, t2 += 2);
          t2 += 2;
          if (r4 > 0 && r4 !== a2.scanLines) throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", r4);
        } else if (217 === r3) {
          if (l2) {
            const e3 = y2 * (8 === a2.precision ? 8 : 0);
            if (e3 > 0 && Math.round(a2.scanLines / e3) >= 5) throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e3);
          }
          throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new JpegError(`unexpected marker ${(f2 << 8 | r3).toString(16)}`);
      }
    }
    g2 = 7;
    return f2 >>> 7;
  }
  function decodeHuffman(e3) {
    let t3 = e3;
    for (; ; ) {
      t3 = t3[readBit()];
      switch (typeof t3) {
        case "number":
          return t3;
        case "object":
          continue;
      }
      throw new JpegError("invalid huffman sequence");
    }
  }
  function receive(e3) {
    let t3 = 0;
    for (; e3 > 0; ) {
      t3 = t3 << 1 | readBit();
      e3--;
    }
    return t3;
  }
  function receiveAndExtend(e3) {
    if (1 === e3) return 1 === readBit() ? 1 : -1;
    const t3 = receive(e3);
    return t3 >= 1 << e3 - 1 ? t3 : t3 + (-1 << e3) + 1;
  }
  let p2 = 0;
  let m2, b2 = 0;
  let y2 = 0;
  function decodeMcu(e3, t3, a3, r3, i3) {
    const n3 = a3 % h2;
    y2 = (a3 / h2 | 0) * e3.v + r3;
    const s3 = n3 * e3.h + i3;
    t3(e3, getBlockBufferOffset(e3, y2, s3));
  }
  function decodeBlock(e3, t3, a3) {
    y2 = a3 / e3.blocksPerLine | 0;
    const r3 = a3 % e3.blocksPerLine;
    t3(e3, getBlockBufferOffset(e3, y2, r3));
  }
  const w2 = r2.length;
  let x2, S2, k2, C2, v2, F2;
  F2 = u2 ? 0 === n2 ? 0 === o2 ? function decodeDCFirst(e3, t3) {
    const a3 = decodeHuffman(e3.huffmanTableDC), r3 = 0 === a3 ? 0 : receiveAndExtend(a3) << c2;
    e3.blockData[t3] = e3.pred += r3;
  } : function decodeDCSuccessive(e3, t3) {
    e3.blockData[t3] |= readBit() << c2;
  } : 0 === o2 ? function decodeACFirst(e3, t3) {
    if (p2 > 0) {
      p2--;
      return;
    }
    let a3 = n2;
    const r3 = s2;
    for (; a3 <= r3; ) {
      const r4 = decodeHuffman(e3.huffmanTableAC), i3 = 15 & r4, n3 = r4 >> 4;
      if (0 === i3) {
        if (n3 < 15) {
          p2 = receive(n3) + (1 << n3) - 1;
          break;
        }
        a3 += 16;
        continue;
      }
      a3 += n3;
      const s3 = ja[a3];
      e3.blockData[t3 + s3] = receiveAndExtend(i3) * (1 << c2);
      a3++;
    }
  } : function decodeACSuccessive(e3, t3) {
    let a3 = n2;
    const r3 = s2;
    let i3, o3, l3 = 0;
    for (; a3 <= r3; ) {
      const r4 = t3 + ja[a3], n3 = e3.blockData[r4] < 0 ? -1 : 1;
      switch (b2) {
        case 0:
          o3 = decodeHuffman(e3.huffmanTableAC);
          i3 = 15 & o3;
          l3 = o3 >> 4;
          if (0 === i3) if (l3 < 15) {
            p2 = receive(l3) + (1 << l3);
            b2 = 4;
          } else {
            l3 = 16;
            b2 = 1;
          }
          else {
            if (1 !== i3) throw new JpegError("invalid ACn encoding");
            m2 = receiveAndExtend(i3);
            b2 = l3 ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          if (e3.blockData[r4]) e3.blockData[r4] += n3 * (readBit() << c2);
          else {
            l3--;
            0 === l3 && (b2 = 2 === b2 ? 3 : 0);
          }
          break;
        case 3:
          if (e3.blockData[r4]) e3.blockData[r4] += n3 * (readBit() << c2);
          else {
            e3.blockData[r4] = m2 << c2;
            b2 = 0;
          }
          break;
        case 4:
          e3.blockData[r4] && (e3.blockData[r4] += n3 * (readBit() << c2));
      }
      a3++;
    }
    if (4 === b2) {
      p2--;
      0 === p2 && (b2 = 0);
    }
  } : function decodeBaseline(e3, t3) {
    const a3 = decodeHuffman(e3.huffmanTableDC), r3 = 0 === a3 ? 0 : receiveAndExtend(a3);
    e3.blockData[t3] = e3.pred += r3;
    let i3 = 1;
    for (; i3 < 64; ) {
      const a4 = decodeHuffman(e3.huffmanTableAC), r4 = 15 & a4, n3 = a4 >> 4;
      if (0 === r4) {
        if (n3 < 15) break;
        i3 += 16;
        continue;
      }
      i3 += n3;
      const s3 = ja[i3];
      e3.blockData[t3 + s3] = receiveAndExtend(r4);
      i3++;
    }
  };
  let T2, O2 = 0;
  const M2 = 1 === w2 ? r2[0].blocksPerLine * r2[0].blocksPerColumn : h2 * a2.mcusPerColumn;
  let D2, R2;
  for (; O2 <= M2; ) {
    const a3 = i2 ? Math.min(M2 - O2, i2) : M2;
    if (a3 > 0) {
      for (S2 = 0; S2 < w2; S2++) r2[S2].pred = 0;
      p2 = 0;
      if (1 === w2) {
        x2 = r2[0];
        for (v2 = 0; v2 < a3; v2++) {
          decodeBlock(x2, F2, O2);
          O2++;
        }
      } else for (v2 = 0; v2 < a3; v2++) {
        for (S2 = 0; S2 < w2; S2++) {
          x2 = r2[S2];
          D2 = x2.h;
          R2 = x2.v;
          for (k2 = 0; k2 < R2; k2++) for (C2 = 0; C2 < D2; C2++) decodeMcu(x2, F2, O2, k2, C2);
        }
        O2++;
      }
    }
    g2 = 0;
    T2 = findNextFileMarker(e2, t2);
    if (!T2) break;
    if (T2.invalid) {
      warn(`decodeScan - ${a3 > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${T2.invalid}`);
      t2 = T2.offset;
    }
    if (!(T2.marker >= 65488 && T2.marker <= 65495)) break;
    t2 += 2;
  }
  return t2 - d2;
}
function quantizeAndInverse(e2, t2, a2) {
  const r2 = e2.quantizationTable, i2 = e2.blockData;
  let n2, s2, o2, c2, l2, h2, u2, d2, f2, g2, p2, m2, b2, y2, w2, x2, S2;
  if (!r2) throw new JpegError("missing required Quantization Table.");
  for (let e3 = 0; e3 < 64; e3 += 8) {
    f2 = i2[t2 + e3];
    g2 = i2[t2 + e3 + 1];
    p2 = i2[t2 + e3 + 2];
    m2 = i2[t2 + e3 + 3];
    b2 = i2[t2 + e3 + 4];
    y2 = i2[t2 + e3 + 5];
    w2 = i2[t2 + e3 + 6];
    x2 = i2[t2 + e3 + 7];
    f2 *= r2[e3];
    if (g2 | p2 | m2 | b2 | y2 | w2 | x2) {
      g2 *= r2[e3 + 1];
      p2 *= r2[e3 + 2];
      m2 *= r2[e3 + 3];
      b2 *= r2[e3 + 4];
      y2 *= r2[e3 + 5];
      w2 *= r2[e3 + 6];
      x2 *= r2[e3 + 7];
      n2 = za * f2 + 128 >> 8;
      s2 = za * b2 + 128 >> 8;
      o2 = p2;
      c2 = w2;
      l2 = $a * (g2 - x2) + 128 >> 8;
      d2 = $a * (g2 + x2) + 128 >> 8;
      h2 = m2 << 4;
      u2 = y2 << 4;
      n2 = n2 + s2 + 1 >> 1;
      s2 = n2 - s2;
      S2 = o2 * Wa + c2 * Ha + 128 >> 8;
      o2 = o2 * Ha - c2 * Wa + 128 >> 8;
      c2 = S2;
      l2 = l2 + u2 + 1 >> 1;
      u2 = l2 - u2;
      d2 = d2 + h2 + 1 >> 1;
      h2 = d2 - h2;
      n2 = n2 + c2 + 1 >> 1;
      c2 = n2 - c2;
      s2 = s2 + o2 + 1 >> 1;
      o2 = s2 - o2;
      S2 = l2 * qa + d2 * Xa + 2048 >> 12;
      l2 = l2 * Xa - d2 * qa + 2048 >> 12;
      d2 = S2;
      S2 = h2 * Ua + u2 * _a + 2048 >> 12;
      h2 = h2 * _a - u2 * Ua + 2048 >> 12;
      u2 = S2;
      a2[e3] = n2 + d2;
      a2[e3 + 7] = n2 - d2;
      a2[e3 + 1] = s2 + u2;
      a2[e3 + 6] = s2 - u2;
      a2[e3 + 2] = o2 + h2;
      a2[e3 + 5] = o2 - h2;
      a2[e3 + 3] = c2 + l2;
      a2[e3 + 4] = c2 - l2;
    } else {
      S2 = za * f2 + 512 >> 10;
      a2[e3] = S2;
      a2[e3 + 1] = S2;
      a2[e3 + 2] = S2;
      a2[e3 + 3] = S2;
      a2[e3 + 4] = S2;
      a2[e3 + 5] = S2;
      a2[e3 + 6] = S2;
      a2[e3 + 7] = S2;
    }
  }
  for (let e3 = 0; e3 < 8; ++e3) {
    f2 = a2[e3];
    g2 = a2[e3 + 8];
    p2 = a2[e3 + 16];
    m2 = a2[e3 + 24];
    b2 = a2[e3 + 32];
    y2 = a2[e3 + 40];
    w2 = a2[e3 + 48];
    x2 = a2[e3 + 56];
    if (g2 | p2 | m2 | b2 | y2 | w2 | x2) {
      n2 = za * f2 + 2048 >> 12;
      s2 = za * b2 + 2048 >> 12;
      o2 = p2;
      c2 = w2;
      l2 = $a * (g2 - x2) + 2048 >> 12;
      d2 = $a * (g2 + x2) + 2048 >> 12;
      h2 = m2;
      u2 = y2;
      n2 = 4112 + (n2 + s2 + 1 >> 1);
      s2 = n2 - s2;
      S2 = o2 * Wa + c2 * Ha + 2048 >> 12;
      o2 = o2 * Ha - c2 * Wa + 2048 >> 12;
      c2 = S2;
      l2 = l2 + u2 + 1 >> 1;
      u2 = l2 - u2;
      d2 = d2 + h2 + 1 >> 1;
      h2 = d2 - h2;
      n2 = n2 + c2 + 1 >> 1;
      c2 = n2 - c2;
      s2 = s2 + o2 + 1 >> 1;
      o2 = s2 - o2;
      S2 = l2 * qa + d2 * Xa + 2048 >> 12;
      l2 = l2 * Xa - d2 * qa + 2048 >> 12;
      d2 = S2;
      S2 = h2 * Ua + u2 * _a + 2048 >> 12;
      h2 = h2 * _a - u2 * Ua + 2048 >> 12;
      u2 = S2;
      f2 = n2 + d2;
      x2 = n2 - d2;
      g2 = s2 + u2;
      w2 = s2 - u2;
      p2 = o2 + h2;
      y2 = o2 - h2;
      m2 = c2 + l2;
      b2 = c2 - l2;
      f2 < 16 ? f2 = 0 : f2 >= 4080 ? f2 = 255 : f2 >>= 4;
      g2 < 16 ? g2 = 0 : g2 >= 4080 ? g2 = 255 : g2 >>= 4;
      p2 < 16 ? p2 = 0 : p2 >= 4080 ? p2 = 255 : p2 >>= 4;
      m2 < 16 ? m2 = 0 : m2 >= 4080 ? m2 = 255 : m2 >>= 4;
      b2 < 16 ? b2 = 0 : b2 >= 4080 ? b2 = 255 : b2 >>= 4;
      y2 < 16 ? y2 = 0 : y2 >= 4080 ? y2 = 255 : y2 >>= 4;
      w2 < 16 ? w2 = 0 : w2 >= 4080 ? w2 = 255 : w2 >>= 4;
      x2 < 16 ? x2 = 0 : x2 >= 4080 ? x2 = 255 : x2 >>= 4;
      i2[t2 + e3] = f2;
      i2[t2 + e3 + 8] = g2;
      i2[t2 + e3 + 16] = p2;
      i2[t2 + e3 + 24] = m2;
      i2[t2 + e3 + 32] = b2;
      i2[t2 + e3 + 40] = y2;
      i2[t2 + e3 + 48] = w2;
      i2[t2 + e3 + 56] = x2;
    } else {
      S2 = za * f2 + 8192 >> 14;
      S2 = S2 < -2040 ? 0 : S2 >= 2024 ? 255 : S2 + 2056 >> 4;
      i2[t2 + e3] = S2;
      i2[t2 + e3 + 8] = S2;
      i2[t2 + e3 + 16] = S2;
      i2[t2 + e3 + 24] = S2;
      i2[t2 + e3 + 32] = S2;
      i2[t2 + e3 + 40] = S2;
      i2[t2 + e3 + 48] = S2;
      i2[t2 + e3 + 56] = S2;
    }
  }
}
function buildComponentData(e2, t2) {
  const a2 = t2.blocksPerLine, r2 = t2.blocksPerColumn, i2 = new Int16Array(64);
  for (let e3 = 0; e3 < r2; e3++) for (let r3 = 0; r3 < a2; r3++) {
    quantizeAndInverse(t2, getBlockBufferOffset(t2, e3, r3), i2);
  }
  return t2.blockData;
}
function findNextFileMarker(e2, t2, a2 = t2) {
  const r2 = e2.length - 1;
  let i2 = a2 < t2 ? a2 : t2;
  if (t2 >= r2) return null;
  const n2 = readUint16(e2, t2);
  if (n2 >= 65472 && n2 <= 65534) return { invalid: null, marker: n2, offset: t2 };
  let s2 = readUint16(e2, i2);
  for (; !(s2 >= 65472 && s2 <= 65534); ) {
    if (++i2 >= r2) return null;
    s2 = readUint16(e2, i2);
  }
  return { invalid: n2.toString(16), marker: s2, offset: i2 };
}
function prepareComponents(e2) {
  const t2 = Math.ceil(e2.samplesPerLine / 8 / e2.maxH), a2 = Math.ceil(e2.scanLines / 8 / e2.maxV);
  for (const r2 of e2.components) {
    const i2 = Math.ceil(Math.ceil(e2.samplesPerLine / 8) * r2.h / e2.maxH), n2 = Math.ceil(Math.ceil(e2.scanLines / 8) * r2.v / e2.maxV), s2 = t2 * r2.h, o2 = 64 * (a2 * r2.v) * (s2 + 1);
    r2.blockData = new Int16Array(o2);
    r2.blocksPerLine = i2;
    r2.blocksPerColumn = n2;
  }
  e2.mcusPerLine = t2;
  e2.mcusPerColumn = a2;
}
function readDataBlock(e2, t2) {
  const a2 = readUint16(e2, t2);
  let r2 = (t2 += 2) + a2 - 2;
  const i2 = findNextFileMarker(e2, r2, t2);
  if (i2?.invalid) {
    warn("readDataBlock - incorrect length, current marker is: " + i2.invalid);
    r2 = i2.offset;
  }
  const n2 = e2.subarray(t2, r2);
  return { appData: n2, oldOffset: t2, newOffset: t2 + n2.length };
}
function skipData(e2, t2) {
  const a2 = readUint16(e2, t2), r2 = (t2 += 2) + a2 - 2, i2 = findNextFileMarker(e2, r2, t2);
  return i2?.invalid ? i2.offset : r2;
}
var JpegImage = class {
  constructor({ decodeTransform: e2 = null, colorTransform: t2 = -1 } = {}) {
    this._decodeTransform = e2;
    this._colorTransform = t2;
  }
  static canUseImageDecoder(e2, t2 = -1) {
    let a2 = null, r2 = 0, i2 = null, n2 = readUint16(e2, r2);
    r2 += 2;
    if (65496 !== n2) throw new JpegError("SOI not found");
    n2 = readUint16(e2, r2);
    r2 += 2;
    e: for (; 65497 !== n2; ) {
      switch (n2) {
        case 65505:
          const { appData: t3, oldOffset: s2, newOffset: o2 } = readDataBlock(e2, r2);
          r2 = o2;
          if (69 === t3[0] && 120 === t3[1] && 105 === t3[2] && 102 === t3[3] && 0 === t3[4] && 0 === t3[5]) {
            if (a2) throw new JpegError("Duplicate EXIF-blocks found.");
            a2 = { exifStart: s2 + 6, exifEnd: o2 };
          }
          n2 = readUint16(e2, r2);
          r2 += 2;
          continue;
        case 65472:
        case 65473:
        case 65474:
          i2 = e2[r2 + 7];
          break e;
        case 65535:
          255 !== e2[r2] && r2--;
      }
      r2 = skipData(e2, r2);
      n2 = readUint16(e2, r2);
      r2 += 2;
    }
    return 4 === i2 || 3 === i2 && 0 === t2 ? null : a2 || {};
  }
  parse(e2, { dnlScanLines: t2 = null } = {}) {
    let a2, r2, i2 = 0, n2 = null, s2 = null, o2 = 0;
    const c2 = [], l2 = [], h2 = [];
    let u2 = readUint16(e2, i2);
    i2 += 2;
    if (65496 !== u2) throw new JpegError("SOI not found");
    u2 = readUint16(e2, i2);
    i2 += 2;
    e: for (; 65497 !== u2; ) {
      let d2, f2, g2;
      switch (u2) {
        case 65504:
        case 65505:
        case 65506:
        case 65507:
        case 65508:
        case 65509:
        case 65510:
        case 65511:
        case 65512:
        case 65513:
        case 65514:
        case 65515:
        case 65516:
        case 65517:
        case 65518:
        case 65519:
        case 65534:
          const { appData: p2, newOffset: m2 } = readDataBlock(e2, i2);
          i2 = m2;
          65504 === u2 && 74 === p2[0] && 70 === p2[1] && 73 === p2[2] && 70 === p2[3] && 0 === p2[4] && (n2 = { version: { major: p2[5], minor: p2[6] }, densityUnits: p2[7], xDensity: p2[8] << 8 | p2[9], yDensity: p2[10] << 8 | p2[11], thumbWidth: p2[12], thumbHeight: p2[13], thumbData: p2.subarray(14, 14 + 3 * p2[12] * p2[13]) });
          65518 === u2 && 65 === p2[0] && 100 === p2[1] && 111 === p2[2] && 98 === p2[3] && 101 === p2[4] && (s2 = { version: p2[5] << 8 | p2[6], flags0: p2[7] << 8 | p2[8], flags1: p2[9] << 8 | p2[10], transformCode: p2[11] });
          break;
        case 65499:
          const b2 = readUint16(e2, i2);
          i2 += 2;
          const y2 = b2 + i2 - 2;
          let w2;
          for (; i2 < y2; ) {
            const t3 = e2[i2++], a3 = new Uint16Array(64);
            if (t3 >> 4) {
              if (t3 >> 4 != 1) throw new JpegError("DQT - invalid table spec");
              for (f2 = 0; f2 < 64; f2++) {
                w2 = ja[f2];
                a3[w2] = readUint16(e2, i2);
                i2 += 2;
              }
            } else for (f2 = 0; f2 < 64; f2++) {
              w2 = ja[f2];
              a3[w2] = e2[i2++];
            }
            c2[15 & t3] = a3;
          }
          break;
        case 65472:
        case 65473:
        case 65474:
          if (a2) throw new JpegError("Only single frame JPEGs supported");
          i2 += 2;
          a2 = {};
          a2.extended = 65473 === u2;
          a2.progressive = 65474 === u2;
          a2.precision = e2[i2++];
          const x2 = readUint16(e2, i2);
          i2 += 2;
          a2.scanLines = t2 || x2;
          a2.samplesPerLine = readUint16(e2, i2);
          i2 += 2;
          a2.components = [];
          a2.componentIds = {};
          const S2 = e2[i2++];
          let k2 = 0, C2 = 0;
          for (d2 = 0; d2 < S2; d2++) {
            const t3 = e2[i2], r3 = e2[i2 + 1] >> 4, n3 = 15 & e2[i2 + 1];
            k2 < r3 && (k2 = r3);
            C2 < n3 && (C2 = n3);
            const s3 = e2[i2 + 2];
            g2 = a2.components.push({ h: r3, v: n3, quantizationId: s3, quantizationTable: null });
            a2.componentIds[t3] = g2 - 1;
            i2 += 3;
          }
          a2.maxH = k2;
          a2.maxV = C2;
          prepareComponents(a2);
          break;
        case 65476:
          const v2 = readUint16(e2, i2);
          i2 += 2;
          for (d2 = 2; d2 < v2; ) {
            const t3 = e2[i2++], a3 = new Uint8Array(16);
            let r3 = 0;
            for (f2 = 0; f2 < 16; f2++, i2++) r3 += a3[f2] = e2[i2];
            const n3 = new Uint8Array(r3);
            for (f2 = 0; f2 < r3; f2++, i2++) n3[f2] = e2[i2];
            d2 += 17 + r3;
            (t3 >> 4 ? l2 : h2)[15 & t3] = buildHuffmanTable(a3, n3);
          }
          break;
        case 65501:
          i2 += 2;
          r2 = readUint16(e2, i2);
          i2 += 2;
          break;
        case 65498:
          const F2 = 1 == ++o2 && !t2;
          i2 += 2;
          const T2 = e2[i2++], O2 = [];
          for (d2 = 0; d2 < T2; d2++) {
            const t3 = e2[i2++], r3 = a2.componentIds[t3], n3 = a2.components[r3];
            n3.index = t3;
            const s3 = e2[i2++];
            n3.huffmanTableDC = h2[s3 >> 4];
            n3.huffmanTableAC = l2[15 & s3];
            O2.push(n3);
          }
          const M2 = e2[i2++], D2 = e2[i2++], R2 = e2[i2++];
          try {
            i2 += decodeScan(e2, i2, a2, O2, r2, M2, D2, R2 >> 4, 15 & R2, F2);
          } catch (t3) {
            if (t3 instanceof DNLMarkerError) {
              warn(`${t3.message} -- attempting to re-parse the JPEG image.`);
              return this.parse(e2, { dnlScanLines: t3.scanLines });
            }
            if (t3 instanceof EOIMarkerError) {
              warn(`${t3.message} -- ignoring the rest of the image data.`);
              break e;
            }
            throw t3;
          }
          break;
        case 65500:
          i2 += 4;
          break;
        case 65535:
          255 !== e2[i2] && i2--;
          break;
        default:
          const N2 = findNextFileMarker(e2, i2 - 2, i2 - 3);
          if (N2?.invalid) {
            warn("JpegImage.parse - unexpected data, current marker is: " + N2.invalid);
            i2 = N2.offset;
            break;
          }
          if (!N2 || i2 >= e2.length - 1) {
            warn("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
            break e;
          }
          throw new JpegError("JpegImage.parse - unknown marker: " + u2.toString(16));
      }
      u2 = readUint16(e2, i2);
      i2 += 2;
    }
    if (!a2) throw new JpegError("JpegImage.parse - no frame data found.");
    this.width = a2.samplesPerLine;
    this.height = a2.scanLines;
    this.jfif = n2;
    this.adobe = s2;
    this.components = [];
    for (const e3 of a2.components) {
      const t3 = c2[e3.quantizationId];
      t3 && (e3.quantizationTable = t3);
      this.components.push({ index: e3.index, output: buildComponentData(0, e3), scaleX: e3.h / a2.maxH, scaleY: e3.v / a2.maxV, blocksPerLine: e3.blocksPerLine, blocksPerColumn: e3.blocksPerColumn });
    }
    this.numComponents = this.components.length;
  }
  _getLinearizedBlockData(e2, t2, a2 = false) {
    const r2 = this.width / e2, i2 = this.height / t2;
    let n2, s2, o2, c2, l2, h2, u2, d2, f2, g2, p2, m2 = 0;
    const b2 = this.components.length, y2 = e2 * t2 * b2, w2 = new Uint8ClampedArray(y2), x2 = new Uint32Array(e2), S2 = 4294967288;
    let k2;
    for (u2 = 0; u2 < b2; u2++) {
      n2 = this.components[u2];
      s2 = n2.scaleX * r2;
      o2 = n2.scaleY * i2;
      m2 = u2;
      p2 = n2.output;
      c2 = n2.blocksPerLine + 1 << 3;
      if (s2 !== k2) {
        for (l2 = 0; l2 < e2; l2++) {
          d2 = 0 | l2 * s2;
          x2[l2] = (d2 & S2) << 3 | 7 & d2;
        }
        k2 = s2;
      }
      for (h2 = 0; h2 < t2; h2++) {
        d2 = 0 | h2 * o2;
        g2 = c2 * (d2 & S2) | (7 & d2) << 3;
        for (l2 = 0; l2 < e2; l2++) {
          w2[m2] = p2[g2 + x2[l2]];
          m2 += b2;
        }
      }
    }
    let C2 = this._decodeTransform;
    a2 || 4 !== b2 || C2 || (C2 = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]));
    if (C2) for (u2 = 0; u2 < y2; ) for (d2 = 0, f2 = 0; d2 < b2; d2++, u2++, f2 += 2) w2[u2] = (w2[u2] * C2[f2] >> 8) + C2[f2 + 1];
    return w2;
  }
  get _isColorConversionNeeded() {
    return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
  }
  _convertYccToRgb(e2) {
    let t2, a2, r2;
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2 += 3) {
      t2 = e2[i2];
      a2 = e2[i2 + 1];
      r2 = e2[i2 + 2];
      e2[i2] = t2 - 179.456 + 1.402 * r2;
      e2[i2 + 1] = t2 + 135.459 - 0.344 * a2 - 0.714 * r2;
      e2[i2 + 2] = t2 - 226.816 + 1.772 * a2;
    }
    return e2;
  }
  _convertYccToRgba(e2, t2) {
    for (let a2 = 0, r2 = 0, i2 = e2.length; a2 < i2; a2 += 3, r2 += 4) {
      const i3 = e2[a2], n2 = e2[a2 + 1], s2 = e2[a2 + 2];
      t2[r2] = i3 - 179.456 + 1.402 * s2;
      t2[r2 + 1] = i3 + 135.459 - 0.344 * n2 - 0.714 * s2;
      t2[r2 + 2] = i3 - 226.816 + 1.772 * n2;
      t2[r2 + 3] = 255;
    }
    return t2;
  }
  _convertYcckToRgb(e2) {
    this._convertYcckToCmyk(e2);
    return this._convertCmykToRgb(e2);
  }
  _convertYcckToRgba(e2) {
    this._convertYcckToCmyk(e2);
    return this._convertCmykToRgba(e2);
  }
  _convertYcckToCmyk(e2) {
    let t2, a2, r2;
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2 += 4) {
      t2 = e2[i2];
      a2 = e2[i2 + 1];
      r2 = e2[i2 + 2];
      e2[i2] = 434.456 - t2 - 1.402 * r2;
      e2[i2 + 1] = 119.541 - t2 + 0.344 * a2 + 0.714 * r2;
      e2[i2 + 2] = 481.816 - t2 - 1.772 * a2;
    }
    return e2;
  }
  _convertCmykToRgb(e2) {
    const t2 = e2.length / 4;
    ColorSpaceUtils.cmyk.getRgbBuffer(e2, 0, t2, e2, 0, 8, 0);
    return e2.subarray(0, 3 * t2);
  }
  _convertCmykToRgba(e2) {
    ColorSpaceUtils.cmyk.getRgbBuffer(e2, 0, e2.length / 4, e2, 0, 8, 1);
    if (ColorSpaceUtils.cmyk instanceof DeviceCmykCS) for (let t2 = 3, a2 = e2.length; t2 < a2; t2 += 4) e2[t2] = 255;
    return e2;
  }
  getData({ width: e2, height: t2, forceRGBA: a2 = false, forceRGB: r2 = false, isSourcePDF: i2 = false }) {
    if (this.numComponents > 4) throw new JpegError("Unsupported color mode");
    const n2 = this._getLinearizedBlockData(e2, t2, i2);
    if (1 === this.numComponents && (a2 || r2)) {
      const e3 = n2.length * (a2 ? 4 : 3), t3 = new Uint8ClampedArray(e3);
      let r3 = 0;
      if (a2) !(function grayToRGBA(e4, t4) {
        if (FeatureTest.isLittleEndian) for (let a3 = 0, r4 = e4.length; a3 < r4; a3++) t4[a3] = 65793 * e4[a3] | 4278190080;
        else for (let a3 = 0, r4 = e4.length; a3 < r4; a3++) t4[a3] = 16843008 * e4[a3] | 255;
      })(n2, new Uint32Array(t3.buffer));
      else for (const e4 of n2) {
        t3[r3++] = e4;
        t3[r3++] = e4;
        t3[r3++] = e4;
      }
      return t3;
    }
    if (3 === this.numComponents && this._isColorConversionNeeded) {
      if (a2) {
        const e3 = new Uint8ClampedArray(n2.length / 3 * 4);
        return this._convertYccToRgba(n2, e3);
      }
      return this._convertYccToRgb(n2);
    }
    if (4 === this.numComponents) {
      if (this._isColorConversionNeeded) return a2 ? this._convertYcckToRgba(n2) : r2 ? this._convertYcckToRgb(n2) : this._convertYcckToCmyk(n2);
      if (a2) return this._convertCmykToRgba(n2);
      if (r2) return this._convertCmykToRgb(n2);
    }
    return n2;
  }
};
var JpegStream = class _JpegStream extends DecodeStream {
  static #M = FeatureTest.isImageDecoderSupported;
  constructor(e2, t2, a2) {
    super(t2);
    this.stream = e2;
    this.dict = e2.dict;
    this.maybeLength = t2;
    this.params = a2;
  }
  static get canUseImageDecoder() {
    return shadow(this, "canUseImageDecoder", this.#M ? ImageDecoder.isTypeSupported("image/jpeg") : Promise.resolve(false));
  }
  static setOptions({ isImageDecoderSupported: e2 = false }) {
    this.#M = e2;
  }
  get bytes() {
    return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e2) {
  }
  readBlock() {
    this.decodeImage();
  }
  get jpegOptions() {
    const e2 = { decodeTransform: void 0, colorTransform: void 0 }, t2 = this.dict.getArray("D", "Decode");
    if ((this.forceRGBA || this.forceRGB) && Array.isArray(t2)) {
      const a2 = this.dict.get("BPC", "BitsPerComponent") || 8, r2 = t2.length, i2 = new Int32Array(r2);
      let n2 = false;
      const s2 = (1 << a2) - 1;
      for (let e3 = 0; e3 < r2; e3 += 2) {
        i2[e3] = 256 * (t2[e3 + 1] - t2[e3]) | 0;
        i2[e3 + 1] = t2[e3] * s2 | 0;
        256 === i2[e3] && 0 === i2[e3 + 1] || (n2 = true);
      }
      n2 && (e2.decodeTransform = i2);
    }
    if (this.params instanceof Dict) {
      const t3 = this.params.get("ColorTransform");
      Number.isInteger(t3) && (e2.colorTransform = t3);
    }
    return shadow(this, "jpegOptions", e2);
  }
  #N(e2) {
    for (let t2 = 0, a2 = e2.length - 1; t2 < a2; t2++) if (255 === e2[t2] && 216 === e2[t2 + 1]) {
      t2 > 0 && (e2 = e2.subarray(t2));
      break;
    }
    return e2;
  }
  decodeImage(e2) {
    if (this.eof) return this.buffer;
    e2 = this.#N(e2 || this.bytes);
    const t2 = new JpegImage(this.jpegOptions);
    t2.parse(e2);
    const a2 = t2.getData({ width: this.drawWidth, height: this.drawHeight, forceRGBA: this.forceRGBA, forceRGB: this.forceRGB, isSourcePDF: true });
    this.buffer = a2;
    this.bufferLength = a2.length;
    this.eof = true;
    return this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
  async getTransferableImage() {
    if (!await _JpegStream.canUseImageDecoder) return null;
    const e2 = this.jpegOptions;
    if (e2.decodeTransform) return null;
    let t2;
    try {
      const a2 = this.canAsyncDecodeImageFromBuffer && await this.stream.asyncGetBytes() || this.bytes;
      if (!a2) return null;
      let r2 = this.#N(a2);
      const i2 = JpegImage.canUseImageDecoder(r2, e2.colorTransform);
      if (!i2) return null;
      if (i2.exifStart) {
        r2 = r2.slice();
        r2.fill(0, i2.exifStart, i2.exifEnd);
      }
      t2 = new ImageDecoder({ data: r2, type: "image/jpeg", preferAnimation: false });
      return (await t2.decode()).image;
    } catch (e3) {
      warn(`getTransferableImage - failed: "${e3}".`);
      return null;
    } finally {
      t2?.close();
    }
  }
};
var OpenJPEG = async function(e2 = {}) {
  var t2, a2, r2 = e2, i2 = new Promise(((e3, r3) => {
    t2 = e3;
    a2 = r3;
  })), n2 = "./this.program", quit_ = (e3, t3) => {
    throw t3;
  }, s2 = import.meta.url;
  try {
    new URL(".", s2).href;
  } catch {
  }
  var o2, c2, l2, h2, u2, d2, f2 = console.log.bind(console), g2 = console.error.bind(console), p2 = false;
  function updateMemoryViews() {
    var e3 = o2.buffer;
    l2 = new Int8Array(e3);
    new Int16Array(e3);
    h2 = new Uint8Array(e3);
    new Uint16Array(e3);
    u2 = new Int32Array(e3);
    d2 = new Uint32Array(e3);
    new Float32Array(e3);
    new Float64Array(e3);
    new BigInt64Array(e3);
    new BigUint64Array(e3);
  }
  var m2 = 0, b2 = null;
  class ExitStatus {
    name = "ExitStatus";
    constructor(e3) {
      this.message = `Program terminated with exit(${e3})`;
      this.status = e3;
    }
  }
  var callRuntimeCallbacks = (e3) => {
    for (; e3.length > 0; ) e3.shift()(r2);
  }, y2 = [], addOnPostRun = (e3) => y2.push(e3), w2 = [], addOnPreRun = (e3) => w2.push(e3), x2 = true, S2 = 0, k2 = {}, handleException = (e3) => {
    if (e3 instanceof ExitStatus || "unwind" == e3) return c2;
    quit_(0, e3);
  }, keepRuntimeAlive = () => x2 || S2 > 0, _proc_exit = (e3) => {
    c2 = e3;
    if (!keepRuntimeAlive()) {
      r2.onExit?.(e3);
      p2 = true;
    }
    quit_(0, new ExitStatus(e3));
  }, _exit = (e3, t3) => {
    c2 = e3;
    _proc_exit(e3);
  }, callUserCallback = (e3) => {
    if (!p2) try {
      e3();
      (() => {
        if (!keepRuntimeAlive()) try {
          _exit(c2);
        } catch (e4) {
          handleException(e4);
        }
      })();
    } catch (e4) {
      handleException(e4);
    }
  }, growMemory = (e3) => {
    var t3 = (e3 - o2.buffer.byteLength + 65535) / 65536 | 0;
    try {
      o2.grow(t3);
      updateMemoryViews();
      return 1;
    } catch (e4) {
    }
  }, C2 = {}, getEnvStrings = () => {
    if (!getEnvStrings.strings) {
      var e3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: n2 || "./this.program" };
      for (var t3 in C2) void 0 === C2[t3] ? delete e3[t3] : e3[t3] = C2[t3];
      var a3 = [];
      for (var t3 in e3) a3.push(`${t3}=${e3[t3]}`);
      getEnvStrings.strings = a3;
    }
    return getEnvStrings.strings;
  }, lengthBytesUTF8 = (e3) => {
    for (var t3 = 0, a3 = 0; a3 < e3.length; ++a3) {
      var r3 = e3.charCodeAt(a3);
      if (r3 <= 127) t3++;
      else if (r3 <= 2047) t3 += 2;
      else if (r3 >= 55296 && r3 <= 57343) {
        t3 += 4;
        ++a3;
      } else t3 += 3;
    }
    return t3;
  }, v2 = [null, [], []], F2 = "undefined" != typeof TextDecoder ? new TextDecoder() : void 0, UTF8ArrayToString = (e3, t3 = 0, a3 = NaN) => {
    for (var r3 = t3 + a3, i3 = t3; e3[i3] && !(i3 >= r3); ) ++i3;
    if (i3 - t3 > 16 && e3.buffer && F2) return F2.decode(e3.subarray(t3, i3));
    for (var n3 = ""; t3 < i3; ) {
      var s3 = e3[t3++];
      if (128 & s3) {
        var o3 = 63 & e3[t3++];
        if (192 != (224 & s3)) {
          var c3 = 63 & e3[t3++];
          if ((s3 = 224 == (240 & s3) ? (15 & s3) << 12 | o3 << 6 | c3 : (7 & s3) << 18 | o3 << 12 | c3 << 6 | 63 & e3[t3++]) < 65536) n3 += String.fromCharCode(s3);
          else {
            var l3 = s3 - 65536;
            n3 += String.fromCharCode(55296 | l3 >> 10, 56320 | 1023 & l3);
          }
        } else n3 += String.fromCharCode((31 & s3) << 6 | o3);
      } else n3 += String.fromCharCode(s3);
    }
    return n3;
  }, printChar = (e3, t3) => {
    var a3 = v2[e3];
    if (0 === t3 || 10 === t3) {
      (1 === e3 ? f2 : g2)(UTF8ArrayToString(a3));
      a3.length = 0;
    } else a3.push(t3);
  }, UTF8ToString = (e3, t3) => e3 ? UTF8ArrayToString(h2, e3, t3) : "";
  r2.noExitRuntime && (x2 = r2.noExitRuntime);
  r2.print && (f2 = r2.print);
  r2.printErr && (g2 = r2.printErr);
  r2.wasmBinary && r2.wasmBinary;
  r2.arguments && r2.arguments;
  r2.thisProgram && (n2 = r2.thisProgram);
  r2.writeArrayToMemory = (e3, t3) => {
    l2.set(e3, t3);
  };
  var T2 = { l: () => (function abort(e3) {
    r2.onAbort?.(e3);
    g2(e3 = "Aborted(" + e3 + ")");
    p2 = true;
    e3 += ". Build with -sASSERTIONS for more info.";
    var t3 = new WebAssembly.RuntimeError(e3);
    a2(t3);
    throw t3;
  })(""), k: () => {
    x2 = false;
    S2 = 0;
  }, m: (e3, t3) => {
    if (k2[e3]) {
      clearTimeout(k2[e3].id);
      delete k2[e3];
    }
    if (!t3) return 0;
    var a3 = setTimeout((() => {
      delete k2[e3];
      callUserCallback((() => M2(e3, performance.now())));
    }), t3);
    k2[e3] = { id: a3, timeout_ms: t3 };
    return 0;
  }, g: function _copy_pixels_1(e3, t3) {
    e3 >>= 2;
    const a3 = r2.imageData = new Uint8ClampedArray(t3), i3 = u2.subarray(e3, e3 + t3);
    a3.set(i3);
  }, f: function _copy_pixels_3(e3, t3, a3, i3) {
    e3 >>= 2;
    t3 >>= 2;
    a3 >>= 2;
    const n3 = r2.imageData = new Uint8ClampedArray(3 * i3), s3 = u2.subarray(e3, e3 + i3), o3 = u2.subarray(t3, t3 + i3), c3 = u2.subarray(a3, a3 + i3);
    for (let e4 = 0; e4 < i3; e4++) {
      n3[3 * e4] = s3[e4];
      n3[3 * e4 + 1] = o3[e4];
      n3[3 * e4 + 2] = c3[e4];
    }
  }, e: function _copy_pixels_4(e3, t3, a3, i3, n3) {
    e3 >>= 2;
    t3 >>= 2;
    a3 >>= 2;
    i3 >>= 2;
    const s3 = r2.imageData = new Uint8ClampedArray(4 * n3), o3 = u2.subarray(e3, e3 + n3), c3 = u2.subarray(t3, t3 + n3), l3 = u2.subarray(a3, a3 + n3), h3 = u2.subarray(i3, i3 + n3);
    for (let e4 = 0; e4 < n3; e4++) {
      s3[4 * e4] = o3[e4];
      s3[4 * e4 + 1] = c3[e4];
      s3[4 * e4 + 2] = l3[e4];
      s3[4 * e4 + 3] = h3[e4];
    }
  }, n: (e3) => {
    var t3, a3, r3 = h2.length, i3 = 2147483648;
    if ((e3 >>>= 0) > i3) return false;
    for (var n3 = 1; n3 <= 4; n3 *= 2) {
      var s3 = r3 * (1 + 0.2 / n3);
      s3 = Math.min(s3, e3 + 100663296);
      var o3 = Math.min(i3, (t3 = Math.max(e3, s3), a3 = 65536, Math.ceil(t3 / a3) * a3));
      if (growMemory(o3)) return true;
    }
    return false;
  }, p: (e3, t3) => {
    var a3 = 0, r3 = 0;
    for (var i3 of getEnvStrings()) {
      var n3 = t3 + a3;
      d2[e3 + r3 >> 2] = n3;
      a3 += ((e4, t4, a4, r4) => {
        if (!(r4 > 0)) return 0;
        for (var i4 = a4, n4 = a4 + r4 - 1, s3 = 0; s3 < e4.length; ++s3) {
          var o3 = e4.charCodeAt(s3);
          o3 >= 55296 && o3 <= 57343 && (o3 = 65536 + ((1023 & o3) << 10) | 1023 & e4.charCodeAt(++s3));
          if (o3 <= 127) {
            if (a4 >= n4) break;
            t4[a4++] = o3;
          } else if (o3 <= 2047) {
            if (a4 + 1 >= n4) break;
            t4[a4++] = 192 | o3 >> 6;
            t4[a4++] = 128 | 63 & o3;
          } else if (o3 <= 65535) {
            if (a4 + 2 >= n4) break;
            t4[a4++] = 224 | o3 >> 12;
            t4[a4++] = 128 | o3 >> 6 & 63;
            t4[a4++] = 128 | 63 & o3;
          } else {
            if (a4 + 3 >= n4) break;
            t4[a4++] = 240 | o3 >> 18;
            t4[a4++] = 128 | o3 >> 12 & 63;
            t4[a4++] = 128 | o3 >> 6 & 63;
            t4[a4++] = 128 | 63 & o3;
          }
        }
        t4[a4] = 0;
        return a4 - i4;
      })(i3, h2, n3, 1 / 0) + 1;
      r3 += 4;
    }
    return 0;
  }, q: (e3, t3) => {
    var a3 = getEnvStrings();
    d2[e3 >> 2] = a3.length;
    var r3 = 0;
    for (var i3 of a3) r3 += lengthBytesUTF8(i3) + 1;
    d2[t3 >> 2] = r3;
    return 0;
  }, b: (e3) => 52, o: function _fd_seek(e3, t3, a3, r3) {
    t3 = (i3 = t3) < -9007199254740992 || i3 > 9007199254740992 ? NaN : Number(i3);
    var i3;
    return 70;
  }, c: (e3, t3, a3, r3) => {
    for (var i3 = 0, n3 = 0; n3 < a3; n3++) {
      var s3 = d2[t3 >> 2], o3 = d2[t3 + 4 >> 2];
      t3 += 8;
      for (var c3 = 0; c3 < o3; c3++) printChar(e3, h2[s3 + c3]);
      i3 += o3;
    }
    d2[r3 >> 2] = i3;
    return 0;
  }, r: function _gray_to_rgba(e3, t3) {
    e3 >>= 2;
    const a3 = r2.imageData = new Uint8ClampedArray(4 * t3), i3 = u2.subarray(e3, e3 + t3);
    for (let e4 = 0; e4 < t3; e4++) {
      a3[4 * e4] = a3[4 * e4 + 1] = a3[4 * e4 + 2] = i3[e4];
      a3[4 * e4 + 3] = 255;
    }
  }, i: function _graya_to_rgba(e3, t3, a3) {
    e3 >>= 2;
    t3 >>= 2;
    const i3 = r2.imageData = new Uint8ClampedArray(4 * a3), n3 = u2.subarray(e3, e3 + a3), s3 = u2.subarray(t3, t3 + a3);
    for (let e4 = 0; e4 < a3; e4++) {
      i3[4 * e4] = i3[4 * e4 + 1] = i3[4 * e4 + 2] = n3[e4];
      i3[4 * e4 + 3] = s3[e4];
    }
  }, d: function _jsPrintWarning(e3) {
    const t3 = UTF8ToString(e3);
    (r2.warn || console.warn)(`OpenJPEG: ${t3}`);
  }, j: _proc_exit, h: function _rgb_to_rgba(e3, t3, a3, i3) {
    e3 >>= 2;
    t3 >>= 2;
    a3 >>= 2;
    const n3 = r2.imageData = new Uint8ClampedArray(4 * i3), s3 = u2.subarray(e3, e3 + i3), o3 = u2.subarray(t3, t3 + i3), c3 = u2.subarray(a3, a3 + i3);
    for (let e4 = 0; e4 < i3; e4++) {
      n3[4 * e4] = s3[e4];
      n3[4 * e4 + 1] = o3[e4];
      n3[4 * e4 + 2] = c3[e4];
      n3[4 * e4 + 3] = 255;
    }
  }, a: function _storeErrorMessage(e3) {
    const t3 = UTF8ToString(e3);
    r2.errorMessages ? r2.errorMessages += "\n" + t3 : r2.errorMessages = t3;
  } }, O2 = await (async function createWasm() {
    function receiveInstance(e4, t3) {
      O2 = e4.exports;
      o2 = O2.s;
      updateMemoryViews();
      !(function removeRunDependency(e5) {
        m2--;
        r2.monitorRunDependencies?.(m2);
        if (0 == m2 && b2) {
          var t4 = b2;
          b2 = null;
          t4();
        }
      })();
      return O2;
    }
    !(function addRunDependency(e4) {
      m2++;
      r2.monitorRunDependencies?.(m2);
    })();
    var e3 = /* @__PURE__ */ (function getWasmImports() {
      return { a: T2 };
    })();
    return new Promise(((t3, a3) => {
      r2.instantiateWasm(e3, ((e4, a4) => {
        t3(receiveInstance(e4));
      }));
    }));
  })(), M2 = (O2.t, r2._malloc = O2.u, r2._free = O2.v, r2._jp2_decode = O2.w, O2.x);
  !(function preInit() {
    if (r2.preInit) {
      "function" == typeof r2.preInit && (r2.preInit = [r2.preInit]);
      for (; r2.preInit.length > 0; ) r2.preInit.shift()();
    }
  })();
  !(function run() {
    if (m2 > 0) b2 = run;
    else {
      !(function preRun() {
        if (r2.preRun) {
          "function" == typeof r2.preRun && (r2.preRun = [r2.preRun]);
          for (; r2.preRun.length; ) addOnPreRun(r2.preRun.shift());
        }
        callRuntimeCallbacks(w2);
      })();
      if (m2 > 0) b2 = run;
      else if (r2.setStatus) {
        r2.setStatus("Running...");
        setTimeout((() => {
          setTimeout((() => r2.setStatus("")), 1);
          doRun();
        }), 1);
      } else doRun();
    }
    function doRun() {
      r2.calledRun = true;
      if (!p2) {
        !(function initRuntime() {
          O2.t();
        })();
        t2(r2);
        r2.onRuntimeInitialized?.();
        !(function postRun() {
          if (r2.postRun) {
            "function" == typeof r2.postRun && (r2.postRun = [r2.postRun]);
            for (; r2.postRun.length; ) addOnPostRun(r2.postRun.shift());
          }
          callRuntimeCallbacks(y2);
        })();
      }
    }
  })();
  return i2;
};
var Ga = OpenJPEG;
var JpxError = class extends fa {
  constructor(e2) {
    super(e2, "JpxError");
  }
};
var JpxImage = class {
  static #E = null;
  static #P = null;
  static #L = null;
  static #v = true;
  static #j = true;
  static #F = null;
  static setOptions({ handler: e2, useWasm: t2, useWorkerFetch: a2, wasmUrl: r2 }) {
    this.#v = t2;
    this.#j = a2;
    this.#F = r2;
    a2 || (this.#P = e2);
  }
  static async #_(e2) {
    const t2 = `${this.#F}openjpeg_nowasm_fallback.js`;
    let a2 = null;
    try {
      a2 = (await import(
        /*webpackIgnore: true*/
        /*@vite-ignore*/
        t2
      )).default();
    } catch (e3) {
      warn(`JpxImage#getJsModule: ${e3}`);
    }
    e2(a2);
  }
  static async #U(e2, t2, a2) {
    const r2 = "openjpeg.wasm";
    try {
      this.#E || (this.#j ? this.#E = await fetchBinaryData(`${this.#F}${r2}`) : this.#E = await this.#P.sendWithPromise("FetchBinaryData", { type: "wasmFactory", filename: r2 }));
      return a2((await WebAssembly.instantiate(this.#E, t2)).instance);
    } catch (t3) {
      warn(`JpxImage#instantiateWasm: ${t3}`);
      this.#_(e2);
      return null;
    } finally {
      this.#P = null;
    }
  }
  static async decode(e2, { numComponents: t2 = 4, isIndexedColormap: a2 = false, smaskInData: r2 = false, reducePower: i2 = 0 } = {}) {
    if (!this.#L) {
      const { promise: e3, resolve: t3 } = Promise.withResolvers(), a3 = [e3];
      this.#v ? a3.push(Ga({ warn, instantiateWasm: this.#U.bind(this, t3) })) : this.#_(t3);
      this.#L = Promise.race(a3);
    }
    const n2 = await this.#L;
    if (!n2) throw new JpxError("OpenJPEG failed to initialize");
    let s2;
    try {
      const o2 = e2.length;
      s2 = n2._malloc(o2);
      n2.writeArrayToMemory(e2, s2);
      if (n2._jp2_decode(s2, o2, t2 > 0 ? t2 : 0, !!a2, !!r2, i2)) {
        const { errorMessages: e3 } = n2;
        if (e3) {
          delete n2.errorMessages;
          throw new JpxError(e3);
        }
        throw new JpxError("Unknown error");
      }
      const { imageData: c2 } = n2;
      n2.imageData = null;
      return c2;
    } finally {
      s2 && n2._free(s2);
    }
  }
  static cleanup() {
    this.#L = null;
  }
  static parseImageProperties(e2) {
    let t2 = e2.getByte();
    for (; t2 >= 0; ) {
      const a2 = t2;
      t2 = e2.getByte();
      if (65361 === (a2 << 8 | t2)) {
        e2.skip(4);
        const t3 = e2.getInt32() >>> 0, a3 = e2.getInt32() >>> 0, r2 = e2.getInt32() >>> 0, i2 = e2.getInt32() >>> 0;
        e2.skip(16);
        return { width: t3 - r2, height: a3 - i2, bitsPerComponent: 8, componentsCount: e2.getUint16() };
      }
    }
    throw new JpxError("No size marker found in JPX stream");
  }
};
function addState(e2, t2, a2, r2, i2) {
  let n2 = e2;
  for (let e3 = 0, a3 = t2.length - 1; e3 < a3; e3++) {
    const a4 = t2[e3];
    n2 = n2[a4] ||= [];
  }
  n2[t2.at(-1)] = { checkFn: a2, iterateFn: r2, processFn: i2 };
}
var Va = [];
addState(Va, [Be, Ne, Yt, Re], null, (function iterateInlineImageGroup(e2, t2) {
  const a2 = e2.fnArray, r2 = (t2 - (e2.iCurr - 3)) % 4;
  switch (r2) {
    case 0:
      return a2[t2] === Be;
    case 1:
      return a2[t2] === Ne;
    case 2:
      return a2[t2] === Yt;
    case 3:
      return a2[t2] === Re;
  }
  throw new Error(`iterateInlineImageGroup - invalid pos: ${r2}`);
}), (function foundInlineImageGroup(e2, t2) {
  const a2 = e2.fnArray, r2 = e2.argsArray, i2 = e2.iCurr, n2 = i2 - 3, s2 = i2 - 2, o2 = i2 - 1, c2 = Math.min(Math.floor((t2 - n2) / 4), 200);
  if (c2 < 10) return t2 - (t2 - n2) % 4;
  let l2 = 0;
  const h2 = [];
  let u2 = 0, d2 = 1, f2 = 1;
  for (let e3 = 0; e3 < c2; e3++) {
    const t3 = r2[s2 + (e3 << 2)], a3 = r2[o2 + (e3 << 2)][0];
    if (d2 + a3.width > 1e3) {
      l2 = Math.max(l2, d2);
      f2 += u2 + 2;
      d2 = 0;
      u2 = 0;
    }
    h2.push({ transform: t3, x: d2, y: f2, w: a3.width, h: a3.height });
    d2 += a3.width + 2;
    u2 = Math.max(u2, a3.height);
  }
  const g2 = Math.max(l2, d2) + 1, p2 = f2 + u2 + 1, m2 = new Uint8Array(g2 * p2 * 4), b2 = g2 << 2;
  for (let e3 = 0; e3 < c2; e3++) {
    const t3 = r2[o2 + (e3 << 2)][0].data, a3 = h2[e3].w << 2;
    let i3 = 0, n3 = h2[e3].x + h2[e3].y * g2 << 2;
    m2.set(t3.subarray(0, a3), n3 - b2);
    for (let r3 = 0, s3 = h2[e3].h; r3 < s3; r3++) {
      m2.set(t3.subarray(i3, i3 + a3), n3);
      i3 += a3;
      n3 += b2;
    }
    m2.set(t3.subarray(i3 - a3, i3), n3);
    for (; n3 >= 0; ) {
      t3[n3 - 4] = t3[n3];
      t3[n3 - 3] = t3[n3 + 1];
      t3[n3 - 2] = t3[n3 + 2];
      t3[n3 - 1] = t3[n3 + 3];
      t3[n3 + a3] = t3[n3 + a3 - 4];
      t3[n3 + a3 + 1] = t3[n3 + a3 - 3];
      t3[n3 + a3 + 2] = t3[n3 + a3 - 2];
      t3[n3 + a3 + 3] = t3[n3 + a3 - 1];
      n3 -= b2;
    }
  }
  const y2 = { width: g2, height: p2 };
  if (e2.isOffscreenCanvasSupported) {
    const e3 = new OffscreenCanvas(g2, p2);
    e3.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(m2.buffer), g2, p2), 0, 0);
    y2.bitmap = e3.transferToImageBitmap();
    y2.data = null;
  } else {
    y2.kind = v;
    y2.data = m2;
  }
  a2.splice(n2, 4 * c2, Zt);
  r2.splice(n2, 4 * c2, [y2, h2]);
  return n2 + 1;
}));
addState(Va, [Be, Ne, Vt, Re], null, (function iterateImageMaskGroup(e2, t2) {
  const a2 = e2.fnArray, r2 = (t2 - (e2.iCurr - 3)) % 4;
  switch (r2) {
    case 0:
      return a2[t2] === Be;
    case 1:
      return a2[t2] === Ne;
    case 2:
      return a2[t2] === Vt;
    case 3:
      return a2[t2] === Re;
  }
  throw new Error(`iterateImageMaskGroup - invalid pos: ${r2}`);
}), (function foundImageMaskGroup(e2, t2) {
  const a2 = e2.fnArray, r2 = e2.argsArray, i2 = e2.iCurr, n2 = i2 - 3, s2 = i2 - 2, o2 = i2 - 1;
  let c2 = Math.floor((t2 - n2) / 4);
  if (c2 < 10) return t2 - (t2 - n2) % 4;
  let l2, h2, u2 = false;
  const d2 = r2[o2][0], f2 = r2[s2][0], g2 = r2[s2][1], p2 = r2[s2][2], m2 = r2[s2][3];
  if (g2 === p2) {
    u2 = true;
    l2 = s2 + 4;
    let e3 = o2 + 4;
    for (let t3 = 1; t3 < c2; t3++, l2 += 4, e3 += 4) {
      h2 = r2[l2];
      if (r2[e3][0] !== d2 || h2[0] !== f2 || h2[1] !== g2 || h2[2] !== p2 || h2[3] !== m2) {
        t3 < 10 ? u2 = false : c2 = t3;
        break;
      }
    }
  }
  if (u2) {
    c2 = Math.min(c2, 1e3);
    const e3 = new Float32Array(2 * c2);
    l2 = s2;
    for (let t3 = 0; t3 < c2; t3++, l2 += 4) {
      h2 = r2[l2];
      e3[t3 << 1] = h2[4];
      e3[1 + (t3 << 1)] = h2[5];
    }
    a2.splice(n2, 4 * c2, ea);
    r2.splice(n2, 4 * c2, [d2, f2, g2, p2, m2, e3]);
  } else {
    c2 = Math.min(c2, 100);
    const e3 = [];
    for (let t3 = 0; t3 < c2; t3++) {
      h2 = r2[s2 + (t3 << 2)];
      const a3 = r2[o2 + (t3 << 2)][0];
      e3.push({ data: a3.data, width: a3.width, height: a3.height, interpolate: a3.interpolate, count: a3.count, transform: h2 });
    }
    a2.splice(n2, 4 * c2, Kt);
    r2.splice(n2, 4 * c2, [e3]);
  }
  return n2 + 1;
}));
addState(Va, [Be, Ne, Jt, Re], (function(e2) {
  const t2 = e2.argsArray, a2 = e2.iCurr - 2;
  return 0 === t2[a2][1] && 0 === t2[a2][2];
}), (function iterateImageGroup(e2, t2) {
  const a2 = e2.fnArray, r2 = e2.argsArray, i2 = (t2 - (e2.iCurr - 3)) % 4;
  switch (i2) {
    case 0:
      return a2[t2] === Be;
    case 1:
      if (a2[t2] !== Ne) return false;
      const i3 = e2.iCurr - 2, n2 = r2[i3][0], s2 = r2[i3][3];
      return r2[t2][0] === n2 && 0 === r2[t2][1] && 0 === r2[t2][2] && r2[t2][3] === s2;
    case 2:
      if (a2[t2] !== Jt) return false;
      const o2 = r2[e2.iCurr - 1][0];
      return r2[t2][0] === o2;
    case 3:
      return a2[t2] === Re;
  }
  throw new Error(`iterateImageGroup - invalid pos: ${i2}`);
}), (function(e2, t2) {
  const a2 = e2.fnArray, r2 = e2.argsArray, i2 = e2.iCurr, n2 = i2 - 3, s2 = i2 - 2, o2 = r2[i2 - 1][0], c2 = r2[s2][0], l2 = r2[s2][3], h2 = Math.min(Math.floor((t2 - n2) / 4), 1e3);
  if (h2 < 3) return t2 - (t2 - n2) % 4;
  const u2 = new Float32Array(2 * h2);
  let d2 = s2;
  for (let e3 = 0; e3 < h2; e3++, d2 += 4) {
    const t3 = r2[d2];
    u2[e3 << 1] = t3[4];
    u2[1 + (e3 << 1)] = t3[5];
  }
  const f2 = [o2, c2, l2, u2];
  a2.splice(n2, 4 * h2, Qt);
  r2.splice(n2, 4 * h2, f2);
  return n2 + 1;
}));
addState(Va, [Qe, nt, ht, dt, et], null, (function iterateShowTextGroup(e2, t2) {
  const a2 = e2.fnArray, r2 = e2.argsArray, i2 = (t2 - (e2.iCurr - 4)) % 5;
  switch (i2) {
    case 0:
      return a2[t2] === Qe;
    case 1:
      return a2[t2] === nt;
    case 2:
      return a2[t2] === ht;
    case 3:
      if (a2[t2] !== dt) return false;
      const i3 = e2.iCurr - 3, n2 = r2[i3][0], s2 = r2[i3][1];
      return r2[t2][0] === n2 && r2[t2][1] === s2;
    case 4:
      return a2[t2] === et;
  }
  throw new Error(`iterateShowTextGroup - invalid pos: ${i2}`);
}), (function(e2, t2) {
  const a2 = e2.fnArray, r2 = e2.argsArray, i2 = e2.iCurr, n2 = i2 - 4, s2 = i2 - 3, o2 = i2 - 2, c2 = i2 - 1, l2 = i2, h2 = r2[s2][0], u2 = r2[s2][1];
  let d2 = Math.min(Math.floor((t2 - n2) / 5), 1e3);
  if (d2 < 3) return t2 - (t2 - n2) % 5;
  let f2 = n2;
  if (n2 >= 4 && a2[n2 - 4] === a2[s2] && a2[n2 - 3] === a2[o2] && a2[n2 - 2] === a2[c2] && a2[n2 - 1] === a2[l2] && r2[n2 - 4][0] === h2 && r2[n2 - 4][1] === u2) {
    d2++;
    f2 -= 5;
  }
  let g2 = f2 + 4;
  for (let e3 = 1; e3 < d2; e3++) {
    a2.splice(g2, 3);
    r2.splice(g2, 3);
    g2 += 2;
  }
  return g2 + 1;
}));
addState(Va, [Be, Ne, aa, Re], ((e2) => {
  const t2 = e2.argsArray, a2 = t2[e2.iCurr - 1][0];
  if (a2 !== qe && a2 !== He && a2 !== $e && a2 !== Ge && a2 !== Ve && a2 !== Ke) return true;
  const r2 = t2[e2.iCurr - 2];
  return 1 === r2[0] && 0 === r2[1] && 0 === r2[2] && 1 === r2[3];
}), (() => false), ((e2, t2) => {
  const { fnArray: a2, argsArray: r2 } = e2, i2 = e2.iCurr, n2 = i2 - 3, s2 = i2 - 2, o2 = r2[i2 - 1], c2 = r2[s2], [, [l2], h2] = o2;
  if (h2) {
    Util.scaleMinMax(c2, h2);
    for (let e3 = 0, t3 = l2.length; e3 < t3; ) switch (l2[e3++]) {
      case sa:
      case oa:
        Util.applyTransform(l2, c2, e3);
        e3 += 2;
        break;
      case ca:
        Util.applyTransformToBezier(l2, c2, e3);
        e3 += 6;
    }
  }
  a2.splice(n2, 4, aa);
  r2.splice(n2, 4, o2);
  return n2 + 1;
}));
var NullOptimizer = class {
  constructor(e2) {
    this.queue = e2;
  }
  _optimize() {
  }
  push(e2, t2) {
    this.queue.fnArray.push(e2);
    this.queue.argsArray.push(t2);
    this._optimize();
  }
  flush() {
  }
  reset() {
  }
};
var QueueOptimizer = class extends NullOptimizer {
  constructor(e2) {
    super(e2);
    this.state = null;
    this.context = { iCurr: 0, fnArray: e2.fnArray, argsArray: e2.argsArray, isOffscreenCanvasSupported: OperatorList.isOffscreenCanvasSupported };
    this.match = null;
    this.lastProcessed = 0;
  }
  _optimize() {
    const e2 = this.queue.fnArray;
    let t2 = this.lastProcessed, a2 = e2.length, r2 = this.state, i2 = this.match;
    if (!r2 && !i2 && t2 + 1 === a2 && !Va[e2[t2]]) {
      this.lastProcessed = a2;
      return;
    }
    const n2 = this.context;
    for (; t2 < a2; ) {
      if (i2) {
        if ((0, i2.iterateFn)(n2, t2)) {
          t2++;
          continue;
        }
        t2 = (0, i2.processFn)(n2, t2 + 1);
        a2 = e2.length;
        i2 = null;
        r2 = null;
        if (t2 >= a2) break;
      }
      r2 = (r2 || Va)[e2[t2]];
      if (r2 && !Array.isArray(r2)) {
        n2.iCurr = t2;
        t2++;
        if (!r2.checkFn || (0, r2.checkFn)(n2)) {
          i2 = r2;
          r2 = null;
        } else r2 = null;
      } else t2++;
    }
    this.state = r2;
    this.match = i2;
    this.lastProcessed = t2;
  }
  flush() {
    for (; this.match; ) {
      const e2 = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, e2);
      this.match = null;
      this.state = null;
      this._optimize();
    }
  }
  reset() {
    this.state = null;
    this.match = null;
    this.lastProcessed = 0;
  }
};
var OperatorList = class _OperatorList {
  static CHUNK_SIZE = 1e3;
  static CHUNK_SIZE_ABOUT = this.CHUNK_SIZE - 5;
  static isOffscreenCanvasSupported = false;
  constructor(e2 = 0, t2) {
    this._streamSink = t2;
    this.fnArray = [];
    this.argsArray = [];
    this.optimizer = !t2 || e2 & d ? new NullOptimizer(this) : new QueueOptimizer(this);
    this.dependencies = /* @__PURE__ */ new Set();
    this._totalLength = 0;
    this.weight = 0;
    this._resolved = t2 ? null : Promise.resolve();
  }
  static setOptions({ isOffscreenCanvasSupported: e2 }) {
    this.isOffscreenCanvasSupported = e2;
  }
  get length() {
    return this.argsArray.length;
  }
  get ready() {
    return this._resolved || this._streamSink.ready;
  }
  get totalLength() {
    return this._totalLength + this.length;
  }
  addOp(e2, t2) {
    this.optimizer.push(e2, t2);
    this.weight++;
    this._streamSink && (this.weight >= _OperatorList.CHUNK_SIZE || this.weight >= _OperatorList.CHUNK_SIZE_ABOUT && (e2 === Re || e2 === et)) && this.flush();
  }
  addImageOps(e2, t2, a2, r2 = false) {
    if (r2) {
      this.addOp(Be);
      this.addOp(De, [[["SMask", false]]]);
    }
    void 0 !== a2 && this.addOp(jt, ["OC", a2]);
    this.addOp(e2, t2);
    void 0 !== a2 && this.addOp(_t, []);
    r2 && this.addOp(Re);
  }
  addDependency(e2) {
    if (!this.dependencies.has(e2)) {
      this.dependencies.add(e2);
      this.addOp(ke, [e2]);
    }
  }
  addDependencies(e2) {
    for (const t2 of e2) this.addDependency(t2);
  }
  addOpList(e2) {
    if (e2 instanceof _OperatorList) {
      for (const t2 of e2.dependencies) this.dependencies.add(t2);
      for (let t2 = 0, a2 = e2.length; t2 < a2; t2++) this.addOp(e2.fnArray[t2], e2.argsArray[t2]);
    } else warn('addOpList - ignoring invalid "opList" parameter.');
  }
  getIR() {
    return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length };
  }
  get _transfers() {
    const e2 = [], { fnArray: t2, argsArray: a2, length: r2 } = this;
    for (let i2 = 0; i2 < r2; i2++) switch (t2[i2]) {
      case Yt:
      case Zt:
      case Vt: {
        const { bitmap: t4, data: r4 } = a2[i2][0];
        (t4 || r4?.buffer) && e2.push(t4 || r4.buffer);
        break;
      }
      case aa: {
        const [, [t4], r4] = a2[i2];
        t4 && e2.push(t4.buffer, r4.buffer);
        break;
      }
      case qt:
        const [t3, r3] = a2[i2];
        t3 && e2.push(t3.buffer);
        r3 && e2.push(r3.buffer);
        break;
      case ht:
        e2.push(a2[i2][0].buffer);
    }
    return e2;
  }
  flush(e2 = false, t2 = null) {
    this.optimizer.flush();
    const a2 = this.length;
    this._totalLength += a2;
    this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk: e2, separateAnnots: t2, length: a2 }, 1, this._transfers);
    this.dependencies.clear();
    this.fnArray.length = 0;
    this.argsArray.length = 0;
    this.weight = 0;
    this.optimizer.reset();
  }
};
function hexToInt(e2, t2) {
  let a2 = 0;
  for (let r2 = 0; r2 <= t2; r2++) a2 = a2 << 8 | e2[r2];
  return a2 >>> 0;
}
function hexToStr(e2, t2) {
  return 1 === t2 ? String.fromCharCode(e2[0], e2[1]) : 3 === t2 ? String.fromCharCode(e2[0], e2[1], e2[2], e2[3]) : String.fromCharCode(...e2.subarray(0, t2 + 1));
}
function addHex(e2, t2, a2) {
  let r2 = 0;
  for (let i2 = a2; i2 >= 0; i2--) {
    r2 += e2[i2] + t2[i2];
    e2[i2] = 255 & r2;
    r2 >>= 8;
  }
}
function incHex(e2, t2) {
  let a2 = 1;
  for (let r2 = t2; r2 >= 0 && a2 > 0; r2--) {
    a2 += e2[r2];
    e2[r2] = 255 & a2;
    a2 >>= 8;
  }
}
var Ka = 16;
var BinaryCMapStream = class {
  constructor(e2) {
    this.buffer = e2;
    this.pos = 0;
    this.end = e2.length;
    this.tmpBuf = new Uint8Array(19);
  }
  readByte() {
    return this.pos >= this.end ? -1 : this.buffer[this.pos++];
  }
  readNumber() {
    let e2, t2 = 0;
    do {
      const a2 = this.readByte();
      if (a2 < 0) throw new FormatError("unexpected EOF in bcmap");
      e2 = !(128 & a2);
      t2 = t2 << 7 | 127 & a2;
    } while (!e2);
    return t2;
  }
  readSigned() {
    const e2 = this.readNumber();
    return 1 & e2 ? ~(e2 >>> 1) : e2 >>> 1;
  }
  readHex(e2, t2) {
    e2.set(this.buffer.subarray(this.pos, this.pos + t2 + 1));
    this.pos += t2 + 1;
  }
  readHexNumber(e2, t2) {
    let a2;
    const r2 = this.tmpBuf;
    let i2 = 0;
    do {
      const e3 = this.readByte();
      if (e3 < 0) throw new FormatError("unexpected EOF in bcmap");
      a2 = !(128 & e3);
      r2[i2++] = 127 & e3;
    } while (!a2);
    let n2 = t2, s2 = 0, o2 = 0;
    for (; n2 >= 0; ) {
      for (; o2 < 8 && r2.length > 0; ) {
        s2 |= r2[--i2] << o2;
        o2 += 7;
      }
      e2[n2] = 255 & s2;
      n2--;
      s2 >>= 8;
      o2 -= 8;
    }
  }
  readHexSigned(e2, t2) {
    this.readHexNumber(e2, t2);
    const a2 = 1 & e2[t2] ? 255 : 0;
    let r2 = 0;
    for (let i2 = 0; i2 <= t2; i2++) {
      r2 = (1 & r2) << 8 | e2[i2];
      e2[i2] = r2 >> 1 ^ a2;
    }
  }
  readString() {
    const e2 = this.readNumber(), t2 = new Array(e2);
    for (let a2 = 0; a2 < e2; a2++) t2[a2] = this.readNumber();
    return String.fromCharCode(...t2);
  }
};
var BinaryCMapReader = class {
  async process(e2, t2, a2) {
    const r2 = new BinaryCMapStream(e2), i2 = r2.readByte();
    t2.vertical = !!(1 & i2);
    let n2 = null;
    const s2 = new Uint8Array(Ka), o2 = new Uint8Array(Ka), c2 = new Uint8Array(Ka), l2 = new Uint8Array(Ka), h2 = new Uint8Array(Ka);
    let u2, d2;
    for (; (d2 = r2.readByte()) >= 0; ) {
      const e3 = d2 >> 5;
      if (7 === e3) {
        switch (31 & d2) {
          case 0:
            r2.readString();
            break;
          case 1:
            n2 = r2.readString();
        }
        continue;
      }
      const a3 = !!(16 & d2), i3 = 15 & d2;
      if (i3 + 1 > Ka) throw new Error("BinaryCMapReader.process: Invalid dataSize.");
      const f2 = 1, g2 = r2.readNumber();
      switch (e3) {
        case 0:
          r2.readHex(s2, i3);
          r2.readHexNumber(o2, i3);
          addHex(o2, s2, i3);
          t2.addCodespaceRange(i3 + 1, hexToInt(s2, i3), hexToInt(o2, i3));
          for (let e4 = 1; e4 < g2; e4++) {
            incHex(o2, i3);
            r2.readHexNumber(s2, i3);
            addHex(s2, o2, i3);
            r2.readHexNumber(o2, i3);
            addHex(o2, s2, i3);
            t2.addCodespaceRange(i3 + 1, hexToInt(s2, i3), hexToInt(o2, i3));
          }
          break;
        case 1:
          r2.readHex(s2, i3);
          r2.readHexNumber(o2, i3);
          addHex(o2, s2, i3);
          r2.readNumber();
          for (let e4 = 1; e4 < g2; e4++) {
            incHex(o2, i3);
            r2.readHexNumber(s2, i3);
            addHex(s2, o2, i3);
            r2.readHexNumber(o2, i3);
            addHex(o2, s2, i3);
            r2.readNumber();
          }
          break;
        case 2:
          r2.readHex(c2, i3);
          u2 = r2.readNumber();
          t2.mapOne(hexToInt(c2, i3), u2);
          for (let e4 = 1; e4 < g2; e4++) {
            incHex(c2, i3);
            if (!a3) {
              r2.readHexNumber(h2, i3);
              addHex(c2, h2, i3);
            }
            u2 = r2.readSigned() + (u2 + 1);
            t2.mapOne(hexToInt(c2, i3), u2);
          }
          break;
        case 3:
          r2.readHex(s2, i3);
          r2.readHexNumber(o2, i3);
          addHex(o2, s2, i3);
          u2 = r2.readNumber();
          t2.mapCidRange(hexToInt(s2, i3), hexToInt(o2, i3), u2);
          for (let e4 = 1; e4 < g2; e4++) {
            incHex(o2, i3);
            if (a3) s2.set(o2);
            else {
              r2.readHexNumber(s2, i3);
              addHex(s2, o2, i3);
            }
            r2.readHexNumber(o2, i3);
            addHex(o2, s2, i3);
            u2 = r2.readNumber();
            t2.mapCidRange(hexToInt(s2, i3), hexToInt(o2, i3), u2);
          }
          break;
        case 4:
          r2.readHex(c2, f2);
          r2.readHex(l2, i3);
          t2.mapOne(hexToInt(c2, f2), hexToStr(l2, i3));
          for (let e4 = 1; e4 < g2; e4++) {
            incHex(c2, f2);
            if (!a3) {
              r2.readHexNumber(h2, f2);
              addHex(c2, h2, f2);
            }
            incHex(l2, i3);
            r2.readHexSigned(h2, i3);
            addHex(l2, h2, i3);
            t2.mapOne(hexToInt(c2, f2), hexToStr(l2, i3));
          }
          break;
        case 5:
          r2.readHex(s2, f2);
          r2.readHexNumber(o2, f2);
          addHex(o2, s2, f2);
          r2.readHex(l2, i3);
          t2.mapBfRange(hexToInt(s2, f2), hexToInt(o2, f2), hexToStr(l2, i3));
          for (let e4 = 1; e4 < g2; e4++) {
            incHex(o2, f2);
            if (a3) s2.set(o2);
            else {
              r2.readHexNumber(s2, f2);
              addHex(s2, o2, f2);
            }
            r2.readHexNumber(o2, f2);
            addHex(o2, s2, f2);
            r2.readHex(l2, i3);
            t2.mapBfRange(hexToInt(s2, f2), hexToInt(o2, f2), hexToStr(l2, i3));
          }
          break;
        default:
          throw new Error(`BinaryCMapReader.process - unknown type: ${e3}`);
      }
    }
    return n2 ? a2(n2) : t2;
  }
};
var Ascii85Stream = class extends DecodeStream {
  constructor(e2, t2) {
    t2 && (t2 *= 0.8);
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    this.input = new Uint8Array(5);
  }
  readBlock() {
    const e2 = this.str;
    let t2 = e2.getByte();
    for (; isWhiteSpace(t2); ) t2 = e2.getByte();
    if (-1 === t2 || 126 === t2) {
      this.eof = true;
      return;
    }
    const a2 = this.bufferLength;
    let r2, i2;
    if (122 === t2) {
      r2 = this.ensureBuffer(a2 + 4);
      for (i2 = 0; i2 < 4; ++i2) r2[a2 + i2] = 0;
      this.bufferLength += 4;
    } else {
      const n2 = this.input;
      n2[0] = t2;
      for (i2 = 1; i2 < 5; ++i2) {
        t2 = e2.getByte();
        for (; isWhiteSpace(t2); ) t2 = e2.getByte();
        n2[i2] = t2;
        if (-1 === t2 || 126 === t2) break;
      }
      r2 = this.ensureBuffer(a2 + i2 - 1);
      this.bufferLength += i2 - 1;
      if (i2 < 5) {
        for (; i2 < 5; ++i2) n2[i2] = 117;
        this.eof = true;
      }
      let s2 = 0;
      for (i2 = 0; i2 < 5; ++i2) s2 = 85 * s2 + (n2[i2] - 33);
      for (i2 = 3; i2 >= 0; --i2) {
        r2[a2 + i2] = 255 & s2;
        s2 >>= 8;
      }
    }
  }
};
var AsciiHexStream = class extends DecodeStream {
  constructor(e2, t2) {
    t2 && (t2 *= 0.5);
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    this.firstDigit = -1;
  }
  readBlock() {
    const e2 = this.str.getBytes(8e3);
    if (!e2.length) {
      this.eof = true;
      return;
    }
    const t2 = e2.length + 1 >> 1, a2 = this.ensureBuffer(this.bufferLength + t2);
    let r2 = this.bufferLength, i2 = this.firstDigit;
    for (const t3 of e2) {
      let e3;
      if (t3 >= 48 && t3 <= 57) e3 = 15 & t3;
      else {
        if (!(t3 >= 65 && t3 <= 70 || t3 >= 97 && t3 <= 102)) {
          if (62 === t3) {
            this.eof = true;
            break;
          }
          continue;
        }
        e3 = 9 + (15 & t3);
      }
      if (i2 < 0) i2 = e3;
      else {
        a2[r2++] = i2 << 4 | e3;
        i2 = -1;
      }
    }
    if (i2 >= 0 && this.eof) {
      a2[r2++] = i2 << 4;
      i2 = -1;
    }
    this.firstDigit = i2;
    this.bufferLength = r2;
  }
};
var Ja = -1;
var Ya = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]];
var Za = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]];
var Qa = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]];
var er = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]];
var tr = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]];
var ar = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
var CCITTFaxDecoder = class {
  constructor(e2, t2 = {}) {
    if ("function" != typeof e2?.next) throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    this.source = e2;
    this.eof = false;
    this.encoding = t2.K || 0;
    this.eoline = t2.EndOfLine || false;
    this.byteAlign = t2.EncodedByteAlign || false;
    this.columns = t2.Columns || 1728;
    this.rows = t2.Rows || 0;
    this.eoblock = t2.EndOfBlock ?? true;
    this.black = t2.BlackIs1 || false;
    this.codingLine = new Uint32Array(this.columns + 1);
    this.refLine = new Uint32Array(this.columns + 2);
    this.codingLine[0] = this.columns;
    this.codingPos = 0;
    this.row = 0;
    this.nextLine2D = this.encoding < 0;
    this.inputBits = 0;
    this.inputBuf = 0;
    this.outputBits = 0;
    this.rowsDone = false;
    let a2;
    for (; 0 === (a2 = this._lookBits(12)); ) this._eatBits(1);
    1 === a2 && this._eatBits(12);
    if (this.encoding > 0) {
      this.nextLine2D = !this._lookBits(1);
      this._eatBits(1);
    }
  }
  readNextChar() {
    if (this.eof) return -1;
    const e2 = this.refLine, t2 = this.codingLine, a2 = this.columns;
    let r2, i2, n2, s2, o2;
    if (0 === this.outputBits) {
      this.rowsDone && (this.eof = true);
      if (this.eof) return -1;
      this.err = false;
      let n3, o3, c2;
      if (this.nextLine2D) {
        for (s2 = 0; t2[s2] < a2; ++s2) e2[s2] = t2[s2];
        e2[s2++] = a2;
        e2[s2] = a2;
        t2[0] = 0;
        this.codingPos = 0;
        r2 = 0;
        i2 = 0;
        for (; t2[this.codingPos] < a2; ) {
          n3 = this._getTwoDimCode();
          switch (n3) {
            case 0:
              this._addPixels(e2[r2 + 1], i2);
              e2[r2 + 1] < a2 && (r2 += 2);
              break;
            case 1:
              n3 = o3 = 0;
              if (i2) {
                do {
                  n3 += c2 = this._getBlackCode();
                } while (c2 >= 64);
                do {
                  o3 += c2 = this._getWhiteCode();
                } while (c2 >= 64);
              } else {
                do {
                  n3 += c2 = this._getWhiteCode();
                } while (c2 >= 64);
                do {
                  o3 += c2 = this._getBlackCode();
                } while (c2 >= 64);
              }
              this._addPixels(t2[this.codingPos] + n3, i2);
              t2[this.codingPos] < a2 && this._addPixels(t2[this.codingPos] + o3, 1 ^ i2);
              for (; e2[r2] <= t2[this.codingPos] && e2[r2] < a2; ) r2 += 2;
              break;
            case 7:
              this._addPixels(e2[r2] + 3, i2);
              i2 ^= 1;
              if (t2[this.codingPos] < a2) {
                ++r2;
                for (; e2[r2] <= t2[this.codingPos] && e2[r2] < a2; ) r2 += 2;
              }
              break;
            case 5:
              this._addPixels(e2[r2] + 2, i2);
              i2 ^= 1;
              if (t2[this.codingPos] < a2) {
                ++r2;
                for (; e2[r2] <= t2[this.codingPos] && e2[r2] < a2; ) r2 += 2;
              }
              break;
            case 3:
              this._addPixels(e2[r2] + 1, i2);
              i2 ^= 1;
              if (t2[this.codingPos] < a2) {
                ++r2;
                for (; e2[r2] <= t2[this.codingPos] && e2[r2] < a2; ) r2 += 2;
              }
              break;
            case 2:
              this._addPixels(e2[r2], i2);
              i2 ^= 1;
              if (t2[this.codingPos] < a2) {
                ++r2;
                for (; e2[r2] <= t2[this.codingPos] && e2[r2] < a2; ) r2 += 2;
              }
              break;
            case 8:
              this._addPixelsNeg(e2[r2] - 3, i2);
              i2 ^= 1;
              if (t2[this.codingPos] < a2) {
                r2 > 0 ? --r2 : ++r2;
                for (; e2[r2] <= t2[this.codingPos] && e2[r2] < a2; ) r2 += 2;
              }
              break;
            case 6:
              this._addPixelsNeg(e2[r2] - 2, i2);
              i2 ^= 1;
              if (t2[this.codingPos] < a2) {
                r2 > 0 ? --r2 : ++r2;
                for (; e2[r2] <= t2[this.codingPos] && e2[r2] < a2; ) r2 += 2;
              }
              break;
            case 4:
              this._addPixelsNeg(e2[r2] - 1, i2);
              i2 ^= 1;
              if (t2[this.codingPos] < a2) {
                r2 > 0 ? --r2 : ++r2;
                for (; e2[r2] <= t2[this.codingPos] && e2[r2] < a2; ) r2 += 2;
              }
              break;
            case Ja:
              this._addPixels(a2, 0);
              this.eof = true;
              break;
            default:
              info("bad 2d code");
              this._addPixels(a2, 0);
              this.err = true;
          }
        }
      } else {
        t2[0] = 0;
        this.codingPos = 0;
        i2 = 0;
        for (; t2[this.codingPos] < a2; ) {
          n3 = 0;
          if (i2) do {
            n3 += c2 = this._getBlackCode();
          } while (c2 >= 64);
          else do {
            n3 += c2 = this._getWhiteCode();
          } while (c2 >= 64);
          this._addPixels(t2[this.codingPos] + n3, i2);
          i2 ^= 1;
        }
      }
      let l2 = false;
      this.byteAlign && (this.inputBits &= -8);
      if (this.eoblock || this.row !== this.rows - 1) {
        n3 = this._lookBits(12);
        if (this.eoline) for (; n3 !== Ja && 1 !== n3; ) {
          this._eatBits(1);
          n3 = this._lookBits(12);
        }
        else for (; 0 === n3; ) {
          this._eatBits(1);
          n3 = this._lookBits(12);
        }
        if (1 === n3) {
          this._eatBits(12);
          l2 = true;
        } else n3 === Ja && (this.eof = true);
      } else this.rowsDone = true;
      if (!this.eof && this.encoding > 0 && !this.rowsDone) {
        this.nextLine2D = !this._lookBits(1);
        this._eatBits(1);
      }
      if (this.eoblock && l2 && this.byteAlign) {
        n3 = this._lookBits(12);
        if (1 === n3) {
          this._eatBits(12);
          if (this.encoding > 0) {
            this._lookBits(1);
            this._eatBits(1);
          }
          if (this.encoding >= 0) for (s2 = 0; s2 < 4; ++s2) {
            n3 = this._lookBits(12);
            1 !== n3 && info("bad rtc code: " + n3);
            this._eatBits(12);
            if (this.encoding > 0) {
              this._lookBits(1);
              this._eatBits(1);
            }
          }
          this.eof = true;
        }
      } else if (this.err && this.eoline) {
        for (; ; ) {
          n3 = this._lookBits(13);
          if (n3 === Ja) {
            this.eof = true;
            return -1;
          }
          if (n3 >> 1 == 1) break;
          this._eatBits(1);
        }
        this._eatBits(12);
        if (this.encoding > 0) {
          this._eatBits(1);
          this.nextLine2D = !(1 & n3);
        }
      }
      this.outputBits = t2[0] > 0 ? t2[this.codingPos = 0] : t2[this.codingPos = 1];
      this.row++;
    }
    if (this.outputBits >= 8) {
      o2 = 1 & this.codingPos ? 0 : 255;
      this.outputBits -= 8;
      if (0 === this.outputBits && t2[this.codingPos] < a2) {
        this.codingPos++;
        this.outputBits = t2[this.codingPos] - t2[this.codingPos - 1];
      }
    } else {
      n2 = 8;
      o2 = 0;
      do {
        if ("number" != typeof this.outputBits) throw new FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
        if (this.outputBits > n2) {
          o2 <<= n2;
          1 & this.codingPos || (o2 |= 255 >> 8 - n2);
          this.outputBits -= n2;
          n2 = 0;
        } else {
          o2 <<= this.outputBits;
          1 & this.codingPos || (o2 |= 255 >> 8 - this.outputBits);
          n2 -= this.outputBits;
          this.outputBits = 0;
          if (t2[this.codingPos] < a2) {
            this.codingPos++;
            this.outputBits = t2[this.codingPos] - t2[this.codingPos - 1];
          } else if (n2 > 0) {
            o2 <<= n2;
            n2 = 0;
          }
        }
      } while (n2);
    }
    this.black && (o2 ^= 255);
    return o2;
  }
  _addPixels(e2, t2) {
    const a2 = this.codingLine;
    let r2 = this.codingPos;
    if (e2 > a2[r2]) {
      if (e2 > this.columns) {
        info("row is wrong length");
        this.err = true;
        e2 = this.columns;
      }
      1 & r2 ^ t2 && ++r2;
      a2[r2] = e2;
    }
    this.codingPos = r2;
  }
  _addPixelsNeg(e2, t2) {
    const a2 = this.codingLine;
    let r2 = this.codingPos;
    if (e2 > a2[r2]) {
      if (e2 > this.columns) {
        info("row is wrong length");
        this.err = true;
        e2 = this.columns;
      }
      1 & r2 ^ t2 && ++r2;
      a2[r2] = e2;
    } else if (e2 < a2[r2]) {
      if (e2 < 0) {
        info("invalid code");
        this.err = true;
        e2 = 0;
      }
      for (; r2 > 0 && e2 < a2[r2 - 1]; ) --r2;
      a2[r2] = e2;
    }
    this.codingPos = r2;
  }
  _findTableCode(e2, t2, a2, r2) {
    const i2 = r2 || 0;
    for (let r3 = e2; r3 <= t2; ++r3) {
      let e3 = this._lookBits(r3);
      if (e3 === Ja) return [true, 1, false];
      r3 < t2 && (e3 <<= t2 - r3);
      if (!i2 || e3 >= i2) {
        const t3 = a2[e3 - i2];
        if (t3[0] === r3) {
          this._eatBits(r3);
          return [true, t3[1], true];
        }
      }
    }
    return [false, 0, false];
  }
  _getTwoDimCode() {
    let e2, t2 = 0;
    if (this.eoblock) {
      t2 = this._lookBits(7);
      e2 = Ya[t2];
      if (e2?.[0] > 0) {
        this._eatBits(e2[0]);
        return e2[1];
      }
    } else {
      const e3 = this._findTableCode(1, 7, Ya);
      if (e3[0] && e3[2]) return e3[1];
    }
    info("Bad two dim code");
    return Ja;
  }
  _getWhiteCode() {
    let e2, t2 = 0;
    if (this.eoblock) {
      t2 = this._lookBits(12);
      if (t2 === Ja) return 1;
      e2 = t2 >> 5 ? Qa[t2 >> 3] : Za[t2];
      if (e2[0] > 0) {
        this._eatBits(e2[0]);
        return e2[1];
      }
    } else {
      let e3 = this._findTableCode(1, 9, Qa);
      if (e3[0]) return e3[1];
      e3 = this._findTableCode(11, 12, Za);
      if (e3[0]) return e3[1];
    }
    info("bad white code");
    this._eatBits(1);
    return 1;
  }
  _getBlackCode() {
    let e2, t2;
    if (this.eoblock) {
      e2 = this._lookBits(13);
      if (e2 === Ja) return 1;
      t2 = e2 >> 7 ? !(e2 >> 9) && e2 >> 7 ? tr[(e2 >> 1) - 64] : ar[e2 >> 7] : er[e2];
      if (t2[0] > 0) {
        this._eatBits(t2[0]);
        return t2[1];
      }
    } else {
      let e3 = this._findTableCode(2, 6, ar);
      if (e3[0]) return e3[1];
      e3 = this._findTableCode(7, 12, tr, 64);
      if (e3[0]) return e3[1];
      e3 = this._findTableCode(10, 13, er);
      if (e3[0]) return e3[1];
    }
    info("bad black code");
    this._eatBits(1);
    return 1;
  }
  _lookBits(e2) {
    let t2;
    for (; this.inputBits < e2; ) {
      if (-1 === (t2 = this.source.next())) return 0 === this.inputBits ? Ja : this.inputBuf << e2 - this.inputBits & 65535 >> 16 - e2;
      this.inputBuf = this.inputBuf << 8 | t2;
      this.inputBits += 8;
    }
    return this.inputBuf >> this.inputBits - e2 & 65535 >> 16 - e2;
  }
  _eatBits(e2) {
    (this.inputBits -= e2) < 0 && (this.inputBits = 0);
  }
};
var CCITTFaxStream = class extends DecodeStream {
  constructor(e2, t2, a2) {
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    a2 instanceof Dict || (a2 = Dict.empty);
    const r2 = { next: () => e2.getByte() };
    this.ccittFaxDecoder = new CCITTFaxDecoder(r2, { K: a2.get("K"), EndOfLine: a2.get("EndOfLine"), EncodedByteAlign: a2.get("EncodedByteAlign"), Columns: a2.get("Columns"), Rows: a2.get("Rows"), EndOfBlock: a2.get("EndOfBlock"), BlackIs1: a2.get("BlackIs1") });
  }
  readBlock() {
    for (; !this.eof; ) {
      const e2 = this.ccittFaxDecoder.readNextChar();
      if (-1 === e2) {
        this.eof = true;
        return;
      }
      this.ensureBuffer(this.bufferLength + 1);
      this.buffer[this.bufferLength++] = e2;
    }
  }
};
var rr = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var ir = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]);
var nr = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]);
var sr = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9];
var or = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
var FlateStream = class extends DecodeStream {
  constructor(e2, t2) {
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    const a2 = e2.getByte(), r2 = e2.getByte();
    if (-1 === a2 || -1 === r2) throw new FormatError(`Invalid header in flate stream: ${a2}, ${r2}`);
    if (8 != (15 & a2)) throw new FormatError(`Unknown compression method in flate stream: ${a2}, ${r2}`);
    if (((a2 << 8) + r2) % 31 != 0) throw new FormatError(`Bad FCHECK in flate stream: ${a2}, ${r2}`);
    if (32 & r2) throw new FormatError(`FDICT bit set in flate stream: ${a2}, ${r2}`);
    this.codeSize = 0;
    this.codeBuf = 0;
  }
  async getImageData(e2, t2) {
    const a2 = await this.asyncGetBytes();
    return a2 ? a2.length <= e2 ? a2 : a2.subarray(0, e2) : this.getBytes(e2);
  }
  async asyncGetBytes() {
    this.str.reset();
    const e2 = this.str.getBytes();
    try {
      const { readable: t2, writable: a2 } = new DecompressionStream("deflate"), r2 = a2.getWriter();
      await r2.ready;
      r2.write(e2).then((async () => {
        await r2.ready;
        await r2.close();
      })).catch((() => {
      }));
      const i2 = [];
      let n2 = 0;
      for await (const e3 of t2) {
        i2.push(e3);
        n2 += e3.byteLength;
      }
      const s2 = new Uint8Array(n2);
      let o2 = 0;
      for (const e3 of i2) {
        s2.set(e3, o2);
        o2 += e3.byteLength;
      }
      return s2;
    } catch {
      this.str = new Stream(e2, 2, e2.length, this.str.dict);
      this.reset();
      return null;
    }
  }
  get isAsync() {
    return true;
  }
  getBits(e2) {
    const t2 = this.str;
    let a2, r2 = this.codeSize, i2 = this.codeBuf;
    for (; r2 < e2; ) {
      if (-1 === (a2 = t2.getByte())) throw new FormatError("Bad encoding in flate stream");
      i2 |= a2 << r2;
      r2 += 8;
    }
    a2 = i2 & (1 << e2) - 1;
    this.codeBuf = i2 >> e2;
    this.codeSize = r2 -= e2;
    return a2;
  }
  getCode(e2) {
    const t2 = this.str, a2 = e2[0], r2 = e2[1];
    let i2, n2 = this.codeSize, s2 = this.codeBuf;
    for (; n2 < r2 && -1 !== (i2 = t2.getByte()); ) {
      s2 |= i2 << n2;
      n2 += 8;
    }
    const o2 = a2[s2 & (1 << r2) - 1], c2 = o2 >> 16, l2 = 65535 & o2;
    if (c2 < 1 || n2 < c2) throw new FormatError("Bad encoding in flate stream");
    this.codeBuf = s2 >> c2;
    this.codeSize = n2 - c2;
    return l2;
  }
  generateHuffmanTable(e2) {
    const t2 = e2.length;
    let a2, r2 = 0;
    for (a2 = 0; a2 < t2; ++a2) e2[a2] > r2 && (r2 = e2[a2]);
    const i2 = 1 << r2, n2 = new Int32Array(i2);
    for (let s2 = 1, o2 = 0, c2 = 2; s2 <= r2; ++s2, o2 <<= 1, c2 <<= 1) for (let r3 = 0; r3 < t2; ++r3) if (e2[r3] === s2) {
      let e3 = 0, t3 = o2;
      for (a2 = 0; a2 < s2; ++a2) {
        e3 = e3 << 1 | 1 & t3;
        t3 >>= 1;
      }
      for (a2 = e3; a2 < i2; a2 += c2) n2[a2] = s2 << 16 | r3;
      ++o2;
    }
    return [n2, r2];
  }
  #X(e2) {
    info(e2);
    this.eof = true;
  }
  readBlock() {
    let e2, t2, a2;
    const r2 = this.str;
    try {
      t2 = this.getBits(3);
    } catch (e3) {
      this.#X(e3.message);
      return;
    }
    1 & t2 && (this.eof = true);
    t2 >>= 1;
    if (0 === t2) {
      let t3;
      if (-1 === (t3 = r2.getByte())) {
        this.#X("Bad block header in flate stream");
        return;
      }
      let a3 = t3;
      if (-1 === (t3 = r2.getByte())) {
        this.#X("Bad block header in flate stream");
        return;
      }
      a3 |= t3 << 8;
      if (-1 === (t3 = r2.getByte())) {
        this.#X("Bad block header in flate stream");
        return;
      }
      let i3 = t3;
      if (-1 === (t3 = r2.getByte())) {
        this.#X("Bad block header in flate stream");
        return;
      }
      i3 |= t3 << 8;
      if (i3 !== (65535 & ~a3) && (0 !== a3 || 0 !== i3)) throw new FormatError("Bad uncompressed block length in flate stream");
      this.codeBuf = 0;
      this.codeSize = 0;
      const n3 = this.bufferLength, s3 = n3 + a3;
      e2 = this.ensureBuffer(s3);
      this.bufferLength = s3;
      if (0 === a3) -1 === r2.peekByte() && (this.eof = true);
      else {
        const t4 = r2.getBytes(a3);
        e2.set(t4, n3);
        t4.length < a3 && (this.eof = true);
      }
      return;
    }
    let i2, n2;
    if (1 === t2) {
      i2 = sr;
      n2 = or;
    } else {
      if (2 !== t2) throw new FormatError("Unknown block type in flate stream");
      {
        const e3 = this.getBits(5) + 257, t3 = this.getBits(5) + 1, r3 = this.getBits(4) + 4, s3 = new Uint8Array(rr.length);
        let o3;
        for (o3 = 0; o3 < r3; ++o3) s3[rr[o3]] = this.getBits(3);
        const c2 = this.generateHuffmanTable(s3);
        a2 = 0;
        o3 = 0;
        const l2 = e3 + t3, h2 = new Uint8Array(l2);
        let u2, d2, f2;
        for (; o3 < l2; ) {
          const e4 = this.getCode(c2);
          if (16 === e4) {
            u2 = 2;
            d2 = 3;
            f2 = a2;
          } else if (17 === e4) {
            u2 = 3;
            d2 = 3;
            f2 = a2 = 0;
          } else {
            if (18 !== e4) {
              h2[o3++] = a2 = e4;
              continue;
            }
            u2 = 7;
            d2 = 11;
            f2 = a2 = 0;
          }
          let t4 = this.getBits(u2) + d2;
          for (; t4-- > 0; ) h2[o3++] = f2;
        }
        i2 = this.generateHuffmanTable(h2.subarray(0, e3));
        n2 = this.generateHuffmanTable(h2.subarray(e3, l2));
      }
    }
    e2 = this.buffer;
    let s2 = e2 ? e2.length : 0, o2 = this.bufferLength;
    for (; ; ) {
      let t3 = this.getCode(i2);
      if (t3 < 256) {
        if (o2 + 1 >= s2) {
          e2 = this.ensureBuffer(o2 + 1);
          s2 = e2.length;
        }
        e2[o2++] = t3;
        continue;
      }
      if (256 === t3) {
        this.bufferLength = o2;
        return;
      }
      t3 -= 257;
      t3 = ir[t3];
      let r3 = t3 >> 16;
      r3 > 0 && (r3 = this.getBits(r3));
      a2 = (65535 & t3) + r3;
      t3 = this.getCode(n2);
      t3 = nr[t3];
      r3 = t3 >> 16;
      r3 > 0 && (r3 = this.getBits(r3));
      const c2 = (65535 & t3) + r3;
      if (o2 + a2 >= s2) {
        e2 = this.ensureBuffer(o2 + a2);
        s2 = e2.length;
      }
      for (let t4 = 0; t4 < a2; ++t4, ++o2) e2[o2] = e2[o2 - c2];
    }
  }
};
var cr = [{ qe: 22017, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 13313, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 6145, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 2753, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 1313, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 545, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 22017, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 21505, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 18433, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 14337, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 12289, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 9217, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 7169, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 5633, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 22017, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 21505, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 20737, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 18433, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 14337, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 13313, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 12289, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 10241, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 9217, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 8705, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 7169, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 6145, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 5633, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 5121, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 4609, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 4353, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 2753, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 2497, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 2209, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 1313, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 1089, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 673, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 545, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 321, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 273, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 133, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 73, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 37, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 21, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 9, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 5, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 1, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 22017, nmps: 46, nlps: 46, switchFlag: 0 }];
var ArithmeticDecoder = class {
  constructor(e2, t2, a2) {
    this.data = e2;
    this.bp = t2;
    this.dataEnd = a2;
    this.chigh = e2[t2];
    this.clow = 0;
    this.byteIn();
    this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
    this.clow = this.clow << 7 & 65535;
    this.ct -= 7;
    this.a = 32768;
  }
  byteIn() {
    const e2 = this.data;
    let t2 = this.bp;
    if (255 === e2[t2]) if (e2[t2 + 1] > 143) {
      this.clow += 65280;
      this.ct = 8;
    } else {
      t2++;
      this.clow += e2[t2] << 9;
      this.ct = 7;
      this.bp = t2;
    }
    else {
      t2++;
      this.clow += t2 < this.dataEnd ? e2[t2] << 8 : 65280;
      this.ct = 8;
      this.bp = t2;
    }
    if (this.clow > 65535) {
      this.chigh += this.clow >> 16;
      this.clow &= 65535;
    }
  }
  readBit(e2, t2) {
    let a2 = e2[t2] >> 1, r2 = 1 & e2[t2];
    const i2 = cr[a2], n2 = i2.qe;
    let s2, o2 = this.a - n2;
    if (this.chigh < n2) if (o2 < n2) {
      o2 = n2;
      s2 = r2;
      a2 = i2.nmps;
    } else {
      o2 = n2;
      s2 = 1 ^ r2;
      1 === i2.switchFlag && (r2 = s2);
      a2 = i2.nlps;
    }
    else {
      this.chigh -= n2;
      if (32768 & o2) {
        this.a = o2;
        return r2;
      }
      if (o2 < n2) {
        s2 = 1 ^ r2;
        1 === i2.switchFlag && (r2 = s2);
        a2 = i2.nlps;
      } else {
        s2 = r2;
        a2 = i2.nmps;
      }
    }
    do {
      0 === this.ct && this.byteIn();
      o2 <<= 1;
      this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
      this.clow = this.clow << 1 & 65535;
      this.ct--;
    } while (!(32768 & o2));
    this.a = o2;
    e2[t2] = a2 << 1 | r2;
    return s2;
  }
};
var Jbig2Error = class extends fa {
  constructor(e2) {
    super(e2, "Jbig2Error");
  }
};
var ContextCache = class {
  getContexts(e2) {
    return e2 in this ? this[e2] : this[e2] = new Int8Array(65536);
  }
};
var DecodingContext = class {
  constructor(e2, t2, a2) {
    this.data = e2;
    this.start = t2;
    this.end = a2;
  }
  get decoder() {
    return shadow(this, "decoder", new ArithmeticDecoder(this.data, this.start, this.end));
  }
  get contextCache() {
    return shadow(this, "contextCache", new ContextCache());
  }
};
function decodeInteger(e2, t2, a2) {
  const r2 = e2.getContexts(t2);
  let i2 = 1;
  function readBits(e3) {
    let t3 = 0;
    for (let n3 = 0; n3 < e3; n3++) {
      const e4 = a2.readBit(r2, i2);
      i2 = i2 < 256 ? i2 << 1 | e4 : 511 & (i2 << 1 | e4) | 256;
      t3 = t3 << 1 | e4;
    }
    return t3 >>> 0;
  }
  const n2 = readBits(1), s2 = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
  let o2;
  0 === n2 ? o2 = s2 : s2 > 0 && (o2 = -s2);
  return o2 >= -2147483648 && o2 <= va ? o2 : null;
}
function decodeIAID(e2, t2, a2) {
  const r2 = e2.getContexts("IAID");
  let i2 = 1;
  for (let e3 = 0; e3 < a2; e3++) {
    i2 = i2 << 1 | t2.readBit(r2, i2);
  }
  return a2 < 31 ? i2 & (1 << a2) - 1 : 2147483647 & i2;
}
var lr = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"];
var hr = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]];
var ur = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }];
var dr = [39717, 1941, 229, 405];
var fr = [32, 8];
function decodeBitmap(e2, t2, a2, r2, i2, n2, s2, o2) {
  if (e2) {
    return decodeMMRBitmap(new Reader(o2.data, o2.start, o2.end), t2, a2, false);
  }
  if (0 === r2 && !n2 && !i2 && 4 === s2.length && 3 === s2[0].x && -1 === s2[0].y && -3 === s2[1].x && -1 === s2[1].y && 2 === s2[2].x && -2 === s2[2].y && -2 === s2[3].x && -2 === s2[3].y) return (function decodeBitmapTemplate0(e3, t3, a3) {
    const r3 = a3.decoder, i3 = a3.contextCache.getContexts("GB"), n3 = [];
    let s3, o3, c3, l3, h3, u3, d3;
    for (o3 = 0; o3 < t3; o3++) {
      h3 = n3[o3] = new Uint8Array(e3);
      u3 = o3 < 1 ? h3 : n3[o3 - 1];
      d3 = o3 < 2 ? h3 : n3[o3 - 2];
      s3 = d3[0] << 13 | d3[1] << 12 | d3[2] << 11 | u3[0] << 7 | u3[1] << 6 | u3[2] << 5 | u3[3] << 4;
      for (c3 = 0; c3 < e3; c3++) {
        h3[c3] = l3 = r3.readBit(i3, s3);
        s3 = (31735 & s3) << 1 | (c3 + 3 < e3 ? d3[c3 + 3] << 11 : 0) | (c3 + 4 < e3 ? u3[c3 + 4] << 4 : 0) | l3;
      }
    }
    return n3;
  })(t2, a2, o2);
  const c2 = !!n2, l2 = hr[r2].concat(s2);
  l2.sort(((e3, t3) => e3.y - t3.y || e3.x - t3.x));
  const h2 = l2.length, u2 = new Int8Array(h2), d2 = new Int8Array(h2), f2 = [];
  let g2, p2, m2 = 0, b2 = 0, y2 = 0, w2 = 0;
  for (p2 = 0; p2 < h2; p2++) {
    u2[p2] = l2[p2].x;
    d2[p2] = l2[p2].y;
    b2 = Math.min(b2, l2[p2].x);
    y2 = Math.max(y2, l2[p2].x);
    w2 = Math.min(w2, l2[p2].y);
    p2 < h2 - 1 && l2[p2].y === l2[p2 + 1].y && l2[p2].x === l2[p2 + 1].x - 1 ? m2 |= 1 << h2 - 1 - p2 : f2.push(p2);
  }
  const x2 = f2.length, S2 = new Int8Array(x2), k2 = new Int8Array(x2), C2 = new Uint16Array(x2);
  for (g2 = 0; g2 < x2; g2++) {
    p2 = f2[g2];
    S2[g2] = l2[p2].x;
    k2[g2] = l2[p2].y;
    C2[g2] = 1 << h2 - 1 - p2;
  }
  const v2 = -b2, F2 = -w2, T2 = t2 - y2, O2 = dr[r2];
  let M2 = new Uint8Array(t2);
  const D2 = [], R2 = o2.decoder, N2 = o2.contextCache.getContexts("GB");
  let E2, L2, j2, _2, U2, X2 = 0, q2 = 0;
  for (let e3 = 0; e3 < a2; e3++) {
    if (i2) {
      X2 ^= R2.readBit(N2, O2);
      if (X2) {
        D2.push(M2);
        continue;
      }
    }
    M2 = new Uint8Array(M2);
    D2.push(M2);
    for (E2 = 0; E2 < t2; E2++) {
      if (c2 && n2[e3][E2]) {
        M2[E2] = 0;
        continue;
      }
      if (E2 >= v2 && E2 < T2 && e3 >= F2) {
        q2 = q2 << 1 & m2;
        for (p2 = 0; p2 < x2; p2++) {
          L2 = e3 + k2[p2];
          j2 = E2 + S2[p2];
          _2 = D2[L2][j2];
          if (_2) {
            _2 = C2[p2];
            q2 |= _2;
          }
        }
      } else {
        q2 = 0;
        U2 = h2 - 1;
        for (p2 = 0; p2 < h2; p2++, U2--) {
          j2 = E2 + u2[p2];
          if (j2 >= 0 && j2 < t2) {
            L2 = e3 + d2[p2];
            if (L2 >= 0) {
              _2 = D2[L2][j2];
              _2 && (q2 |= _2 << U2);
            }
          }
        }
      }
      const a3 = R2.readBit(N2, q2);
      M2[E2] = a3;
    }
  }
  return D2;
}
function decodeRefinement(e2, t2, a2, r2, i2, n2, s2, o2, c2) {
  let l2 = ur[a2].coding;
  0 === a2 && (l2 = l2.concat([o2[0]]));
  const h2 = l2.length, u2 = new Int32Array(h2), d2 = new Int32Array(h2);
  let f2;
  for (f2 = 0; f2 < h2; f2++) {
    u2[f2] = l2[f2].x;
    d2[f2] = l2[f2].y;
  }
  let g2 = ur[a2].reference;
  0 === a2 && (g2 = g2.concat([o2[1]]));
  const p2 = g2.length, m2 = new Int32Array(p2), b2 = new Int32Array(p2);
  for (f2 = 0; f2 < p2; f2++) {
    m2[f2] = g2[f2].x;
    b2[f2] = g2[f2].y;
  }
  const y2 = r2[0].length, w2 = r2.length, x2 = fr[a2], S2 = [], k2 = c2.decoder, C2 = c2.contextCache.getContexts("GR");
  let v2 = 0;
  for (let a3 = 0; a3 < t2; a3++) {
    if (s2) {
      v2 ^= k2.readBit(C2, x2);
      if (v2) throw new Jbig2Error("prediction is not supported");
    }
    const t3 = new Uint8Array(e2);
    S2.push(t3);
    for (let s3 = 0; s3 < e2; s3++) {
      let o3, c3, l3 = 0;
      for (f2 = 0; f2 < h2; f2++) {
        o3 = a3 + d2[f2];
        c3 = s3 + u2[f2];
        o3 < 0 || c3 < 0 || c3 >= e2 ? l3 <<= 1 : l3 = l3 << 1 | S2[o3][c3];
      }
      for (f2 = 0; f2 < p2; f2++) {
        o3 = a3 + b2[f2] - n2;
        c3 = s3 + m2[f2] - i2;
        o3 < 0 || o3 >= w2 || c3 < 0 || c3 >= y2 ? l3 <<= 1 : l3 = l3 << 1 | r2[o3][c3];
      }
      const g3 = k2.readBit(C2, l3);
      t3[s3] = g3;
    }
  }
  return S2;
}
function decodeTextRegion(e2, t2, a2, r2, i2, n2, s2, o2, c2, l2, h2, u2, d2, f2, g2, p2, m2, b2, y2) {
  if (e2 && t2) throw new Jbig2Error("refinement with Huffman is not supported");
  const w2 = [];
  let x2, S2;
  for (x2 = 0; x2 < r2; x2++) {
    S2 = new Uint8Array(a2);
    i2 && S2.fill(i2);
    w2.push(S2);
  }
  const k2 = m2.decoder, C2 = m2.contextCache;
  let v2 = e2 ? -f2.tableDeltaT.decode(y2) : -decodeInteger(C2, "IADT", k2), F2 = 0;
  x2 = 0;
  for (; x2 < n2; ) {
    v2 += e2 ? f2.tableDeltaT.decode(y2) : decodeInteger(C2, "IADT", k2);
    F2 += e2 ? f2.tableFirstS.decode(y2) : decodeInteger(C2, "IAFS", k2);
    let r3 = F2;
    for (; ; ) {
      let i3 = 0;
      s2 > 1 && (i3 = e2 ? y2.readBits(b2) : decodeInteger(C2, "IAIT", k2));
      const n3 = s2 * v2 + i3, F3 = e2 ? f2.symbolIDTable.decode(y2) : decodeIAID(C2, k2, c2), T2 = t2 && (e2 ? y2.readBit() : decodeInteger(C2, "IARI", k2));
      let O2 = o2[F3], M2 = O2[0].length, D2 = O2.length;
      if (T2) {
        const e3 = decodeInteger(C2, "IARDW", k2), t3 = decodeInteger(C2, "IARDH", k2);
        M2 += e3;
        D2 += t3;
        O2 = decodeRefinement(M2, D2, g2, O2, (e3 >> 1) + decodeInteger(C2, "IARDX", k2), (t3 >> 1) + decodeInteger(C2, "IARDY", k2), false, p2, m2);
      }
      let R2 = 0;
      l2 ? 1 & u2 ? R2 = D2 - 1 : r3 += D2 - 1 : u2 > 1 ? r3 += M2 - 1 : R2 = M2 - 1;
      const N2 = n3 - (1 & u2 ? 0 : D2 - 1), E2 = r3 - (2 & u2 ? M2 - 1 : 0);
      let L2, j2, _2;
      if (l2) for (L2 = 0; L2 < D2; L2++) {
        S2 = w2[E2 + L2];
        if (!S2) continue;
        _2 = O2[L2];
        const e3 = Math.min(a2 - N2, M2);
        switch (d2) {
          case 0:
            for (j2 = 0; j2 < e3; j2++) S2[N2 + j2] |= _2[j2];
            break;
          case 2:
            for (j2 = 0; j2 < e3; j2++) S2[N2 + j2] ^= _2[j2];
            break;
          default:
            throw new Jbig2Error(`operator ${d2} is not supported`);
        }
      }
      else for (j2 = 0; j2 < D2; j2++) {
        S2 = w2[N2 + j2];
        if (S2) {
          _2 = O2[j2];
          switch (d2) {
            case 0:
              for (L2 = 0; L2 < M2; L2++) S2[E2 + L2] |= _2[L2];
              break;
            case 2:
              for (L2 = 0; L2 < M2; L2++) S2[E2 + L2] ^= _2[L2];
              break;
            default:
              throw new Jbig2Error(`operator ${d2} is not supported`);
          }
        }
      }
      x2++;
      const U2 = e2 ? f2.tableDeltaS.decode(y2) : decodeInteger(C2, "IADS", k2);
      if (null === U2) break;
      r3 += R2 + U2 + h2;
    }
  }
  return w2;
}
function readSegmentHeader(e2, t2) {
  const a2 = {};
  a2.number = readUint32(e2, t2);
  const r2 = e2[t2 + 4], i2 = 63 & r2;
  if (!lr[i2]) throw new Jbig2Error("invalid segment type: " + i2);
  a2.type = i2;
  a2.typeName = lr[i2];
  a2.deferredNonRetain = !!(128 & r2);
  const n2 = !!(64 & r2), s2 = e2[t2 + 5];
  let o2 = s2 >> 5 & 7;
  const c2 = [31 & s2];
  let l2 = t2 + 6;
  if (7 === s2) {
    o2 = 536870911 & readUint32(e2, l2 - 1);
    l2 += 3;
    let t3 = o2 + 7 >> 3;
    c2[0] = e2[l2++];
    for (; --t3 > 0; ) c2.push(e2[l2++]);
  } else if (5 === s2 || 6 === s2) throw new Jbig2Error("invalid referred-to flags");
  a2.retainBits = c2;
  let h2 = 4;
  a2.number <= 256 ? h2 = 1 : a2.number <= 65536 && (h2 = 2);
  const u2 = [];
  let d2, f2;
  for (d2 = 0; d2 < o2; d2++) {
    let t3;
    t3 = 1 === h2 ? e2[l2] : 2 === h2 ? readUint16(e2, l2) : readUint32(e2, l2);
    u2.push(t3);
    l2 += h2;
  }
  a2.referredTo = u2;
  if (n2) {
    a2.pageAssociation = readUint32(e2, l2);
    l2 += 4;
  } else a2.pageAssociation = e2[l2++];
  a2.length = readUint32(e2, l2);
  l2 += 4;
  if (4294967295 === a2.length) {
    if (38 !== i2) throw new Jbig2Error("invalid unknown segment length");
    {
      const t3 = readRegionSegmentInformation(e2, l2), r3 = !!(1 & e2[l2 + gr]), i3 = 6, n3 = new Uint8Array(i3);
      if (!r3) {
        n3[0] = 255;
        n3[1] = 172;
      }
      n3[2] = t3.height >>> 24 & 255;
      n3[3] = t3.height >> 16 & 255;
      n3[4] = t3.height >> 8 & 255;
      n3[5] = 255 & t3.height;
      for (d2 = l2, f2 = e2.length; d2 < f2; d2++) {
        let t4 = 0;
        for (; t4 < i3 && n3[t4] === e2[d2 + t4]; ) t4++;
        if (t4 === i3) {
          a2.length = d2 + i3;
          break;
        }
      }
      if (4294967295 === a2.length) throw new Jbig2Error("segment end was not found");
    }
  }
  a2.headerEnd = l2;
  return a2;
}
function readSegments(e2, t2, a2, r2) {
  const i2 = [];
  let n2 = a2;
  for (; n2 < r2; ) {
    const a3 = readSegmentHeader(t2, n2);
    n2 = a3.headerEnd;
    const r3 = { header: a3, data: t2 };
    if (!e2.randomAccess) {
      r3.start = n2;
      n2 += a3.length;
      r3.end = n2;
    }
    i2.push(r3);
    if (51 === a3.type) break;
  }
  if (e2.randomAccess) for (let e3 = 0, t3 = i2.length; e3 < t3; e3++) {
    i2[e3].start = n2;
    n2 += i2[e3].header.length;
    i2[e3].end = n2;
  }
  return i2;
}
function readRegionSegmentInformation(e2, t2) {
  return { width: readUint32(e2, t2), height: readUint32(e2, t2 + 4), x: readUint32(e2, t2 + 8), y: readUint32(e2, t2 + 12), combinationOperator: 7 & e2[t2 + 16] };
}
var gr = 17;
function processSegment(e2, t2) {
  const a2 = e2.header, r2 = e2.data, i2 = e2.end;
  let n2, s2, o2, c2, l2 = e2.start;
  switch (a2.type) {
    case 0:
      const e3 = {}, t3 = readUint16(r2, l2);
      e3.huffman = !!(1 & t3);
      e3.refinement = !!(2 & t3);
      e3.huffmanDHSelector = t3 >> 2 & 3;
      e3.huffmanDWSelector = t3 >> 4 & 3;
      e3.bitmapSizeSelector = t3 >> 6 & 1;
      e3.aggregationInstancesSelector = t3 >> 7 & 1;
      e3.bitmapCodingContextUsed = !!(256 & t3);
      e3.bitmapCodingContextRetained = !!(512 & t3);
      e3.template = t3 >> 10 & 3;
      e3.refinementTemplate = t3 >> 12 & 1;
      l2 += 2;
      if (!e3.huffman) {
        c2 = 0 === e3.template ? 4 : 1;
        s2 = [];
        for (o2 = 0; o2 < c2; o2++) {
          s2.push({ x: readInt8(r2, l2), y: readInt8(r2, l2 + 1) });
          l2 += 2;
        }
        e3.at = s2;
      }
      if (e3.refinement && !e3.refinementTemplate) {
        s2 = [];
        for (o2 = 0; o2 < 2; o2++) {
          s2.push({ x: readInt8(r2, l2), y: readInt8(r2, l2 + 1) });
          l2 += 2;
        }
        e3.refinementAt = s2;
      }
      e3.numberOfExportedSymbols = readUint32(r2, l2);
      l2 += 4;
      e3.numberOfNewSymbols = readUint32(r2, l2);
      l2 += 4;
      n2 = [e3, a2.number, a2.referredTo, r2, l2, i2];
      break;
    case 6:
    case 7:
      const h3 = {};
      h3.info = readRegionSegmentInformation(r2, l2);
      l2 += gr;
      const u2 = readUint16(r2, l2);
      l2 += 2;
      h3.huffman = !!(1 & u2);
      h3.refinement = !!(2 & u2);
      h3.logStripSize = u2 >> 2 & 3;
      h3.stripSize = 1 << h3.logStripSize;
      h3.referenceCorner = u2 >> 4 & 3;
      h3.transposed = !!(64 & u2);
      h3.combinationOperator = u2 >> 7 & 3;
      h3.defaultPixelValue = u2 >> 9 & 1;
      h3.dsOffset = u2 << 17 >> 27;
      h3.refinementTemplate = u2 >> 15 & 1;
      if (h3.huffman) {
        const e4 = readUint16(r2, l2);
        l2 += 2;
        h3.huffmanFS = 3 & e4;
        h3.huffmanDS = e4 >> 2 & 3;
        h3.huffmanDT = e4 >> 4 & 3;
        h3.huffmanRefinementDW = e4 >> 6 & 3;
        h3.huffmanRefinementDH = e4 >> 8 & 3;
        h3.huffmanRefinementDX = e4 >> 10 & 3;
        h3.huffmanRefinementDY = e4 >> 12 & 3;
        h3.huffmanRefinementSizeSelector = !!(16384 & e4);
      }
      if (h3.refinement && !h3.refinementTemplate) {
        s2 = [];
        for (o2 = 0; o2 < 2; o2++) {
          s2.push({ x: readInt8(r2, l2), y: readInt8(r2, l2 + 1) });
          l2 += 2;
        }
        h3.refinementAt = s2;
      }
      h3.numberOfSymbolInstances = readUint32(r2, l2);
      l2 += 4;
      n2 = [h3, a2.referredTo, r2, l2, i2];
      break;
    case 16:
      const d2 = {}, f2 = r2[l2++];
      d2.mmr = !!(1 & f2);
      d2.template = f2 >> 1 & 3;
      d2.patternWidth = r2[l2++];
      d2.patternHeight = r2[l2++];
      d2.maxPatternIndex = readUint32(r2, l2);
      l2 += 4;
      n2 = [d2, a2.number, r2, l2, i2];
      break;
    case 22:
    case 23:
      const g2 = {};
      g2.info = readRegionSegmentInformation(r2, l2);
      l2 += gr;
      const p2 = r2[l2++];
      g2.mmr = !!(1 & p2);
      g2.template = p2 >> 1 & 3;
      g2.enableSkip = !!(8 & p2);
      g2.combinationOperator = p2 >> 4 & 7;
      g2.defaultPixelValue = p2 >> 7 & 1;
      g2.gridWidth = readUint32(r2, l2);
      l2 += 4;
      g2.gridHeight = readUint32(r2, l2);
      l2 += 4;
      g2.gridOffsetX = 4294967295 & readUint32(r2, l2);
      l2 += 4;
      g2.gridOffsetY = 4294967295 & readUint32(r2, l2);
      l2 += 4;
      g2.gridVectorX = readUint16(r2, l2);
      l2 += 2;
      g2.gridVectorY = readUint16(r2, l2);
      l2 += 2;
      n2 = [g2, a2.referredTo, r2, l2, i2];
      break;
    case 38:
    case 39:
      const m2 = {};
      m2.info = readRegionSegmentInformation(r2, l2);
      l2 += gr;
      const b2 = r2[l2++];
      m2.mmr = !!(1 & b2);
      m2.template = b2 >> 1 & 3;
      m2.prediction = !!(8 & b2);
      if (!m2.mmr) {
        c2 = 0 === m2.template ? 4 : 1;
        s2 = [];
        for (o2 = 0; o2 < c2; o2++) {
          s2.push({ x: readInt8(r2, l2), y: readInt8(r2, l2 + 1) });
          l2 += 2;
        }
        m2.at = s2;
      }
      n2 = [m2, r2, l2, i2];
      break;
    case 48:
      const y2 = { width: readUint32(r2, l2), height: readUint32(r2, l2 + 4), resolutionX: readUint32(r2, l2 + 8), resolutionY: readUint32(r2, l2 + 12) };
      4294967295 === y2.height && delete y2.height;
      const w2 = r2[l2 + 16];
      readUint16(r2, l2 + 17);
      y2.lossless = !!(1 & w2);
      y2.refinement = !!(2 & w2);
      y2.defaultPixelValue = w2 >> 2 & 1;
      y2.combinationOperator = w2 >> 3 & 3;
      y2.requiresBuffer = !!(32 & w2);
      y2.combinationOperatorOverride = !!(64 & w2);
      n2 = [y2];
      break;
    case 49:
    case 50:
    case 51:
    case 62:
      break;
    case 53:
      n2 = [a2.number, r2, l2, i2];
      break;
    default:
      throw new Jbig2Error(`segment type ${a2.typeName}(${a2.type}) is not implemented`);
  }
  const h2 = "on" + a2.typeName;
  h2 in t2 && t2[h2].apply(t2, n2);
}
function processSegments(e2, t2) {
  for (let a2 = 0, r2 = e2.length; a2 < r2; a2++) processSegment(e2[a2], t2);
}
var SimpleSegmentVisitor = class {
  onPageInformation(e2) {
    this.currentPageInfo = e2;
    const t2 = e2.width + 7 >> 3, a2 = new Uint8ClampedArray(t2 * e2.height);
    e2.defaultPixelValue && a2.fill(255);
    this.buffer = a2;
  }
  drawBitmap(e2, t2) {
    const a2 = this.currentPageInfo, r2 = e2.width, i2 = e2.height, n2 = a2.width + 7 >> 3, s2 = a2.combinationOperatorOverride ? e2.combinationOperator : a2.combinationOperator, o2 = this.buffer, c2 = 128 >> (7 & e2.x);
    let l2, h2, u2, d2, f2 = e2.y * n2 + (e2.x >> 3);
    switch (s2) {
      case 0:
        for (l2 = 0; l2 < i2; l2++) {
          u2 = c2;
          d2 = f2;
          for (h2 = 0; h2 < r2; h2++) {
            t2[l2][h2] && (o2[d2] |= u2);
            u2 >>= 1;
            if (!u2) {
              u2 = 128;
              d2++;
            }
          }
          f2 += n2;
        }
        break;
      case 2:
        for (l2 = 0; l2 < i2; l2++) {
          u2 = c2;
          d2 = f2;
          for (h2 = 0; h2 < r2; h2++) {
            t2[l2][h2] && (o2[d2] ^= u2);
            u2 >>= 1;
            if (!u2) {
              u2 = 128;
              d2++;
            }
          }
          f2 += n2;
        }
        break;
      default:
        throw new Jbig2Error(`operator ${s2} is not supported`);
    }
  }
  onImmediateGenericRegion(e2, t2, a2, r2) {
    const i2 = e2.info, n2 = new DecodingContext(t2, a2, r2), s2 = decodeBitmap(e2.mmr, i2.width, i2.height, e2.template, e2.prediction, null, e2.at, n2);
    this.drawBitmap(i2, s2);
  }
  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion(...arguments);
  }
  onSymbolDictionary(e2, t2, a2, r2, i2, n2) {
    let s2, o2;
    if (e2.huffman) {
      s2 = (function getSymbolDictionaryHuffmanTables(e3, t3, a3) {
        let r3, i3, n3, s3, o3 = 0;
        switch (e3.huffmanDHSelector) {
          case 0:
          case 1:
            r3 = getStandardTable(e3.huffmanDHSelector + 4);
            break;
          case 3:
            r3 = getCustomHuffmanTable(o3, t3, a3);
            o3++;
            break;
          default:
            throw new Jbig2Error("invalid Huffman DH selector");
        }
        switch (e3.huffmanDWSelector) {
          case 0:
          case 1:
            i3 = getStandardTable(e3.huffmanDWSelector + 2);
            break;
          case 3:
            i3 = getCustomHuffmanTable(o3, t3, a3);
            o3++;
            break;
          default:
            throw new Jbig2Error("invalid Huffman DW selector");
        }
        if (e3.bitmapSizeSelector) {
          n3 = getCustomHuffmanTable(o3, t3, a3);
          o3++;
        } else n3 = getStandardTable(1);
        s3 = e3.aggregationInstancesSelector ? getCustomHuffmanTable(o3, t3, a3) : getStandardTable(1);
        return { tableDeltaHeight: r3, tableDeltaWidth: i3, tableBitmapSize: n3, tableAggregateInstances: s3 };
      })(e2, a2, this.customTables);
      o2 = new Reader(r2, i2, n2);
    }
    let c2 = this.symbols;
    c2 || (this.symbols = c2 = {});
    const l2 = [];
    for (const e3 of a2) {
      const t3 = c2[e3];
      t3 && l2.push(...t3);
    }
    const h2 = new DecodingContext(r2, i2, n2);
    c2[t2] = (function decodeSymbolDictionary(e3, t3, a3, r3, i3, n3, s3, o3, c3, l3, h3, u2) {
      if (e3 && t3) throw new Jbig2Error("symbol refinement with Huffman is not supported");
      const d2 = [];
      let f2 = 0, g2 = log2(a3.length + r3);
      const p2 = h3.decoder, m2 = h3.contextCache;
      let b2, y2;
      if (e3) {
        b2 = getStandardTable(1);
        y2 = [];
        g2 = Math.max(g2, 1);
      }
      for (; d2.length < r3; ) {
        f2 += e3 ? n3.tableDeltaHeight.decode(u2) : decodeInteger(m2, "IADH", p2);
        let r4 = 0, i4 = 0;
        const b3 = e3 ? y2.length : 0;
        for (; ; ) {
          const b4 = e3 ? n3.tableDeltaWidth.decode(u2) : decodeInteger(m2, "IADW", p2);
          if (null === b4) break;
          r4 += b4;
          i4 += r4;
          let w3;
          if (t3) {
            const i5 = decodeInteger(m2, "IAAI", p2);
            if (i5 > 1) w3 = decodeTextRegion(e3, t3, r4, f2, 0, i5, 1, a3.concat(d2), g2, 0, 0, 1, 0, n3, c3, l3, h3, 0, u2);
            else {
              const e4 = decodeIAID(m2, p2, g2), t4 = decodeInteger(m2, "IARDX", p2), i6 = decodeInteger(m2, "IARDY", p2);
              w3 = decodeRefinement(r4, f2, c3, e4 < a3.length ? a3[e4] : d2[e4 - a3.length], t4, i6, false, l3, h3);
            }
            d2.push(w3);
          } else if (e3) y2.push(r4);
          else {
            w3 = decodeBitmap(false, r4, f2, s3, false, null, o3, h3);
            d2.push(w3);
          }
        }
        if (e3 && !t3) {
          const e4 = n3.tableBitmapSize.decode(u2);
          u2.byteAlign();
          let t4;
          if (0 === e4) t4 = readUncompressedBitmap(u2, i4, f2);
          else {
            const a5 = u2.end, r5 = u2.position + e4;
            u2.end = r5;
            t4 = decodeMMRBitmap(u2, i4, f2, false);
            u2.end = a5;
            u2.position = r5;
          }
          const a4 = y2.length;
          if (b3 === a4 - 1) d2.push(t4);
          else {
            let e5, r5, i5, n4, s4, o4 = 0;
            for (e5 = b3; e5 < a4; e5++) {
              n4 = y2[e5];
              i5 = o4 + n4;
              s4 = [];
              for (r5 = 0; r5 < f2; r5++) s4.push(t4[r5].subarray(o4, i5));
              d2.push(s4);
              o4 = i5;
            }
          }
        }
      }
      const w2 = [], x2 = [];
      let S2, k2, C2 = false;
      const v2 = a3.length + r3;
      for (; x2.length < v2; ) {
        let t4 = e3 ? b2.decode(u2) : decodeInteger(m2, "IAEX", p2);
        for (; t4--; ) x2.push(C2);
        C2 = !C2;
      }
      for (S2 = 0, k2 = a3.length; S2 < k2; S2++) x2[S2] && w2.push(a3[S2]);
      for (let e4 = 0; e4 < r3; S2++, e4++) x2[S2] && w2.push(d2[e4]);
      return w2;
    })(e2.huffman, e2.refinement, l2, e2.numberOfNewSymbols, e2.numberOfExportedSymbols, s2, e2.template, e2.at, e2.refinementTemplate, e2.refinementAt, h2, o2);
  }
  onImmediateTextRegion(e2, t2, a2, r2, i2) {
    const n2 = e2.info;
    let s2, o2;
    const c2 = this.symbols, l2 = [];
    for (const e3 of t2) {
      const t3 = c2[e3];
      t3 && l2.push(...t3);
    }
    const h2 = log2(l2.length);
    if (e2.huffman) {
      o2 = new Reader(a2, r2, i2);
      s2 = (function getTextRegionHuffmanTables(e3, t3, a3, r3, i3) {
        const n3 = [];
        for (let e4 = 0; e4 <= 34; e4++) {
          const t4 = i3.readBits(4);
          n3.push(new HuffmanLine([e4, t4, 0, 0]));
        }
        const s3 = new HuffmanTable(n3, false);
        n3.length = 0;
        for (let e4 = 0; e4 < r3; ) {
          const t4 = s3.decode(i3);
          if (t4 >= 32) {
            let a4, r4, s4;
            switch (t4) {
              case 32:
                if (0 === e4) throw new Jbig2Error("no previous value in symbol ID table");
                r4 = i3.readBits(2) + 3;
                a4 = n3[e4 - 1].prefixLength;
                break;
              case 33:
                r4 = i3.readBits(3) + 3;
                a4 = 0;
                break;
              case 34:
                r4 = i3.readBits(7) + 11;
                a4 = 0;
                break;
              default:
                throw new Jbig2Error("invalid code length in symbol ID table");
            }
            for (s4 = 0; s4 < r4; s4++) {
              n3.push(new HuffmanLine([e4, a4, 0, 0]));
              e4++;
            }
          } else {
            n3.push(new HuffmanLine([e4, t4, 0, 0]));
            e4++;
          }
        }
        i3.byteAlign();
        const o3 = new HuffmanTable(n3, false);
        let c3, l3, h3, u3 = 0;
        switch (e3.huffmanFS) {
          case 0:
          case 1:
            c3 = getStandardTable(e3.huffmanFS + 6);
            break;
          case 3:
            c3 = getCustomHuffmanTable(u3, t3, a3);
            u3++;
            break;
          default:
            throw new Jbig2Error("invalid Huffman FS selector");
        }
        switch (e3.huffmanDS) {
          case 0:
          case 1:
          case 2:
            l3 = getStandardTable(e3.huffmanDS + 8);
            break;
          case 3:
            l3 = getCustomHuffmanTable(u3, t3, a3);
            u3++;
            break;
          default:
            throw new Jbig2Error("invalid Huffman DS selector");
        }
        switch (e3.huffmanDT) {
          case 0:
          case 1:
          case 2:
            h3 = getStandardTable(e3.huffmanDT + 11);
            break;
          case 3:
            h3 = getCustomHuffmanTable(u3, t3, a3);
            u3++;
            break;
          default:
            throw new Jbig2Error("invalid Huffman DT selector");
        }
        if (e3.refinement) throw new Jbig2Error("refinement with Huffman is not supported");
        return { symbolIDTable: o3, tableFirstS: c3, tableDeltaS: l3, tableDeltaT: h3 };
      })(e2, t2, this.customTables, l2.length, o2);
    }
    const u2 = new DecodingContext(a2, r2, i2), d2 = decodeTextRegion(e2.huffman, e2.refinement, n2.width, n2.height, e2.defaultPixelValue, e2.numberOfSymbolInstances, e2.stripSize, l2, h2, e2.transposed, e2.dsOffset, e2.referenceCorner, e2.combinationOperator, s2, e2.refinementTemplate, e2.refinementAt, u2, e2.logStripSize, o2);
    this.drawBitmap(n2, d2);
  }
  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion(...arguments);
  }
  onPatternDictionary(e2, t2, a2, r2, i2) {
    let n2 = this.patterns;
    n2 || (this.patterns = n2 = {});
    const s2 = new DecodingContext(a2, r2, i2);
    n2[t2] = (function decodePatternDictionary(e3, t3, a3, r3, i3, n3) {
      const s3 = [];
      if (!e3) {
        s3.push({ x: -t3, y: 0 });
        0 === i3 && s3.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 });
      }
      const o2 = decodeBitmap(e3, (r3 + 1) * t3, a3, i3, false, null, s3, n3), c2 = [];
      for (let e4 = 0; e4 <= r3; e4++) {
        const r4 = [], i4 = t3 * e4, n4 = i4 + t3;
        for (let e5 = 0; e5 < a3; e5++) r4.push(o2[e5].subarray(i4, n4));
        c2.push(r4);
      }
      return c2;
    })(e2.mmr, e2.patternWidth, e2.patternHeight, e2.maxPatternIndex, e2.template, s2);
  }
  onImmediateHalftoneRegion(e2, t2, a2, r2, i2) {
    const n2 = this.patterns[t2[0]], s2 = e2.info, o2 = new DecodingContext(a2, r2, i2), c2 = (function decodeHalftoneRegion(e3, t3, a3, r3, i3, n3, s3, o3, c3, l2, h2, u2, d2, f2, g2) {
      if (s3) throw new Jbig2Error("skip is not supported");
      if (0 !== o3) throw new Jbig2Error(`operator "${o3}" is not supported in halftone region`);
      const p2 = [];
      let m2, b2, y2;
      for (m2 = 0; m2 < i3; m2++) {
        y2 = new Uint8Array(r3);
        n3 && y2.fill(n3);
        p2.push(y2);
      }
      const w2 = t3.length, x2 = t3[0], S2 = x2[0].length, k2 = x2.length, C2 = log2(w2), v2 = [];
      if (!e3) {
        v2.push({ x: a3 <= 1 ? 3 : 2, y: -1 });
        0 === a3 && v2.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 });
      }
      const F2 = [];
      let T2, O2, M2, D2, R2, N2, E2, L2, j2, _2, U2;
      e3 && (T2 = new Reader(g2.data, g2.start, g2.end));
      for (m2 = C2 - 1; m2 >= 0; m2--) {
        O2 = e3 ? decodeMMRBitmap(T2, c3, l2, true) : decodeBitmap(false, c3, l2, a3, false, null, v2, g2);
        F2[m2] = O2;
      }
      for (M2 = 0; M2 < l2; M2++) for (D2 = 0; D2 < c3; D2++) {
        R2 = 0;
        N2 = 0;
        for (b2 = C2 - 1; b2 >= 0; b2--) {
          R2 ^= F2[b2][M2][D2];
          N2 |= R2 << b2;
        }
        E2 = t3[N2];
        L2 = h2 + M2 * f2 + D2 * d2 >> 8;
        j2 = u2 + M2 * d2 - D2 * f2 >> 8;
        if (L2 >= 0 && L2 + S2 <= r3 && j2 >= 0 && j2 + k2 <= i3) for (m2 = 0; m2 < k2; m2++) {
          U2 = p2[j2 + m2];
          _2 = E2[m2];
          for (b2 = 0; b2 < S2; b2++) U2[L2 + b2] |= _2[b2];
        }
        else {
          let e4, t4;
          for (m2 = 0; m2 < k2; m2++) {
            t4 = j2 + m2;
            if (!(t4 < 0 || t4 >= i3)) {
              U2 = p2[t4];
              _2 = E2[m2];
              for (b2 = 0; b2 < S2; b2++) {
                e4 = L2 + b2;
                e4 >= 0 && e4 < r3 && (U2[e4] |= _2[b2]);
              }
            }
          }
        }
      }
      return p2;
    })(e2.mmr, n2, e2.template, s2.width, s2.height, e2.defaultPixelValue, e2.enableSkip, e2.combinationOperator, e2.gridWidth, e2.gridHeight, e2.gridOffsetX, e2.gridOffsetY, e2.gridVectorX, e2.gridVectorY, o2);
    this.drawBitmap(s2, c2);
  }
  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion(...arguments);
  }
  onTables(e2, t2, a2, r2) {
    let i2 = this.customTables;
    i2 || (this.customTables = i2 = {});
    i2[e2] = (function decodeTablesSegment(e3, t3, a3) {
      const r3 = e3[t3], i3 = 4294967295 & readUint32(e3, t3 + 1), n2 = 4294967295 & readUint32(e3, t3 + 5), s2 = new Reader(e3, t3 + 9, a3), o2 = 1 + (r3 >> 1 & 7), c2 = 1 + (r3 >> 4 & 7), l2 = [];
      let h2, u2, d2 = i3;
      do {
        h2 = s2.readBits(o2);
        u2 = s2.readBits(c2);
        l2.push(new HuffmanLine([d2, h2, u2, 0]));
        d2 += 1 << u2;
      } while (d2 < n2);
      h2 = s2.readBits(o2);
      l2.push(new HuffmanLine([i3 - 1, h2, 32, 0, "lower"]));
      h2 = s2.readBits(o2);
      l2.push(new HuffmanLine([n2, h2, 32, 0]));
      if (1 & r3) {
        h2 = s2.readBits(o2);
        l2.push(new HuffmanLine([h2, 0]));
      }
      return new HuffmanTable(l2, false);
    })(t2, a2, r2);
  }
};
var HuffmanLine = class {
  constructor(e2) {
    if (2 === e2.length) {
      this.isOOB = true;
      this.rangeLow = 0;
      this.prefixLength = e2[0];
      this.rangeLength = 0;
      this.prefixCode = e2[1];
      this.isLowerRange = false;
    } else {
      this.isOOB = false;
      this.rangeLow = e2[0];
      this.prefixLength = e2[1];
      this.rangeLength = e2[2];
      this.prefixCode = e2[3];
      this.isLowerRange = "lower" === e2[4];
    }
  }
};
var HuffmanTreeNode = class _HuffmanTreeNode {
  constructor(e2) {
    this.children = [];
    if (e2) {
      this.isLeaf = true;
      this.rangeLength = e2.rangeLength;
      this.rangeLow = e2.rangeLow;
      this.isLowerRange = e2.isLowerRange;
      this.isOOB = e2.isOOB;
    } else this.isLeaf = false;
  }
  buildTree(e2, t2) {
    const a2 = e2.prefixCode >> t2 & 1;
    if (t2 <= 0) this.children[a2] = new _HuffmanTreeNode(e2);
    else {
      let r2 = this.children[a2];
      r2 || (this.children[a2] = r2 = new _HuffmanTreeNode(null));
      r2.buildTree(e2, t2 - 1);
    }
  }
  decodeNode(e2) {
    if (this.isLeaf) {
      if (this.isOOB) return null;
      const t3 = e2.readBits(this.rangeLength);
      return this.rangeLow + (this.isLowerRange ? -t3 : t3);
    }
    const t2 = this.children[e2.readBit()];
    if (!t2) throw new Jbig2Error("invalid Huffman data");
    return t2.decodeNode(e2);
  }
};
var HuffmanTable = class {
  constructor(e2, t2) {
    t2 || this.assignPrefixCodes(e2);
    this.rootNode = new HuffmanTreeNode(null);
    for (let t3 = 0, a2 = e2.length; t3 < a2; t3++) {
      const a3 = e2[t3];
      a3.prefixLength > 0 && this.rootNode.buildTree(a3, a3.prefixLength - 1);
    }
  }
  decode(e2) {
    return this.rootNode.decodeNode(e2);
  }
  assignPrefixCodes(e2) {
    const t2 = e2.length;
    let a2 = 0;
    for (let r3 = 0; r3 < t2; r3++) a2 = Math.max(a2, e2[r3].prefixLength);
    const r2 = new Uint32Array(a2 + 1);
    for (let a3 = 0; a3 < t2; a3++) r2[e2[a3].prefixLength]++;
    let i2, n2, s2, o2 = 1, c2 = 0;
    r2[0] = 0;
    for (; o2 <= a2; ) {
      c2 = c2 + r2[o2 - 1] << 1;
      i2 = c2;
      n2 = 0;
      for (; n2 < t2; ) {
        s2 = e2[n2];
        if (s2.prefixLength === o2) {
          s2.prefixCode = i2;
          i2++;
        }
        n2++;
      }
      o2++;
    }
  }
};
var pr = {};
function getStandardTable(e2) {
  let t2, a2 = pr[e2];
  if (a2) return a2;
  switch (e2) {
    case 1:
      t2 = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
      break;
    case 2:
      t2 = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
      break;
    case 3:
      t2 = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
      break;
    case 4:
      t2 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
      break;
    case 5:
      t2 = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
      break;
    case 6:
      t2 = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
      break;
    case 7:
      t2 = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
      break;
    case 8:
      t2 = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
      break;
    case 9:
      t2 = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
      break;
    case 10:
      t2 = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
      break;
    case 11:
      t2 = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 12:
      t2 = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
      break;
    case 13:
      t2 = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 14:
      t2 = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      t2 = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
      break;
    default:
      throw new Jbig2Error(`standard table B.${e2} does not exist`);
  }
  for (let e3 = 0, a3 = t2.length; e3 < a3; e3++) t2[e3] = new HuffmanLine(t2[e3]);
  a2 = new HuffmanTable(t2, true);
  pr[e2] = a2;
  return a2;
}
var Reader = class {
  constructor(e2, t2, a2) {
    this.data = e2;
    this.start = t2;
    this.end = a2;
    this.position = t2;
    this.shift = -1;
    this.currentByte = 0;
  }
  readBit() {
    if (this.shift < 0) {
      if (this.position >= this.end) throw new Jbig2Error("end of data while reading bit");
      this.currentByte = this.data[this.position++];
      this.shift = 7;
    }
    const e2 = this.currentByte >> this.shift & 1;
    this.shift--;
    return e2;
  }
  readBits(e2) {
    let t2, a2 = 0;
    for (t2 = e2 - 1; t2 >= 0; t2--) a2 |= this.readBit() << t2;
    return a2;
  }
  byteAlign() {
    this.shift = -1;
  }
  next() {
    return this.position >= this.end ? -1 : this.data[this.position++];
  }
};
function getCustomHuffmanTable(e2, t2, a2) {
  let r2 = 0;
  for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) {
    const n3 = a2[t2[i2]];
    if (n3) {
      if (e2 === r2) return n3;
      r2++;
    }
  }
  throw new Jbig2Error("can't find custom Huffman table");
}
function readUncompressedBitmap(e2, t2, a2) {
  const r2 = [];
  for (let i2 = 0; i2 < a2; i2++) {
    const a3 = new Uint8Array(t2);
    r2.push(a3);
    for (let r3 = 0; r3 < t2; r3++) a3[r3] = e2.readBit();
    e2.byteAlign();
  }
  return r2;
}
function decodeMMRBitmap(e2, t2, a2, r2) {
  const i2 = new CCITTFaxDecoder(e2, { K: -1, Columns: t2, Rows: a2, BlackIs1: true, EndOfBlock: r2 }), n2 = [];
  let s2, o2 = false;
  for (let e3 = 0; e3 < a2; e3++) {
    const e4 = new Uint8Array(t2);
    n2.push(e4);
    let a3 = -1;
    for (let r3 = 0; r3 < t2; r3++) {
      if (a3 < 0) {
        s2 = i2.readNextChar();
        if (-1 === s2) {
          s2 = 0;
          o2 = true;
        }
        a3 = 7;
      }
      e4[r3] = s2 >> a3 & 1;
      a3--;
    }
  }
  if (r2 && !o2) {
    const e3 = 5;
    for (let t3 = 0; t3 < e3 && -1 !== i2.readNextChar(); t3++) ;
  }
  return n2;
}
var Jbig2Image = class {
  parseChunks(e2) {
    return (function parseJbig2Chunks(e3) {
      const t2 = new SimpleSegmentVisitor();
      for (let a2 = 0, r2 = e3.length; a2 < r2; a2++) {
        const r3 = e3[a2];
        processSegments(readSegments({}, r3.data, r3.start, r3.end), t2);
      }
      return t2.buffer;
    })(e2);
  }
  parse(e2) {
    throw new Error("Not implemented: Jbig2Image.parse");
  }
};
var Jbig2Stream = class extends DecodeStream {
  constructor(e2, t2, a2) {
    super(t2);
    this.stream = e2;
    this.dict = e2.dict;
    this.maybeLength = t2;
    this.params = a2;
  }
  get bytes() {
    return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e2) {
  }
  readBlock() {
    this.decodeImage();
  }
  decodeImage(e2) {
    if (this.eof) return this.buffer;
    e2 ||= this.bytes;
    const t2 = new Jbig2Image(), a2 = [];
    if (this.params instanceof Dict) {
      const e3 = this.params.get("JBIG2Globals");
      if (e3 instanceof BaseStream) {
        const t3 = e3.getBytes();
        a2.push({ data: t3, start: 0, end: t3.length });
      }
    }
    a2.push({ data: e2, start: 0, end: e2.length });
    const r2 = t2.parseChunks(a2), i2 = r2.length;
    for (let e3 = 0; e3 < i2; e3++) r2[e3] ^= 255;
    this.buffer = r2;
    this.bufferLength = i2;
    this.eof = true;
    return this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
};
var JpxStream = class extends DecodeStream {
  constructor(e2, t2, a2) {
    super(t2);
    this.stream = e2;
    this.dict = e2.dict;
    this.maybeLength = t2;
    this.params = a2;
  }
  get bytes() {
    return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e2) {
  }
  readBlock(e2) {
    unreachable("JpxStream.readBlock");
  }
  get isAsyncDecoder() {
    return true;
  }
  async decodeImage(e2, t2) {
    if (this.eof) return this.buffer;
    e2 ||= this.bytes;
    this.buffer = await JpxImage.decode(e2, t2);
    this.bufferLength = this.buffer.length;
    this.eof = true;
    return this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
};
var LZWStream = class extends DecodeStream {
  constructor(e2, t2, a2) {
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    this.cachedData = 0;
    this.bitsCached = 0;
    const r2 = 4096, i2 = { earlyChange: a2, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(r2), dictionaryLengths: new Uint16Array(r2), dictionaryPrevCodes: new Uint16Array(r2), currentSequence: new Uint8Array(r2), currentSequenceLength: 0 };
    for (let e3 = 0; e3 < 256; ++e3) {
      i2.dictionaryValues[e3] = e3;
      i2.dictionaryLengths[e3] = 1;
    }
    this.lzwState = i2;
  }
  readBits(e2) {
    let t2 = this.bitsCached, a2 = this.cachedData;
    for (; t2 < e2; ) {
      const e3 = this.str.getByte();
      if (-1 === e3) {
        this.eof = true;
        return null;
      }
      a2 = a2 << 8 | e3;
      t2 += 8;
    }
    this.bitsCached = t2 -= e2;
    this.cachedData = a2;
    this.lastCode = null;
    return a2 >>> t2 & (1 << e2) - 1;
  }
  readBlock() {
    let e2, t2, a2, r2 = 1024;
    const i2 = this.lzwState;
    if (!i2) return;
    const n2 = i2.earlyChange;
    let s2 = i2.nextCode;
    const o2 = i2.dictionaryValues, c2 = i2.dictionaryLengths, l2 = i2.dictionaryPrevCodes;
    let h2 = i2.codeLength, u2 = i2.prevCode;
    const d2 = i2.currentSequence;
    let f2 = i2.currentSequenceLength, g2 = 0, p2 = this.bufferLength, m2 = this.ensureBuffer(this.bufferLength + r2);
    for (e2 = 0; e2 < 512; e2++) {
      const e3 = this.readBits(h2), i3 = f2 > 0;
      if (e3 < 256) {
        d2[0] = e3;
        f2 = 1;
      } else {
        if (!(e3 >= 258)) {
          if (256 === e3) {
            h2 = 9;
            s2 = 258;
            f2 = 0;
            continue;
          }
          this.eof = true;
          delete this.lzwState;
          break;
        }
        if (e3 < s2) {
          f2 = c2[e3];
          for (t2 = f2 - 1, a2 = e3; t2 >= 0; t2--) {
            d2[t2] = o2[a2];
            a2 = l2[a2];
          }
        } else d2[f2++] = d2[0];
      }
      if (i3) {
        l2[s2] = u2;
        c2[s2] = c2[u2] + 1;
        o2[s2] = d2[0];
        s2++;
        h2 = s2 + n2 & s2 + n2 - 1 ? h2 : 0 | Math.min(Math.log(s2 + n2) / 0.6931471805599453 + 1, 12);
      }
      u2 = e3;
      g2 += f2;
      if (r2 < g2) {
        do {
          r2 += 512;
        } while (r2 < g2);
        m2 = this.ensureBuffer(this.bufferLength + r2);
      }
      for (t2 = 0; t2 < f2; t2++) m2[p2++] = d2[t2];
    }
    i2.nextCode = s2;
    i2.codeLength = h2;
    i2.prevCode = u2;
    i2.currentSequenceLength = f2;
    this.bufferLength = p2;
  }
};
var PredictorStream = class extends DecodeStream {
  constructor(e2, t2, a2) {
    super(t2);
    if (!(a2 instanceof Dict)) return e2;
    const r2 = this.predictor = a2.get("Predictor") || 1;
    if (r2 <= 1) return e2;
    if (2 !== r2 && (r2 < 10 || r2 > 15)) throw new FormatError(`Unsupported predictor: ${r2}`);
    this.readBlock = 2 === r2 ? this.readBlockTiff : this.readBlockPng;
    this.str = e2;
    this.dict = e2.dict;
    const i2 = this.colors = a2.get("Colors") || 1, n2 = this.bits = a2.get("BPC", "BitsPerComponent") || 8, s2 = this.columns = a2.get("Columns") || 1;
    this.pixBytes = i2 * n2 + 7 >> 3;
    this.rowBytes = s2 * i2 * n2 + 7 >> 3;
    return this;
  }
  readBlockTiff() {
    const e2 = this.rowBytes, t2 = this.bufferLength, a2 = this.ensureBuffer(t2 + e2), r2 = this.bits, i2 = this.colors, n2 = this.str.getBytes(e2);
    this.eof = !n2.length;
    if (this.eof) return;
    let s2, o2 = 0, c2 = 0, l2 = 0, h2 = 0, u2 = t2;
    if (1 === r2 && 1 === i2) for (s2 = 0; s2 < e2; ++s2) {
      let e3 = n2[s2] ^ o2;
      e3 ^= e3 >> 1;
      e3 ^= e3 >> 2;
      e3 ^= e3 >> 4;
      o2 = (1 & e3) << 7;
      a2[u2++] = e3;
    }
    else if (8 === r2) {
      for (s2 = 0; s2 < i2; ++s2) a2[u2++] = n2[s2];
      for (; s2 < e2; ++s2) {
        a2[u2] = a2[u2 - i2] + n2[s2];
        u2++;
      }
    } else if (16 === r2) {
      const t3 = 2 * i2;
      for (s2 = 0; s2 < t3; ++s2) a2[u2++] = n2[s2];
      for (; s2 < e2; s2 += 2) {
        const e3 = ((255 & n2[s2]) << 8) + (255 & n2[s2 + 1]) + ((255 & a2[u2 - t3]) << 8) + (255 & a2[u2 - t3 + 1]);
        a2[u2++] = e3 >> 8 & 255;
        a2[u2++] = 255 & e3;
      }
    } else {
      const e3 = new Uint8Array(i2 + 1), u3 = (1 << r2) - 1;
      let d2 = 0, f2 = t2;
      const g2 = this.columns;
      for (s2 = 0; s2 < g2; ++s2) for (let t3 = 0; t3 < i2; ++t3) {
        if (l2 < r2) {
          o2 = o2 << 8 | 255 & n2[d2++];
          l2 += 8;
        }
        e3[t3] = e3[t3] + (o2 >> l2 - r2) & u3;
        l2 -= r2;
        c2 = c2 << r2 | e3[t3];
        h2 += r2;
        if (h2 >= 8) {
          a2[f2++] = c2 >> h2 - 8 & 255;
          h2 -= 8;
        }
      }
      h2 > 0 && (a2[f2++] = (c2 << 8 - h2) + (o2 & (1 << 8 - h2) - 1));
    }
    this.bufferLength += e2;
  }
  readBlockPng() {
    const e2 = this.rowBytes, t2 = this.pixBytes, a2 = this.str.getByte(), r2 = this.str.getBytes(e2);
    this.eof = !r2.length;
    if (this.eof) return;
    const i2 = this.bufferLength, n2 = this.ensureBuffer(i2 + e2);
    let s2 = n2.subarray(i2 - e2, i2);
    0 === s2.length && (s2 = new Uint8Array(e2));
    let o2, c2, l2, h2 = i2;
    switch (a2) {
      case 0:
        for (o2 = 0; o2 < e2; ++o2) n2[h2++] = r2[o2];
        break;
      case 1:
        for (o2 = 0; o2 < t2; ++o2) n2[h2++] = r2[o2];
        for (; o2 < e2; ++o2) {
          n2[h2] = n2[h2 - t2] + r2[o2] & 255;
          h2++;
        }
        break;
      case 2:
        for (o2 = 0; o2 < e2; ++o2) n2[h2++] = s2[o2] + r2[o2] & 255;
        break;
      case 3:
        for (o2 = 0; o2 < t2; ++o2) n2[h2++] = (s2[o2] >> 1) + r2[o2];
        for (; o2 < e2; ++o2) {
          n2[h2] = (s2[o2] + n2[h2 - t2] >> 1) + r2[o2] & 255;
          h2++;
        }
        break;
      case 4:
        for (o2 = 0; o2 < t2; ++o2) {
          c2 = s2[o2];
          l2 = r2[o2];
          n2[h2++] = c2 + l2;
        }
        for (; o2 < e2; ++o2) {
          c2 = s2[o2];
          const e3 = s2[o2 - t2], a3 = n2[h2 - t2], i3 = a3 + c2 - e3;
          let u2 = i3 - a3;
          u2 < 0 && (u2 = -u2);
          let d2 = i3 - c2;
          d2 < 0 && (d2 = -d2);
          let f2 = i3 - e3;
          f2 < 0 && (f2 = -f2);
          l2 = r2[o2];
          n2[h2++] = u2 <= d2 && u2 <= f2 ? a3 + l2 : d2 <= f2 ? c2 + l2 : e3 + l2;
        }
        break;
      default:
        throw new FormatError(`Unsupported predictor: ${a2}`);
    }
    this.bufferLength += e2;
  }
};
var RunLengthStream = class extends DecodeStream {
  constructor(e2, t2) {
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
  }
  readBlock() {
    const e2 = this.str.getBytes(2);
    if (!e2 || e2.length < 2 || 128 === e2[0]) {
      this.eof = true;
      return;
    }
    let t2, a2 = this.bufferLength, r2 = e2[0];
    if (r2 < 128) {
      t2 = this.ensureBuffer(a2 + r2 + 1);
      t2[a2++] = e2[1];
      if (r2 > 0) {
        const e3 = this.str.getBytes(r2);
        t2.set(e3, a2);
        a2 += r2;
      }
    } else {
      r2 = 257 - r2;
      t2 = this.ensureBuffer(a2 + r2 + 1);
      t2.fill(e2[1], a2, a2 + r2);
      a2 += r2;
    }
    this.bufferLength = a2;
  }
};
var Parser = class {
  constructor({ lexer: e2, xref: t2, allowStreams: a2 = false, recoveryMode: r2 = false }) {
    this.lexer = e2;
    this.xref = t2;
    this.allowStreams = a2;
    this.recoveryMode = r2;
    this.imageCache = /* @__PURE__ */ Object.create(null);
    this._imageId = 0;
    this.refill();
  }
  refill() {
    this.buf1 = this.lexer.getObj();
    this.buf2 = this.lexer.getObj();
  }
  shift() {
    if (this.buf2 instanceof Cmd && "ID" === this.buf2.cmd) {
      this.buf1 = this.buf2;
      this.buf2 = null;
    } else {
      this.buf1 = this.buf2;
      this.buf2 = this.lexer.getObj();
    }
  }
  tryShift() {
    try {
      this.shift();
      return true;
    } catch (e2) {
      if (e2 instanceof MissingDataException) throw e2;
      return false;
    }
  }
  getObj(e2 = null) {
    const t2 = this.buf1;
    this.shift();
    if (t2 instanceof Cmd) switch (t2.cmd) {
      case "BI":
        return this.makeInlineImage(e2);
      case "[":
        const a2 = [];
        for (; !isCmd(this.buf1, "]") && this.buf1 !== wa; ) a2.push(this.getObj(e2));
        if (this.buf1 === wa) {
          if (this.recoveryMode) return a2;
          throw new ParserEOFException("End of file inside array.");
        }
        this.shift();
        return a2;
      case "<<":
        const r2 = new Dict(this.xref);
        for (; !isCmd(this.buf1, ">>") && this.buf1 !== wa; ) {
          if (!(this.buf1 instanceof Name)) {
            info("Malformed dictionary: key must be a name object");
            this.shift();
            continue;
          }
          const t3 = this.buf1.name;
          this.shift();
          if (this.buf1 === wa) break;
          r2.set(t3, this.getObj(e2));
        }
        if (this.buf1 === wa) {
          if (this.recoveryMode) return r2;
          throw new ParserEOFException("End of file inside dictionary.");
        }
        if (isCmd(this.buf2, "stream")) return this.allowStreams ? this.makeStream(r2, e2) : r2;
        this.shift();
        return r2;
      default:
        return t2;
    }
    if (Number.isInteger(t2)) {
      if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
        const e3 = Ref.get(t2, this.buf1);
        this.shift();
        this.shift();
        return e3;
      }
      return t2;
    }
    return "string" == typeof t2 && e2 ? e2.decryptString(t2) : t2;
  }
  findDefaultInlineStreamEnd(e2) {
    const { knownCommands: t2 } = this.lexer, a2 = e2.pos;
    let r2, i2, n2 = 0;
    for (; -1 !== (r2 = e2.getByte()); ) if (0 === n2) n2 = 69 === r2 ? 1 : 0;
    else if (1 === n2) n2 = 73 === r2 ? 2 : 0;
    else if (32 === r2 || 10 === r2 || 13 === r2) {
      i2 = e2.pos;
      const a3 = e2.peekBytes(15), s3 = a3.length;
      if (0 === s3) break;
      for (let e3 = 0; e3 < s3; e3++) {
        r2 = a3[e3];
        if ((0 !== r2 || 0 === a3[e3 + 1]) && (10 !== r2 && 13 !== r2 && (r2 < 32 || r2 > 127))) {
          n2 = 0;
          break;
        }
      }
      if (2 !== n2) continue;
      if (!t2) {
        warn("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
        continue;
      }
      const o2 = new Lexer(new Stream(e2.peekBytes(75)), t2);
      o2._hexStringWarn = () => {
      };
      let c2 = 0;
      for (; ; ) {
        const e3 = o2.getObj();
        if (e3 === wa) {
          n2 = 0;
          break;
        }
        if (e3 instanceof Cmd) {
          const a4 = t2[e3.cmd];
          if (!a4) {
            n2 = 0;
            break;
          }
          if (a4.variableArgs ? c2 <= a4.numArgs : c2 === a4.numArgs) break;
          c2 = 0;
        } else c2++;
      }
      if (2 === n2) break;
    } else n2 = 0;
    if (-1 === r2) {
      warn("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
      if (i2) {
        warn('... trying to recover by using the last "EI" occurrence.');
        e2.skip(-(e2.pos - i2));
      }
    }
    let s2 = 4;
    e2.skip(-s2);
    r2 = e2.peekByte();
    e2.skip(s2);
    isWhiteSpace(r2) || s2--;
    return e2.pos - s2 - a2;
  }
  findDCTDecodeInlineStreamEnd(e2) {
    const t2 = e2.pos;
    let a2, r2, i2 = false;
    for (; -1 !== (a2 = e2.getByte()); ) if (255 === a2) {
      switch (e2.getByte()) {
        case 0:
          break;
        case 255:
          e2.skip(-1);
          break;
        case 217:
          i2 = true;
          break;
        case 192:
        case 193:
        case 194:
        case 195:
        case 197:
        case 198:
        case 199:
        case 201:
        case 202:
        case 203:
        case 205:
        case 206:
        case 207:
        case 196:
        case 204:
        case 218:
        case 219:
        case 220:
        case 221:
        case 222:
        case 223:
        case 224:
        case 225:
        case 226:
        case 227:
        case 228:
        case 229:
        case 230:
        case 231:
        case 232:
        case 233:
        case 234:
        case 235:
        case 236:
        case 237:
        case 238:
        case 239:
        case 254:
          r2 = e2.getUint16();
          r2 > 2 ? e2.skip(r2 - 2) : e2.skip(-2);
      }
      if (i2) break;
    }
    const n2 = e2.pos - t2;
    if (-1 === a2) {
      warn("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
      e2.skip(-n2);
      return this.findDefaultInlineStreamEnd(e2);
    }
    this.inlineStreamSkipEI(e2);
    return n2;
  }
  findASCII85DecodeInlineStreamEnd(e2) {
    const t2 = e2.pos;
    let a2;
    for (; -1 !== (a2 = e2.getByte()); ) if (126 === a2) {
      const t3 = e2.pos;
      a2 = e2.peekByte();
      for (; isWhiteSpace(a2); ) {
        e2.skip();
        a2 = e2.peekByte();
      }
      if (62 === a2) {
        e2.skip();
        break;
      }
      if (e2.pos > t3) {
        const t4 = e2.peekBytes(2);
        if (69 === t4[0] && 73 === t4[1]) break;
      }
    }
    const r2 = e2.pos - t2;
    if (-1 === a2) {
      warn("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
      e2.skip(-r2);
      return this.findDefaultInlineStreamEnd(e2);
    }
    this.inlineStreamSkipEI(e2);
    return r2;
  }
  findASCIIHexDecodeInlineStreamEnd(e2) {
    const t2 = e2.pos;
    let a2;
    for (; -1 !== (a2 = e2.getByte()) && 62 !== a2; ) ;
    const r2 = e2.pos - t2;
    if (-1 === a2) {
      warn("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
      e2.skip(-r2);
      return this.findDefaultInlineStreamEnd(e2);
    }
    this.inlineStreamSkipEI(e2);
    return r2;
  }
  inlineStreamSkipEI(e2) {
    let t2, a2 = 0;
    for (; -1 !== (t2 = e2.getByte()); ) if (0 === a2) a2 = 69 === t2 ? 1 : 0;
    else if (1 === a2) a2 = 73 === t2 ? 2 : 0;
    else if (2 === a2) break;
  }
  makeInlineImage(e2) {
    const t2 = this.lexer, a2 = t2.stream, r2 = /* @__PURE__ */ Object.create(null);
    let i2;
    for (; !isCmd(this.buf1, "ID") && this.buf1 !== wa; ) {
      if (!(this.buf1 instanceof Name)) throw new FormatError("Dictionary key must be a name object");
      const t3 = this.buf1.name;
      this.shift();
      if (this.buf1 === wa) break;
      r2[t3] = this.getObj(e2);
    }
    -1 !== t2.beginInlineImagePos && (i2 = a2.pos - t2.beginInlineImagePos);
    const n2 = this.xref.fetchIfRef(r2.F || r2.Filter);
    let s2;
    if (n2 instanceof Name) s2 = n2.name;
    else if (Array.isArray(n2)) {
      const e3 = this.xref.fetchIfRef(n2[0]);
      e3 instanceof Name && (s2 = e3.name);
    }
    const o2 = a2.pos;
    let c2, l2;
    switch (s2) {
      case "DCT":
      case "DCTDecode":
        c2 = this.findDCTDecodeInlineStreamEnd(a2);
        break;
      case "A85":
      case "ASCII85Decode":
        c2 = this.findASCII85DecodeInlineStreamEnd(a2);
        break;
      case "AHx":
      case "ASCIIHexDecode":
        c2 = this.findASCIIHexDecodeInlineStreamEnd(a2);
        break;
      default:
        c2 = this.findDefaultInlineStreamEnd(a2);
    }
    if (c2 < 1e3 && i2 > 0) {
      const e3 = a2.pos;
      a2.pos = t2.beginInlineImagePos;
      l2 = (function getInlineImageCacheKey(e4) {
        const t3 = [], a3 = e4.length;
        let r4 = 0;
        for (; r4 < a3 - 1; ) t3.push(e4[r4++] << 8 | e4[r4++]);
        r4 < a3 && t3.push(e4[r4]);
        return a3 + "_" + String.fromCharCode.apply(null, t3);
      })(a2.getBytes(i2 + c2));
      a2.pos = e3;
      const r3 = this.imageCache[l2];
      if (void 0 !== r3) {
        this.buf2 = Cmd.get("EI");
        this.shift();
        r3.reset();
        return r3;
      }
    }
    const h2 = new Dict(this.xref);
    for (const e3 in r2) h2.set(e3, r2[e3]);
    let u2 = a2.makeSubStream(o2, c2, h2);
    e2 && (u2 = e2.createStream(u2, c2));
    u2 = this.filter(u2, h2, c2);
    u2.dict = h2;
    if (void 0 !== l2) {
      u2.cacheKey = "inline_img_" + ++this._imageId;
      this.imageCache[l2] = u2;
    }
    this.buf2 = Cmd.get("EI");
    this.shift();
    return u2;
  }
  #q(e2) {
    const { stream: t2 } = this.lexer;
    t2.pos = e2;
    const a2 = new Uint8Array([101, 110, 100]), r2 = a2.length, i2 = [new Uint8Array([115, 116, 114, 101, 97, 109]), new Uint8Array([115, 116, 101, 97, 109]), new Uint8Array([115, 116, 114, 101, 97])], n2 = 9 - r2;
    for (; t2.pos < t2.end; ) {
      const s2 = t2.peekBytes(2048), o2 = s2.length - 9;
      if (o2 <= 0) break;
      let c2 = 0;
      for (; c2 < o2; ) {
        let o3 = 0;
        for (; o3 < r2 && s2[c2 + o3] === a2[o3]; ) o3++;
        if (o3 >= r2) {
          let r3 = false;
          for (const e3 of i2) {
            const t3 = e3.length;
            let i3 = 0;
            for (; i3 < t3 && s2[c2 + o3 + i3] === e3[i3]; ) i3++;
            if (i3 >= n2) {
              r3 = true;
              break;
            }
            if (i3 >= t3) {
              if (isWhiteSpace(s2[c2 + o3 + i3])) {
                info(`Found "${bytesToString([...a2, ...e3])}" when searching for endstream command.`);
                r3 = true;
              }
              break;
            }
          }
          if (r3) {
            t2.pos += c2;
            return t2.pos - e2;
          }
        }
        c2++;
      }
      t2.pos += o2;
    }
    return -1;
  }
  makeStream(e2, t2) {
    const a2 = this.lexer;
    let r2 = a2.stream;
    a2.skipToNextLine();
    const i2 = r2.pos - 1;
    let n2 = e2.get("Length");
    if (!Number.isInteger(n2)) {
      info(`Bad length "${n2 && n2.toString()}" in stream.`);
      n2 = 0;
    }
    r2.pos = i2 + n2;
    a2.nextChar();
    if (this.tryShift() && isCmd(this.buf2, "endstream")) this.shift();
    else {
      n2 = this.#q(i2);
      if (n2 < 0) throw new FormatError("Missing endstream command.");
      a2.nextChar();
      this.shift();
      this.shift();
    }
    this.shift();
    r2 = r2.makeSubStream(i2, n2, e2);
    t2 && (r2 = t2.createStream(r2, n2));
    r2 = this.filter(r2, e2, n2);
    r2.dict = e2;
    return r2;
  }
  filter(e2, t2, a2) {
    let r2 = t2.get("F", "Filter"), i2 = t2.get("DP", "DecodeParms");
    if (r2 instanceof Name) {
      Array.isArray(i2) && warn("/DecodeParms should not be an Array, when /Filter is a Name.");
      return this.makeFilter(e2, r2.name, a2, i2);
    }
    let n2 = a2;
    if (Array.isArray(r2)) {
      const t3 = r2, a3 = i2;
      for (let s2 = 0, o2 = t3.length; s2 < o2; ++s2) {
        r2 = this.xref.fetchIfRef(t3[s2]);
        if (!(r2 instanceof Name)) throw new FormatError(`Bad filter name "${r2}"`);
        i2 = null;
        Array.isArray(a3) && s2 in a3 && (i2 = this.xref.fetchIfRef(a3[s2]));
        e2 = this.makeFilter(e2, r2.name, n2, i2);
        n2 = null;
      }
    }
    return e2;
  }
  makeFilter(e2, t2, a2, r2) {
    if (0 === a2) {
      warn(`Empty "${t2}" stream.`);
      return new NullStream();
    }
    try {
      switch (t2) {
        case "Fl":
        case "FlateDecode":
          return r2 ? new PredictorStream(new FlateStream(e2, a2), a2, r2) : new FlateStream(e2, a2);
        case "LZW":
        case "LZWDecode":
          let t3 = 1;
          if (r2) {
            r2.has("EarlyChange") && (t3 = r2.get("EarlyChange"));
            return new PredictorStream(new LZWStream(e2, a2, t3), a2, r2);
          }
          return new LZWStream(e2, a2, t3);
        case "DCT":
        case "DCTDecode":
          return new JpegStream(e2, a2, r2);
        case "JPX":
        case "JPXDecode":
          return new JpxStream(e2, a2, r2);
        case "A85":
        case "ASCII85Decode":
          return new Ascii85Stream(e2, a2);
        case "AHx":
        case "ASCIIHexDecode":
          return new AsciiHexStream(e2, a2);
        case "CCF":
        case "CCITTFaxDecode":
          return new CCITTFaxStream(e2, a2, r2);
        case "RL":
        case "RunLengthDecode":
          return new RunLengthStream(e2, a2);
        case "JBIG2Decode":
          return new Jbig2Stream(e2, a2, r2);
      }
      warn(`Filter "${t2}" is not supported.`);
      return e2;
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn(`Invalid stream: "${e3}"`);
      return new NullStream();
    }
  }
};
var mr = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
function toHexDigit(e2) {
  return e2 >= 48 && e2 <= 57 ? 15 & e2 : e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102 ? 9 + (15 & e2) : -1;
}
var Lexer = class {
  constructor(e2, t2 = null) {
    this.stream = e2;
    this.nextChar();
    this.strBuf = [];
    this.knownCommands = t2;
    this._hexStringNumWarn = 0;
    this.beginInlineImagePos = -1;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  peekChar() {
    return this.stream.peekByte();
  }
  getNumber() {
    let e2 = this.currentChar, t2 = false, a2 = 0, r2 = 1;
    if (45 === e2) {
      r2 = -1;
      e2 = this.nextChar();
      45 === e2 && (e2 = this.nextChar());
    } else 43 === e2 && (e2 = this.nextChar());
    if (10 === e2 || 13 === e2) do {
      e2 = this.nextChar();
    } while (10 === e2 || 13 === e2);
    if (46 === e2) {
      a2 = 10;
      e2 = this.nextChar();
    }
    if (e2 < 48 || e2 > 57) {
      const t3 = `Invalid number: ${String.fromCharCode(e2)} (charCode ${e2})`;
      if (isWhiteSpace(e2) || 40 === e2 || 60 === e2 || -1 === e2) {
        info(`Lexer.getNumber - "${t3}".`);
        return 0;
      }
      throw new FormatError(t3);
    }
    let i2 = e2 - 48, n2 = 0, s2 = 1;
    for (; (e2 = this.nextChar()) >= 0; ) if (e2 >= 48 && e2 <= 57) {
      const r3 = e2 - 48;
      if (t2) n2 = 10 * n2 + r3;
      else {
        0 !== a2 && (a2 *= 10);
        i2 = 10 * i2 + r3;
      }
    } else if (46 === e2) {
      if (0 !== a2) break;
      a2 = 1;
    } else if (45 === e2) warn("Badly formatted number: minus sign in the middle");
    else {
      if (69 !== e2 && 101 !== e2) break;
      e2 = this.peekChar();
      if (43 === e2 || 45 === e2) {
        s2 = 45 === e2 ? -1 : 1;
        this.nextChar();
      } else if (e2 < 48 || e2 > 57) break;
      t2 = true;
    }
    0 !== a2 && (i2 /= a2);
    t2 && (i2 *= 10 ** (s2 * n2));
    return r2 * i2;
  }
  getString() {
    let e2 = 1, t2 = false;
    const a2 = this.strBuf;
    a2.length = 0;
    let r2 = this.nextChar();
    for (; ; ) {
      let i2 = false;
      switch (0 | r2) {
        case -1:
          warn("Unterminated string");
          t2 = true;
          break;
        case 40:
          ++e2;
          a2.push("(");
          break;
        case 41:
          if (0 == --e2) {
            this.nextChar();
            t2 = true;
          } else a2.push(")");
          break;
        case 92:
          r2 = this.nextChar();
          switch (r2) {
            case -1:
              warn("Unterminated string");
              t2 = true;
              break;
            case 110:
              a2.push("\n");
              break;
            case 114:
              a2.push("\r");
              break;
            case 116:
              a2.push("	");
              break;
            case 98:
              a2.push("\b");
              break;
            case 102:
              a2.push("\f");
              break;
            case 92:
            case 40:
            case 41:
              a2.push(String.fromCharCode(r2));
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
              let e3 = 15 & r2;
              r2 = this.nextChar();
              i2 = true;
              if (r2 >= 48 && r2 <= 55) {
                e3 = (e3 << 3) + (15 & r2);
                r2 = this.nextChar();
                if (r2 >= 48 && r2 <= 55) {
                  i2 = false;
                  e3 = (e3 << 3) + (15 & r2);
                }
              }
              a2.push(String.fromCharCode(e3));
              break;
            case 13:
              10 === this.peekChar() && this.nextChar();
              break;
            case 10:
              break;
            default:
              a2.push(String.fromCharCode(r2));
          }
          break;
        default:
          a2.push(String.fromCharCode(r2));
      }
      if (t2) break;
      i2 || (r2 = this.nextChar());
    }
    return a2.join("");
  }
  getName() {
    let e2, t2;
    const a2 = this.strBuf;
    a2.length = 0;
    for (; (e2 = this.nextChar()) >= 0 && !mr[e2]; ) if (35 === e2) {
      e2 = this.nextChar();
      if (mr[e2]) {
        warn("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
        a2.push("#");
        break;
      }
      const r2 = toHexDigit(e2);
      if (-1 !== r2) {
        t2 = e2;
        e2 = this.nextChar();
        const i2 = toHexDigit(e2);
        if (-1 === i2) {
          warn(`Lexer_getName: Illegal digit (${String.fromCharCode(e2)}) in hexadecimal number.`);
          a2.push("#", String.fromCharCode(t2));
          if (mr[e2]) break;
          a2.push(String.fromCharCode(e2));
          continue;
        }
        a2.push(String.fromCharCode(r2 << 4 | i2));
      } else a2.push("#", String.fromCharCode(e2));
    } else a2.push(String.fromCharCode(e2));
    a2.length > 127 && warn(`Name token is longer than allowed by the spec: ${a2.length}`);
    return Name.get(a2.join(""));
  }
  _hexStringWarn(e2) {
    5 != this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn(`getHexString - ignoring invalid character: ${e2}`) : warn("getHexString - ignoring additional invalid characters.");
  }
  getHexString() {
    const e2 = this.strBuf;
    e2.length = 0;
    let t2 = this.currentChar, a2 = -1, r2 = -1;
    this._hexStringNumWarn = 0;
    for (; ; ) {
      if (t2 < 0) {
        warn("Unterminated hex string");
        break;
      }
      if (62 === t2) {
        this.nextChar();
        break;
      }
      if (1 !== mr[t2]) {
        r2 = toHexDigit(t2);
        if (-1 === r2) this._hexStringWarn(t2);
        else if (-1 === a2) a2 = r2;
        else {
          e2.push(String.fromCharCode(a2 << 4 | r2));
          a2 = -1;
        }
        t2 = this.nextChar();
      } else t2 = this.nextChar();
    }
    -1 !== a2 && e2.push(String.fromCharCode(a2 << 4));
    return e2.join("");
  }
  getObj() {
    let e2 = false, t2 = this.currentChar;
    for (; ; ) {
      if (t2 < 0) return wa;
      if (e2) 10 !== t2 && 13 !== t2 || (e2 = false);
      else if (37 === t2) e2 = true;
      else if (1 !== mr[t2]) break;
      t2 = this.nextChar();
    }
    switch (0 | t2) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return this.getNumber();
      case 40:
        return this.getString();
      case 47:
        return this.getName();
      case 91:
        this.nextChar();
        return Cmd.get("[");
      case 93:
        this.nextChar();
        return Cmd.get("]");
      case 60:
        t2 = this.nextChar();
        if (60 === t2) {
          this.nextChar();
          return Cmd.get("<<");
        }
        return this.getHexString();
      case 62:
        t2 = this.nextChar();
        if (62 === t2) {
          this.nextChar();
          return Cmd.get(">>");
        }
        return Cmd.get(">");
      case 123:
        this.nextChar();
        return Cmd.get("{");
      case 125:
        this.nextChar();
        return Cmd.get("}");
      case 41:
        this.nextChar();
        throw new FormatError(`Illegal character: ${t2}`);
    }
    let a2 = String.fromCharCode(t2);
    if (t2 < 32 || t2 > 127) {
      const e3 = this.peekChar();
      if (e3 >= 32 && e3 <= 127) {
        this.nextChar();
        return Cmd.get(a2);
      }
    }
    const r2 = this.knownCommands;
    let i2 = void 0 !== r2?.[a2];
    for (; (t2 = this.nextChar()) >= 0 && !mr[t2]; ) {
      const e3 = a2 + String.fromCharCode(t2);
      if (i2 && void 0 === r2[e3]) break;
      if (128 === a2.length) throw new FormatError(`Command token too long: ${a2.length}`);
      a2 = e3;
      i2 = void 0 !== r2?.[a2];
    }
    if ("true" === a2) return true;
    if ("false" === a2) return false;
    if ("null" === a2) return null;
    "BI" === a2 && (this.beginInlineImagePos = this.stream.pos);
    return Cmd.get(a2);
  }
  skipToNextLine() {
    let e2 = this.currentChar;
    for (; e2 >= 0; ) {
      if (13 === e2) {
        e2 = this.nextChar();
        10 === e2 && this.nextChar();
        break;
      }
      if (10 === e2) {
        this.nextChar();
        break;
      }
      e2 = this.nextChar();
    }
  }
};
var Linearization = class {
  static create(e2) {
    function getInt(e3, t3, a3 = false) {
      const r3 = e3.get(t3);
      if (Number.isInteger(r3) && (a3 ? r3 >= 0 : r3 > 0)) return r3;
      throw new Error(`The "${t3}" parameter in the linearization dictionary is invalid.`);
    }
    const t2 = new Parser({ lexer: new Lexer(e2), xref: null }), a2 = t2.getObj(), r2 = t2.getObj(), i2 = t2.getObj(), n2 = t2.getObj();
    let s2, o2;
    if (!(Number.isInteger(a2) && Number.isInteger(r2) && isCmd(i2, "obj") && n2 instanceof Dict && "number" == typeof (s2 = n2.get("Linearized")) && s2 > 0)) return null;
    if ((o2 = getInt(n2, "L")) !== e2.length) throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
    return { length: o2, hints: (function getHints(e3) {
      const t3 = e3.get("H");
      let a3;
      if (Array.isArray(t3) && (2 === (a3 = t3.length) || 4 === a3)) {
        for (let e4 = 0; e4 < a3; e4++) {
          const a4 = t3[e4];
          if (!(Number.isInteger(a4) && a4 > 0)) throw new Error(`Hint (${e4}) in the linearization dictionary is invalid.`);
        }
        return t3;
      }
      throw new Error("Hint array in the linearization dictionary is invalid.");
    })(n2), objectNumberFirst: getInt(n2, "O"), endFirst: getInt(n2, "E"), numPages: getInt(n2, "N"), mainXRefEntriesOffset: getInt(n2, "T"), pageFirst: n2.has("P") ? getInt(n2, "P", true) : 0 };
  }
};
var br = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"];
var yr = 2 ** 24 - 1;
var CMap = class {
  constructor(e2 = false) {
    this.codespaceRanges = [[], [], [], []];
    this.numCodespaceRanges = 0;
    this._map = [];
    this.name = "";
    this.vertical = false;
    this.useCMap = null;
    this.builtInCMap = e2;
  }
  addCodespaceRange(e2, t2, a2) {
    this.codespaceRanges[e2 - 1].push(t2, a2);
    this.numCodespaceRanges++;
  }
  mapCidRange(e2, t2, a2) {
    if (t2 - e2 > yr) throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
    for (; e2 <= t2; ) this._map[e2++] = a2++;
  }
  mapBfRange(e2, t2, a2) {
    if (t2 - e2 > yr) throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
    const r2 = a2.length - 1;
    for (; e2 <= t2; ) {
      this._map[e2++] = a2;
      const t3 = a2.charCodeAt(r2) + 1;
      t3 > 255 ? a2 = a2.substring(0, r2 - 1) + String.fromCharCode(a2.charCodeAt(r2 - 1) + 1) + "\0" : a2 = a2.substring(0, r2) + String.fromCharCode(t3);
    }
  }
  mapBfRangeToArray(e2, t2, a2) {
    if (t2 - e2 > yr) throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
    const r2 = a2.length;
    let i2 = 0;
    for (; e2 <= t2 && i2 < r2; ) {
      this._map[e2] = a2[i2++];
      ++e2;
    }
  }
  mapOne(e2, t2) {
    this._map[e2] = t2;
  }
  lookup(e2) {
    return this._map[e2];
  }
  contains(e2) {
    return void 0 !== this._map[e2];
  }
  forEach(e2) {
    const t2 = this._map, a2 = t2.length;
    if (a2 <= 65536) for (let r2 = 0; r2 < a2; r2++) void 0 !== t2[r2] && e2(r2, t2[r2]);
    else for (const a3 in t2) e2(a3, t2[a3]);
  }
  charCodeOf(e2) {
    const t2 = this._map;
    if (t2.length <= 65536) return t2.indexOf(e2);
    for (const a2 in t2) if (t2[a2] === e2) return 0 | a2;
    return -1;
  }
  getMap() {
    return this._map;
  }
  readCharCode(e2, t2, a2) {
    let r2 = 0;
    const i2 = this.codespaceRanges;
    for (let n2 = 0, s2 = i2.length; n2 < s2; n2++) {
      r2 = (r2 << 8 | e2.charCodeAt(t2 + n2)) >>> 0;
      const s3 = i2[n2];
      for (let e3 = 0, t3 = s3.length; e3 < t3; ) {
        const t4 = s3[e3++], i3 = s3[e3++];
        if (r2 >= t4 && r2 <= i3) {
          a2.charcode = r2;
          a2.length = n2 + 1;
          return;
        }
      }
    }
    a2.charcode = 0;
    a2.length = 1;
  }
  getCharCodeLength(e2) {
    const t2 = this.codespaceRanges;
    for (let a2 = 0, r2 = t2.length; a2 < r2; a2++) {
      const r3 = t2[a2];
      for (let t3 = 0, i2 = r3.length; t3 < i2; ) {
        const i3 = r3[t3++], n2 = r3[t3++];
        if (e2 >= i3 && e2 <= n2) return a2 + 1;
      }
    }
    return 1;
  }
  get length() {
    return this._map.length;
  }
  get isIdentityCMap() {
    if ("Identity-H" !== this.name && "Identity-V" !== this.name) return false;
    if (65536 !== this._map.length) return false;
    for (let e2 = 0; e2 < 65536; e2++) if (this._map[e2] !== e2) return false;
    return true;
  }
};
var IdentityCMap = class extends CMap {
  constructor(e2, t2) {
    super();
    this.vertical = e2;
    this.addCodespaceRange(t2, 0, 65535);
  }
  mapCidRange(e2, t2, a2) {
    unreachable("should not call mapCidRange");
  }
  mapBfRange(e2, t2, a2) {
    unreachable("should not call mapBfRange");
  }
  mapBfRangeToArray(e2, t2, a2) {
    unreachable("should not call mapBfRangeToArray");
  }
  mapOne(e2, t2) {
    unreachable("should not call mapCidOne");
  }
  lookup(e2) {
    return Number.isInteger(e2) && e2 <= 65535 ? e2 : void 0;
  }
  contains(e2) {
    return Number.isInteger(e2) && e2 <= 65535;
  }
  forEach(e2) {
    for (let t2 = 0; t2 <= 65535; t2++) e2(t2, t2);
  }
  charCodeOf(e2) {
    return Number.isInteger(e2) && e2 <= 65535 ? e2 : -1;
  }
  getMap() {
    const e2 = new Array(65536);
    for (let t2 = 0; t2 <= 65535; t2++) e2[t2] = t2;
    return e2;
  }
  get length() {
    return 65536;
  }
  get isIdentityCMap() {
    unreachable("should not access .isIdentityCMap");
  }
};
function strToInt(e2) {
  let t2 = 0;
  for (let a2 = 0; a2 < e2.length; a2++) t2 = t2 << 8 | e2.charCodeAt(a2);
  return t2 >>> 0;
}
function expectString(e2) {
  if ("string" != typeof e2) throw new FormatError("Malformed CMap: expected string.");
}
function expectInt(e2) {
  if (!Number.isInteger(e2)) throw new FormatError("Malformed CMap: expected int.");
}
function parseBfChar(e2, t2) {
  for (; ; ) {
    let a2 = t2.getObj();
    if (a2 === wa) break;
    if (isCmd(a2, "endbfchar")) return;
    expectString(a2);
    const r2 = strToInt(a2);
    a2 = t2.getObj();
    expectString(a2);
    const i2 = a2;
    e2.mapOne(r2, i2);
  }
}
function parseBfRange(e2, t2) {
  for (; ; ) {
    let a2 = t2.getObj();
    if (a2 === wa) break;
    if (isCmd(a2, "endbfrange")) return;
    expectString(a2);
    const r2 = strToInt(a2);
    a2 = t2.getObj();
    expectString(a2);
    const i2 = strToInt(a2);
    a2 = t2.getObj();
    if (Number.isInteger(a2) || "string" == typeof a2) {
      const t3 = Number.isInteger(a2) ? String.fromCharCode(a2) : a2;
      e2.mapBfRange(r2, i2, t3);
    } else {
      if (!isCmd(a2, "[")) break;
      {
        a2 = t2.getObj();
        const n2 = [];
        for (; !isCmd(a2, "]") && a2 !== wa; ) {
          n2.push(a2);
          a2 = t2.getObj();
        }
        e2.mapBfRangeToArray(r2, i2, n2);
      }
    }
  }
  throw new FormatError("Invalid bf range.");
}
function parseCidChar(e2, t2) {
  for (; ; ) {
    let a2 = t2.getObj();
    if (a2 === wa) break;
    if (isCmd(a2, "endcidchar")) return;
    expectString(a2);
    const r2 = strToInt(a2);
    a2 = t2.getObj();
    expectInt(a2);
    const i2 = a2;
    e2.mapOne(r2, i2);
  }
}
function parseCidRange(e2, t2) {
  for (; ; ) {
    let a2 = t2.getObj();
    if (a2 === wa) break;
    if (isCmd(a2, "endcidrange")) return;
    expectString(a2);
    const r2 = strToInt(a2);
    a2 = t2.getObj();
    expectString(a2);
    const i2 = strToInt(a2);
    a2 = t2.getObj();
    expectInt(a2);
    const n2 = a2;
    e2.mapCidRange(r2, i2, n2);
  }
}
function parseCodespaceRange(e2, t2) {
  for (; ; ) {
    let a2 = t2.getObj();
    if (a2 === wa) break;
    if (isCmd(a2, "endcodespacerange")) return;
    if ("string" != typeof a2) break;
    const r2 = strToInt(a2);
    a2 = t2.getObj();
    if ("string" != typeof a2) break;
    const i2 = strToInt(a2);
    e2.addCodespaceRange(a2.length, r2, i2);
  }
  throw new FormatError("Invalid codespace range.");
}
function parseWMode(e2, t2) {
  const a2 = t2.getObj();
  Number.isInteger(a2) && (e2.vertical = !!a2);
}
function parseCMapName(e2, t2) {
  const a2 = t2.getObj();
  a2 instanceof Name && (e2.name = a2.name);
}
async function parseCMap(e2, t2, a2, r2) {
  let i2, n2;
  e: for (; ; ) try {
    const a3 = t2.getObj();
    if (a3 === wa) break;
    if (a3 instanceof Name) {
      "WMode" === a3.name ? parseWMode(e2, t2) : "CMapName" === a3.name && parseCMapName(e2, t2);
      i2 = a3;
    } else if (a3 instanceof Cmd) switch (a3.cmd) {
      case "endcmap":
        break e;
      case "usecmap":
        i2 instanceof Name && (n2 = i2.name);
        break;
      case "begincodespacerange":
        parseCodespaceRange(e2, t2);
        break;
      case "beginbfchar":
        parseBfChar(e2, t2);
        break;
      case "begincidchar":
        parseCidChar(e2, t2);
        break;
      case "beginbfrange":
        parseBfRange(e2, t2);
        break;
      case "begincidrange":
        parseCidRange(e2, t2);
    }
  } catch (e3) {
    if (e3 instanceof MissingDataException) throw e3;
    warn("Invalid cMap data: " + e3);
    continue;
  }
  !r2 && n2 && (r2 = n2);
  return r2 ? extendCMap(e2, a2, r2) : e2;
}
async function extendCMap(e2, t2, a2) {
  e2.useCMap = await createBuiltInCMap(a2, t2);
  if (0 === e2.numCodespaceRanges) {
    const t3 = e2.useCMap.codespaceRanges;
    for (let a3 = 0; a3 < t3.length; a3++) e2.codespaceRanges[a3] = t3[a3].slice();
    e2.numCodespaceRanges = e2.useCMap.numCodespaceRanges;
  }
  e2.useCMap.forEach((function(t3, a3) {
    e2.contains(t3) || e2.mapOne(t3, a3);
  }));
  return e2;
}
async function createBuiltInCMap(e2, t2) {
  if ("Identity-H" === e2) return new IdentityCMap(false, 2);
  if ("Identity-V" === e2) return new IdentityCMap(true, 2);
  if (!br.includes(e2)) throw new Error("Unknown CMap name: " + e2);
  if (!t2) throw new Error("Built-in CMap parameters are not provided.");
  const { cMapData: a2, isCompressed: r2 } = await t2(e2), i2 = new CMap(true);
  if (r2) return new BinaryCMapReader().process(a2, i2, ((e3) => extendCMap(i2, t2, e3)));
  const n2 = new Lexer(new Stream(a2));
  return parseCMap(i2, n2, t2, null);
}
var CMapFactory = class {
  static async create({ encoding: e2, fetchBuiltInCMap: t2, useCMap: a2 }) {
    if (e2 instanceof Name) return createBuiltInCMap(e2.name, t2);
    if (e2 instanceof BaseStream) {
      const r2 = await parseCMap(new CMap(), new Lexer(e2), t2, a2);
      return r2.isIdentityCMap ? createBuiltInCMap(r2.name, t2) : r2;
    }
    throw new Error("Encoding required.");
  }
};
var wr = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
var xr = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""];
var Sr = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"];
var Ar = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""];
var kr = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"];
var Cr = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""];
var vr = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
function getEncoding(e2) {
  switch (e2) {
    case "WinAnsiEncoding":
      return kr;
    case "StandardEncoding":
      return Ar;
    case "MacRomanEncoding":
      return Sr;
    case "SymbolSetEncoding":
      return Cr;
    case "ZapfDingbatsEncoding":
      return vr;
    case "ExpertEncoding":
      return wr;
    case "MacExpertEncoding":
      return xr;
    default:
      return null;
  }
}
var Fr = getLookupTableFactory((function(e2) {
  e2.A = 65;
  e2.AE = 198;
  e2.AEacute = 508;
  e2.AEmacron = 482;
  e2.AEsmall = 63462;
  e2.Aacute = 193;
  e2.Aacutesmall = 63457;
  e2.Abreve = 258;
  e2.Abreveacute = 7854;
  e2.Abrevecyrillic = 1232;
  e2.Abrevedotbelow = 7862;
  e2.Abrevegrave = 7856;
  e2.Abrevehookabove = 7858;
  e2.Abrevetilde = 7860;
  e2.Acaron = 461;
  e2.Acircle = 9398;
  e2.Acircumflex = 194;
  e2.Acircumflexacute = 7844;
  e2.Acircumflexdotbelow = 7852;
  e2.Acircumflexgrave = 7846;
  e2.Acircumflexhookabove = 7848;
  e2.Acircumflexsmall = 63458;
  e2.Acircumflextilde = 7850;
  e2.Acute = 63177;
  e2.Acutesmall = 63412;
  e2.Acyrillic = 1040;
  e2.Adblgrave = 512;
  e2.Adieresis = 196;
  e2.Adieresiscyrillic = 1234;
  e2.Adieresismacron = 478;
  e2.Adieresissmall = 63460;
  e2.Adotbelow = 7840;
  e2.Adotmacron = 480;
  e2.Agrave = 192;
  e2.Agravesmall = 63456;
  e2.Ahookabove = 7842;
  e2.Aiecyrillic = 1236;
  e2.Ainvertedbreve = 514;
  e2.Alpha = 913;
  e2.Alphatonos = 902;
  e2.Amacron = 256;
  e2.Amonospace = 65313;
  e2.Aogonek = 260;
  e2.Aring = 197;
  e2.Aringacute = 506;
  e2.Aringbelow = 7680;
  e2.Aringsmall = 63461;
  e2.Asmall = 63329;
  e2.Atilde = 195;
  e2.Atildesmall = 63459;
  e2.Aybarmenian = 1329;
  e2.B = 66;
  e2.Bcircle = 9399;
  e2.Bdotaccent = 7682;
  e2.Bdotbelow = 7684;
  e2.Becyrillic = 1041;
  e2.Benarmenian = 1330;
  e2.Beta = 914;
  e2.Bhook = 385;
  e2.Blinebelow = 7686;
  e2.Bmonospace = 65314;
  e2.Brevesmall = 63220;
  e2.Bsmall = 63330;
  e2.Btopbar = 386;
  e2.C = 67;
  e2.Caarmenian = 1342;
  e2.Cacute = 262;
  e2.Caron = 63178;
  e2.Caronsmall = 63221;
  e2.Ccaron = 268;
  e2.Ccedilla = 199;
  e2.Ccedillaacute = 7688;
  e2.Ccedillasmall = 63463;
  e2.Ccircle = 9400;
  e2.Ccircumflex = 264;
  e2.Cdot = 266;
  e2.Cdotaccent = 266;
  e2.Cedillasmall = 63416;
  e2.Chaarmenian = 1353;
  e2.Cheabkhasiancyrillic = 1212;
  e2.Checyrillic = 1063;
  e2.Chedescenderabkhasiancyrillic = 1214;
  e2.Chedescendercyrillic = 1206;
  e2.Chedieresiscyrillic = 1268;
  e2.Cheharmenian = 1347;
  e2.Chekhakassiancyrillic = 1227;
  e2.Cheverticalstrokecyrillic = 1208;
  e2.Chi = 935;
  e2.Chook = 391;
  e2.Circumflexsmall = 63222;
  e2.Cmonospace = 65315;
  e2.Coarmenian = 1361;
  e2.Csmall = 63331;
  e2.D = 68;
  e2.DZ = 497;
  e2.DZcaron = 452;
  e2.Daarmenian = 1332;
  e2.Dafrican = 393;
  e2.Dcaron = 270;
  e2.Dcedilla = 7696;
  e2.Dcircle = 9401;
  e2.Dcircumflexbelow = 7698;
  e2.Dcroat = 272;
  e2.Ddotaccent = 7690;
  e2.Ddotbelow = 7692;
  e2.Decyrillic = 1044;
  e2.Deicoptic = 1006;
  e2.Delta = 8710;
  e2.Deltagreek = 916;
  e2.Dhook = 394;
  e2.Dieresis = 63179;
  e2.DieresisAcute = 63180;
  e2.DieresisGrave = 63181;
  e2.Dieresissmall = 63400;
  e2.Digammagreek = 988;
  e2.Djecyrillic = 1026;
  e2.Dlinebelow = 7694;
  e2.Dmonospace = 65316;
  e2.Dotaccentsmall = 63223;
  e2.Dslash = 272;
  e2.Dsmall = 63332;
  e2.Dtopbar = 395;
  e2.Dz = 498;
  e2.Dzcaron = 453;
  e2.Dzeabkhasiancyrillic = 1248;
  e2.Dzecyrillic = 1029;
  e2.Dzhecyrillic = 1039;
  e2.E = 69;
  e2.Eacute = 201;
  e2.Eacutesmall = 63465;
  e2.Ebreve = 276;
  e2.Ecaron = 282;
  e2.Ecedillabreve = 7708;
  e2.Echarmenian = 1333;
  e2.Ecircle = 9402;
  e2.Ecircumflex = 202;
  e2.Ecircumflexacute = 7870;
  e2.Ecircumflexbelow = 7704;
  e2.Ecircumflexdotbelow = 7878;
  e2.Ecircumflexgrave = 7872;
  e2.Ecircumflexhookabove = 7874;
  e2.Ecircumflexsmall = 63466;
  e2.Ecircumflextilde = 7876;
  e2.Ecyrillic = 1028;
  e2.Edblgrave = 516;
  e2.Edieresis = 203;
  e2.Edieresissmall = 63467;
  e2.Edot = 278;
  e2.Edotaccent = 278;
  e2.Edotbelow = 7864;
  e2.Efcyrillic = 1060;
  e2.Egrave = 200;
  e2.Egravesmall = 63464;
  e2.Eharmenian = 1335;
  e2.Ehookabove = 7866;
  e2.Eightroman = 8551;
  e2.Einvertedbreve = 518;
  e2.Eiotifiedcyrillic = 1124;
  e2.Elcyrillic = 1051;
  e2.Elevenroman = 8554;
  e2.Emacron = 274;
  e2.Emacronacute = 7702;
  e2.Emacrongrave = 7700;
  e2.Emcyrillic = 1052;
  e2.Emonospace = 65317;
  e2.Encyrillic = 1053;
  e2.Endescendercyrillic = 1186;
  e2.Eng = 330;
  e2.Enghecyrillic = 1188;
  e2.Enhookcyrillic = 1223;
  e2.Eogonek = 280;
  e2.Eopen = 400;
  e2.Epsilon = 917;
  e2.Epsilontonos = 904;
  e2.Ercyrillic = 1056;
  e2.Ereversed = 398;
  e2.Ereversedcyrillic = 1069;
  e2.Escyrillic = 1057;
  e2.Esdescendercyrillic = 1194;
  e2.Esh = 425;
  e2.Esmall = 63333;
  e2.Eta = 919;
  e2.Etarmenian = 1336;
  e2.Etatonos = 905;
  e2.Eth = 208;
  e2.Ethsmall = 63472;
  e2.Etilde = 7868;
  e2.Etildebelow = 7706;
  e2.Euro = 8364;
  e2.Ezh = 439;
  e2.Ezhcaron = 494;
  e2.Ezhreversed = 440;
  e2.F = 70;
  e2.Fcircle = 9403;
  e2.Fdotaccent = 7710;
  e2.Feharmenian = 1366;
  e2.Feicoptic = 996;
  e2.Fhook = 401;
  e2.Fitacyrillic = 1138;
  e2.Fiveroman = 8548;
  e2.Fmonospace = 65318;
  e2.Fourroman = 8547;
  e2.Fsmall = 63334;
  e2.G = 71;
  e2.GBsquare = 13191;
  e2.Gacute = 500;
  e2.Gamma = 915;
  e2.Gammaafrican = 404;
  e2.Gangiacoptic = 1002;
  e2.Gbreve = 286;
  e2.Gcaron = 486;
  e2.Gcedilla = 290;
  e2.Gcircle = 9404;
  e2.Gcircumflex = 284;
  e2.Gcommaaccent = 290;
  e2.Gdot = 288;
  e2.Gdotaccent = 288;
  e2.Gecyrillic = 1043;
  e2.Ghadarmenian = 1346;
  e2.Ghemiddlehookcyrillic = 1172;
  e2.Ghestrokecyrillic = 1170;
  e2.Gheupturncyrillic = 1168;
  e2.Ghook = 403;
  e2.Gimarmenian = 1331;
  e2.Gjecyrillic = 1027;
  e2.Gmacron = 7712;
  e2.Gmonospace = 65319;
  e2.Grave = 63182;
  e2.Gravesmall = 63328;
  e2.Gsmall = 63335;
  e2.Gsmallhook = 667;
  e2.Gstroke = 484;
  e2.H = 72;
  e2.H18533 = 9679;
  e2.H18543 = 9642;
  e2.H18551 = 9643;
  e2.H22073 = 9633;
  e2.HPsquare = 13259;
  e2.Haabkhasiancyrillic = 1192;
  e2.Hadescendercyrillic = 1202;
  e2.Hardsigncyrillic = 1066;
  e2.Hbar = 294;
  e2.Hbrevebelow = 7722;
  e2.Hcedilla = 7720;
  e2.Hcircle = 9405;
  e2.Hcircumflex = 292;
  e2.Hdieresis = 7718;
  e2.Hdotaccent = 7714;
  e2.Hdotbelow = 7716;
  e2.Hmonospace = 65320;
  e2.Hoarmenian = 1344;
  e2.Horicoptic = 1e3;
  e2.Hsmall = 63336;
  e2.Hungarumlaut = 63183;
  e2.Hungarumlautsmall = 63224;
  e2.Hzsquare = 13200;
  e2.I = 73;
  e2.IAcyrillic = 1071;
  e2.IJ = 306;
  e2.IUcyrillic = 1070;
  e2.Iacute = 205;
  e2.Iacutesmall = 63469;
  e2.Ibreve = 300;
  e2.Icaron = 463;
  e2.Icircle = 9406;
  e2.Icircumflex = 206;
  e2.Icircumflexsmall = 63470;
  e2.Icyrillic = 1030;
  e2.Idblgrave = 520;
  e2.Idieresis = 207;
  e2.Idieresisacute = 7726;
  e2.Idieresiscyrillic = 1252;
  e2.Idieresissmall = 63471;
  e2.Idot = 304;
  e2.Idotaccent = 304;
  e2.Idotbelow = 7882;
  e2.Iebrevecyrillic = 1238;
  e2.Iecyrillic = 1045;
  e2.Ifraktur = 8465;
  e2.Igrave = 204;
  e2.Igravesmall = 63468;
  e2.Ihookabove = 7880;
  e2.Iicyrillic = 1048;
  e2.Iinvertedbreve = 522;
  e2.Iishortcyrillic = 1049;
  e2.Imacron = 298;
  e2.Imacroncyrillic = 1250;
  e2.Imonospace = 65321;
  e2.Iniarmenian = 1339;
  e2.Iocyrillic = 1025;
  e2.Iogonek = 302;
  e2.Iota = 921;
  e2.Iotaafrican = 406;
  e2.Iotadieresis = 938;
  e2.Iotatonos = 906;
  e2.Ismall = 63337;
  e2.Istroke = 407;
  e2.Itilde = 296;
  e2.Itildebelow = 7724;
  e2.Izhitsacyrillic = 1140;
  e2.Izhitsadblgravecyrillic = 1142;
  e2.J = 74;
  e2.Jaarmenian = 1345;
  e2.Jcircle = 9407;
  e2.Jcircumflex = 308;
  e2.Jecyrillic = 1032;
  e2.Jheharmenian = 1355;
  e2.Jmonospace = 65322;
  e2.Jsmall = 63338;
  e2.K = 75;
  e2.KBsquare = 13189;
  e2.KKsquare = 13261;
  e2.Kabashkircyrillic = 1184;
  e2.Kacute = 7728;
  e2.Kacyrillic = 1050;
  e2.Kadescendercyrillic = 1178;
  e2.Kahookcyrillic = 1219;
  e2.Kappa = 922;
  e2.Kastrokecyrillic = 1182;
  e2.Kaverticalstrokecyrillic = 1180;
  e2.Kcaron = 488;
  e2.Kcedilla = 310;
  e2.Kcircle = 9408;
  e2.Kcommaaccent = 310;
  e2.Kdotbelow = 7730;
  e2.Keharmenian = 1364;
  e2.Kenarmenian = 1343;
  e2.Khacyrillic = 1061;
  e2.Kheicoptic = 998;
  e2.Khook = 408;
  e2.Kjecyrillic = 1036;
  e2.Klinebelow = 7732;
  e2.Kmonospace = 65323;
  e2.Koppacyrillic = 1152;
  e2.Koppagreek = 990;
  e2.Ksicyrillic = 1134;
  e2.Ksmall = 63339;
  e2.L = 76;
  e2.LJ = 455;
  e2.LL = 63167;
  e2.Lacute = 313;
  e2.Lambda = 923;
  e2.Lcaron = 317;
  e2.Lcedilla = 315;
  e2.Lcircle = 9409;
  e2.Lcircumflexbelow = 7740;
  e2.Lcommaaccent = 315;
  e2.Ldot = 319;
  e2.Ldotaccent = 319;
  e2.Ldotbelow = 7734;
  e2.Ldotbelowmacron = 7736;
  e2.Liwnarmenian = 1340;
  e2.Lj = 456;
  e2.Ljecyrillic = 1033;
  e2.Llinebelow = 7738;
  e2.Lmonospace = 65324;
  e2.Lslash = 321;
  e2.Lslashsmall = 63225;
  e2.Lsmall = 63340;
  e2.M = 77;
  e2.MBsquare = 13190;
  e2.Macron = 63184;
  e2.Macronsmall = 63407;
  e2.Macute = 7742;
  e2.Mcircle = 9410;
  e2.Mdotaccent = 7744;
  e2.Mdotbelow = 7746;
  e2.Menarmenian = 1348;
  e2.Mmonospace = 65325;
  e2.Msmall = 63341;
  e2.Mturned = 412;
  e2.Mu = 924;
  e2.N = 78;
  e2.NJ = 458;
  e2.Nacute = 323;
  e2.Ncaron = 327;
  e2.Ncedilla = 325;
  e2.Ncircle = 9411;
  e2.Ncircumflexbelow = 7754;
  e2.Ncommaaccent = 325;
  e2.Ndotaccent = 7748;
  e2.Ndotbelow = 7750;
  e2.Nhookleft = 413;
  e2.Nineroman = 8552;
  e2.Nj = 459;
  e2.Njecyrillic = 1034;
  e2.Nlinebelow = 7752;
  e2.Nmonospace = 65326;
  e2.Nowarmenian = 1350;
  e2.Nsmall = 63342;
  e2.Ntilde = 209;
  e2.Ntildesmall = 63473;
  e2.Nu = 925;
  e2.O = 79;
  e2.OE = 338;
  e2.OEsmall = 63226;
  e2.Oacute = 211;
  e2.Oacutesmall = 63475;
  e2.Obarredcyrillic = 1256;
  e2.Obarreddieresiscyrillic = 1258;
  e2.Obreve = 334;
  e2.Ocaron = 465;
  e2.Ocenteredtilde = 415;
  e2.Ocircle = 9412;
  e2.Ocircumflex = 212;
  e2.Ocircumflexacute = 7888;
  e2.Ocircumflexdotbelow = 7896;
  e2.Ocircumflexgrave = 7890;
  e2.Ocircumflexhookabove = 7892;
  e2.Ocircumflexsmall = 63476;
  e2.Ocircumflextilde = 7894;
  e2.Ocyrillic = 1054;
  e2.Odblacute = 336;
  e2.Odblgrave = 524;
  e2.Odieresis = 214;
  e2.Odieresiscyrillic = 1254;
  e2.Odieresissmall = 63478;
  e2.Odotbelow = 7884;
  e2.Ogoneksmall = 63227;
  e2.Ograve = 210;
  e2.Ogravesmall = 63474;
  e2.Oharmenian = 1365;
  e2.Ohm = 8486;
  e2.Ohookabove = 7886;
  e2.Ohorn = 416;
  e2.Ohornacute = 7898;
  e2.Ohorndotbelow = 7906;
  e2.Ohorngrave = 7900;
  e2.Ohornhookabove = 7902;
  e2.Ohorntilde = 7904;
  e2.Ohungarumlaut = 336;
  e2.Oi = 418;
  e2.Oinvertedbreve = 526;
  e2.Omacron = 332;
  e2.Omacronacute = 7762;
  e2.Omacrongrave = 7760;
  e2.Omega = 8486;
  e2.Omegacyrillic = 1120;
  e2.Omegagreek = 937;
  e2.Omegaroundcyrillic = 1146;
  e2.Omegatitlocyrillic = 1148;
  e2.Omegatonos = 911;
  e2.Omicron = 927;
  e2.Omicrontonos = 908;
  e2.Omonospace = 65327;
  e2.Oneroman = 8544;
  e2.Oogonek = 490;
  e2.Oogonekmacron = 492;
  e2.Oopen = 390;
  e2.Oslash = 216;
  e2.Oslashacute = 510;
  e2.Oslashsmall = 63480;
  e2.Osmall = 63343;
  e2.Ostrokeacute = 510;
  e2.Otcyrillic = 1150;
  e2.Otilde = 213;
  e2.Otildeacute = 7756;
  e2.Otildedieresis = 7758;
  e2.Otildesmall = 63477;
  e2.P = 80;
  e2.Pacute = 7764;
  e2.Pcircle = 9413;
  e2.Pdotaccent = 7766;
  e2.Pecyrillic = 1055;
  e2.Peharmenian = 1354;
  e2.Pemiddlehookcyrillic = 1190;
  e2.Phi = 934;
  e2.Phook = 420;
  e2.Pi = 928;
  e2.Piwrarmenian = 1363;
  e2.Pmonospace = 65328;
  e2.Psi = 936;
  e2.Psicyrillic = 1136;
  e2.Psmall = 63344;
  e2.Q = 81;
  e2.Qcircle = 9414;
  e2.Qmonospace = 65329;
  e2.Qsmall = 63345;
  e2.R = 82;
  e2.Raarmenian = 1356;
  e2.Racute = 340;
  e2.Rcaron = 344;
  e2.Rcedilla = 342;
  e2.Rcircle = 9415;
  e2.Rcommaaccent = 342;
  e2.Rdblgrave = 528;
  e2.Rdotaccent = 7768;
  e2.Rdotbelow = 7770;
  e2.Rdotbelowmacron = 7772;
  e2.Reharmenian = 1360;
  e2.Rfraktur = 8476;
  e2.Rho = 929;
  e2.Ringsmall = 63228;
  e2.Rinvertedbreve = 530;
  e2.Rlinebelow = 7774;
  e2.Rmonospace = 65330;
  e2.Rsmall = 63346;
  e2.Rsmallinverted = 641;
  e2.Rsmallinvertedsuperior = 694;
  e2.S = 83;
  e2.SF010000 = 9484;
  e2.SF020000 = 9492;
  e2.SF030000 = 9488;
  e2.SF040000 = 9496;
  e2.SF050000 = 9532;
  e2.SF060000 = 9516;
  e2.SF070000 = 9524;
  e2.SF080000 = 9500;
  e2.SF090000 = 9508;
  e2.SF100000 = 9472;
  e2.SF110000 = 9474;
  e2.SF190000 = 9569;
  e2.SF200000 = 9570;
  e2.SF210000 = 9558;
  e2.SF220000 = 9557;
  e2.SF230000 = 9571;
  e2.SF240000 = 9553;
  e2.SF250000 = 9559;
  e2.SF260000 = 9565;
  e2.SF270000 = 9564;
  e2.SF280000 = 9563;
  e2.SF360000 = 9566;
  e2.SF370000 = 9567;
  e2.SF380000 = 9562;
  e2.SF390000 = 9556;
  e2.SF400000 = 9577;
  e2.SF410000 = 9574;
  e2.SF420000 = 9568;
  e2.SF430000 = 9552;
  e2.SF440000 = 9580;
  e2.SF450000 = 9575;
  e2.SF460000 = 9576;
  e2.SF470000 = 9572;
  e2.SF480000 = 9573;
  e2.SF490000 = 9561;
  e2.SF500000 = 9560;
  e2.SF510000 = 9554;
  e2.SF520000 = 9555;
  e2.SF530000 = 9579;
  e2.SF540000 = 9578;
  e2.Sacute = 346;
  e2.Sacutedotaccent = 7780;
  e2.Sampigreek = 992;
  e2.Scaron = 352;
  e2.Scarondotaccent = 7782;
  e2.Scaronsmall = 63229;
  e2.Scedilla = 350;
  e2.Schwa = 399;
  e2.Schwacyrillic = 1240;
  e2.Schwadieresiscyrillic = 1242;
  e2.Scircle = 9416;
  e2.Scircumflex = 348;
  e2.Scommaaccent = 536;
  e2.Sdotaccent = 7776;
  e2.Sdotbelow = 7778;
  e2.Sdotbelowdotaccent = 7784;
  e2.Seharmenian = 1357;
  e2.Sevenroman = 8550;
  e2.Shaarmenian = 1351;
  e2.Shacyrillic = 1064;
  e2.Shchacyrillic = 1065;
  e2.Sheicoptic = 994;
  e2.Shhacyrillic = 1210;
  e2.Shimacoptic = 1004;
  e2.Sigma = 931;
  e2.Sixroman = 8549;
  e2.Smonospace = 65331;
  e2.Softsigncyrillic = 1068;
  e2.Ssmall = 63347;
  e2.Stigmagreek = 986;
  e2.T = 84;
  e2.Tau = 932;
  e2.Tbar = 358;
  e2.Tcaron = 356;
  e2.Tcedilla = 354;
  e2.Tcircle = 9417;
  e2.Tcircumflexbelow = 7792;
  e2.Tcommaaccent = 354;
  e2.Tdotaccent = 7786;
  e2.Tdotbelow = 7788;
  e2.Tecyrillic = 1058;
  e2.Tedescendercyrillic = 1196;
  e2.Tenroman = 8553;
  e2.Tetsecyrillic = 1204;
  e2.Theta = 920;
  e2.Thook = 428;
  e2.Thorn = 222;
  e2.Thornsmall = 63486;
  e2.Threeroman = 8546;
  e2.Tildesmall = 63230;
  e2.Tiwnarmenian = 1359;
  e2.Tlinebelow = 7790;
  e2.Tmonospace = 65332;
  e2.Toarmenian = 1337;
  e2.Tonefive = 444;
  e2.Tonesix = 388;
  e2.Tonetwo = 423;
  e2.Tretroflexhook = 430;
  e2.Tsecyrillic = 1062;
  e2.Tshecyrillic = 1035;
  e2.Tsmall = 63348;
  e2.Twelveroman = 8555;
  e2.Tworoman = 8545;
  e2.U = 85;
  e2.Uacute = 218;
  e2.Uacutesmall = 63482;
  e2.Ubreve = 364;
  e2.Ucaron = 467;
  e2.Ucircle = 9418;
  e2.Ucircumflex = 219;
  e2.Ucircumflexbelow = 7798;
  e2.Ucircumflexsmall = 63483;
  e2.Ucyrillic = 1059;
  e2.Udblacute = 368;
  e2.Udblgrave = 532;
  e2.Udieresis = 220;
  e2.Udieresisacute = 471;
  e2.Udieresisbelow = 7794;
  e2.Udieresiscaron = 473;
  e2.Udieresiscyrillic = 1264;
  e2.Udieresisgrave = 475;
  e2.Udieresismacron = 469;
  e2.Udieresissmall = 63484;
  e2.Udotbelow = 7908;
  e2.Ugrave = 217;
  e2.Ugravesmall = 63481;
  e2.Uhookabove = 7910;
  e2.Uhorn = 431;
  e2.Uhornacute = 7912;
  e2.Uhorndotbelow = 7920;
  e2.Uhorngrave = 7914;
  e2.Uhornhookabove = 7916;
  e2.Uhorntilde = 7918;
  e2.Uhungarumlaut = 368;
  e2.Uhungarumlautcyrillic = 1266;
  e2.Uinvertedbreve = 534;
  e2.Ukcyrillic = 1144;
  e2.Umacron = 362;
  e2.Umacroncyrillic = 1262;
  e2.Umacrondieresis = 7802;
  e2.Umonospace = 65333;
  e2.Uogonek = 370;
  e2.Upsilon = 933;
  e2.Upsilon1 = 978;
  e2.Upsilonacutehooksymbolgreek = 979;
  e2.Upsilonafrican = 433;
  e2.Upsilondieresis = 939;
  e2.Upsilondieresishooksymbolgreek = 980;
  e2.Upsilonhooksymbol = 978;
  e2.Upsilontonos = 910;
  e2.Uring = 366;
  e2.Ushortcyrillic = 1038;
  e2.Usmall = 63349;
  e2.Ustraightcyrillic = 1198;
  e2.Ustraightstrokecyrillic = 1200;
  e2.Utilde = 360;
  e2.Utildeacute = 7800;
  e2.Utildebelow = 7796;
  e2.V = 86;
  e2.Vcircle = 9419;
  e2.Vdotbelow = 7806;
  e2.Vecyrillic = 1042;
  e2.Vewarmenian = 1358;
  e2.Vhook = 434;
  e2.Vmonospace = 65334;
  e2.Voarmenian = 1352;
  e2.Vsmall = 63350;
  e2.Vtilde = 7804;
  e2.W = 87;
  e2.Wacute = 7810;
  e2.Wcircle = 9420;
  e2.Wcircumflex = 372;
  e2.Wdieresis = 7812;
  e2.Wdotaccent = 7814;
  e2.Wdotbelow = 7816;
  e2.Wgrave = 7808;
  e2.Wmonospace = 65335;
  e2.Wsmall = 63351;
  e2.X = 88;
  e2.Xcircle = 9421;
  e2.Xdieresis = 7820;
  e2.Xdotaccent = 7818;
  e2.Xeharmenian = 1341;
  e2.Xi = 926;
  e2.Xmonospace = 65336;
  e2.Xsmall = 63352;
  e2.Y = 89;
  e2.Yacute = 221;
  e2.Yacutesmall = 63485;
  e2.Yatcyrillic = 1122;
  e2.Ycircle = 9422;
  e2.Ycircumflex = 374;
  e2.Ydieresis = 376;
  e2.Ydieresissmall = 63487;
  e2.Ydotaccent = 7822;
  e2.Ydotbelow = 7924;
  e2.Yericyrillic = 1067;
  e2.Yerudieresiscyrillic = 1272;
  e2.Ygrave = 7922;
  e2.Yhook = 435;
  e2.Yhookabove = 7926;
  e2.Yiarmenian = 1349;
  e2.Yicyrillic = 1031;
  e2.Yiwnarmenian = 1362;
  e2.Ymonospace = 65337;
  e2.Ysmall = 63353;
  e2.Ytilde = 7928;
  e2.Yusbigcyrillic = 1130;
  e2.Yusbigiotifiedcyrillic = 1132;
  e2.Yuslittlecyrillic = 1126;
  e2.Yuslittleiotifiedcyrillic = 1128;
  e2.Z = 90;
  e2.Zaarmenian = 1334;
  e2.Zacute = 377;
  e2.Zcaron = 381;
  e2.Zcaronsmall = 63231;
  e2.Zcircle = 9423;
  e2.Zcircumflex = 7824;
  e2.Zdot = 379;
  e2.Zdotaccent = 379;
  e2.Zdotbelow = 7826;
  e2.Zecyrillic = 1047;
  e2.Zedescendercyrillic = 1176;
  e2.Zedieresiscyrillic = 1246;
  e2.Zeta = 918;
  e2.Zhearmenian = 1338;
  e2.Zhebrevecyrillic = 1217;
  e2.Zhecyrillic = 1046;
  e2.Zhedescendercyrillic = 1174;
  e2.Zhedieresiscyrillic = 1244;
  e2.Zlinebelow = 7828;
  e2.Zmonospace = 65338;
  e2.Zsmall = 63354;
  e2.Zstroke = 437;
  e2.a = 97;
  e2.aabengali = 2438;
  e2.aacute = 225;
  e2.aadeva = 2310;
  e2.aagujarati = 2694;
  e2.aagurmukhi = 2566;
  e2.aamatragurmukhi = 2622;
  e2.aarusquare = 13059;
  e2.aavowelsignbengali = 2494;
  e2.aavowelsigndeva = 2366;
  e2.aavowelsigngujarati = 2750;
  e2.abbreviationmarkarmenian = 1375;
  e2.abbreviationsigndeva = 2416;
  e2.abengali = 2437;
  e2.abopomofo = 12570;
  e2.abreve = 259;
  e2.abreveacute = 7855;
  e2.abrevecyrillic = 1233;
  e2.abrevedotbelow = 7863;
  e2.abrevegrave = 7857;
  e2.abrevehookabove = 7859;
  e2.abrevetilde = 7861;
  e2.acaron = 462;
  e2.acircle = 9424;
  e2.acircumflex = 226;
  e2.acircumflexacute = 7845;
  e2.acircumflexdotbelow = 7853;
  e2.acircumflexgrave = 7847;
  e2.acircumflexhookabove = 7849;
  e2.acircumflextilde = 7851;
  e2.acute = 180;
  e2.acutebelowcmb = 791;
  e2.acutecmb = 769;
  e2.acutecomb = 769;
  e2.acutedeva = 2388;
  e2.acutelowmod = 719;
  e2.acutetonecmb = 833;
  e2.acyrillic = 1072;
  e2.adblgrave = 513;
  e2.addakgurmukhi = 2673;
  e2.adeva = 2309;
  e2.adieresis = 228;
  e2.adieresiscyrillic = 1235;
  e2.adieresismacron = 479;
  e2.adotbelow = 7841;
  e2.adotmacron = 481;
  e2.ae = 230;
  e2.aeacute = 509;
  e2.aekorean = 12624;
  e2.aemacron = 483;
  e2.afii00208 = 8213;
  e2.afii08941 = 8356;
  e2.afii10017 = 1040;
  e2.afii10018 = 1041;
  e2.afii10019 = 1042;
  e2.afii10020 = 1043;
  e2.afii10021 = 1044;
  e2.afii10022 = 1045;
  e2.afii10023 = 1025;
  e2.afii10024 = 1046;
  e2.afii10025 = 1047;
  e2.afii10026 = 1048;
  e2.afii10027 = 1049;
  e2.afii10028 = 1050;
  e2.afii10029 = 1051;
  e2.afii10030 = 1052;
  e2.afii10031 = 1053;
  e2.afii10032 = 1054;
  e2.afii10033 = 1055;
  e2.afii10034 = 1056;
  e2.afii10035 = 1057;
  e2.afii10036 = 1058;
  e2.afii10037 = 1059;
  e2.afii10038 = 1060;
  e2.afii10039 = 1061;
  e2.afii10040 = 1062;
  e2.afii10041 = 1063;
  e2.afii10042 = 1064;
  e2.afii10043 = 1065;
  e2.afii10044 = 1066;
  e2.afii10045 = 1067;
  e2.afii10046 = 1068;
  e2.afii10047 = 1069;
  e2.afii10048 = 1070;
  e2.afii10049 = 1071;
  e2.afii10050 = 1168;
  e2.afii10051 = 1026;
  e2.afii10052 = 1027;
  e2.afii10053 = 1028;
  e2.afii10054 = 1029;
  e2.afii10055 = 1030;
  e2.afii10056 = 1031;
  e2.afii10057 = 1032;
  e2.afii10058 = 1033;
  e2.afii10059 = 1034;
  e2.afii10060 = 1035;
  e2.afii10061 = 1036;
  e2.afii10062 = 1038;
  e2.afii10063 = 63172;
  e2.afii10064 = 63173;
  e2.afii10065 = 1072;
  e2.afii10066 = 1073;
  e2.afii10067 = 1074;
  e2.afii10068 = 1075;
  e2.afii10069 = 1076;
  e2.afii10070 = 1077;
  e2.afii10071 = 1105;
  e2.afii10072 = 1078;
  e2.afii10073 = 1079;
  e2.afii10074 = 1080;
  e2.afii10075 = 1081;
  e2.afii10076 = 1082;
  e2.afii10077 = 1083;
  e2.afii10078 = 1084;
  e2.afii10079 = 1085;
  e2.afii10080 = 1086;
  e2.afii10081 = 1087;
  e2.afii10082 = 1088;
  e2.afii10083 = 1089;
  e2.afii10084 = 1090;
  e2.afii10085 = 1091;
  e2.afii10086 = 1092;
  e2.afii10087 = 1093;
  e2.afii10088 = 1094;
  e2.afii10089 = 1095;
  e2.afii10090 = 1096;
  e2.afii10091 = 1097;
  e2.afii10092 = 1098;
  e2.afii10093 = 1099;
  e2.afii10094 = 1100;
  e2.afii10095 = 1101;
  e2.afii10096 = 1102;
  e2.afii10097 = 1103;
  e2.afii10098 = 1169;
  e2.afii10099 = 1106;
  e2.afii10100 = 1107;
  e2.afii10101 = 1108;
  e2.afii10102 = 1109;
  e2.afii10103 = 1110;
  e2.afii10104 = 1111;
  e2.afii10105 = 1112;
  e2.afii10106 = 1113;
  e2.afii10107 = 1114;
  e2.afii10108 = 1115;
  e2.afii10109 = 1116;
  e2.afii10110 = 1118;
  e2.afii10145 = 1039;
  e2.afii10146 = 1122;
  e2.afii10147 = 1138;
  e2.afii10148 = 1140;
  e2.afii10192 = 63174;
  e2.afii10193 = 1119;
  e2.afii10194 = 1123;
  e2.afii10195 = 1139;
  e2.afii10196 = 1141;
  e2.afii10831 = 63175;
  e2.afii10832 = 63176;
  e2.afii10846 = 1241;
  e2.afii299 = 8206;
  e2.afii300 = 8207;
  e2.afii301 = 8205;
  e2.afii57381 = 1642;
  e2.afii57388 = 1548;
  e2.afii57392 = 1632;
  e2.afii57393 = 1633;
  e2.afii57394 = 1634;
  e2.afii57395 = 1635;
  e2.afii57396 = 1636;
  e2.afii57397 = 1637;
  e2.afii57398 = 1638;
  e2.afii57399 = 1639;
  e2.afii57400 = 1640;
  e2.afii57401 = 1641;
  e2.afii57403 = 1563;
  e2.afii57407 = 1567;
  e2.afii57409 = 1569;
  e2.afii57410 = 1570;
  e2.afii57411 = 1571;
  e2.afii57412 = 1572;
  e2.afii57413 = 1573;
  e2.afii57414 = 1574;
  e2.afii57415 = 1575;
  e2.afii57416 = 1576;
  e2.afii57417 = 1577;
  e2.afii57418 = 1578;
  e2.afii57419 = 1579;
  e2.afii57420 = 1580;
  e2.afii57421 = 1581;
  e2.afii57422 = 1582;
  e2.afii57423 = 1583;
  e2.afii57424 = 1584;
  e2.afii57425 = 1585;
  e2.afii57426 = 1586;
  e2.afii57427 = 1587;
  e2.afii57428 = 1588;
  e2.afii57429 = 1589;
  e2.afii57430 = 1590;
  e2.afii57431 = 1591;
  e2.afii57432 = 1592;
  e2.afii57433 = 1593;
  e2.afii57434 = 1594;
  e2.afii57440 = 1600;
  e2.afii57441 = 1601;
  e2.afii57442 = 1602;
  e2.afii57443 = 1603;
  e2.afii57444 = 1604;
  e2.afii57445 = 1605;
  e2.afii57446 = 1606;
  e2.afii57448 = 1608;
  e2.afii57449 = 1609;
  e2.afii57450 = 1610;
  e2.afii57451 = 1611;
  e2.afii57452 = 1612;
  e2.afii57453 = 1613;
  e2.afii57454 = 1614;
  e2.afii57455 = 1615;
  e2.afii57456 = 1616;
  e2.afii57457 = 1617;
  e2.afii57458 = 1618;
  e2.afii57470 = 1607;
  e2.afii57505 = 1700;
  e2.afii57506 = 1662;
  e2.afii57507 = 1670;
  e2.afii57508 = 1688;
  e2.afii57509 = 1711;
  e2.afii57511 = 1657;
  e2.afii57512 = 1672;
  e2.afii57513 = 1681;
  e2.afii57514 = 1722;
  e2.afii57519 = 1746;
  e2.afii57534 = 1749;
  e2.afii57636 = 8362;
  e2.afii57645 = 1470;
  e2.afii57658 = 1475;
  e2.afii57664 = 1488;
  e2.afii57665 = 1489;
  e2.afii57666 = 1490;
  e2.afii57667 = 1491;
  e2.afii57668 = 1492;
  e2.afii57669 = 1493;
  e2.afii57670 = 1494;
  e2.afii57671 = 1495;
  e2.afii57672 = 1496;
  e2.afii57673 = 1497;
  e2.afii57674 = 1498;
  e2.afii57675 = 1499;
  e2.afii57676 = 1500;
  e2.afii57677 = 1501;
  e2.afii57678 = 1502;
  e2.afii57679 = 1503;
  e2.afii57680 = 1504;
  e2.afii57681 = 1505;
  e2.afii57682 = 1506;
  e2.afii57683 = 1507;
  e2.afii57684 = 1508;
  e2.afii57685 = 1509;
  e2.afii57686 = 1510;
  e2.afii57687 = 1511;
  e2.afii57688 = 1512;
  e2.afii57689 = 1513;
  e2.afii57690 = 1514;
  e2.afii57694 = 64298;
  e2.afii57695 = 64299;
  e2.afii57700 = 64331;
  e2.afii57705 = 64287;
  e2.afii57716 = 1520;
  e2.afii57717 = 1521;
  e2.afii57718 = 1522;
  e2.afii57723 = 64309;
  e2.afii57793 = 1460;
  e2.afii57794 = 1461;
  e2.afii57795 = 1462;
  e2.afii57796 = 1467;
  e2.afii57797 = 1464;
  e2.afii57798 = 1463;
  e2.afii57799 = 1456;
  e2.afii57800 = 1458;
  e2.afii57801 = 1457;
  e2.afii57802 = 1459;
  e2.afii57803 = 1474;
  e2.afii57804 = 1473;
  e2.afii57806 = 1465;
  e2.afii57807 = 1468;
  e2.afii57839 = 1469;
  e2.afii57841 = 1471;
  e2.afii57842 = 1472;
  e2.afii57929 = 700;
  e2.afii61248 = 8453;
  e2.afii61289 = 8467;
  e2.afii61352 = 8470;
  e2.afii61573 = 8236;
  e2.afii61574 = 8237;
  e2.afii61575 = 8238;
  e2.afii61664 = 8204;
  e2.afii63167 = 1645;
  e2.afii64937 = 701;
  e2.agrave = 224;
  e2.agujarati = 2693;
  e2.agurmukhi = 2565;
  e2.ahiragana = 12354;
  e2.ahookabove = 7843;
  e2.aibengali = 2448;
  e2.aibopomofo = 12574;
  e2.aideva = 2320;
  e2.aiecyrillic = 1237;
  e2.aigujarati = 2704;
  e2.aigurmukhi = 2576;
  e2.aimatragurmukhi = 2632;
  e2.ainarabic = 1593;
  e2.ainfinalarabic = 65226;
  e2.aininitialarabic = 65227;
  e2.ainmedialarabic = 65228;
  e2.ainvertedbreve = 515;
  e2.aivowelsignbengali = 2504;
  e2.aivowelsigndeva = 2376;
  e2.aivowelsigngujarati = 2760;
  e2.akatakana = 12450;
  e2.akatakanahalfwidth = 65393;
  e2.akorean = 12623;
  e2.alef = 1488;
  e2.alefarabic = 1575;
  e2.alefdageshhebrew = 64304;
  e2.aleffinalarabic = 65166;
  e2.alefhamzaabovearabic = 1571;
  e2.alefhamzaabovefinalarabic = 65156;
  e2.alefhamzabelowarabic = 1573;
  e2.alefhamzabelowfinalarabic = 65160;
  e2.alefhebrew = 1488;
  e2.aleflamedhebrew = 64335;
  e2.alefmaddaabovearabic = 1570;
  e2.alefmaddaabovefinalarabic = 65154;
  e2.alefmaksuraarabic = 1609;
  e2.alefmaksurafinalarabic = 65264;
  e2.alefmaksurainitialarabic = 65267;
  e2.alefmaksuramedialarabic = 65268;
  e2.alefpatahhebrew = 64302;
  e2.alefqamatshebrew = 64303;
  e2.aleph = 8501;
  e2.allequal = 8780;
  e2.alpha = 945;
  e2.alphatonos = 940;
  e2.amacron = 257;
  e2.amonospace = 65345;
  e2.ampersand = 38;
  e2.ampersandmonospace = 65286;
  e2.ampersandsmall = 63270;
  e2.amsquare = 13250;
  e2.anbopomofo = 12578;
  e2.angbopomofo = 12580;
  e2.angbracketleft = 12296;
  e2.angbracketright = 12297;
  e2.angkhankhuthai = 3674;
  e2.angle = 8736;
  e2.anglebracketleft = 12296;
  e2.anglebracketleftvertical = 65087;
  e2.anglebracketright = 12297;
  e2.anglebracketrightvertical = 65088;
  e2.angleleft = 9001;
  e2.angleright = 9002;
  e2.angstrom = 8491;
  e2.anoteleia = 903;
  e2.anudattadeva = 2386;
  e2.anusvarabengali = 2434;
  e2.anusvaradeva = 2306;
  e2.anusvaragujarati = 2690;
  e2.aogonek = 261;
  e2.apaatosquare = 13056;
  e2.aparen = 9372;
  e2.apostrophearmenian = 1370;
  e2.apostrophemod = 700;
  e2.apple = 63743;
  e2.approaches = 8784;
  e2.approxequal = 8776;
  e2.approxequalorimage = 8786;
  e2.approximatelyequal = 8773;
  e2.araeaekorean = 12686;
  e2.araeakorean = 12685;
  e2.arc = 8978;
  e2.arighthalfring = 7834;
  e2.aring = 229;
  e2.aringacute = 507;
  e2.aringbelow = 7681;
  e2.arrowboth = 8596;
  e2.arrowdashdown = 8675;
  e2.arrowdashleft = 8672;
  e2.arrowdashright = 8674;
  e2.arrowdashup = 8673;
  e2.arrowdblboth = 8660;
  e2.arrowdbldown = 8659;
  e2.arrowdblleft = 8656;
  e2.arrowdblright = 8658;
  e2.arrowdblup = 8657;
  e2.arrowdown = 8595;
  e2.arrowdownleft = 8601;
  e2.arrowdownright = 8600;
  e2.arrowdownwhite = 8681;
  e2.arrowheaddownmod = 709;
  e2.arrowheadleftmod = 706;
  e2.arrowheadrightmod = 707;
  e2.arrowheadupmod = 708;
  e2.arrowhorizex = 63719;
  e2.arrowleft = 8592;
  e2.arrowleftdbl = 8656;
  e2.arrowleftdblstroke = 8653;
  e2.arrowleftoverright = 8646;
  e2.arrowleftwhite = 8678;
  e2.arrowright = 8594;
  e2.arrowrightdblstroke = 8655;
  e2.arrowrightheavy = 10142;
  e2.arrowrightoverleft = 8644;
  e2.arrowrightwhite = 8680;
  e2.arrowtableft = 8676;
  e2.arrowtabright = 8677;
  e2.arrowup = 8593;
  e2.arrowupdn = 8597;
  e2.arrowupdnbse = 8616;
  e2.arrowupdownbase = 8616;
  e2.arrowupleft = 8598;
  e2.arrowupleftofdown = 8645;
  e2.arrowupright = 8599;
  e2.arrowupwhite = 8679;
  e2.arrowvertex = 63718;
  e2.asciicircum = 94;
  e2.asciicircummonospace = 65342;
  e2.asciitilde = 126;
  e2.asciitildemonospace = 65374;
  e2.ascript = 593;
  e2.ascriptturned = 594;
  e2.asmallhiragana = 12353;
  e2.asmallkatakana = 12449;
  e2.asmallkatakanahalfwidth = 65383;
  e2.asterisk = 42;
  e2.asteriskaltonearabic = 1645;
  e2.asteriskarabic = 1645;
  e2.asteriskmath = 8727;
  e2.asteriskmonospace = 65290;
  e2.asterisksmall = 65121;
  e2.asterism = 8258;
  e2.asuperior = 63209;
  e2.asymptoticallyequal = 8771;
  e2.at = 64;
  e2.atilde = 227;
  e2.atmonospace = 65312;
  e2.atsmall = 65131;
  e2.aturned = 592;
  e2.aubengali = 2452;
  e2.aubopomofo = 12576;
  e2.audeva = 2324;
  e2.augujarati = 2708;
  e2.augurmukhi = 2580;
  e2.aulengthmarkbengali = 2519;
  e2.aumatragurmukhi = 2636;
  e2.auvowelsignbengali = 2508;
  e2.auvowelsigndeva = 2380;
  e2.auvowelsigngujarati = 2764;
  e2.avagrahadeva = 2365;
  e2.aybarmenian = 1377;
  e2.ayin = 1506;
  e2.ayinaltonehebrew = 64288;
  e2.ayinhebrew = 1506;
  e2.b = 98;
  e2.babengali = 2476;
  e2.backslash = 92;
  e2.backslashmonospace = 65340;
  e2.badeva = 2348;
  e2.bagujarati = 2732;
  e2.bagurmukhi = 2604;
  e2.bahiragana = 12400;
  e2.bahtthai = 3647;
  e2.bakatakana = 12496;
  e2.bar = 124;
  e2.barmonospace = 65372;
  e2.bbopomofo = 12549;
  e2.bcircle = 9425;
  e2.bdotaccent = 7683;
  e2.bdotbelow = 7685;
  e2.beamedsixteenthnotes = 9836;
  e2.because = 8757;
  e2.becyrillic = 1073;
  e2.beharabic = 1576;
  e2.behfinalarabic = 65168;
  e2.behinitialarabic = 65169;
  e2.behiragana = 12409;
  e2.behmedialarabic = 65170;
  e2.behmeeminitialarabic = 64671;
  e2.behmeemisolatedarabic = 64520;
  e2.behnoonfinalarabic = 64621;
  e2.bekatakana = 12505;
  e2.benarmenian = 1378;
  e2.bet = 1489;
  e2.beta = 946;
  e2.betasymbolgreek = 976;
  e2.betdagesh = 64305;
  e2.betdageshhebrew = 64305;
  e2.bethebrew = 1489;
  e2.betrafehebrew = 64332;
  e2.bhabengali = 2477;
  e2.bhadeva = 2349;
  e2.bhagujarati = 2733;
  e2.bhagurmukhi = 2605;
  e2.bhook = 595;
  e2.bihiragana = 12403;
  e2.bikatakana = 12499;
  e2.bilabialclick = 664;
  e2.bindigurmukhi = 2562;
  e2.birusquare = 13105;
  e2.blackcircle = 9679;
  e2.blackdiamond = 9670;
  e2.blackdownpointingtriangle = 9660;
  e2.blackleftpointingpointer = 9668;
  e2.blackleftpointingtriangle = 9664;
  e2.blacklenticularbracketleft = 12304;
  e2.blacklenticularbracketleftvertical = 65083;
  e2.blacklenticularbracketright = 12305;
  e2.blacklenticularbracketrightvertical = 65084;
  e2.blacklowerlefttriangle = 9699;
  e2.blacklowerrighttriangle = 9698;
  e2.blackrectangle = 9644;
  e2.blackrightpointingpointer = 9658;
  e2.blackrightpointingtriangle = 9654;
  e2.blacksmallsquare = 9642;
  e2.blacksmilingface = 9787;
  e2.blacksquare = 9632;
  e2.blackstar = 9733;
  e2.blackupperlefttriangle = 9700;
  e2.blackupperrighttriangle = 9701;
  e2.blackuppointingsmalltriangle = 9652;
  e2.blackuppointingtriangle = 9650;
  e2.blank = 9251;
  e2.blinebelow = 7687;
  e2.block = 9608;
  e2.bmonospace = 65346;
  e2.bobaimaithai = 3610;
  e2.bohiragana = 12412;
  e2.bokatakana = 12508;
  e2.bparen = 9373;
  e2.bqsquare = 13251;
  e2.braceex = 63732;
  e2.braceleft = 123;
  e2.braceleftbt = 63731;
  e2.braceleftmid = 63730;
  e2.braceleftmonospace = 65371;
  e2.braceleftsmall = 65115;
  e2.bracelefttp = 63729;
  e2.braceleftvertical = 65079;
  e2.braceright = 125;
  e2.bracerightbt = 63742;
  e2.bracerightmid = 63741;
  e2.bracerightmonospace = 65373;
  e2.bracerightsmall = 65116;
  e2.bracerighttp = 63740;
  e2.bracerightvertical = 65080;
  e2.bracketleft = 91;
  e2.bracketleftbt = 63728;
  e2.bracketleftex = 63727;
  e2.bracketleftmonospace = 65339;
  e2.bracketlefttp = 63726;
  e2.bracketright = 93;
  e2.bracketrightbt = 63739;
  e2.bracketrightex = 63738;
  e2.bracketrightmonospace = 65341;
  e2.bracketrighttp = 63737;
  e2.breve = 728;
  e2.brevebelowcmb = 814;
  e2.brevecmb = 774;
  e2.breveinvertedbelowcmb = 815;
  e2.breveinvertedcmb = 785;
  e2.breveinverteddoublecmb = 865;
  e2.bridgebelowcmb = 810;
  e2.bridgeinvertedbelowcmb = 826;
  e2.brokenbar = 166;
  e2.bstroke = 384;
  e2.bsuperior = 63210;
  e2.btopbar = 387;
  e2.buhiragana = 12406;
  e2.bukatakana = 12502;
  e2.bullet = 8226;
  e2.bulletinverse = 9688;
  e2.bulletoperator = 8729;
  e2.bullseye = 9678;
  e2.c = 99;
  e2.caarmenian = 1390;
  e2.cabengali = 2458;
  e2.cacute = 263;
  e2.cadeva = 2330;
  e2.cagujarati = 2714;
  e2.cagurmukhi = 2586;
  e2.calsquare = 13192;
  e2.candrabindubengali = 2433;
  e2.candrabinducmb = 784;
  e2.candrabindudeva = 2305;
  e2.candrabindugujarati = 2689;
  e2.capslock = 8682;
  e2.careof = 8453;
  e2.caron = 711;
  e2.caronbelowcmb = 812;
  e2.caroncmb = 780;
  e2.carriagereturn = 8629;
  e2.cbopomofo = 12568;
  e2.ccaron = 269;
  e2.ccedilla = 231;
  e2.ccedillaacute = 7689;
  e2.ccircle = 9426;
  e2.ccircumflex = 265;
  e2.ccurl = 597;
  e2.cdot = 267;
  e2.cdotaccent = 267;
  e2.cdsquare = 13253;
  e2.cedilla = 184;
  e2.cedillacmb = 807;
  e2.cent = 162;
  e2.centigrade = 8451;
  e2.centinferior = 63199;
  e2.centmonospace = 65504;
  e2.centoldstyle = 63394;
  e2.centsuperior = 63200;
  e2.chaarmenian = 1401;
  e2.chabengali = 2459;
  e2.chadeva = 2331;
  e2.chagujarati = 2715;
  e2.chagurmukhi = 2587;
  e2.chbopomofo = 12564;
  e2.cheabkhasiancyrillic = 1213;
  e2.checkmark = 10003;
  e2.checyrillic = 1095;
  e2.chedescenderabkhasiancyrillic = 1215;
  e2.chedescendercyrillic = 1207;
  e2.chedieresiscyrillic = 1269;
  e2.cheharmenian = 1395;
  e2.chekhakassiancyrillic = 1228;
  e2.cheverticalstrokecyrillic = 1209;
  e2.chi = 967;
  e2.chieuchacirclekorean = 12919;
  e2.chieuchaparenkorean = 12823;
  e2.chieuchcirclekorean = 12905;
  e2.chieuchkorean = 12618;
  e2.chieuchparenkorean = 12809;
  e2.chochangthai = 3594;
  e2.chochanthai = 3592;
  e2.chochingthai = 3593;
  e2.chochoethai = 3596;
  e2.chook = 392;
  e2.cieucacirclekorean = 12918;
  e2.cieucaparenkorean = 12822;
  e2.cieuccirclekorean = 12904;
  e2.cieuckorean = 12616;
  e2.cieucparenkorean = 12808;
  e2.cieucuparenkorean = 12828;
  e2.circle = 9675;
  e2.circlecopyrt = 169;
  e2.circlemultiply = 8855;
  e2.circleot = 8857;
  e2.circleplus = 8853;
  e2.circlepostalmark = 12342;
  e2.circlewithlefthalfblack = 9680;
  e2.circlewithrighthalfblack = 9681;
  e2.circumflex = 710;
  e2.circumflexbelowcmb = 813;
  e2.circumflexcmb = 770;
  e2.clear = 8999;
  e2.clickalveolar = 450;
  e2.clickdental = 448;
  e2.clicklateral = 449;
  e2.clickretroflex = 451;
  e2.club = 9827;
  e2.clubsuitblack = 9827;
  e2.clubsuitwhite = 9831;
  e2.cmcubedsquare = 13220;
  e2.cmonospace = 65347;
  e2.cmsquaredsquare = 13216;
  e2.coarmenian = 1409;
  e2.colon = 58;
  e2.colonmonetary = 8353;
  e2.colonmonospace = 65306;
  e2.colonsign = 8353;
  e2.colonsmall = 65109;
  e2.colontriangularhalfmod = 721;
  e2.colontriangularmod = 720;
  e2.comma = 44;
  e2.commaabovecmb = 787;
  e2.commaaboverightcmb = 789;
  e2.commaaccent = 63171;
  e2.commaarabic = 1548;
  e2.commaarmenian = 1373;
  e2.commainferior = 63201;
  e2.commamonospace = 65292;
  e2.commareversedabovecmb = 788;
  e2.commareversedmod = 701;
  e2.commasmall = 65104;
  e2.commasuperior = 63202;
  e2.commaturnedabovecmb = 786;
  e2.commaturnedmod = 699;
  e2.compass = 9788;
  e2.congruent = 8773;
  e2.contourintegral = 8750;
  e2.control = 8963;
  e2.controlACK = 6;
  e2.controlBEL = 7;
  e2.controlBS = 8;
  e2.controlCAN = 24;
  e2.controlCR = 13;
  e2.controlDC1 = 17;
  e2.controlDC2 = 18;
  e2.controlDC3 = 19;
  e2.controlDC4 = 20;
  e2.controlDEL = 127;
  e2.controlDLE = 16;
  e2.controlEM = 25;
  e2.controlENQ = 5;
  e2.controlEOT = 4;
  e2.controlESC = 27;
  e2.controlETB = 23;
  e2.controlETX = 3;
  e2.controlFF = 12;
  e2.controlFS = 28;
  e2.controlGS = 29;
  e2.controlHT = 9;
  e2.controlLF = 10;
  e2.controlNAK = 21;
  e2.controlNULL = 0;
  e2.controlRS = 30;
  e2.controlSI = 15;
  e2.controlSO = 14;
  e2.controlSOT = 2;
  e2.controlSTX = 1;
  e2.controlSUB = 26;
  e2.controlSYN = 22;
  e2.controlUS = 31;
  e2.controlVT = 11;
  e2.copyright = 169;
  e2.copyrightsans = 63721;
  e2.copyrightserif = 63193;
  e2.cornerbracketleft = 12300;
  e2.cornerbracketlefthalfwidth = 65378;
  e2.cornerbracketleftvertical = 65089;
  e2.cornerbracketright = 12301;
  e2.cornerbracketrighthalfwidth = 65379;
  e2.cornerbracketrightvertical = 65090;
  e2.corporationsquare = 13183;
  e2.cosquare = 13255;
  e2.coverkgsquare = 13254;
  e2.cparen = 9374;
  e2.cruzeiro = 8354;
  e2.cstretched = 663;
  e2.curlyand = 8911;
  e2.curlyor = 8910;
  e2.currency = 164;
  e2.cyrBreve = 63185;
  e2.cyrFlex = 63186;
  e2.cyrbreve = 63188;
  e2.cyrflex = 63189;
  e2.d = 100;
  e2.daarmenian = 1380;
  e2.dabengali = 2470;
  e2.dadarabic = 1590;
  e2.dadeva = 2342;
  e2.dadfinalarabic = 65214;
  e2.dadinitialarabic = 65215;
  e2.dadmedialarabic = 65216;
  e2.dagesh = 1468;
  e2.dageshhebrew = 1468;
  e2.dagger = 8224;
  e2.daggerdbl = 8225;
  e2.dagujarati = 2726;
  e2.dagurmukhi = 2598;
  e2.dahiragana = 12384;
  e2.dakatakana = 12480;
  e2.dalarabic = 1583;
  e2.dalet = 1491;
  e2.daletdagesh = 64307;
  e2.daletdageshhebrew = 64307;
  e2.dalethebrew = 1491;
  e2.dalfinalarabic = 65194;
  e2.dammaarabic = 1615;
  e2.dammalowarabic = 1615;
  e2.dammatanaltonearabic = 1612;
  e2.dammatanarabic = 1612;
  e2.danda = 2404;
  e2.dargahebrew = 1447;
  e2.dargalefthebrew = 1447;
  e2.dasiapneumatacyrilliccmb = 1157;
  e2.dblGrave = 63187;
  e2.dblanglebracketleft = 12298;
  e2.dblanglebracketleftvertical = 65085;
  e2.dblanglebracketright = 12299;
  e2.dblanglebracketrightvertical = 65086;
  e2.dblarchinvertedbelowcmb = 811;
  e2.dblarrowleft = 8660;
  e2.dblarrowright = 8658;
  e2.dbldanda = 2405;
  e2.dblgrave = 63190;
  e2.dblgravecmb = 783;
  e2.dblintegral = 8748;
  e2.dbllowline = 8215;
  e2.dbllowlinecmb = 819;
  e2.dbloverlinecmb = 831;
  e2.dblprimemod = 698;
  e2.dblverticalbar = 8214;
  e2.dblverticallineabovecmb = 782;
  e2.dbopomofo = 12553;
  e2.dbsquare = 13256;
  e2.dcaron = 271;
  e2.dcedilla = 7697;
  e2.dcircle = 9427;
  e2.dcircumflexbelow = 7699;
  e2.dcroat = 273;
  e2.ddabengali = 2465;
  e2.ddadeva = 2337;
  e2.ddagujarati = 2721;
  e2.ddagurmukhi = 2593;
  e2.ddalarabic = 1672;
  e2.ddalfinalarabic = 64393;
  e2.dddhadeva = 2396;
  e2.ddhabengali = 2466;
  e2.ddhadeva = 2338;
  e2.ddhagujarati = 2722;
  e2.ddhagurmukhi = 2594;
  e2.ddotaccent = 7691;
  e2.ddotbelow = 7693;
  e2.decimalseparatorarabic = 1643;
  e2.decimalseparatorpersian = 1643;
  e2.decyrillic = 1076;
  e2.degree = 176;
  e2.dehihebrew = 1453;
  e2.dehiragana = 12391;
  e2.deicoptic = 1007;
  e2.dekatakana = 12487;
  e2.deleteleft = 9003;
  e2.deleteright = 8998;
  e2.delta = 948;
  e2.deltaturned = 397;
  e2.denominatorminusonenumeratorbengali = 2552;
  e2.dezh = 676;
  e2.dhabengali = 2471;
  e2.dhadeva = 2343;
  e2.dhagujarati = 2727;
  e2.dhagurmukhi = 2599;
  e2.dhook = 599;
  e2.dialytikatonos = 901;
  e2.dialytikatonoscmb = 836;
  e2.diamond = 9830;
  e2.diamondsuitwhite = 9826;
  e2.dieresis = 168;
  e2.dieresisacute = 63191;
  e2.dieresisbelowcmb = 804;
  e2.dieresiscmb = 776;
  e2.dieresisgrave = 63192;
  e2.dieresistonos = 901;
  e2.dihiragana = 12386;
  e2.dikatakana = 12482;
  e2.dittomark = 12291;
  e2.divide = 247;
  e2.divides = 8739;
  e2.divisionslash = 8725;
  e2.djecyrillic = 1106;
  e2.dkshade = 9619;
  e2.dlinebelow = 7695;
  e2.dlsquare = 13207;
  e2.dmacron = 273;
  e2.dmonospace = 65348;
  e2.dnblock = 9604;
  e2.dochadathai = 3598;
  e2.dodekthai = 3604;
  e2.dohiragana = 12393;
  e2.dokatakana = 12489;
  e2.dollar = 36;
  e2.dollarinferior = 63203;
  e2.dollarmonospace = 65284;
  e2.dollaroldstyle = 63268;
  e2.dollarsmall = 65129;
  e2.dollarsuperior = 63204;
  e2.dong = 8363;
  e2.dorusquare = 13094;
  e2.dotaccent = 729;
  e2.dotaccentcmb = 775;
  e2.dotbelowcmb = 803;
  e2.dotbelowcomb = 803;
  e2.dotkatakana = 12539;
  e2.dotlessi = 305;
  e2.dotlessj = 63166;
  e2.dotlessjstrokehook = 644;
  e2.dotmath = 8901;
  e2.dottedcircle = 9676;
  e2.doubleyodpatah = 64287;
  e2.doubleyodpatahhebrew = 64287;
  e2.downtackbelowcmb = 798;
  e2.downtackmod = 725;
  e2.dparen = 9375;
  e2.dsuperior = 63211;
  e2.dtail = 598;
  e2.dtopbar = 396;
  e2.duhiragana = 12389;
  e2.dukatakana = 12485;
  e2.dz = 499;
  e2.dzaltone = 675;
  e2.dzcaron = 454;
  e2.dzcurl = 677;
  e2.dzeabkhasiancyrillic = 1249;
  e2.dzecyrillic = 1109;
  e2.dzhecyrillic = 1119;
  e2.e = 101;
  e2.eacute = 233;
  e2.earth = 9793;
  e2.ebengali = 2447;
  e2.ebopomofo = 12572;
  e2.ebreve = 277;
  e2.ecandradeva = 2317;
  e2.ecandragujarati = 2701;
  e2.ecandravowelsigndeva = 2373;
  e2.ecandravowelsigngujarati = 2757;
  e2.ecaron = 283;
  e2.ecedillabreve = 7709;
  e2.echarmenian = 1381;
  e2.echyiwnarmenian = 1415;
  e2.ecircle = 9428;
  e2.ecircumflex = 234;
  e2.ecircumflexacute = 7871;
  e2.ecircumflexbelow = 7705;
  e2.ecircumflexdotbelow = 7879;
  e2.ecircumflexgrave = 7873;
  e2.ecircumflexhookabove = 7875;
  e2.ecircumflextilde = 7877;
  e2.ecyrillic = 1108;
  e2.edblgrave = 517;
  e2.edeva = 2319;
  e2.edieresis = 235;
  e2.edot = 279;
  e2.edotaccent = 279;
  e2.edotbelow = 7865;
  e2.eegurmukhi = 2575;
  e2.eematragurmukhi = 2631;
  e2.efcyrillic = 1092;
  e2.egrave = 232;
  e2.egujarati = 2703;
  e2.eharmenian = 1383;
  e2.ehbopomofo = 12573;
  e2.ehiragana = 12360;
  e2.ehookabove = 7867;
  e2.eibopomofo = 12575;
  e2.eight = 56;
  e2.eightarabic = 1640;
  e2.eightbengali = 2542;
  e2.eightcircle = 9319;
  e2.eightcircleinversesansserif = 10129;
  e2.eightdeva = 2414;
  e2.eighteencircle = 9329;
  e2.eighteenparen = 9349;
  e2.eighteenperiod = 9369;
  e2.eightgujarati = 2798;
  e2.eightgurmukhi = 2670;
  e2.eighthackarabic = 1640;
  e2.eighthangzhou = 12328;
  e2.eighthnotebeamed = 9835;
  e2.eightideographicparen = 12839;
  e2.eightinferior = 8328;
  e2.eightmonospace = 65304;
  e2.eightoldstyle = 63288;
  e2.eightparen = 9339;
  e2.eightperiod = 9359;
  e2.eightpersian = 1784;
  e2.eightroman = 8567;
  e2.eightsuperior = 8312;
  e2.eightthai = 3672;
  e2.einvertedbreve = 519;
  e2.eiotifiedcyrillic = 1125;
  e2.ekatakana = 12456;
  e2.ekatakanahalfwidth = 65396;
  e2.ekonkargurmukhi = 2676;
  e2.ekorean = 12628;
  e2.elcyrillic = 1083;
  e2.element = 8712;
  e2.elevencircle = 9322;
  e2.elevenparen = 9342;
  e2.elevenperiod = 9362;
  e2.elevenroman = 8570;
  e2.ellipsis = 8230;
  e2.ellipsisvertical = 8942;
  e2.emacron = 275;
  e2.emacronacute = 7703;
  e2.emacrongrave = 7701;
  e2.emcyrillic = 1084;
  e2.emdash = 8212;
  e2.emdashvertical = 65073;
  e2.emonospace = 65349;
  e2.emphasismarkarmenian = 1371;
  e2.emptyset = 8709;
  e2.enbopomofo = 12579;
  e2.encyrillic = 1085;
  e2.endash = 8211;
  e2.endashvertical = 65074;
  e2.endescendercyrillic = 1187;
  e2.eng = 331;
  e2.engbopomofo = 12581;
  e2.enghecyrillic = 1189;
  e2.enhookcyrillic = 1224;
  e2.enspace = 8194;
  e2.eogonek = 281;
  e2.eokorean = 12627;
  e2.eopen = 603;
  e2.eopenclosed = 666;
  e2.eopenreversed = 604;
  e2.eopenreversedclosed = 606;
  e2.eopenreversedhook = 605;
  e2.eparen = 9376;
  e2.epsilon = 949;
  e2.epsilontonos = 941;
  e2.equal = 61;
  e2.equalmonospace = 65309;
  e2.equalsmall = 65126;
  e2.equalsuperior = 8316;
  e2.equivalence = 8801;
  e2.erbopomofo = 12582;
  e2.ercyrillic = 1088;
  e2.ereversed = 600;
  e2.ereversedcyrillic = 1101;
  e2.escyrillic = 1089;
  e2.esdescendercyrillic = 1195;
  e2.esh = 643;
  e2.eshcurl = 646;
  e2.eshortdeva = 2318;
  e2.eshortvowelsigndeva = 2374;
  e2.eshreversedloop = 426;
  e2.eshsquatreversed = 645;
  e2.esmallhiragana = 12359;
  e2.esmallkatakana = 12455;
  e2.esmallkatakanahalfwidth = 65386;
  e2.estimated = 8494;
  e2.esuperior = 63212;
  e2.eta = 951;
  e2.etarmenian = 1384;
  e2.etatonos = 942;
  e2.eth = 240;
  e2.etilde = 7869;
  e2.etildebelow = 7707;
  e2.etnahtafoukhhebrew = 1425;
  e2.etnahtafoukhlefthebrew = 1425;
  e2.etnahtahebrew = 1425;
  e2.etnahtalefthebrew = 1425;
  e2.eturned = 477;
  e2.eukorean = 12641;
  e2.euro = 8364;
  e2.evowelsignbengali = 2503;
  e2.evowelsigndeva = 2375;
  e2.evowelsigngujarati = 2759;
  e2.exclam = 33;
  e2.exclamarmenian = 1372;
  e2.exclamdbl = 8252;
  e2.exclamdown = 161;
  e2.exclamdownsmall = 63393;
  e2.exclammonospace = 65281;
  e2.exclamsmall = 63265;
  e2.existential = 8707;
  e2.ezh = 658;
  e2.ezhcaron = 495;
  e2.ezhcurl = 659;
  e2.ezhreversed = 441;
  e2.ezhtail = 442;
  e2.f = 102;
  e2.fadeva = 2398;
  e2.fagurmukhi = 2654;
  e2.fahrenheit = 8457;
  e2.fathaarabic = 1614;
  e2.fathalowarabic = 1614;
  e2.fathatanarabic = 1611;
  e2.fbopomofo = 12552;
  e2.fcircle = 9429;
  e2.fdotaccent = 7711;
  e2.feharabic = 1601;
  e2.feharmenian = 1414;
  e2.fehfinalarabic = 65234;
  e2.fehinitialarabic = 65235;
  e2.fehmedialarabic = 65236;
  e2.feicoptic = 997;
  e2.female = 9792;
  e2.ff = 64256;
  e2.f_f = 64256;
  e2.ffi = 64259;
  e2.f_f_i = 64259;
  e2.ffl = 64260;
  e2.f_f_l = 64260;
  e2.fi = 64257;
  e2.f_i = 64257;
  e2.fifteencircle = 9326;
  e2.fifteenparen = 9346;
  e2.fifteenperiod = 9366;
  e2.figuredash = 8210;
  e2.filledbox = 9632;
  e2.filledrect = 9644;
  e2.finalkaf = 1498;
  e2.finalkafdagesh = 64314;
  e2.finalkafdageshhebrew = 64314;
  e2.finalkafhebrew = 1498;
  e2.finalmem = 1501;
  e2.finalmemhebrew = 1501;
  e2.finalnun = 1503;
  e2.finalnunhebrew = 1503;
  e2.finalpe = 1507;
  e2.finalpehebrew = 1507;
  e2.finaltsadi = 1509;
  e2.finaltsadihebrew = 1509;
  e2.firsttonechinese = 713;
  e2.fisheye = 9673;
  e2.fitacyrillic = 1139;
  e2.five = 53;
  e2.fivearabic = 1637;
  e2.fivebengali = 2539;
  e2.fivecircle = 9316;
  e2.fivecircleinversesansserif = 10126;
  e2.fivedeva = 2411;
  e2.fiveeighths = 8541;
  e2.fivegujarati = 2795;
  e2.fivegurmukhi = 2667;
  e2.fivehackarabic = 1637;
  e2.fivehangzhou = 12325;
  e2.fiveideographicparen = 12836;
  e2.fiveinferior = 8325;
  e2.fivemonospace = 65301;
  e2.fiveoldstyle = 63285;
  e2.fiveparen = 9336;
  e2.fiveperiod = 9356;
  e2.fivepersian = 1781;
  e2.fiveroman = 8564;
  e2.fivesuperior = 8309;
  e2.fivethai = 3669;
  e2.fl = 64258;
  e2.f_l = 64258;
  e2.florin = 402;
  e2.fmonospace = 65350;
  e2.fmsquare = 13209;
  e2.fofanthai = 3615;
  e2.fofathai = 3613;
  e2.fongmanthai = 3663;
  e2.forall = 8704;
  e2.four = 52;
  e2.fourarabic = 1636;
  e2.fourbengali = 2538;
  e2.fourcircle = 9315;
  e2.fourcircleinversesansserif = 10125;
  e2.fourdeva = 2410;
  e2.fourgujarati = 2794;
  e2.fourgurmukhi = 2666;
  e2.fourhackarabic = 1636;
  e2.fourhangzhou = 12324;
  e2.fourideographicparen = 12835;
  e2.fourinferior = 8324;
  e2.fourmonospace = 65300;
  e2.fournumeratorbengali = 2551;
  e2.fouroldstyle = 63284;
  e2.fourparen = 9335;
  e2.fourperiod = 9355;
  e2.fourpersian = 1780;
  e2.fourroman = 8563;
  e2.foursuperior = 8308;
  e2.fourteencircle = 9325;
  e2.fourteenparen = 9345;
  e2.fourteenperiod = 9365;
  e2.fourthai = 3668;
  e2.fourthtonechinese = 715;
  e2.fparen = 9377;
  e2.fraction = 8260;
  e2.franc = 8355;
  e2.g = 103;
  e2.gabengali = 2455;
  e2.gacute = 501;
  e2.gadeva = 2327;
  e2.gafarabic = 1711;
  e2.gaffinalarabic = 64403;
  e2.gafinitialarabic = 64404;
  e2.gafmedialarabic = 64405;
  e2.gagujarati = 2711;
  e2.gagurmukhi = 2583;
  e2.gahiragana = 12364;
  e2.gakatakana = 12460;
  e2.gamma = 947;
  e2.gammalatinsmall = 611;
  e2.gammasuperior = 736;
  e2.gangiacoptic = 1003;
  e2.gbopomofo = 12557;
  e2.gbreve = 287;
  e2.gcaron = 487;
  e2.gcedilla = 291;
  e2.gcircle = 9430;
  e2.gcircumflex = 285;
  e2.gcommaaccent = 291;
  e2.gdot = 289;
  e2.gdotaccent = 289;
  e2.gecyrillic = 1075;
  e2.gehiragana = 12370;
  e2.gekatakana = 12466;
  e2.geometricallyequal = 8785;
  e2.gereshaccenthebrew = 1436;
  e2.gereshhebrew = 1523;
  e2.gereshmuqdamhebrew = 1437;
  e2.germandbls = 223;
  e2.gershayimaccenthebrew = 1438;
  e2.gershayimhebrew = 1524;
  e2.getamark = 12307;
  e2.ghabengali = 2456;
  e2.ghadarmenian = 1394;
  e2.ghadeva = 2328;
  e2.ghagujarati = 2712;
  e2.ghagurmukhi = 2584;
  e2.ghainarabic = 1594;
  e2.ghainfinalarabic = 65230;
  e2.ghaininitialarabic = 65231;
  e2.ghainmedialarabic = 65232;
  e2.ghemiddlehookcyrillic = 1173;
  e2.ghestrokecyrillic = 1171;
  e2.gheupturncyrillic = 1169;
  e2.ghhadeva = 2394;
  e2.ghhagurmukhi = 2650;
  e2.ghook = 608;
  e2.ghzsquare = 13203;
  e2.gihiragana = 12366;
  e2.gikatakana = 12462;
  e2.gimarmenian = 1379;
  e2.gimel = 1490;
  e2.gimeldagesh = 64306;
  e2.gimeldageshhebrew = 64306;
  e2.gimelhebrew = 1490;
  e2.gjecyrillic = 1107;
  e2.glottalinvertedstroke = 446;
  e2.glottalstop = 660;
  e2.glottalstopinverted = 662;
  e2.glottalstopmod = 704;
  e2.glottalstopreversed = 661;
  e2.glottalstopreversedmod = 705;
  e2.glottalstopreversedsuperior = 740;
  e2.glottalstopstroke = 673;
  e2.glottalstopstrokereversed = 674;
  e2.gmacron = 7713;
  e2.gmonospace = 65351;
  e2.gohiragana = 12372;
  e2.gokatakana = 12468;
  e2.gparen = 9378;
  e2.gpasquare = 13228;
  e2.gradient = 8711;
  e2.grave = 96;
  e2.gravebelowcmb = 790;
  e2.gravecmb = 768;
  e2.gravecomb = 768;
  e2.gravedeva = 2387;
  e2.gravelowmod = 718;
  e2.gravemonospace = 65344;
  e2.gravetonecmb = 832;
  e2.greater = 62;
  e2.greaterequal = 8805;
  e2.greaterequalorless = 8923;
  e2.greatermonospace = 65310;
  e2.greaterorequivalent = 8819;
  e2.greaterorless = 8823;
  e2.greateroverequal = 8807;
  e2.greatersmall = 65125;
  e2.gscript = 609;
  e2.gstroke = 485;
  e2.guhiragana = 12368;
  e2.guillemotleft = 171;
  e2.guillemotright = 187;
  e2.guilsinglleft = 8249;
  e2.guilsinglright = 8250;
  e2.gukatakana = 12464;
  e2.guramusquare = 13080;
  e2.gysquare = 13257;
  e2.h = 104;
  e2.haabkhasiancyrillic = 1193;
  e2.haaltonearabic = 1729;
  e2.habengali = 2489;
  e2.hadescendercyrillic = 1203;
  e2.hadeva = 2361;
  e2.hagujarati = 2745;
  e2.hagurmukhi = 2617;
  e2.haharabic = 1581;
  e2.hahfinalarabic = 65186;
  e2.hahinitialarabic = 65187;
  e2.hahiragana = 12399;
  e2.hahmedialarabic = 65188;
  e2.haitusquare = 13098;
  e2.hakatakana = 12495;
  e2.hakatakanahalfwidth = 65418;
  e2.halantgurmukhi = 2637;
  e2.hamzaarabic = 1569;
  e2.hamzalowarabic = 1569;
  e2.hangulfiller = 12644;
  e2.hardsigncyrillic = 1098;
  e2.harpoonleftbarbup = 8636;
  e2.harpoonrightbarbup = 8640;
  e2.hasquare = 13258;
  e2.hatafpatah = 1458;
  e2.hatafpatah16 = 1458;
  e2.hatafpatah23 = 1458;
  e2.hatafpatah2f = 1458;
  e2.hatafpatahhebrew = 1458;
  e2.hatafpatahnarrowhebrew = 1458;
  e2.hatafpatahquarterhebrew = 1458;
  e2.hatafpatahwidehebrew = 1458;
  e2.hatafqamats = 1459;
  e2.hatafqamats1b = 1459;
  e2.hatafqamats28 = 1459;
  e2.hatafqamats34 = 1459;
  e2.hatafqamatshebrew = 1459;
  e2.hatafqamatsnarrowhebrew = 1459;
  e2.hatafqamatsquarterhebrew = 1459;
  e2.hatafqamatswidehebrew = 1459;
  e2.hatafsegol = 1457;
  e2.hatafsegol17 = 1457;
  e2.hatafsegol24 = 1457;
  e2.hatafsegol30 = 1457;
  e2.hatafsegolhebrew = 1457;
  e2.hatafsegolnarrowhebrew = 1457;
  e2.hatafsegolquarterhebrew = 1457;
  e2.hatafsegolwidehebrew = 1457;
  e2.hbar = 295;
  e2.hbopomofo = 12559;
  e2.hbrevebelow = 7723;
  e2.hcedilla = 7721;
  e2.hcircle = 9431;
  e2.hcircumflex = 293;
  e2.hdieresis = 7719;
  e2.hdotaccent = 7715;
  e2.hdotbelow = 7717;
  e2.he = 1492;
  e2.heart = 9829;
  e2.heartsuitblack = 9829;
  e2.heartsuitwhite = 9825;
  e2.hedagesh = 64308;
  e2.hedageshhebrew = 64308;
  e2.hehaltonearabic = 1729;
  e2.heharabic = 1607;
  e2.hehebrew = 1492;
  e2.hehfinalaltonearabic = 64423;
  e2.hehfinalalttwoarabic = 65258;
  e2.hehfinalarabic = 65258;
  e2.hehhamzaabovefinalarabic = 64421;
  e2.hehhamzaaboveisolatedarabic = 64420;
  e2.hehinitialaltonearabic = 64424;
  e2.hehinitialarabic = 65259;
  e2.hehiragana = 12408;
  e2.hehmedialaltonearabic = 64425;
  e2.hehmedialarabic = 65260;
  e2.heiseierasquare = 13179;
  e2.hekatakana = 12504;
  e2.hekatakanahalfwidth = 65421;
  e2.hekutaarusquare = 13110;
  e2.henghook = 615;
  e2.herutusquare = 13113;
  e2.het = 1495;
  e2.hethebrew = 1495;
  e2.hhook = 614;
  e2.hhooksuperior = 689;
  e2.hieuhacirclekorean = 12923;
  e2.hieuhaparenkorean = 12827;
  e2.hieuhcirclekorean = 12909;
  e2.hieuhkorean = 12622;
  e2.hieuhparenkorean = 12813;
  e2.hihiragana = 12402;
  e2.hikatakana = 12498;
  e2.hikatakanahalfwidth = 65419;
  e2.hiriq = 1460;
  e2.hiriq14 = 1460;
  e2.hiriq21 = 1460;
  e2.hiriq2d = 1460;
  e2.hiriqhebrew = 1460;
  e2.hiriqnarrowhebrew = 1460;
  e2.hiriqquarterhebrew = 1460;
  e2.hiriqwidehebrew = 1460;
  e2.hlinebelow = 7830;
  e2.hmonospace = 65352;
  e2.hoarmenian = 1392;
  e2.hohipthai = 3627;
  e2.hohiragana = 12411;
  e2.hokatakana = 12507;
  e2.hokatakanahalfwidth = 65422;
  e2.holam = 1465;
  e2.holam19 = 1465;
  e2.holam26 = 1465;
  e2.holam32 = 1465;
  e2.holamhebrew = 1465;
  e2.holamnarrowhebrew = 1465;
  e2.holamquarterhebrew = 1465;
  e2.holamwidehebrew = 1465;
  e2.honokhukthai = 3630;
  e2.hookabovecomb = 777;
  e2.hookcmb = 777;
  e2.hookpalatalizedbelowcmb = 801;
  e2.hookretroflexbelowcmb = 802;
  e2.hoonsquare = 13122;
  e2.horicoptic = 1001;
  e2.horizontalbar = 8213;
  e2.horncmb = 795;
  e2.hotsprings = 9832;
  e2.house = 8962;
  e2.hparen = 9379;
  e2.hsuperior = 688;
  e2.hturned = 613;
  e2.huhiragana = 12405;
  e2.huiitosquare = 13107;
  e2.hukatakana = 12501;
  e2.hukatakanahalfwidth = 65420;
  e2.hungarumlaut = 733;
  e2.hungarumlautcmb = 779;
  e2.hv = 405;
  e2.hyphen = 45;
  e2.hypheninferior = 63205;
  e2.hyphenmonospace = 65293;
  e2.hyphensmall = 65123;
  e2.hyphensuperior = 63206;
  e2.hyphentwo = 8208;
  e2.i = 105;
  e2.iacute = 237;
  e2.iacyrillic = 1103;
  e2.ibengali = 2439;
  e2.ibopomofo = 12583;
  e2.ibreve = 301;
  e2.icaron = 464;
  e2.icircle = 9432;
  e2.icircumflex = 238;
  e2.icyrillic = 1110;
  e2.idblgrave = 521;
  e2.ideographearthcircle = 12943;
  e2.ideographfirecircle = 12939;
  e2.ideographicallianceparen = 12863;
  e2.ideographiccallparen = 12858;
  e2.ideographiccentrecircle = 12965;
  e2.ideographicclose = 12294;
  e2.ideographiccomma = 12289;
  e2.ideographiccommaleft = 65380;
  e2.ideographiccongratulationparen = 12855;
  e2.ideographiccorrectcircle = 12963;
  e2.ideographicearthparen = 12847;
  e2.ideographicenterpriseparen = 12861;
  e2.ideographicexcellentcircle = 12957;
  e2.ideographicfestivalparen = 12864;
  e2.ideographicfinancialcircle = 12950;
  e2.ideographicfinancialparen = 12854;
  e2.ideographicfireparen = 12843;
  e2.ideographichaveparen = 12850;
  e2.ideographichighcircle = 12964;
  e2.ideographiciterationmark = 12293;
  e2.ideographiclaborcircle = 12952;
  e2.ideographiclaborparen = 12856;
  e2.ideographicleftcircle = 12967;
  e2.ideographiclowcircle = 12966;
  e2.ideographicmedicinecircle = 12969;
  e2.ideographicmetalparen = 12846;
  e2.ideographicmoonparen = 12842;
  e2.ideographicnameparen = 12852;
  e2.ideographicperiod = 12290;
  e2.ideographicprintcircle = 12958;
  e2.ideographicreachparen = 12867;
  e2.ideographicrepresentparen = 12857;
  e2.ideographicresourceparen = 12862;
  e2.ideographicrightcircle = 12968;
  e2.ideographicsecretcircle = 12953;
  e2.ideographicselfparen = 12866;
  e2.ideographicsocietyparen = 12851;
  e2.ideographicspace = 12288;
  e2.ideographicspecialparen = 12853;
  e2.ideographicstockparen = 12849;
  e2.ideographicstudyparen = 12859;
  e2.ideographicsunparen = 12848;
  e2.ideographicsuperviseparen = 12860;
  e2.ideographicwaterparen = 12844;
  e2.ideographicwoodparen = 12845;
  e2.ideographiczero = 12295;
  e2.ideographmetalcircle = 12942;
  e2.ideographmooncircle = 12938;
  e2.ideographnamecircle = 12948;
  e2.ideographsuncircle = 12944;
  e2.ideographwatercircle = 12940;
  e2.ideographwoodcircle = 12941;
  e2.ideva = 2311;
  e2.idieresis = 239;
  e2.idieresisacute = 7727;
  e2.idieresiscyrillic = 1253;
  e2.idotbelow = 7883;
  e2.iebrevecyrillic = 1239;
  e2.iecyrillic = 1077;
  e2.ieungacirclekorean = 12917;
  e2.ieungaparenkorean = 12821;
  e2.ieungcirclekorean = 12903;
  e2.ieungkorean = 12615;
  e2.ieungparenkorean = 12807;
  e2.igrave = 236;
  e2.igujarati = 2695;
  e2.igurmukhi = 2567;
  e2.ihiragana = 12356;
  e2.ihookabove = 7881;
  e2.iibengali = 2440;
  e2.iicyrillic = 1080;
  e2.iideva = 2312;
  e2.iigujarati = 2696;
  e2.iigurmukhi = 2568;
  e2.iimatragurmukhi = 2624;
  e2.iinvertedbreve = 523;
  e2.iishortcyrillic = 1081;
  e2.iivowelsignbengali = 2496;
  e2.iivowelsigndeva = 2368;
  e2.iivowelsigngujarati = 2752;
  e2.ij = 307;
  e2.ikatakana = 12452;
  e2.ikatakanahalfwidth = 65394;
  e2.ikorean = 12643;
  e2.ilde = 732;
  e2.iluyhebrew = 1452;
  e2.imacron = 299;
  e2.imacroncyrillic = 1251;
  e2.imageorapproximatelyequal = 8787;
  e2.imatragurmukhi = 2623;
  e2.imonospace = 65353;
  e2.increment = 8710;
  e2.infinity = 8734;
  e2.iniarmenian = 1387;
  e2.integral = 8747;
  e2.integralbottom = 8993;
  e2.integralbt = 8993;
  e2.integralex = 63733;
  e2.integraltop = 8992;
  e2.integraltp = 8992;
  e2.intersection = 8745;
  e2.intisquare = 13061;
  e2.invbullet = 9688;
  e2.invcircle = 9689;
  e2.invsmileface = 9787;
  e2.iocyrillic = 1105;
  e2.iogonek = 303;
  e2.iota = 953;
  e2.iotadieresis = 970;
  e2.iotadieresistonos = 912;
  e2.iotalatin = 617;
  e2.iotatonos = 943;
  e2.iparen = 9380;
  e2.irigurmukhi = 2674;
  e2.ismallhiragana = 12355;
  e2.ismallkatakana = 12451;
  e2.ismallkatakanahalfwidth = 65384;
  e2.issharbengali = 2554;
  e2.istroke = 616;
  e2.isuperior = 63213;
  e2.iterationhiragana = 12445;
  e2.iterationkatakana = 12541;
  e2.itilde = 297;
  e2.itildebelow = 7725;
  e2.iubopomofo = 12585;
  e2.iucyrillic = 1102;
  e2.ivowelsignbengali = 2495;
  e2.ivowelsigndeva = 2367;
  e2.ivowelsigngujarati = 2751;
  e2.izhitsacyrillic = 1141;
  e2.izhitsadblgravecyrillic = 1143;
  e2.j = 106;
  e2.jaarmenian = 1393;
  e2.jabengali = 2460;
  e2.jadeva = 2332;
  e2.jagujarati = 2716;
  e2.jagurmukhi = 2588;
  e2.jbopomofo = 12560;
  e2.jcaron = 496;
  e2.jcircle = 9433;
  e2.jcircumflex = 309;
  e2.jcrossedtail = 669;
  e2.jdotlessstroke = 607;
  e2.jecyrillic = 1112;
  e2.jeemarabic = 1580;
  e2.jeemfinalarabic = 65182;
  e2.jeeminitialarabic = 65183;
  e2.jeemmedialarabic = 65184;
  e2.jeharabic = 1688;
  e2.jehfinalarabic = 64395;
  e2.jhabengali = 2461;
  e2.jhadeva = 2333;
  e2.jhagujarati = 2717;
  e2.jhagurmukhi = 2589;
  e2.jheharmenian = 1403;
  e2.jis = 12292;
  e2.jmonospace = 65354;
  e2.jparen = 9381;
  e2.jsuperior = 690;
  e2.k = 107;
  e2.kabashkircyrillic = 1185;
  e2.kabengali = 2453;
  e2.kacute = 7729;
  e2.kacyrillic = 1082;
  e2.kadescendercyrillic = 1179;
  e2.kadeva = 2325;
  e2.kaf = 1499;
  e2.kafarabic = 1603;
  e2.kafdagesh = 64315;
  e2.kafdageshhebrew = 64315;
  e2.kaffinalarabic = 65242;
  e2.kafhebrew = 1499;
  e2.kafinitialarabic = 65243;
  e2.kafmedialarabic = 65244;
  e2.kafrafehebrew = 64333;
  e2.kagujarati = 2709;
  e2.kagurmukhi = 2581;
  e2.kahiragana = 12363;
  e2.kahookcyrillic = 1220;
  e2.kakatakana = 12459;
  e2.kakatakanahalfwidth = 65398;
  e2.kappa = 954;
  e2.kappasymbolgreek = 1008;
  e2.kapyeounmieumkorean = 12657;
  e2.kapyeounphieuphkorean = 12676;
  e2.kapyeounpieupkorean = 12664;
  e2.kapyeounssangpieupkorean = 12665;
  e2.karoriisquare = 13069;
  e2.kashidaautoarabic = 1600;
  e2.kashidaautonosidebearingarabic = 1600;
  e2.kasmallkatakana = 12533;
  e2.kasquare = 13188;
  e2.kasraarabic = 1616;
  e2.kasratanarabic = 1613;
  e2.kastrokecyrillic = 1183;
  e2.katahiraprolongmarkhalfwidth = 65392;
  e2.kaverticalstrokecyrillic = 1181;
  e2.kbopomofo = 12558;
  e2.kcalsquare = 13193;
  e2.kcaron = 489;
  e2.kcedilla = 311;
  e2.kcircle = 9434;
  e2.kcommaaccent = 311;
  e2.kdotbelow = 7731;
  e2.keharmenian = 1412;
  e2.kehiragana = 12369;
  e2.kekatakana = 12465;
  e2.kekatakanahalfwidth = 65401;
  e2.kenarmenian = 1391;
  e2.kesmallkatakana = 12534;
  e2.kgreenlandic = 312;
  e2.khabengali = 2454;
  e2.khacyrillic = 1093;
  e2.khadeva = 2326;
  e2.khagujarati = 2710;
  e2.khagurmukhi = 2582;
  e2.khaharabic = 1582;
  e2.khahfinalarabic = 65190;
  e2.khahinitialarabic = 65191;
  e2.khahmedialarabic = 65192;
  e2.kheicoptic = 999;
  e2.khhadeva = 2393;
  e2.khhagurmukhi = 2649;
  e2.khieukhacirclekorean = 12920;
  e2.khieukhaparenkorean = 12824;
  e2.khieukhcirclekorean = 12906;
  e2.khieukhkorean = 12619;
  e2.khieukhparenkorean = 12810;
  e2.khokhaithai = 3586;
  e2.khokhonthai = 3589;
  e2.khokhuatthai = 3587;
  e2.khokhwaithai = 3588;
  e2.khomutthai = 3675;
  e2.khook = 409;
  e2.khorakhangthai = 3590;
  e2.khzsquare = 13201;
  e2.kihiragana = 12365;
  e2.kikatakana = 12461;
  e2.kikatakanahalfwidth = 65399;
  e2.kiroguramusquare = 13077;
  e2.kiromeetorusquare = 13078;
  e2.kirosquare = 13076;
  e2.kiyeokacirclekorean = 12910;
  e2.kiyeokaparenkorean = 12814;
  e2.kiyeokcirclekorean = 12896;
  e2.kiyeokkorean = 12593;
  e2.kiyeokparenkorean = 12800;
  e2.kiyeoksioskorean = 12595;
  e2.kjecyrillic = 1116;
  e2.klinebelow = 7733;
  e2.klsquare = 13208;
  e2.kmcubedsquare = 13222;
  e2.kmonospace = 65355;
  e2.kmsquaredsquare = 13218;
  e2.kohiragana = 12371;
  e2.kohmsquare = 13248;
  e2.kokaithai = 3585;
  e2.kokatakana = 12467;
  e2.kokatakanahalfwidth = 65402;
  e2.kooposquare = 13086;
  e2.koppacyrillic = 1153;
  e2.koreanstandardsymbol = 12927;
  e2.koroniscmb = 835;
  e2.kparen = 9382;
  e2.kpasquare = 13226;
  e2.ksicyrillic = 1135;
  e2.ktsquare = 13263;
  e2.kturned = 670;
  e2.kuhiragana = 12367;
  e2.kukatakana = 12463;
  e2.kukatakanahalfwidth = 65400;
  e2.kvsquare = 13240;
  e2.kwsquare = 13246;
  e2.l = 108;
  e2.labengali = 2482;
  e2.lacute = 314;
  e2.ladeva = 2354;
  e2.lagujarati = 2738;
  e2.lagurmukhi = 2610;
  e2.lakkhangyaothai = 3653;
  e2.lamaleffinalarabic = 65276;
  e2.lamalefhamzaabovefinalarabic = 65272;
  e2.lamalefhamzaaboveisolatedarabic = 65271;
  e2.lamalefhamzabelowfinalarabic = 65274;
  e2.lamalefhamzabelowisolatedarabic = 65273;
  e2.lamalefisolatedarabic = 65275;
  e2.lamalefmaddaabovefinalarabic = 65270;
  e2.lamalefmaddaaboveisolatedarabic = 65269;
  e2.lamarabic = 1604;
  e2.lambda = 955;
  e2.lambdastroke = 411;
  e2.lamed = 1500;
  e2.lameddagesh = 64316;
  e2.lameddageshhebrew = 64316;
  e2.lamedhebrew = 1500;
  e2.lamfinalarabic = 65246;
  e2.lamhahinitialarabic = 64714;
  e2.laminitialarabic = 65247;
  e2.lamjeeminitialarabic = 64713;
  e2.lamkhahinitialarabic = 64715;
  e2.lamlamhehisolatedarabic = 65010;
  e2.lammedialarabic = 65248;
  e2.lammeemhahinitialarabic = 64904;
  e2.lammeeminitialarabic = 64716;
  e2.largecircle = 9711;
  e2.lbar = 410;
  e2.lbelt = 620;
  e2.lbopomofo = 12556;
  e2.lcaron = 318;
  e2.lcedilla = 316;
  e2.lcircle = 9435;
  e2.lcircumflexbelow = 7741;
  e2.lcommaaccent = 316;
  e2.ldot = 320;
  e2.ldotaccent = 320;
  e2.ldotbelow = 7735;
  e2.ldotbelowmacron = 7737;
  e2.leftangleabovecmb = 794;
  e2.lefttackbelowcmb = 792;
  e2.less = 60;
  e2.lessequal = 8804;
  e2.lessequalorgreater = 8922;
  e2.lessmonospace = 65308;
  e2.lessorequivalent = 8818;
  e2.lessorgreater = 8822;
  e2.lessoverequal = 8806;
  e2.lesssmall = 65124;
  e2.lezh = 622;
  e2.lfblock = 9612;
  e2.lhookretroflex = 621;
  e2.lira = 8356;
  e2.liwnarmenian = 1388;
  e2.lj = 457;
  e2.ljecyrillic = 1113;
  e2.ll = 63168;
  e2.lladeva = 2355;
  e2.llagujarati = 2739;
  e2.llinebelow = 7739;
  e2.llladeva = 2356;
  e2.llvocalicbengali = 2529;
  e2.llvocalicdeva = 2401;
  e2.llvocalicvowelsignbengali = 2531;
  e2.llvocalicvowelsigndeva = 2403;
  e2.lmiddletilde = 619;
  e2.lmonospace = 65356;
  e2.lmsquare = 13264;
  e2.lochulathai = 3628;
  e2.logicaland = 8743;
  e2.logicalnot = 172;
  e2.logicalnotreversed = 8976;
  e2.logicalor = 8744;
  e2.lolingthai = 3621;
  e2.longs = 383;
  e2.lowlinecenterline = 65102;
  e2.lowlinecmb = 818;
  e2.lowlinedashed = 65101;
  e2.lozenge = 9674;
  e2.lparen = 9383;
  e2.lslash = 322;
  e2.lsquare = 8467;
  e2.lsuperior = 63214;
  e2.ltshade = 9617;
  e2.luthai = 3622;
  e2.lvocalicbengali = 2444;
  e2.lvocalicdeva = 2316;
  e2.lvocalicvowelsignbengali = 2530;
  e2.lvocalicvowelsigndeva = 2402;
  e2.lxsquare = 13267;
  e2.m = 109;
  e2.mabengali = 2478;
  e2.macron = 175;
  e2.macronbelowcmb = 817;
  e2.macroncmb = 772;
  e2.macronlowmod = 717;
  e2.macronmonospace = 65507;
  e2.macute = 7743;
  e2.madeva = 2350;
  e2.magujarati = 2734;
  e2.magurmukhi = 2606;
  e2.mahapakhhebrew = 1444;
  e2.mahapakhlefthebrew = 1444;
  e2.mahiragana = 12414;
  e2.maichattawalowleftthai = 63637;
  e2.maichattawalowrightthai = 63636;
  e2.maichattawathai = 3659;
  e2.maichattawaupperleftthai = 63635;
  e2.maieklowleftthai = 63628;
  e2.maieklowrightthai = 63627;
  e2.maiekthai = 3656;
  e2.maiekupperleftthai = 63626;
  e2.maihanakatleftthai = 63620;
  e2.maihanakatthai = 3633;
  e2.maitaikhuleftthai = 63625;
  e2.maitaikhuthai = 3655;
  e2.maitholowleftthai = 63631;
  e2.maitholowrightthai = 63630;
  e2.maithothai = 3657;
  e2.maithoupperleftthai = 63629;
  e2.maitrilowleftthai = 63634;
  e2.maitrilowrightthai = 63633;
  e2.maitrithai = 3658;
  e2.maitriupperleftthai = 63632;
  e2.maiyamokthai = 3654;
  e2.makatakana = 12510;
  e2.makatakanahalfwidth = 65423;
  e2.male = 9794;
  e2.mansyonsquare = 13127;
  e2.maqafhebrew = 1470;
  e2.mars = 9794;
  e2.masoracirclehebrew = 1455;
  e2.masquare = 13187;
  e2.mbopomofo = 12551;
  e2.mbsquare = 13268;
  e2.mcircle = 9436;
  e2.mcubedsquare = 13221;
  e2.mdotaccent = 7745;
  e2.mdotbelow = 7747;
  e2.meemarabic = 1605;
  e2.meemfinalarabic = 65250;
  e2.meeminitialarabic = 65251;
  e2.meemmedialarabic = 65252;
  e2.meemmeeminitialarabic = 64721;
  e2.meemmeemisolatedarabic = 64584;
  e2.meetorusquare = 13133;
  e2.mehiragana = 12417;
  e2.meizierasquare = 13182;
  e2.mekatakana = 12513;
  e2.mekatakanahalfwidth = 65426;
  e2.mem = 1502;
  e2.memdagesh = 64318;
  e2.memdageshhebrew = 64318;
  e2.memhebrew = 1502;
  e2.menarmenian = 1396;
  e2.merkhahebrew = 1445;
  e2.merkhakefulahebrew = 1446;
  e2.merkhakefulalefthebrew = 1446;
  e2.merkhalefthebrew = 1445;
  e2.mhook = 625;
  e2.mhzsquare = 13202;
  e2.middledotkatakanahalfwidth = 65381;
  e2.middot = 183;
  e2.mieumacirclekorean = 12914;
  e2.mieumaparenkorean = 12818;
  e2.mieumcirclekorean = 12900;
  e2.mieumkorean = 12609;
  e2.mieumpansioskorean = 12656;
  e2.mieumparenkorean = 12804;
  e2.mieumpieupkorean = 12654;
  e2.mieumsioskorean = 12655;
  e2.mihiragana = 12415;
  e2.mikatakana = 12511;
  e2.mikatakanahalfwidth = 65424;
  e2.minus = 8722;
  e2.minusbelowcmb = 800;
  e2.minuscircle = 8854;
  e2.minusmod = 727;
  e2.minusplus = 8723;
  e2.minute = 8242;
  e2.miribaarusquare = 13130;
  e2.mirisquare = 13129;
  e2.mlonglegturned = 624;
  e2.mlsquare = 13206;
  e2.mmcubedsquare = 13219;
  e2.mmonospace = 65357;
  e2.mmsquaredsquare = 13215;
  e2.mohiragana = 12418;
  e2.mohmsquare = 13249;
  e2.mokatakana = 12514;
  e2.mokatakanahalfwidth = 65427;
  e2.molsquare = 13270;
  e2.momathai = 3617;
  e2.moverssquare = 13223;
  e2.moverssquaredsquare = 13224;
  e2.mparen = 9384;
  e2.mpasquare = 13227;
  e2.mssquare = 13235;
  e2.msuperior = 63215;
  e2.mturned = 623;
  e2.mu = 181;
  e2.mu1 = 181;
  e2.muasquare = 13186;
  e2.muchgreater = 8811;
  e2.muchless = 8810;
  e2.mufsquare = 13196;
  e2.mugreek = 956;
  e2.mugsquare = 13197;
  e2.muhiragana = 12416;
  e2.mukatakana = 12512;
  e2.mukatakanahalfwidth = 65425;
  e2.mulsquare = 13205;
  e2.multiply = 215;
  e2.mumsquare = 13211;
  e2.munahhebrew = 1443;
  e2.munahlefthebrew = 1443;
  e2.musicalnote = 9834;
  e2.musicalnotedbl = 9835;
  e2.musicflatsign = 9837;
  e2.musicsharpsign = 9839;
  e2.mussquare = 13234;
  e2.muvsquare = 13238;
  e2.muwsquare = 13244;
  e2.mvmegasquare = 13241;
  e2.mvsquare = 13239;
  e2.mwmegasquare = 13247;
  e2.mwsquare = 13245;
  e2.n = 110;
  e2.nabengali = 2472;
  e2.nabla = 8711;
  e2.nacute = 324;
  e2.nadeva = 2344;
  e2.nagujarati = 2728;
  e2.nagurmukhi = 2600;
  e2.nahiragana = 12394;
  e2.nakatakana = 12490;
  e2.nakatakanahalfwidth = 65413;
  e2.napostrophe = 329;
  e2.nasquare = 13185;
  e2.nbopomofo = 12555;
  e2.nbspace = 160;
  e2.ncaron = 328;
  e2.ncedilla = 326;
  e2.ncircle = 9437;
  e2.ncircumflexbelow = 7755;
  e2.ncommaaccent = 326;
  e2.ndotaccent = 7749;
  e2.ndotbelow = 7751;
  e2.nehiragana = 12397;
  e2.nekatakana = 12493;
  e2.nekatakanahalfwidth = 65416;
  e2.newsheqelsign = 8362;
  e2.nfsquare = 13195;
  e2.ngabengali = 2457;
  e2.ngadeva = 2329;
  e2.ngagujarati = 2713;
  e2.ngagurmukhi = 2585;
  e2.ngonguthai = 3591;
  e2.nhiragana = 12435;
  e2.nhookleft = 626;
  e2.nhookretroflex = 627;
  e2.nieunacirclekorean = 12911;
  e2.nieunaparenkorean = 12815;
  e2.nieuncieuckorean = 12597;
  e2.nieuncirclekorean = 12897;
  e2.nieunhieuhkorean = 12598;
  e2.nieunkorean = 12596;
  e2.nieunpansioskorean = 12648;
  e2.nieunparenkorean = 12801;
  e2.nieunsioskorean = 12647;
  e2.nieuntikeutkorean = 12646;
  e2.nihiragana = 12395;
  e2.nikatakana = 12491;
  e2.nikatakanahalfwidth = 65414;
  e2.nikhahitleftthai = 63641;
  e2.nikhahitthai = 3661;
  e2.nine = 57;
  e2.ninearabic = 1641;
  e2.ninebengali = 2543;
  e2.ninecircle = 9320;
  e2.ninecircleinversesansserif = 10130;
  e2.ninedeva = 2415;
  e2.ninegujarati = 2799;
  e2.ninegurmukhi = 2671;
  e2.ninehackarabic = 1641;
  e2.ninehangzhou = 12329;
  e2.nineideographicparen = 12840;
  e2.nineinferior = 8329;
  e2.ninemonospace = 65305;
  e2.nineoldstyle = 63289;
  e2.nineparen = 9340;
  e2.nineperiod = 9360;
  e2.ninepersian = 1785;
  e2.nineroman = 8568;
  e2.ninesuperior = 8313;
  e2.nineteencircle = 9330;
  e2.nineteenparen = 9350;
  e2.nineteenperiod = 9370;
  e2.ninethai = 3673;
  e2.nj = 460;
  e2.njecyrillic = 1114;
  e2.nkatakana = 12531;
  e2.nkatakanahalfwidth = 65437;
  e2.nlegrightlong = 414;
  e2.nlinebelow = 7753;
  e2.nmonospace = 65358;
  e2.nmsquare = 13210;
  e2.nnabengali = 2467;
  e2.nnadeva = 2339;
  e2.nnagujarati = 2723;
  e2.nnagurmukhi = 2595;
  e2.nnnadeva = 2345;
  e2.nohiragana = 12398;
  e2.nokatakana = 12494;
  e2.nokatakanahalfwidth = 65417;
  e2.nonbreakingspace = 160;
  e2.nonenthai = 3603;
  e2.nonuthai = 3609;
  e2.noonarabic = 1606;
  e2.noonfinalarabic = 65254;
  e2.noonghunnaarabic = 1722;
  e2.noonghunnafinalarabic = 64415;
  e2.nooninitialarabic = 65255;
  e2.noonjeeminitialarabic = 64722;
  e2.noonjeemisolatedarabic = 64587;
  e2.noonmedialarabic = 65256;
  e2.noonmeeminitialarabic = 64725;
  e2.noonmeemisolatedarabic = 64590;
  e2.noonnoonfinalarabic = 64653;
  e2.notcontains = 8716;
  e2.notelement = 8713;
  e2.notelementof = 8713;
  e2.notequal = 8800;
  e2.notgreater = 8815;
  e2.notgreaternorequal = 8817;
  e2.notgreaternorless = 8825;
  e2.notidentical = 8802;
  e2.notless = 8814;
  e2.notlessnorequal = 8816;
  e2.notparallel = 8742;
  e2.notprecedes = 8832;
  e2.notsubset = 8836;
  e2.notsucceeds = 8833;
  e2.notsuperset = 8837;
  e2.nowarmenian = 1398;
  e2.nparen = 9385;
  e2.nssquare = 13233;
  e2.nsuperior = 8319;
  e2.ntilde = 241;
  e2.nu = 957;
  e2.nuhiragana = 12396;
  e2.nukatakana = 12492;
  e2.nukatakanahalfwidth = 65415;
  e2.nuktabengali = 2492;
  e2.nuktadeva = 2364;
  e2.nuktagujarati = 2748;
  e2.nuktagurmukhi = 2620;
  e2.numbersign = 35;
  e2.numbersignmonospace = 65283;
  e2.numbersignsmall = 65119;
  e2.numeralsigngreek = 884;
  e2.numeralsignlowergreek = 885;
  e2.numero = 8470;
  e2.nun = 1504;
  e2.nundagesh = 64320;
  e2.nundageshhebrew = 64320;
  e2.nunhebrew = 1504;
  e2.nvsquare = 13237;
  e2.nwsquare = 13243;
  e2.nyabengali = 2462;
  e2.nyadeva = 2334;
  e2.nyagujarati = 2718;
  e2.nyagurmukhi = 2590;
  e2.o = 111;
  e2.oacute = 243;
  e2.oangthai = 3629;
  e2.obarred = 629;
  e2.obarredcyrillic = 1257;
  e2.obarreddieresiscyrillic = 1259;
  e2.obengali = 2451;
  e2.obopomofo = 12571;
  e2.obreve = 335;
  e2.ocandradeva = 2321;
  e2.ocandragujarati = 2705;
  e2.ocandravowelsigndeva = 2377;
  e2.ocandravowelsigngujarati = 2761;
  e2.ocaron = 466;
  e2.ocircle = 9438;
  e2.ocircumflex = 244;
  e2.ocircumflexacute = 7889;
  e2.ocircumflexdotbelow = 7897;
  e2.ocircumflexgrave = 7891;
  e2.ocircumflexhookabove = 7893;
  e2.ocircumflextilde = 7895;
  e2.ocyrillic = 1086;
  e2.odblacute = 337;
  e2.odblgrave = 525;
  e2.odeva = 2323;
  e2.odieresis = 246;
  e2.odieresiscyrillic = 1255;
  e2.odotbelow = 7885;
  e2.oe = 339;
  e2.oekorean = 12634;
  e2.ogonek = 731;
  e2.ogonekcmb = 808;
  e2.ograve = 242;
  e2.ogujarati = 2707;
  e2.oharmenian = 1413;
  e2.ohiragana = 12362;
  e2.ohookabove = 7887;
  e2.ohorn = 417;
  e2.ohornacute = 7899;
  e2.ohorndotbelow = 7907;
  e2.ohorngrave = 7901;
  e2.ohornhookabove = 7903;
  e2.ohorntilde = 7905;
  e2.ohungarumlaut = 337;
  e2.oi = 419;
  e2.oinvertedbreve = 527;
  e2.okatakana = 12458;
  e2.okatakanahalfwidth = 65397;
  e2.okorean = 12631;
  e2.olehebrew = 1451;
  e2.omacron = 333;
  e2.omacronacute = 7763;
  e2.omacrongrave = 7761;
  e2.omdeva = 2384;
  e2.omega = 969;
  e2.omega1 = 982;
  e2.omegacyrillic = 1121;
  e2.omegalatinclosed = 631;
  e2.omegaroundcyrillic = 1147;
  e2.omegatitlocyrillic = 1149;
  e2.omegatonos = 974;
  e2.omgujarati = 2768;
  e2.omicron = 959;
  e2.omicrontonos = 972;
  e2.omonospace = 65359;
  e2.one = 49;
  e2.onearabic = 1633;
  e2.onebengali = 2535;
  e2.onecircle = 9312;
  e2.onecircleinversesansserif = 10122;
  e2.onedeva = 2407;
  e2.onedotenleader = 8228;
  e2.oneeighth = 8539;
  e2.onefitted = 63196;
  e2.onegujarati = 2791;
  e2.onegurmukhi = 2663;
  e2.onehackarabic = 1633;
  e2.onehalf = 189;
  e2.onehangzhou = 12321;
  e2.oneideographicparen = 12832;
  e2.oneinferior = 8321;
  e2.onemonospace = 65297;
  e2.onenumeratorbengali = 2548;
  e2.oneoldstyle = 63281;
  e2.oneparen = 9332;
  e2.oneperiod = 9352;
  e2.onepersian = 1777;
  e2.onequarter = 188;
  e2.oneroman = 8560;
  e2.onesuperior = 185;
  e2.onethai = 3665;
  e2.onethird = 8531;
  e2.oogonek = 491;
  e2.oogonekmacron = 493;
  e2.oogurmukhi = 2579;
  e2.oomatragurmukhi = 2635;
  e2.oopen = 596;
  e2.oparen = 9386;
  e2.openbullet = 9702;
  e2.option = 8997;
  e2.ordfeminine = 170;
  e2.ordmasculine = 186;
  e2.orthogonal = 8735;
  e2.oshortdeva = 2322;
  e2.oshortvowelsigndeva = 2378;
  e2.oslash = 248;
  e2.oslashacute = 511;
  e2.osmallhiragana = 12361;
  e2.osmallkatakana = 12457;
  e2.osmallkatakanahalfwidth = 65387;
  e2.ostrokeacute = 511;
  e2.osuperior = 63216;
  e2.otcyrillic = 1151;
  e2.otilde = 245;
  e2.otildeacute = 7757;
  e2.otildedieresis = 7759;
  e2.oubopomofo = 12577;
  e2.overline = 8254;
  e2.overlinecenterline = 65098;
  e2.overlinecmb = 773;
  e2.overlinedashed = 65097;
  e2.overlinedblwavy = 65100;
  e2.overlinewavy = 65099;
  e2.overscore = 175;
  e2.ovowelsignbengali = 2507;
  e2.ovowelsigndeva = 2379;
  e2.ovowelsigngujarati = 2763;
  e2.p = 112;
  e2.paampssquare = 13184;
  e2.paasentosquare = 13099;
  e2.pabengali = 2474;
  e2.pacute = 7765;
  e2.padeva = 2346;
  e2.pagedown = 8671;
  e2.pageup = 8670;
  e2.pagujarati = 2730;
  e2.pagurmukhi = 2602;
  e2.pahiragana = 12401;
  e2.paiyannoithai = 3631;
  e2.pakatakana = 12497;
  e2.palatalizationcyrilliccmb = 1156;
  e2.palochkacyrillic = 1216;
  e2.pansioskorean = 12671;
  e2.paragraph = 182;
  e2.parallel = 8741;
  e2.parenleft = 40;
  e2.parenleftaltonearabic = 64830;
  e2.parenleftbt = 63725;
  e2.parenleftex = 63724;
  e2.parenleftinferior = 8333;
  e2.parenleftmonospace = 65288;
  e2.parenleftsmall = 65113;
  e2.parenleftsuperior = 8317;
  e2.parenlefttp = 63723;
  e2.parenleftvertical = 65077;
  e2.parenright = 41;
  e2.parenrightaltonearabic = 64831;
  e2.parenrightbt = 63736;
  e2.parenrightex = 63735;
  e2.parenrightinferior = 8334;
  e2.parenrightmonospace = 65289;
  e2.parenrightsmall = 65114;
  e2.parenrightsuperior = 8318;
  e2.parenrighttp = 63734;
  e2.parenrightvertical = 65078;
  e2.partialdiff = 8706;
  e2.paseqhebrew = 1472;
  e2.pashtahebrew = 1433;
  e2.pasquare = 13225;
  e2.patah = 1463;
  e2.patah11 = 1463;
  e2.patah1d = 1463;
  e2.patah2a = 1463;
  e2.patahhebrew = 1463;
  e2.patahnarrowhebrew = 1463;
  e2.patahquarterhebrew = 1463;
  e2.patahwidehebrew = 1463;
  e2.pazerhebrew = 1441;
  e2.pbopomofo = 12550;
  e2.pcircle = 9439;
  e2.pdotaccent = 7767;
  e2.pe = 1508;
  e2.pecyrillic = 1087;
  e2.pedagesh = 64324;
  e2.pedageshhebrew = 64324;
  e2.peezisquare = 13115;
  e2.pefinaldageshhebrew = 64323;
  e2.peharabic = 1662;
  e2.peharmenian = 1402;
  e2.pehebrew = 1508;
  e2.pehfinalarabic = 64343;
  e2.pehinitialarabic = 64344;
  e2.pehiragana = 12410;
  e2.pehmedialarabic = 64345;
  e2.pekatakana = 12506;
  e2.pemiddlehookcyrillic = 1191;
  e2.perafehebrew = 64334;
  e2.percent = 37;
  e2.percentarabic = 1642;
  e2.percentmonospace = 65285;
  e2.percentsmall = 65130;
  e2.period = 46;
  e2.periodarmenian = 1417;
  e2.periodcentered = 183;
  e2.periodhalfwidth = 65377;
  e2.periodinferior = 63207;
  e2.periodmonospace = 65294;
  e2.periodsmall = 65106;
  e2.periodsuperior = 63208;
  e2.perispomenigreekcmb = 834;
  e2.perpendicular = 8869;
  e2.perthousand = 8240;
  e2.peseta = 8359;
  e2.pfsquare = 13194;
  e2.phabengali = 2475;
  e2.phadeva = 2347;
  e2.phagujarati = 2731;
  e2.phagurmukhi = 2603;
  e2.phi = 966;
  e2.phi1 = 981;
  e2.phieuphacirclekorean = 12922;
  e2.phieuphaparenkorean = 12826;
  e2.phieuphcirclekorean = 12908;
  e2.phieuphkorean = 12621;
  e2.phieuphparenkorean = 12812;
  e2.philatin = 632;
  e2.phinthuthai = 3642;
  e2.phisymbolgreek = 981;
  e2.phook = 421;
  e2.phophanthai = 3614;
  e2.phophungthai = 3612;
  e2.phosamphaothai = 3616;
  e2.pi = 960;
  e2.pieupacirclekorean = 12915;
  e2.pieupaparenkorean = 12819;
  e2.pieupcieuckorean = 12662;
  e2.pieupcirclekorean = 12901;
  e2.pieupkiyeokkorean = 12658;
  e2.pieupkorean = 12610;
  e2.pieupparenkorean = 12805;
  e2.pieupsioskiyeokkorean = 12660;
  e2.pieupsioskorean = 12612;
  e2.pieupsiostikeutkorean = 12661;
  e2.pieupthieuthkorean = 12663;
  e2.pieuptikeutkorean = 12659;
  e2.pihiragana = 12404;
  e2.pikatakana = 12500;
  e2.pisymbolgreek = 982;
  e2.piwrarmenian = 1411;
  e2.planckover2pi = 8463;
  e2.planckover2pi1 = 8463;
  e2.plus = 43;
  e2.plusbelowcmb = 799;
  e2.pluscircle = 8853;
  e2.plusminus = 177;
  e2.plusmod = 726;
  e2.plusmonospace = 65291;
  e2.plussmall = 65122;
  e2.plussuperior = 8314;
  e2.pmonospace = 65360;
  e2.pmsquare = 13272;
  e2.pohiragana = 12413;
  e2.pointingindexdownwhite = 9759;
  e2.pointingindexleftwhite = 9756;
  e2.pointingindexrightwhite = 9758;
  e2.pointingindexupwhite = 9757;
  e2.pokatakana = 12509;
  e2.poplathai = 3611;
  e2.postalmark = 12306;
  e2.postalmarkface = 12320;
  e2.pparen = 9387;
  e2.precedes = 8826;
  e2.prescription = 8478;
  e2.primemod = 697;
  e2.primereversed = 8245;
  e2.product = 8719;
  e2.projective = 8965;
  e2.prolongedkana = 12540;
  e2.propellor = 8984;
  e2.propersubset = 8834;
  e2.propersuperset = 8835;
  e2.proportion = 8759;
  e2.proportional = 8733;
  e2.psi = 968;
  e2.psicyrillic = 1137;
  e2.psilipneumatacyrilliccmb = 1158;
  e2.pssquare = 13232;
  e2.puhiragana = 12407;
  e2.pukatakana = 12503;
  e2.pvsquare = 13236;
  e2.pwsquare = 13242;
  e2.q = 113;
  e2.qadeva = 2392;
  e2.qadmahebrew = 1448;
  e2.qafarabic = 1602;
  e2.qaffinalarabic = 65238;
  e2.qafinitialarabic = 65239;
  e2.qafmedialarabic = 65240;
  e2.qamats = 1464;
  e2.qamats10 = 1464;
  e2.qamats1a = 1464;
  e2.qamats1c = 1464;
  e2.qamats27 = 1464;
  e2.qamats29 = 1464;
  e2.qamats33 = 1464;
  e2.qamatsde = 1464;
  e2.qamatshebrew = 1464;
  e2.qamatsnarrowhebrew = 1464;
  e2.qamatsqatanhebrew = 1464;
  e2.qamatsqatannarrowhebrew = 1464;
  e2.qamatsqatanquarterhebrew = 1464;
  e2.qamatsqatanwidehebrew = 1464;
  e2.qamatsquarterhebrew = 1464;
  e2.qamatswidehebrew = 1464;
  e2.qarneyparahebrew = 1439;
  e2.qbopomofo = 12561;
  e2.qcircle = 9440;
  e2.qhook = 672;
  e2.qmonospace = 65361;
  e2.qof = 1511;
  e2.qofdagesh = 64327;
  e2.qofdageshhebrew = 64327;
  e2.qofhebrew = 1511;
  e2.qparen = 9388;
  e2.quarternote = 9833;
  e2.qubuts = 1467;
  e2.qubuts18 = 1467;
  e2.qubuts25 = 1467;
  e2.qubuts31 = 1467;
  e2.qubutshebrew = 1467;
  e2.qubutsnarrowhebrew = 1467;
  e2.qubutsquarterhebrew = 1467;
  e2.qubutswidehebrew = 1467;
  e2.question = 63;
  e2.questionarabic = 1567;
  e2.questionarmenian = 1374;
  e2.questiondown = 191;
  e2.questiondownsmall = 63423;
  e2.questiongreek = 894;
  e2.questionmonospace = 65311;
  e2.questionsmall = 63295;
  e2.quotedbl = 34;
  e2.quotedblbase = 8222;
  e2.quotedblleft = 8220;
  e2.quotedblmonospace = 65282;
  e2.quotedblprime = 12318;
  e2.quotedblprimereversed = 12317;
  e2.quotedblright = 8221;
  e2.quoteleft = 8216;
  e2.quoteleftreversed = 8219;
  e2.quotereversed = 8219;
  e2.quoteright = 8217;
  e2.quoterightn = 329;
  e2.quotesinglbase = 8218;
  e2.quotesingle = 39;
  e2.quotesinglemonospace = 65287;
  e2.r = 114;
  e2.raarmenian = 1404;
  e2.rabengali = 2480;
  e2.racute = 341;
  e2.radeva = 2352;
  e2.radical = 8730;
  e2.radicalex = 63717;
  e2.radoverssquare = 13230;
  e2.radoverssquaredsquare = 13231;
  e2.radsquare = 13229;
  e2.rafe = 1471;
  e2.rafehebrew = 1471;
  e2.ragujarati = 2736;
  e2.ragurmukhi = 2608;
  e2.rahiragana = 12425;
  e2.rakatakana = 12521;
  e2.rakatakanahalfwidth = 65431;
  e2.ralowerdiagonalbengali = 2545;
  e2.ramiddlediagonalbengali = 2544;
  e2.ramshorn = 612;
  e2.ratio = 8758;
  e2.rbopomofo = 12566;
  e2.rcaron = 345;
  e2.rcedilla = 343;
  e2.rcircle = 9441;
  e2.rcommaaccent = 343;
  e2.rdblgrave = 529;
  e2.rdotaccent = 7769;
  e2.rdotbelow = 7771;
  e2.rdotbelowmacron = 7773;
  e2.referencemark = 8251;
  e2.reflexsubset = 8838;
  e2.reflexsuperset = 8839;
  e2.registered = 174;
  e2.registersans = 63720;
  e2.registerserif = 63194;
  e2.reharabic = 1585;
  e2.reharmenian = 1408;
  e2.rehfinalarabic = 65198;
  e2.rehiragana = 12428;
  e2.rekatakana = 12524;
  e2.rekatakanahalfwidth = 65434;
  e2.resh = 1512;
  e2.reshdageshhebrew = 64328;
  e2.reshhebrew = 1512;
  e2.reversedtilde = 8765;
  e2.reviahebrew = 1431;
  e2.reviamugrashhebrew = 1431;
  e2.revlogicalnot = 8976;
  e2.rfishhook = 638;
  e2.rfishhookreversed = 639;
  e2.rhabengali = 2525;
  e2.rhadeva = 2397;
  e2.rho = 961;
  e2.rhook = 637;
  e2.rhookturned = 635;
  e2.rhookturnedsuperior = 693;
  e2.rhosymbolgreek = 1009;
  e2.rhotichookmod = 734;
  e2.rieulacirclekorean = 12913;
  e2.rieulaparenkorean = 12817;
  e2.rieulcirclekorean = 12899;
  e2.rieulhieuhkorean = 12608;
  e2.rieulkiyeokkorean = 12602;
  e2.rieulkiyeoksioskorean = 12649;
  e2.rieulkorean = 12601;
  e2.rieulmieumkorean = 12603;
  e2.rieulpansioskorean = 12652;
  e2.rieulparenkorean = 12803;
  e2.rieulphieuphkorean = 12607;
  e2.rieulpieupkorean = 12604;
  e2.rieulpieupsioskorean = 12651;
  e2.rieulsioskorean = 12605;
  e2.rieulthieuthkorean = 12606;
  e2.rieultikeutkorean = 12650;
  e2.rieulyeorinhieuhkorean = 12653;
  e2.rightangle = 8735;
  e2.righttackbelowcmb = 793;
  e2.righttriangle = 8895;
  e2.rihiragana = 12426;
  e2.rikatakana = 12522;
  e2.rikatakanahalfwidth = 65432;
  e2.ring = 730;
  e2.ringbelowcmb = 805;
  e2.ringcmb = 778;
  e2.ringhalfleft = 703;
  e2.ringhalfleftarmenian = 1369;
  e2.ringhalfleftbelowcmb = 796;
  e2.ringhalfleftcentered = 723;
  e2.ringhalfright = 702;
  e2.ringhalfrightbelowcmb = 825;
  e2.ringhalfrightcentered = 722;
  e2.rinvertedbreve = 531;
  e2.rittorusquare = 13137;
  e2.rlinebelow = 7775;
  e2.rlongleg = 636;
  e2.rlonglegturned = 634;
  e2.rmonospace = 65362;
  e2.rohiragana = 12429;
  e2.rokatakana = 12525;
  e2.rokatakanahalfwidth = 65435;
  e2.roruathai = 3619;
  e2.rparen = 9389;
  e2.rrabengali = 2524;
  e2.rradeva = 2353;
  e2.rragurmukhi = 2652;
  e2.rreharabic = 1681;
  e2.rrehfinalarabic = 64397;
  e2.rrvocalicbengali = 2528;
  e2.rrvocalicdeva = 2400;
  e2.rrvocalicgujarati = 2784;
  e2.rrvocalicvowelsignbengali = 2500;
  e2.rrvocalicvowelsigndeva = 2372;
  e2.rrvocalicvowelsigngujarati = 2756;
  e2.rsuperior = 63217;
  e2.rtblock = 9616;
  e2.rturned = 633;
  e2.rturnedsuperior = 692;
  e2.ruhiragana = 12427;
  e2.rukatakana = 12523;
  e2.rukatakanahalfwidth = 65433;
  e2.rupeemarkbengali = 2546;
  e2.rupeesignbengali = 2547;
  e2.rupiah = 63197;
  e2.ruthai = 3620;
  e2.rvocalicbengali = 2443;
  e2.rvocalicdeva = 2315;
  e2.rvocalicgujarati = 2699;
  e2.rvocalicvowelsignbengali = 2499;
  e2.rvocalicvowelsigndeva = 2371;
  e2.rvocalicvowelsigngujarati = 2755;
  e2.s = 115;
  e2.sabengali = 2488;
  e2.sacute = 347;
  e2.sacutedotaccent = 7781;
  e2.sadarabic = 1589;
  e2.sadeva = 2360;
  e2.sadfinalarabic = 65210;
  e2.sadinitialarabic = 65211;
  e2.sadmedialarabic = 65212;
  e2.sagujarati = 2744;
  e2.sagurmukhi = 2616;
  e2.sahiragana = 12373;
  e2.sakatakana = 12469;
  e2.sakatakanahalfwidth = 65403;
  e2.sallallahoualayhewasallamarabic = 65018;
  e2.samekh = 1505;
  e2.samekhdagesh = 64321;
  e2.samekhdageshhebrew = 64321;
  e2.samekhhebrew = 1505;
  e2.saraaathai = 3634;
  e2.saraaethai = 3649;
  e2.saraaimaimalaithai = 3652;
  e2.saraaimaimuanthai = 3651;
  e2.saraamthai = 3635;
  e2.saraathai = 3632;
  e2.saraethai = 3648;
  e2.saraiileftthai = 63622;
  e2.saraiithai = 3637;
  e2.saraileftthai = 63621;
  e2.saraithai = 3636;
  e2.saraothai = 3650;
  e2.saraueeleftthai = 63624;
  e2.saraueethai = 3639;
  e2.saraueleftthai = 63623;
  e2.sarauethai = 3638;
  e2.sarauthai = 3640;
  e2.sarauuthai = 3641;
  e2.sbopomofo = 12569;
  e2.scaron = 353;
  e2.scarondotaccent = 7783;
  e2.scedilla = 351;
  e2.schwa = 601;
  e2.schwacyrillic = 1241;
  e2.schwadieresiscyrillic = 1243;
  e2.schwahook = 602;
  e2.scircle = 9442;
  e2.scircumflex = 349;
  e2.scommaaccent = 537;
  e2.sdotaccent = 7777;
  e2.sdotbelow = 7779;
  e2.sdotbelowdotaccent = 7785;
  e2.seagullbelowcmb = 828;
  e2.second = 8243;
  e2.secondtonechinese = 714;
  e2.section = 167;
  e2.seenarabic = 1587;
  e2.seenfinalarabic = 65202;
  e2.seeninitialarabic = 65203;
  e2.seenmedialarabic = 65204;
  e2.segol = 1462;
  e2.segol13 = 1462;
  e2.segol1f = 1462;
  e2.segol2c = 1462;
  e2.segolhebrew = 1462;
  e2.segolnarrowhebrew = 1462;
  e2.segolquarterhebrew = 1462;
  e2.segoltahebrew = 1426;
  e2.segolwidehebrew = 1462;
  e2.seharmenian = 1405;
  e2.sehiragana = 12379;
  e2.sekatakana = 12475;
  e2.sekatakanahalfwidth = 65406;
  e2.semicolon = 59;
  e2.semicolonarabic = 1563;
  e2.semicolonmonospace = 65307;
  e2.semicolonsmall = 65108;
  e2.semivoicedmarkkana = 12444;
  e2.semivoicedmarkkanahalfwidth = 65439;
  e2.sentisquare = 13090;
  e2.sentosquare = 13091;
  e2.seven = 55;
  e2.sevenarabic = 1639;
  e2.sevenbengali = 2541;
  e2.sevencircle = 9318;
  e2.sevencircleinversesansserif = 10128;
  e2.sevendeva = 2413;
  e2.seveneighths = 8542;
  e2.sevengujarati = 2797;
  e2.sevengurmukhi = 2669;
  e2.sevenhackarabic = 1639;
  e2.sevenhangzhou = 12327;
  e2.sevenideographicparen = 12838;
  e2.seveninferior = 8327;
  e2.sevenmonospace = 65303;
  e2.sevenoldstyle = 63287;
  e2.sevenparen = 9338;
  e2.sevenperiod = 9358;
  e2.sevenpersian = 1783;
  e2.sevenroman = 8566;
  e2.sevensuperior = 8311;
  e2.seventeencircle = 9328;
  e2.seventeenparen = 9348;
  e2.seventeenperiod = 9368;
  e2.seventhai = 3671;
  e2.sfthyphen = 173;
  e2.shaarmenian = 1399;
  e2.shabengali = 2486;
  e2.shacyrillic = 1096;
  e2.shaddaarabic = 1617;
  e2.shaddadammaarabic = 64609;
  e2.shaddadammatanarabic = 64606;
  e2.shaddafathaarabic = 64608;
  e2.shaddakasraarabic = 64610;
  e2.shaddakasratanarabic = 64607;
  e2.shade = 9618;
  e2.shadedark = 9619;
  e2.shadelight = 9617;
  e2.shademedium = 9618;
  e2.shadeva = 2358;
  e2.shagujarati = 2742;
  e2.shagurmukhi = 2614;
  e2.shalshelethebrew = 1427;
  e2.shbopomofo = 12565;
  e2.shchacyrillic = 1097;
  e2.sheenarabic = 1588;
  e2.sheenfinalarabic = 65206;
  e2.sheeninitialarabic = 65207;
  e2.sheenmedialarabic = 65208;
  e2.sheicoptic = 995;
  e2.sheqel = 8362;
  e2.sheqelhebrew = 8362;
  e2.sheva = 1456;
  e2.sheva115 = 1456;
  e2.sheva15 = 1456;
  e2.sheva22 = 1456;
  e2.sheva2e = 1456;
  e2.shevahebrew = 1456;
  e2.shevanarrowhebrew = 1456;
  e2.shevaquarterhebrew = 1456;
  e2.shevawidehebrew = 1456;
  e2.shhacyrillic = 1211;
  e2.shimacoptic = 1005;
  e2.shin = 1513;
  e2.shindagesh = 64329;
  e2.shindageshhebrew = 64329;
  e2.shindageshshindot = 64300;
  e2.shindageshshindothebrew = 64300;
  e2.shindageshsindot = 64301;
  e2.shindageshsindothebrew = 64301;
  e2.shindothebrew = 1473;
  e2.shinhebrew = 1513;
  e2.shinshindot = 64298;
  e2.shinshindothebrew = 64298;
  e2.shinsindot = 64299;
  e2.shinsindothebrew = 64299;
  e2.shook = 642;
  e2.sigma = 963;
  e2.sigma1 = 962;
  e2.sigmafinal = 962;
  e2.sigmalunatesymbolgreek = 1010;
  e2.sihiragana = 12375;
  e2.sikatakana = 12471;
  e2.sikatakanahalfwidth = 65404;
  e2.siluqhebrew = 1469;
  e2.siluqlefthebrew = 1469;
  e2.similar = 8764;
  e2.sindothebrew = 1474;
  e2.siosacirclekorean = 12916;
  e2.siosaparenkorean = 12820;
  e2.sioscieuckorean = 12670;
  e2.sioscirclekorean = 12902;
  e2.sioskiyeokkorean = 12666;
  e2.sioskorean = 12613;
  e2.siosnieunkorean = 12667;
  e2.siosparenkorean = 12806;
  e2.siospieupkorean = 12669;
  e2.siostikeutkorean = 12668;
  e2.six = 54;
  e2.sixarabic = 1638;
  e2.sixbengali = 2540;
  e2.sixcircle = 9317;
  e2.sixcircleinversesansserif = 10127;
  e2.sixdeva = 2412;
  e2.sixgujarati = 2796;
  e2.sixgurmukhi = 2668;
  e2.sixhackarabic = 1638;
  e2.sixhangzhou = 12326;
  e2.sixideographicparen = 12837;
  e2.sixinferior = 8326;
  e2.sixmonospace = 65302;
  e2.sixoldstyle = 63286;
  e2.sixparen = 9337;
  e2.sixperiod = 9357;
  e2.sixpersian = 1782;
  e2.sixroman = 8565;
  e2.sixsuperior = 8310;
  e2.sixteencircle = 9327;
  e2.sixteencurrencydenominatorbengali = 2553;
  e2.sixteenparen = 9347;
  e2.sixteenperiod = 9367;
  e2.sixthai = 3670;
  e2.slash = 47;
  e2.slashmonospace = 65295;
  e2.slong = 383;
  e2.slongdotaccent = 7835;
  e2.smileface = 9786;
  e2.smonospace = 65363;
  e2.sofpasuqhebrew = 1475;
  e2.softhyphen = 173;
  e2.softsigncyrillic = 1100;
  e2.sohiragana = 12381;
  e2.sokatakana = 12477;
  e2.sokatakanahalfwidth = 65407;
  e2.soliduslongoverlaycmb = 824;
  e2.solidusshortoverlaycmb = 823;
  e2.sorusithai = 3625;
  e2.sosalathai = 3624;
  e2.sosothai = 3595;
  e2.sosuathai = 3626;
  e2.space = 32;
  e2.spacehackarabic = 32;
  e2.spade = 9824;
  e2.spadesuitblack = 9824;
  e2.spadesuitwhite = 9828;
  e2.sparen = 9390;
  e2.squarebelowcmb = 827;
  e2.squarecc = 13252;
  e2.squarecm = 13213;
  e2.squarediagonalcrosshatchfill = 9641;
  e2.squarehorizontalfill = 9636;
  e2.squarekg = 13199;
  e2.squarekm = 13214;
  e2.squarekmcapital = 13262;
  e2.squareln = 13265;
  e2.squarelog = 13266;
  e2.squaremg = 13198;
  e2.squaremil = 13269;
  e2.squaremm = 13212;
  e2.squaremsquared = 13217;
  e2.squareorthogonalcrosshatchfill = 9638;
  e2.squareupperlefttolowerrightfill = 9639;
  e2.squareupperrighttolowerleftfill = 9640;
  e2.squareverticalfill = 9637;
  e2.squarewhitewithsmallblack = 9635;
  e2.srsquare = 13275;
  e2.ssabengali = 2487;
  e2.ssadeva = 2359;
  e2.ssagujarati = 2743;
  e2.ssangcieuckorean = 12617;
  e2.ssanghieuhkorean = 12677;
  e2.ssangieungkorean = 12672;
  e2.ssangkiyeokkorean = 12594;
  e2.ssangnieunkorean = 12645;
  e2.ssangpieupkorean = 12611;
  e2.ssangsioskorean = 12614;
  e2.ssangtikeutkorean = 12600;
  e2.ssuperior = 63218;
  e2.sterling = 163;
  e2.sterlingmonospace = 65505;
  e2.strokelongoverlaycmb = 822;
  e2.strokeshortoverlaycmb = 821;
  e2.subset = 8834;
  e2.subsetnotequal = 8842;
  e2.subsetorequal = 8838;
  e2.succeeds = 8827;
  e2.suchthat = 8715;
  e2.suhiragana = 12377;
  e2.sukatakana = 12473;
  e2.sukatakanahalfwidth = 65405;
  e2.sukunarabic = 1618;
  e2.summation = 8721;
  e2.sun = 9788;
  e2.superset = 8835;
  e2.supersetnotequal = 8843;
  e2.supersetorequal = 8839;
  e2.svsquare = 13276;
  e2.syouwaerasquare = 13180;
  e2.t = 116;
  e2.tabengali = 2468;
  e2.tackdown = 8868;
  e2.tackleft = 8867;
  e2.tadeva = 2340;
  e2.tagujarati = 2724;
  e2.tagurmukhi = 2596;
  e2.taharabic = 1591;
  e2.tahfinalarabic = 65218;
  e2.tahinitialarabic = 65219;
  e2.tahiragana = 12383;
  e2.tahmedialarabic = 65220;
  e2.taisyouerasquare = 13181;
  e2.takatakana = 12479;
  e2.takatakanahalfwidth = 65408;
  e2.tatweelarabic = 1600;
  e2.tau = 964;
  e2.tav = 1514;
  e2.tavdages = 64330;
  e2.tavdagesh = 64330;
  e2.tavdageshhebrew = 64330;
  e2.tavhebrew = 1514;
  e2.tbar = 359;
  e2.tbopomofo = 12554;
  e2.tcaron = 357;
  e2.tccurl = 680;
  e2.tcedilla = 355;
  e2.tcheharabic = 1670;
  e2.tchehfinalarabic = 64379;
  e2.tchehinitialarabic = 64380;
  e2.tchehmedialarabic = 64381;
  e2.tcircle = 9443;
  e2.tcircumflexbelow = 7793;
  e2.tcommaaccent = 355;
  e2.tdieresis = 7831;
  e2.tdotaccent = 7787;
  e2.tdotbelow = 7789;
  e2.tecyrillic = 1090;
  e2.tedescendercyrillic = 1197;
  e2.teharabic = 1578;
  e2.tehfinalarabic = 65174;
  e2.tehhahinitialarabic = 64674;
  e2.tehhahisolatedarabic = 64524;
  e2.tehinitialarabic = 65175;
  e2.tehiragana = 12390;
  e2.tehjeeminitialarabic = 64673;
  e2.tehjeemisolatedarabic = 64523;
  e2.tehmarbutaarabic = 1577;
  e2.tehmarbutafinalarabic = 65172;
  e2.tehmedialarabic = 65176;
  e2.tehmeeminitialarabic = 64676;
  e2.tehmeemisolatedarabic = 64526;
  e2.tehnoonfinalarabic = 64627;
  e2.tekatakana = 12486;
  e2.tekatakanahalfwidth = 65411;
  e2.telephone = 8481;
  e2.telephoneblack = 9742;
  e2.telishagedolahebrew = 1440;
  e2.telishaqetanahebrew = 1449;
  e2.tencircle = 9321;
  e2.tenideographicparen = 12841;
  e2.tenparen = 9341;
  e2.tenperiod = 9361;
  e2.tenroman = 8569;
  e2.tesh = 679;
  e2.tet = 1496;
  e2.tetdagesh = 64312;
  e2.tetdageshhebrew = 64312;
  e2.tethebrew = 1496;
  e2.tetsecyrillic = 1205;
  e2.tevirhebrew = 1435;
  e2.tevirlefthebrew = 1435;
  e2.thabengali = 2469;
  e2.thadeva = 2341;
  e2.thagujarati = 2725;
  e2.thagurmukhi = 2597;
  e2.thalarabic = 1584;
  e2.thalfinalarabic = 65196;
  e2.thanthakhatlowleftthai = 63640;
  e2.thanthakhatlowrightthai = 63639;
  e2.thanthakhatthai = 3660;
  e2.thanthakhatupperleftthai = 63638;
  e2.theharabic = 1579;
  e2.thehfinalarabic = 65178;
  e2.thehinitialarabic = 65179;
  e2.thehmedialarabic = 65180;
  e2.thereexists = 8707;
  e2.therefore = 8756;
  e2.theta = 952;
  e2.theta1 = 977;
  e2.thetasymbolgreek = 977;
  e2.thieuthacirclekorean = 12921;
  e2.thieuthaparenkorean = 12825;
  e2.thieuthcirclekorean = 12907;
  e2.thieuthkorean = 12620;
  e2.thieuthparenkorean = 12811;
  e2.thirteencircle = 9324;
  e2.thirteenparen = 9344;
  e2.thirteenperiod = 9364;
  e2.thonangmonthothai = 3601;
  e2.thook = 429;
  e2.thophuthaothai = 3602;
  e2.thorn = 254;
  e2.thothahanthai = 3607;
  e2.thothanthai = 3600;
  e2.thothongthai = 3608;
  e2.thothungthai = 3606;
  e2.thousandcyrillic = 1154;
  e2.thousandsseparatorarabic = 1644;
  e2.thousandsseparatorpersian = 1644;
  e2.three = 51;
  e2.threearabic = 1635;
  e2.threebengali = 2537;
  e2.threecircle = 9314;
  e2.threecircleinversesansserif = 10124;
  e2.threedeva = 2409;
  e2.threeeighths = 8540;
  e2.threegujarati = 2793;
  e2.threegurmukhi = 2665;
  e2.threehackarabic = 1635;
  e2.threehangzhou = 12323;
  e2.threeideographicparen = 12834;
  e2.threeinferior = 8323;
  e2.threemonospace = 65299;
  e2.threenumeratorbengali = 2550;
  e2.threeoldstyle = 63283;
  e2.threeparen = 9334;
  e2.threeperiod = 9354;
  e2.threepersian = 1779;
  e2.threequarters = 190;
  e2.threequartersemdash = 63198;
  e2.threeroman = 8562;
  e2.threesuperior = 179;
  e2.threethai = 3667;
  e2.thzsquare = 13204;
  e2.tihiragana = 12385;
  e2.tikatakana = 12481;
  e2.tikatakanahalfwidth = 65409;
  e2.tikeutacirclekorean = 12912;
  e2.tikeutaparenkorean = 12816;
  e2.tikeutcirclekorean = 12898;
  e2.tikeutkorean = 12599;
  e2.tikeutparenkorean = 12802;
  e2.tilde = 732;
  e2.tildebelowcmb = 816;
  e2.tildecmb = 771;
  e2.tildecomb = 771;
  e2.tildedoublecmb = 864;
  e2.tildeoperator = 8764;
  e2.tildeoverlaycmb = 820;
  e2.tildeverticalcmb = 830;
  e2.timescircle = 8855;
  e2.tipehahebrew = 1430;
  e2.tipehalefthebrew = 1430;
  e2.tippigurmukhi = 2672;
  e2.titlocyrilliccmb = 1155;
  e2.tiwnarmenian = 1407;
  e2.tlinebelow = 7791;
  e2.tmonospace = 65364;
  e2.toarmenian = 1385;
  e2.tohiragana = 12392;
  e2.tokatakana = 12488;
  e2.tokatakanahalfwidth = 65412;
  e2.tonebarextrahighmod = 741;
  e2.tonebarextralowmod = 745;
  e2.tonebarhighmod = 742;
  e2.tonebarlowmod = 744;
  e2.tonebarmidmod = 743;
  e2.tonefive = 445;
  e2.tonesix = 389;
  e2.tonetwo = 424;
  e2.tonos = 900;
  e2.tonsquare = 13095;
  e2.topatakthai = 3599;
  e2.tortoiseshellbracketleft = 12308;
  e2.tortoiseshellbracketleftsmall = 65117;
  e2.tortoiseshellbracketleftvertical = 65081;
  e2.tortoiseshellbracketright = 12309;
  e2.tortoiseshellbracketrightsmall = 65118;
  e2.tortoiseshellbracketrightvertical = 65082;
  e2.totaothai = 3605;
  e2.tpalatalhook = 427;
  e2.tparen = 9391;
  e2.trademark = 8482;
  e2.trademarksans = 63722;
  e2.trademarkserif = 63195;
  e2.tretroflexhook = 648;
  e2.triagdn = 9660;
  e2.triaglf = 9668;
  e2.triagrt = 9658;
  e2.triagup = 9650;
  e2.ts = 678;
  e2.tsadi = 1510;
  e2.tsadidagesh = 64326;
  e2.tsadidageshhebrew = 64326;
  e2.tsadihebrew = 1510;
  e2.tsecyrillic = 1094;
  e2.tsere = 1461;
  e2.tsere12 = 1461;
  e2.tsere1e = 1461;
  e2.tsere2b = 1461;
  e2.tserehebrew = 1461;
  e2.tserenarrowhebrew = 1461;
  e2.tserequarterhebrew = 1461;
  e2.tserewidehebrew = 1461;
  e2.tshecyrillic = 1115;
  e2.tsuperior = 63219;
  e2.ttabengali = 2463;
  e2.ttadeva = 2335;
  e2.ttagujarati = 2719;
  e2.ttagurmukhi = 2591;
  e2.tteharabic = 1657;
  e2.ttehfinalarabic = 64359;
  e2.ttehinitialarabic = 64360;
  e2.ttehmedialarabic = 64361;
  e2.tthabengali = 2464;
  e2.tthadeva = 2336;
  e2.tthagujarati = 2720;
  e2.tthagurmukhi = 2592;
  e2.tturned = 647;
  e2.tuhiragana = 12388;
  e2.tukatakana = 12484;
  e2.tukatakanahalfwidth = 65410;
  e2.tusmallhiragana = 12387;
  e2.tusmallkatakana = 12483;
  e2.tusmallkatakanahalfwidth = 65391;
  e2.twelvecircle = 9323;
  e2.twelveparen = 9343;
  e2.twelveperiod = 9363;
  e2.twelveroman = 8571;
  e2.twentycircle = 9331;
  e2.twentyhangzhou = 21316;
  e2.twentyparen = 9351;
  e2.twentyperiod = 9371;
  e2.two = 50;
  e2.twoarabic = 1634;
  e2.twobengali = 2536;
  e2.twocircle = 9313;
  e2.twocircleinversesansserif = 10123;
  e2.twodeva = 2408;
  e2.twodotenleader = 8229;
  e2.twodotleader = 8229;
  e2.twodotleadervertical = 65072;
  e2.twogujarati = 2792;
  e2.twogurmukhi = 2664;
  e2.twohackarabic = 1634;
  e2.twohangzhou = 12322;
  e2.twoideographicparen = 12833;
  e2.twoinferior = 8322;
  e2.twomonospace = 65298;
  e2.twonumeratorbengali = 2549;
  e2.twooldstyle = 63282;
  e2.twoparen = 9333;
  e2.twoperiod = 9353;
  e2.twopersian = 1778;
  e2.tworoman = 8561;
  e2.twostroke = 443;
  e2.twosuperior = 178;
  e2.twothai = 3666;
  e2.twothirds = 8532;
  e2.u = 117;
  e2.uacute = 250;
  e2.ubar = 649;
  e2.ubengali = 2441;
  e2.ubopomofo = 12584;
  e2.ubreve = 365;
  e2.ucaron = 468;
  e2.ucircle = 9444;
  e2.ucircumflex = 251;
  e2.ucircumflexbelow = 7799;
  e2.ucyrillic = 1091;
  e2.udattadeva = 2385;
  e2.udblacute = 369;
  e2.udblgrave = 533;
  e2.udeva = 2313;
  e2.udieresis = 252;
  e2.udieresisacute = 472;
  e2.udieresisbelow = 7795;
  e2.udieresiscaron = 474;
  e2.udieresiscyrillic = 1265;
  e2.udieresisgrave = 476;
  e2.udieresismacron = 470;
  e2.udotbelow = 7909;
  e2.ugrave = 249;
  e2.ugujarati = 2697;
  e2.ugurmukhi = 2569;
  e2.uhiragana = 12358;
  e2.uhookabove = 7911;
  e2.uhorn = 432;
  e2.uhornacute = 7913;
  e2.uhorndotbelow = 7921;
  e2.uhorngrave = 7915;
  e2.uhornhookabove = 7917;
  e2.uhorntilde = 7919;
  e2.uhungarumlaut = 369;
  e2.uhungarumlautcyrillic = 1267;
  e2.uinvertedbreve = 535;
  e2.ukatakana = 12454;
  e2.ukatakanahalfwidth = 65395;
  e2.ukcyrillic = 1145;
  e2.ukorean = 12636;
  e2.umacron = 363;
  e2.umacroncyrillic = 1263;
  e2.umacrondieresis = 7803;
  e2.umatragurmukhi = 2625;
  e2.umonospace = 65365;
  e2.underscore = 95;
  e2.underscoredbl = 8215;
  e2.underscoremonospace = 65343;
  e2.underscorevertical = 65075;
  e2.underscorewavy = 65103;
  e2.union = 8746;
  e2.universal = 8704;
  e2.uogonek = 371;
  e2.uparen = 9392;
  e2.upblock = 9600;
  e2.upperdothebrew = 1476;
  e2.upsilon = 965;
  e2.upsilondieresis = 971;
  e2.upsilondieresistonos = 944;
  e2.upsilonlatin = 650;
  e2.upsilontonos = 973;
  e2.uptackbelowcmb = 797;
  e2.uptackmod = 724;
  e2.uragurmukhi = 2675;
  e2.uring = 367;
  e2.ushortcyrillic = 1118;
  e2.usmallhiragana = 12357;
  e2.usmallkatakana = 12453;
  e2.usmallkatakanahalfwidth = 65385;
  e2.ustraightcyrillic = 1199;
  e2.ustraightstrokecyrillic = 1201;
  e2.utilde = 361;
  e2.utildeacute = 7801;
  e2.utildebelow = 7797;
  e2.uubengali = 2442;
  e2.uudeva = 2314;
  e2.uugujarati = 2698;
  e2.uugurmukhi = 2570;
  e2.uumatragurmukhi = 2626;
  e2.uuvowelsignbengali = 2498;
  e2.uuvowelsigndeva = 2370;
  e2.uuvowelsigngujarati = 2754;
  e2.uvowelsignbengali = 2497;
  e2.uvowelsigndeva = 2369;
  e2.uvowelsigngujarati = 2753;
  e2.v = 118;
  e2.vadeva = 2357;
  e2.vagujarati = 2741;
  e2.vagurmukhi = 2613;
  e2.vakatakana = 12535;
  e2.vav = 1493;
  e2.vavdagesh = 64309;
  e2.vavdagesh65 = 64309;
  e2.vavdageshhebrew = 64309;
  e2.vavhebrew = 1493;
  e2.vavholam = 64331;
  e2.vavholamhebrew = 64331;
  e2.vavvavhebrew = 1520;
  e2.vavyodhebrew = 1521;
  e2.vcircle = 9445;
  e2.vdotbelow = 7807;
  e2.vecyrillic = 1074;
  e2.veharabic = 1700;
  e2.vehfinalarabic = 64363;
  e2.vehinitialarabic = 64364;
  e2.vehmedialarabic = 64365;
  e2.vekatakana = 12537;
  e2.venus = 9792;
  e2.verticalbar = 124;
  e2.verticallineabovecmb = 781;
  e2.verticallinebelowcmb = 809;
  e2.verticallinelowmod = 716;
  e2.verticallinemod = 712;
  e2.vewarmenian = 1406;
  e2.vhook = 651;
  e2.vikatakana = 12536;
  e2.viramabengali = 2509;
  e2.viramadeva = 2381;
  e2.viramagujarati = 2765;
  e2.visargabengali = 2435;
  e2.visargadeva = 2307;
  e2.visargagujarati = 2691;
  e2.vmonospace = 65366;
  e2.voarmenian = 1400;
  e2.voicediterationhiragana = 12446;
  e2.voicediterationkatakana = 12542;
  e2.voicedmarkkana = 12443;
  e2.voicedmarkkanahalfwidth = 65438;
  e2.vokatakana = 12538;
  e2.vparen = 9393;
  e2.vtilde = 7805;
  e2.vturned = 652;
  e2.vuhiragana = 12436;
  e2.vukatakana = 12532;
  e2.w = 119;
  e2.wacute = 7811;
  e2.waekorean = 12633;
  e2.wahiragana = 12431;
  e2.wakatakana = 12527;
  e2.wakatakanahalfwidth = 65436;
  e2.wakorean = 12632;
  e2.wasmallhiragana = 12430;
  e2.wasmallkatakana = 12526;
  e2.wattosquare = 13143;
  e2.wavedash = 12316;
  e2.wavyunderscorevertical = 65076;
  e2.wawarabic = 1608;
  e2.wawfinalarabic = 65262;
  e2.wawhamzaabovearabic = 1572;
  e2.wawhamzaabovefinalarabic = 65158;
  e2.wbsquare = 13277;
  e2.wcircle = 9446;
  e2.wcircumflex = 373;
  e2.wdieresis = 7813;
  e2.wdotaccent = 7815;
  e2.wdotbelow = 7817;
  e2.wehiragana = 12433;
  e2.weierstrass = 8472;
  e2.wekatakana = 12529;
  e2.wekorean = 12638;
  e2.weokorean = 12637;
  e2.wgrave = 7809;
  e2.whitebullet = 9702;
  e2.whitecircle = 9675;
  e2.whitecircleinverse = 9689;
  e2.whitecornerbracketleft = 12302;
  e2.whitecornerbracketleftvertical = 65091;
  e2.whitecornerbracketright = 12303;
  e2.whitecornerbracketrightvertical = 65092;
  e2.whitediamond = 9671;
  e2.whitediamondcontainingblacksmalldiamond = 9672;
  e2.whitedownpointingsmalltriangle = 9663;
  e2.whitedownpointingtriangle = 9661;
  e2.whiteleftpointingsmalltriangle = 9667;
  e2.whiteleftpointingtriangle = 9665;
  e2.whitelenticularbracketleft = 12310;
  e2.whitelenticularbracketright = 12311;
  e2.whiterightpointingsmalltriangle = 9657;
  e2.whiterightpointingtriangle = 9655;
  e2.whitesmallsquare = 9643;
  e2.whitesmilingface = 9786;
  e2.whitesquare = 9633;
  e2.whitestar = 9734;
  e2.whitetelephone = 9743;
  e2.whitetortoiseshellbracketleft = 12312;
  e2.whitetortoiseshellbracketright = 12313;
  e2.whiteuppointingsmalltriangle = 9653;
  e2.whiteuppointingtriangle = 9651;
  e2.wihiragana = 12432;
  e2.wikatakana = 12528;
  e2.wikorean = 12639;
  e2.wmonospace = 65367;
  e2.wohiragana = 12434;
  e2.wokatakana = 12530;
  e2.wokatakanahalfwidth = 65382;
  e2.won = 8361;
  e2.wonmonospace = 65510;
  e2.wowaenthai = 3623;
  e2.wparen = 9394;
  e2.wring = 7832;
  e2.wsuperior = 695;
  e2.wturned = 653;
  e2.wynn = 447;
  e2.x = 120;
  e2.xabovecmb = 829;
  e2.xbopomofo = 12562;
  e2.xcircle = 9447;
  e2.xdieresis = 7821;
  e2.xdotaccent = 7819;
  e2.xeharmenian = 1389;
  e2.xi = 958;
  e2.xmonospace = 65368;
  e2.xparen = 9395;
  e2.xsuperior = 739;
  e2.y = 121;
  e2.yaadosquare = 13134;
  e2.yabengali = 2479;
  e2.yacute = 253;
  e2.yadeva = 2351;
  e2.yaekorean = 12626;
  e2.yagujarati = 2735;
  e2.yagurmukhi = 2607;
  e2.yahiragana = 12420;
  e2.yakatakana = 12516;
  e2.yakatakanahalfwidth = 65428;
  e2.yakorean = 12625;
  e2.yamakkanthai = 3662;
  e2.yasmallhiragana = 12419;
  e2.yasmallkatakana = 12515;
  e2.yasmallkatakanahalfwidth = 65388;
  e2.yatcyrillic = 1123;
  e2.ycircle = 9448;
  e2.ycircumflex = 375;
  e2.ydieresis = 255;
  e2.ydotaccent = 7823;
  e2.ydotbelow = 7925;
  e2.yeharabic = 1610;
  e2.yehbarreearabic = 1746;
  e2.yehbarreefinalarabic = 64431;
  e2.yehfinalarabic = 65266;
  e2.yehhamzaabovearabic = 1574;
  e2.yehhamzaabovefinalarabic = 65162;
  e2.yehhamzaaboveinitialarabic = 65163;
  e2.yehhamzaabovemedialarabic = 65164;
  e2.yehinitialarabic = 65267;
  e2.yehmedialarabic = 65268;
  e2.yehmeeminitialarabic = 64733;
  e2.yehmeemisolatedarabic = 64600;
  e2.yehnoonfinalarabic = 64660;
  e2.yehthreedotsbelowarabic = 1745;
  e2.yekorean = 12630;
  e2.yen = 165;
  e2.yenmonospace = 65509;
  e2.yeokorean = 12629;
  e2.yeorinhieuhkorean = 12678;
  e2.yerahbenyomohebrew = 1450;
  e2.yerahbenyomolefthebrew = 1450;
  e2.yericyrillic = 1099;
  e2.yerudieresiscyrillic = 1273;
  e2.yesieungkorean = 12673;
  e2.yesieungpansioskorean = 12675;
  e2.yesieungsioskorean = 12674;
  e2.yetivhebrew = 1434;
  e2.ygrave = 7923;
  e2.yhook = 436;
  e2.yhookabove = 7927;
  e2.yiarmenian = 1397;
  e2.yicyrillic = 1111;
  e2.yikorean = 12642;
  e2.yinyang = 9775;
  e2.yiwnarmenian = 1410;
  e2.ymonospace = 65369;
  e2.yod = 1497;
  e2.yoddagesh = 64313;
  e2.yoddageshhebrew = 64313;
  e2.yodhebrew = 1497;
  e2.yodyodhebrew = 1522;
  e2.yodyodpatahhebrew = 64287;
  e2.yohiragana = 12424;
  e2.yoikorean = 12681;
  e2.yokatakana = 12520;
  e2.yokatakanahalfwidth = 65430;
  e2.yokorean = 12635;
  e2.yosmallhiragana = 12423;
  e2.yosmallkatakana = 12519;
  e2.yosmallkatakanahalfwidth = 65390;
  e2.yotgreek = 1011;
  e2.yoyaekorean = 12680;
  e2.yoyakorean = 12679;
  e2.yoyakthai = 3618;
  e2.yoyingthai = 3597;
  e2.yparen = 9396;
  e2.ypogegrammeni = 890;
  e2.ypogegrammenigreekcmb = 837;
  e2.yr = 422;
  e2.yring = 7833;
  e2.ysuperior = 696;
  e2.ytilde = 7929;
  e2.yturned = 654;
  e2.yuhiragana = 12422;
  e2.yuikorean = 12684;
  e2.yukatakana = 12518;
  e2.yukatakanahalfwidth = 65429;
  e2.yukorean = 12640;
  e2.yusbigcyrillic = 1131;
  e2.yusbigiotifiedcyrillic = 1133;
  e2.yuslittlecyrillic = 1127;
  e2.yuslittleiotifiedcyrillic = 1129;
  e2.yusmallhiragana = 12421;
  e2.yusmallkatakana = 12517;
  e2.yusmallkatakanahalfwidth = 65389;
  e2.yuyekorean = 12683;
  e2.yuyeokorean = 12682;
  e2.yyabengali = 2527;
  e2.yyadeva = 2399;
  e2.z = 122;
  e2.zaarmenian = 1382;
  e2.zacute = 378;
  e2.zadeva = 2395;
  e2.zagurmukhi = 2651;
  e2.zaharabic = 1592;
  e2.zahfinalarabic = 65222;
  e2.zahinitialarabic = 65223;
  e2.zahiragana = 12374;
  e2.zahmedialarabic = 65224;
  e2.zainarabic = 1586;
  e2.zainfinalarabic = 65200;
  e2.zakatakana = 12470;
  e2.zaqefgadolhebrew = 1429;
  e2.zaqefqatanhebrew = 1428;
  e2.zarqahebrew = 1432;
  e2.zayin = 1494;
  e2.zayindagesh = 64310;
  e2.zayindageshhebrew = 64310;
  e2.zayinhebrew = 1494;
  e2.zbopomofo = 12567;
  e2.zcaron = 382;
  e2.zcircle = 9449;
  e2.zcircumflex = 7825;
  e2.zcurl = 657;
  e2.zdot = 380;
  e2.zdotaccent = 380;
  e2.zdotbelow = 7827;
  e2.zecyrillic = 1079;
  e2.zedescendercyrillic = 1177;
  e2.zedieresiscyrillic = 1247;
  e2.zehiragana = 12380;
  e2.zekatakana = 12476;
  e2.zero = 48;
  e2.zeroarabic = 1632;
  e2.zerobengali = 2534;
  e2.zerodeva = 2406;
  e2.zerogujarati = 2790;
  e2.zerogurmukhi = 2662;
  e2.zerohackarabic = 1632;
  e2.zeroinferior = 8320;
  e2.zeromonospace = 65296;
  e2.zerooldstyle = 63280;
  e2.zeropersian = 1776;
  e2.zerosuperior = 8304;
  e2.zerothai = 3664;
  e2.zerowidthjoiner = 65279;
  e2.zerowidthnonjoiner = 8204;
  e2.zerowidthspace = 8203;
  e2.zeta = 950;
  e2.zhbopomofo = 12563;
  e2.zhearmenian = 1386;
  e2.zhebrevecyrillic = 1218;
  e2.zhecyrillic = 1078;
  e2.zhedescendercyrillic = 1175;
  e2.zhedieresiscyrillic = 1245;
  e2.zihiragana = 12376;
  e2.zikatakana = 12472;
  e2.zinorhebrew = 1454;
  e2.zlinebelow = 7829;
  e2.zmonospace = 65370;
  e2.zohiragana = 12382;
  e2.zokatakana = 12478;
  e2.zparen = 9397;
  e2.zretroflexhook = 656;
  e2.zstroke = 438;
  e2.zuhiragana = 12378;
  e2.zukatakana = 12474;
  e2[".notdef"] = 0;
  e2.angbracketleftbig = 9001;
  e2.angbracketleftBig = 9001;
  e2.angbracketleftbigg = 9001;
  e2.angbracketleftBigg = 9001;
  e2.angbracketrightBig = 9002;
  e2.angbracketrightbig = 9002;
  e2.angbracketrightBigg = 9002;
  e2.angbracketrightbigg = 9002;
  e2.arrowhookleft = 8618;
  e2.arrowhookright = 8617;
  e2.arrowlefttophalf = 8636;
  e2.arrowleftbothalf = 8637;
  e2.arrownortheast = 8599;
  e2.arrownorthwest = 8598;
  e2.arrowrighttophalf = 8640;
  e2.arrowrightbothalf = 8641;
  e2.arrowsoutheast = 8600;
  e2.arrowsouthwest = 8601;
  e2.backslashbig = 8726;
  e2.backslashBig = 8726;
  e2.backslashBigg = 8726;
  e2.backslashbigg = 8726;
  e2.bardbl = 8214;
  e2.bracehtipdownleft = 65079;
  e2.bracehtipdownright = 65079;
  e2.bracehtipupleft = 65080;
  e2.bracehtipupright = 65080;
  e2.braceleftBig = 123;
  e2.braceleftbig = 123;
  e2.braceleftbigg = 123;
  e2.braceleftBigg = 123;
  e2.bracerightBig = 125;
  e2.bracerightbig = 125;
  e2.bracerightbigg = 125;
  e2.bracerightBigg = 125;
  e2.bracketleftbig = 91;
  e2.bracketleftBig = 91;
  e2.bracketleftbigg = 91;
  e2.bracketleftBigg = 91;
  e2.bracketrightBig = 93;
  e2.bracketrightbig = 93;
  e2.bracketrightbigg = 93;
  e2.bracketrightBigg = 93;
  e2.ceilingleftbig = 8968;
  e2.ceilingleftBig = 8968;
  e2.ceilingleftBigg = 8968;
  e2.ceilingleftbigg = 8968;
  e2.ceilingrightbig = 8969;
  e2.ceilingrightBig = 8969;
  e2.ceilingrightbigg = 8969;
  e2.ceilingrightBigg = 8969;
  e2.circledotdisplay = 8857;
  e2.circledottext = 8857;
  e2.circlemultiplydisplay = 8855;
  e2.circlemultiplytext = 8855;
  e2.circleplusdisplay = 8853;
  e2.circleplustext = 8853;
  e2.contintegraldisplay = 8750;
  e2.contintegraltext = 8750;
  e2.coproductdisplay = 8720;
  e2.coproducttext = 8720;
  e2.floorleftBig = 8970;
  e2.floorleftbig = 8970;
  e2.floorleftbigg = 8970;
  e2.floorleftBigg = 8970;
  e2.floorrightbig = 8971;
  e2.floorrightBig = 8971;
  e2.floorrightBigg = 8971;
  e2.floorrightbigg = 8971;
  e2.hatwide = 770;
  e2.hatwider = 770;
  e2.hatwidest = 770;
  e2.intercal = 7488;
  e2.integraldisplay = 8747;
  e2.integraltext = 8747;
  e2.intersectiondisplay = 8898;
  e2.intersectiontext = 8898;
  e2.logicalanddisplay = 8743;
  e2.logicalandtext = 8743;
  e2.logicalordisplay = 8744;
  e2.logicalortext = 8744;
  e2.parenleftBig = 40;
  e2.parenleftbig = 40;
  e2.parenleftBigg = 40;
  e2.parenleftbigg = 40;
  e2.parenrightBig = 41;
  e2.parenrightbig = 41;
  e2.parenrightBigg = 41;
  e2.parenrightbigg = 41;
  e2.prime = 8242;
  e2.productdisplay = 8719;
  e2.producttext = 8719;
  e2.radicalbig = 8730;
  e2.radicalBig = 8730;
  e2.radicalBigg = 8730;
  e2.radicalbigg = 8730;
  e2.radicalbt = 8730;
  e2.radicaltp = 8730;
  e2.radicalvertex = 8730;
  e2.slashbig = 47;
  e2.slashBig = 47;
  e2.slashBigg = 47;
  e2.slashbigg = 47;
  e2.summationdisplay = 8721;
  e2.summationtext = 8721;
  e2.tildewide = 732;
  e2.tildewider = 732;
  e2.tildewidest = 732;
  e2.uniondisplay = 8899;
  e2.unionmultidisplay = 8846;
  e2.unionmultitext = 8846;
  e2.unionsqdisplay = 8852;
  e2.unionsqtext = 8852;
  e2.uniontext = 8899;
  e2.vextenddouble = 8741;
  e2.vextendsingle = 8739;
}));
var Ir = getLookupTableFactory((function(e2) {
  e2.space = 32;
  e2.a1 = 9985;
  e2.a2 = 9986;
  e2.a202 = 9987;
  e2.a3 = 9988;
  e2.a4 = 9742;
  e2.a5 = 9990;
  e2.a119 = 9991;
  e2.a118 = 9992;
  e2.a117 = 9993;
  e2.a11 = 9755;
  e2.a12 = 9758;
  e2.a13 = 9996;
  e2.a14 = 9997;
  e2.a15 = 9998;
  e2.a16 = 9999;
  e2.a105 = 1e4;
  e2.a17 = 10001;
  e2.a18 = 10002;
  e2.a19 = 10003;
  e2.a20 = 10004;
  e2.a21 = 10005;
  e2.a22 = 10006;
  e2.a23 = 10007;
  e2.a24 = 10008;
  e2.a25 = 10009;
  e2.a26 = 10010;
  e2.a27 = 10011;
  e2.a28 = 10012;
  e2.a6 = 10013;
  e2.a7 = 10014;
  e2.a8 = 10015;
  e2.a9 = 10016;
  e2.a10 = 10017;
  e2.a29 = 10018;
  e2.a30 = 10019;
  e2.a31 = 10020;
  e2.a32 = 10021;
  e2.a33 = 10022;
  e2.a34 = 10023;
  e2.a35 = 9733;
  e2.a36 = 10025;
  e2.a37 = 10026;
  e2.a38 = 10027;
  e2.a39 = 10028;
  e2.a40 = 10029;
  e2.a41 = 10030;
  e2.a42 = 10031;
  e2.a43 = 10032;
  e2.a44 = 10033;
  e2.a45 = 10034;
  e2.a46 = 10035;
  e2.a47 = 10036;
  e2.a48 = 10037;
  e2.a49 = 10038;
  e2.a50 = 10039;
  e2.a51 = 10040;
  e2.a52 = 10041;
  e2.a53 = 10042;
  e2.a54 = 10043;
  e2.a55 = 10044;
  e2.a56 = 10045;
  e2.a57 = 10046;
  e2.a58 = 10047;
  e2.a59 = 10048;
  e2.a60 = 10049;
  e2.a61 = 10050;
  e2.a62 = 10051;
  e2.a63 = 10052;
  e2.a64 = 10053;
  e2.a65 = 10054;
  e2.a66 = 10055;
  e2.a67 = 10056;
  e2.a68 = 10057;
  e2.a69 = 10058;
  e2.a70 = 10059;
  e2.a71 = 9679;
  e2.a72 = 10061;
  e2.a73 = 9632;
  e2.a74 = 10063;
  e2.a203 = 10064;
  e2.a75 = 10065;
  e2.a204 = 10066;
  e2.a76 = 9650;
  e2.a77 = 9660;
  e2.a78 = 9670;
  e2.a79 = 10070;
  e2.a81 = 9687;
  e2.a82 = 10072;
  e2.a83 = 10073;
  e2.a84 = 10074;
  e2.a97 = 10075;
  e2.a98 = 10076;
  e2.a99 = 10077;
  e2.a100 = 10078;
  e2.a101 = 10081;
  e2.a102 = 10082;
  e2.a103 = 10083;
  e2.a104 = 10084;
  e2.a106 = 10085;
  e2.a107 = 10086;
  e2.a108 = 10087;
  e2.a112 = 9827;
  e2.a111 = 9830;
  e2.a110 = 9829;
  e2.a109 = 9824;
  e2.a120 = 9312;
  e2.a121 = 9313;
  e2.a122 = 9314;
  e2.a123 = 9315;
  e2.a124 = 9316;
  e2.a125 = 9317;
  e2.a126 = 9318;
  e2.a127 = 9319;
  e2.a128 = 9320;
  e2.a129 = 9321;
  e2.a130 = 10102;
  e2.a131 = 10103;
  e2.a132 = 10104;
  e2.a133 = 10105;
  e2.a134 = 10106;
  e2.a135 = 10107;
  e2.a136 = 10108;
  e2.a137 = 10109;
  e2.a138 = 10110;
  e2.a139 = 10111;
  e2.a140 = 10112;
  e2.a141 = 10113;
  e2.a142 = 10114;
  e2.a143 = 10115;
  e2.a144 = 10116;
  e2.a145 = 10117;
  e2.a146 = 10118;
  e2.a147 = 10119;
  e2.a148 = 10120;
  e2.a149 = 10121;
  e2.a150 = 10122;
  e2.a151 = 10123;
  e2.a152 = 10124;
  e2.a153 = 10125;
  e2.a154 = 10126;
  e2.a155 = 10127;
  e2.a156 = 10128;
  e2.a157 = 10129;
  e2.a158 = 10130;
  e2.a159 = 10131;
  e2.a160 = 10132;
  e2.a161 = 8594;
  e2.a163 = 8596;
  e2.a164 = 8597;
  e2.a196 = 10136;
  e2.a165 = 10137;
  e2.a192 = 10138;
  e2.a166 = 10139;
  e2.a167 = 10140;
  e2.a168 = 10141;
  e2.a169 = 10142;
  e2.a170 = 10143;
  e2.a171 = 10144;
  e2.a172 = 10145;
  e2.a173 = 10146;
  e2.a162 = 10147;
  e2.a174 = 10148;
  e2.a175 = 10149;
  e2.a176 = 10150;
  e2.a177 = 10151;
  e2.a178 = 10152;
  e2.a179 = 10153;
  e2.a193 = 10154;
  e2.a180 = 10155;
  e2.a199 = 10156;
  e2.a181 = 10157;
  e2.a200 = 10158;
  e2.a182 = 10159;
  e2.a201 = 10161;
  e2.a183 = 10162;
  e2.a184 = 10163;
  e2.a197 = 10164;
  e2.a185 = 10165;
  e2.a194 = 10166;
  e2.a198 = 10167;
  e2.a186 = 10168;
  e2.a195 = 10169;
  e2.a187 = 10170;
  e2.a188 = 10171;
  e2.a189 = 10172;
  e2.a190 = 10173;
  e2.a191 = 10174;
  e2.a89 = 10088;
  e2.a90 = 10089;
  e2.a93 = 10090;
  e2.a94 = 10091;
  e2.a91 = 10092;
  e2.a92 = 10093;
  e2.a205 = 10094;
  e2.a85 = 10095;
  e2.a206 = 10096;
  e2.a86 = 10097;
  e2.a87 = 10098;
  e2.a88 = 10099;
  e2.a95 = 10100;
  e2.a96 = 10101;
  e2[".notdef"] = 0;
}));
var Tr = getLookupTableFactory((function(e2) {
  e2[63721] = 169;
  e2[63193] = 169;
  e2[63720] = 174;
  e2[63194] = 174;
  e2[63722] = 8482;
  e2[63195] = 8482;
  e2[63729] = 9127;
  e2[63730] = 9128;
  e2[63731] = 9129;
  e2[63740] = 9131;
  e2[63741] = 9132;
  e2[63742] = 9133;
  e2[63726] = 9121;
  e2[63727] = 9122;
  e2[63728] = 9123;
  e2[63737] = 9124;
  e2[63738] = 9125;
  e2[63739] = 9126;
  e2[63723] = 9115;
  e2[63724] = 9116;
  e2[63725] = 9117;
  e2[63734] = 9118;
  e2[63735] = 9119;
  e2[63736] = 9120;
}));
function getUnicodeForGlyph(e2, t2) {
  let a2 = t2[e2];
  if (void 0 !== a2) return a2;
  if (!e2) return -1;
  if ("u" === e2[0]) {
    const t3 = e2.length;
    let r2;
    if (7 === t3 && "n" === e2[1] && "i" === e2[2]) r2 = e2.substring(3);
    else {
      if (!(t3 >= 5 && t3 <= 7)) return -1;
      r2 = e2.substring(1);
    }
    if (r2 === r2.toUpperCase()) {
      a2 = parseInt(r2, 16);
      if (a2 >= 0) return a2;
    }
  }
  return -1;
}
var Or = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
function getUnicodeRangeFor(e2, t2 = -1) {
  if (-1 !== t2) {
    const a2 = Or[t2];
    for (let r2 = 0, i2 = a2.length; r2 < i2; r2 += 2) if (e2 >= a2[r2] && e2 <= a2[r2 + 1]) return t2;
  }
  for (let t3 = 0, a2 = Or.length; t3 < a2; t3++) {
    const a3 = Or[t3];
    for (let r2 = 0, i2 = a3.length; r2 < i2; r2 += 2) if (e2 >= a3[r2] && e2 <= a3[r2 + 1]) return t3;
  }
  return -1;
}
var Mr = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u");
var Dr = /* @__PURE__ */ new Map();
var Rr = true;
var Nr = 1;
var Er = 2;
var Pr = 4;
var Lr = 32;
var jr = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
function recoverGlyphName(e2, t2) {
  if (void 0 !== t2[e2]) return e2;
  const a2 = getUnicodeForGlyph(e2, t2);
  if (-1 !== a2) {
    for (const e3 in t2) if (t2[e3] === a2) return e3;
  }
  info("Unable to recover a standard glyph name for: " + e2);
  return e2;
}
function type1FontGlyphMapping(e2, t2, a2) {
  const r2 = /* @__PURE__ */ Object.create(null);
  let i2, n2, s2;
  const o2 = !!(e2.flags & Pr);
  if (e2.isInternalFont) {
    s2 = t2;
    for (n2 = 0; n2 < s2.length; n2++) {
      i2 = a2.indexOf(s2[n2]);
      r2[n2] = i2 >= 0 ? i2 : 0;
    }
  } else if (e2.baseEncodingName) {
    s2 = getEncoding(e2.baseEncodingName);
    for (n2 = 0; n2 < s2.length; n2++) {
      i2 = a2.indexOf(s2[n2]);
      r2[n2] = i2 >= 0 ? i2 : 0;
    }
  } else if (o2) for (n2 in t2) r2[n2] = t2[n2];
  else {
    s2 = Ar;
    for (n2 = 0; n2 < s2.length; n2++) {
      i2 = a2.indexOf(s2[n2]);
      r2[n2] = i2 >= 0 ? i2 : 0;
    }
  }
  const c2 = e2.differences;
  let l2;
  if (c2) for (n2 in c2) {
    const e3 = c2[n2];
    i2 = a2.indexOf(e3);
    if (-1 === i2) {
      l2 || (l2 = Fr());
      const t3 = recoverGlyphName(e3, l2);
      t3 !== e3 && (i2 = a2.indexOf(t3));
    }
    r2[n2] = i2 >= 0 ? i2 : 0;
  }
  return r2;
}
function normalizeFontName(e2) {
  return e2.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
var _r = getLookupTableFactory(((e2) => {
  e2[8211] = 65074;
  e2[8212] = 65073;
  e2[8229] = 65072;
  e2[8230] = 65049;
  e2[12289] = 65041;
  e2[12290] = 65042;
  e2[12296] = 65087;
  e2[12297] = 65088;
  e2[12298] = 65085;
  e2[12299] = 65086;
  e2[12300] = 65089;
  e2[12301] = 65090;
  e2[12302] = 65091;
  e2[12303] = 65092;
  e2[12304] = 65083;
  e2[12305] = 65084;
  e2[12308] = 65081;
  e2[12309] = 65082;
  e2[12310] = 65047;
  e2[12311] = 65048;
  e2[65103] = 65076;
  e2[65281] = 65045;
  e2[65288] = 65077;
  e2[65289] = 65078;
  e2[65292] = 65040;
  e2[65306] = 65043;
  e2[65307] = 65044;
  e2[65311] = 65046;
  e2[65339] = 65095;
  e2[65341] = 65096;
  e2[65343] = 65075;
  e2[65371] = 65079;
  e2[65373] = 65080;
}));
var Ur = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"];
var Xr = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"];
var qr = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"];
var Hr = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"];
var Wr = 391;
var zr = [null, { id: "hstem", min: 2, stackClearing: true, stem: true }, null, { id: "vstem", min: 2, stackClearing: true, stem: true }, { id: "vmoveto", min: 1, stackClearing: true }, { id: "rlineto", min: 2, resetStack: true }, { id: "hlineto", min: 1, resetStack: true }, { id: "vlineto", min: 1, resetStack: true }, { id: "rrcurveto", min: 6, resetStack: true }, null, { id: "callsubr", min: 1, undefStack: true }, { id: "return", min: 0, undefStack: true }, null, null, { id: "endchar", min: 0, stackClearing: true }, null, null, null, { id: "hstemhm", min: 2, stackClearing: true, stem: true }, { id: "hintmask", min: 0, stackClearing: true }, { id: "cntrmask", min: 0, stackClearing: true }, { id: "rmoveto", min: 2, stackClearing: true }, { id: "hmoveto", min: 1, stackClearing: true }, { id: "vstemhm", min: 2, stackClearing: true, stem: true }, { id: "rcurveline", min: 8, resetStack: true }, { id: "rlinecurve", min: 8, resetStack: true }, { id: "vvcurveto", min: 4, resetStack: true }, { id: "hhcurveto", min: 4, resetStack: true }, null, { id: "callgsubr", min: 1, undefStack: true }, { id: "vhcurveto", min: 4, resetStack: true }, { id: "hvcurveto", min: 4, resetStack: true }];
var $r = [null, null, null, { id: "and", min: 2, stackDelta: -1 }, { id: "or", min: 2, stackDelta: -1 }, { id: "not", min: 1, stackDelta: 0 }, null, null, null, { id: "abs", min: 1, stackDelta: 0 }, { id: "add", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] + e2[t2 - 1];
} }, { id: "sub", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] - e2[t2 - 1];
} }, { id: "div", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] / e2[t2 - 1];
} }, null, { id: "neg", min: 1, stackDelta: 0, stackFn(e2, t2) {
  e2[t2 - 1] = -e2[t2 - 1];
} }, { id: "eq", min: 2, stackDelta: -1 }, null, null, { id: "drop", min: 1, stackDelta: -1 }, null, { id: "put", min: 2, stackDelta: -2 }, { id: "get", min: 1, stackDelta: 0 }, { id: "ifelse", min: 4, stackDelta: -3 }, { id: "random", min: 0, stackDelta: 1 }, { id: "mul", min: 2, stackDelta: -1, stackFn(e2, t2) {
  e2[t2 - 2] = e2[t2 - 2] * e2[t2 - 1];
} }, null, { id: "sqrt", min: 1, stackDelta: 0 }, { id: "dup", min: 1, stackDelta: 1 }, { id: "exch", min: 2, stackDelta: 0 }, { id: "index", min: 2, stackDelta: 0 }, { id: "roll", min: 3, stackDelta: -2 }, null, null, null, { id: "hflex", min: 7, resetStack: true }, { id: "flex", min: 13, resetStack: true }, { id: "hflex1", min: 9, resetStack: true }, { id: "flex1", min: 11, resetStack: true }];
var CFFParser = class {
  constructor(e2, t2, a2) {
    this.bytes = e2.getBytes();
    this.properties = t2;
    this.seacAnalysisEnabled = !!a2;
  }
  parse() {
    const e2 = this.properties, t2 = new CFF();
    this.cff = t2;
    const a2 = this.parseHeader(), r2 = this.parseIndex(a2.endPos), i2 = this.parseIndex(r2.endPos), n2 = this.parseIndex(i2.endPos), s2 = this.parseIndex(n2.endPos), o2 = this.parseDict(i2.obj.get(0)), c2 = this.createDict(CFFTopDict, o2, t2.strings);
    t2.header = a2.obj;
    t2.names = this.parseNameIndex(r2.obj);
    t2.strings = this.parseStringIndex(n2.obj);
    t2.topDict = c2;
    t2.globalSubrIndex = s2.obj;
    this.parsePrivateDict(t2.topDict);
    t2.isCIDFont = c2.hasName("ROS");
    const l2 = c2.getByName("CharStrings"), h2 = this.parseIndex(l2).obj, u2 = c2.getByName("FontMatrix");
    u2 && (e2.fontMatrix = u2);
    const d2 = c2.getByName("FontBBox");
    if (d2) {
      e2.ascent = Math.max(d2[3], d2[1]);
      e2.descent = Math.min(d2[1], d2[3]);
      e2.ascentScaled = true;
    }
    let f2, g2;
    if (t2.isCIDFont) {
      const e3 = this.parseIndex(c2.getByName("FDArray")).obj;
      for (let a3 = 0, r3 = e3.count; a3 < r3; ++a3) {
        const r4 = e3.get(a3), i3 = this.createDict(CFFTopDict, this.parseDict(r4), t2.strings);
        this.parsePrivateDict(i3);
        t2.fdArray.push(i3);
      }
      g2 = null;
      f2 = this.parseCharsets(c2.getByName("charset"), h2.count, t2.strings, true);
      t2.fdSelect = this.parseFDSelect(c2.getByName("FDSelect"), h2.count);
    } else {
      f2 = this.parseCharsets(c2.getByName("charset"), h2.count, t2.strings, false);
      g2 = this.parseEncoding(c2.getByName("Encoding"), e2, t2.strings, f2.charset);
    }
    t2.charset = f2;
    t2.encoding = g2;
    const p2 = this.parseCharStrings({ charStrings: h2, localSubrIndex: c2.privateDict.subrsIndex, globalSubrIndex: s2.obj, fdSelect: t2.fdSelect, fdArray: t2.fdArray, privateDict: c2.privateDict });
    t2.charStrings = p2.charStrings;
    t2.seacs = p2.seacs;
    t2.widths = p2.widths;
    return t2;
  }
  parseHeader() {
    let e2 = this.bytes;
    const t2 = e2.length;
    let a2 = 0;
    for (; a2 < t2 && 1 !== e2[a2]; ) ++a2;
    if (a2 >= t2) throw new FormatError("Invalid CFF header");
    if (0 !== a2) {
      info("cff data is shifted");
      e2 = e2.subarray(a2);
      this.bytes = e2;
    }
    const r2 = e2[0], i2 = e2[1], n2 = e2[2], s2 = e2[3];
    return { obj: new CFFHeader(r2, i2, n2, s2), endPos: n2 };
  }
  parseDict(e2) {
    let t2 = 0;
    function parseOperand() {
      let a3 = e2[t2++];
      if (30 === a3) return (function parseFloatOperand() {
        let a4 = "";
        const r3 = 15, i3 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], n2 = e2.length;
        for (; t2 < n2; ) {
          const n3 = e2[t2++], s2 = n3 >> 4, o2 = 15 & n3;
          if (s2 === r3) break;
          a4 += i3[s2];
          if (o2 === r3) break;
          a4 += i3[o2];
        }
        return parseFloat(a4);
      })();
      if (28 === a3) {
        a3 = readInt16(e2, t2);
        t2 += 2;
        return a3;
      }
      if (29 === a3) {
        a3 = e2[t2++];
        a3 = a3 << 8 | e2[t2++];
        a3 = a3 << 8 | e2[t2++];
        a3 = a3 << 8 | e2[t2++];
        return a3;
      }
      if (a3 >= 32 && a3 <= 246) return a3 - 139;
      if (a3 >= 247 && a3 <= 250) return 256 * (a3 - 247) + e2[t2++] + 108;
      if (a3 >= 251 && a3 <= 254) return -256 * (a3 - 251) - e2[t2++] - 108;
      warn('CFFParser_parseDict: "' + a3 + '" is a reserved command.');
      return NaN;
    }
    let a2 = [];
    const r2 = [];
    t2 = 0;
    const i2 = e2.length;
    for (; t2 < i2; ) {
      let i3 = e2[t2];
      if (i3 <= 21) {
        12 === i3 && (i3 = i3 << 8 | e2[++t2]);
        r2.push([i3, a2]);
        a2 = [];
        ++t2;
      } else a2.push(parseOperand());
    }
    return r2;
  }
  parseIndex(e2) {
    const t2 = new CFFIndex(), a2 = this.bytes, r2 = a2[e2++] << 8 | a2[e2++], i2 = [];
    let n2, s2, o2 = e2;
    if (0 !== r2) {
      const t3 = a2[e2++], c2 = e2 + (r2 + 1) * t3 - 1;
      for (n2 = 0, s2 = r2 + 1; n2 < s2; ++n2) {
        let r3 = 0;
        for (let i3 = 0; i3 < t3; ++i3) {
          r3 <<= 8;
          r3 += a2[e2++];
        }
        i2.push(c2 + r3);
      }
      o2 = i2[r2];
    }
    for (n2 = 0, s2 = i2.length - 1; n2 < s2; ++n2) {
      const e3 = i2[n2], r3 = i2[n2 + 1];
      t2.add(a2.subarray(e3, r3));
    }
    return { obj: t2, endPos: o2 };
  }
  parseNameIndex(e2) {
    const t2 = [];
    for (let a2 = 0, r2 = e2.count; a2 < r2; ++a2) {
      const r3 = e2.get(a2);
      t2.push(bytesToString(r3));
    }
    return t2;
  }
  parseStringIndex(e2) {
    const t2 = new CFFStrings();
    for (let a2 = 0, r2 = e2.count; a2 < r2; ++a2) {
      const r3 = e2.get(a2);
      t2.add(bytesToString(r3));
    }
    return t2;
  }
  createDict(e2, t2, a2) {
    const r2 = new e2(a2);
    for (const [e3, a3] of t2) r2.setByKey(e3, a3);
    return r2;
  }
  parseCharString(e2, t2, a2, r2) {
    if (!t2 || e2.callDepth > 10) return false;
    let i2 = e2.stackSize;
    const n2 = e2.stack;
    let s2 = t2.length;
    for (let o2 = 0; o2 < s2; ) {
      const c2 = t2[o2++];
      let l2 = null;
      if (12 === c2) {
        const e3 = t2[o2++];
        if (0 === e3) {
          t2[o2 - 2] = 139;
          t2[o2 - 1] = 22;
          i2 = 0;
        } else l2 = $r[e3];
      } else if (28 === c2) {
        n2[i2] = readInt16(t2, o2);
        o2 += 2;
        i2++;
      } else if (14 === c2) {
        if (i2 >= 4) {
          i2 -= 4;
          if (this.seacAnalysisEnabled) {
            e2.seac = n2.slice(i2, i2 + 4);
            return false;
          }
        }
        l2 = zr[c2];
      } else if (c2 >= 32 && c2 <= 246) {
        n2[i2] = c2 - 139;
        i2++;
      } else if (c2 >= 247 && c2 <= 254) {
        n2[i2] = c2 < 251 ? (c2 - 247 << 8) + t2[o2] + 108 : -(c2 - 251 << 8) - t2[o2] - 108;
        o2++;
        i2++;
      } else if (255 === c2) {
        n2[i2] = (t2[o2] << 24 | t2[o2 + 1] << 16 | t2[o2 + 2] << 8 | t2[o2 + 3]) / 65536;
        o2 += 4;
        i2++;
      } else if (19 === c2 || 20 === c2) {
        e2.hints += i2 >> 1;
        if (0 === e2.hints) {
          t2.copyWithin(o2 - 1, o2, -1);
          o2 -= 1;
          s2 -= 1;
          continue;
        }
        o2 += e2.hints + 7 >> 3;
        i2 %= 2;
        l2 = zr[c2];
      } else {
        if (10 === c2 || 29 === c2) {
          const t3 = 10 === c2 ? a2 : r2;
          if (!t3) {
            l2 = zr[c2];
            warn("Missing subrsIndex for " + l2.id);
            return false;
          }
          let s3 = 32768;
          t3.count < 1240 ? s3 = 107 : t3.count < 33900 && (s3 = 1131);
          const o3 = n2[--i2] + s3;
          if (o3 < 0 || o3 >= t3.count || isNaN(o3)) {
            l2 = zr[c2];
            warn("Out of bounds subrIndex for " + l2.id);
            return false;
          }
          e2.stackSize = i2;
          e2.callDepth++;
          if (!this.parseCharString(e2, t3.get(o3), a2, r2)) return false;
          e2.callDepth--;
          i2 = e2.stackSize;
          continue;
        }
        if (11 === c2) {
          e2.stackSize = i2;
          return true;
        }
        if (0 === c2 && o2 === t2.length) {
          t2[o2 - 1] = 14;
          l2 = zr[14];
        } else {
          if (9 === c2) {
            t2.copyWithin(o2 - 1, o2, -1);
            o2 -= 1;
            s2 -= 1;
            continue;
          }
          l2 = zr[c2];
        }
      }
      if (l2) {
        if (l2.stem) {
          e2.hints += i2 >> 1;
          if (3 === c2 || 23 === c2) e2.hasVStems = true;
          else if (e2.hasVStems && (1 === c2 || 18 === c2)) {
            warn("CFF stem hints are in wrong order");
            t2[o2 - 1] = 1 === c2 ? 3 : 23;
          }
        }
        if ("min" in l2 && !e2.undefStack && i2 < l2.min) {
          warn("Not enough parameters for " + l2.id + "; actual: " + i2 + ", expected: " + l2.min);
          if (0 === i2) {
            t2[o2 - 1] = 14;
            return true;
          }
          return false;
        }
        if (e2.firstStackClearing && l2.stackClearing) {
          e2.firstStackClearing = false;
          i2 -= l2.min;
          i2 >= 2 && l2.stem ? i2 %= 2 : i2 > 1 && warn("Found too many parameters for stack-clearing command");
          i2 > 0 && (e2.width = n2[i2 - 1]);
        }
        if ("stackDelta" in l2) {
          "stackFn" in l2 && l2.stackFn(n2, i2);
          i2 += l2.stackDelta;
        } else if (l2.stackClearing) i2 = 0;
        else if (l2.resetStack) {
          i2 = 0;
          e2.undefStack = false;
        } else if (l2.undefStack) {
          i2 = 0;
          e2.undefStack = true;
          e2.firstStackClearing = false;
        }
      }
    }
    s2 < t2.length && t2.fill(14, s2);
    e2.stackSize = i2;
    return true;
  }
  parseCharStrings({ charStrings: e2, localSubrIndex: t2, globalSubrIndex: a2, fdSelect: r2, fdArray: i2, privateDict: n2 }) {
    const s2 = [], o2 = [], c2 = e2.count;
    for (let l2 = 0; l2 < c2; l2++) {
      const c3 = e2.get(l2), h2 = { callDepth: 0, stackSize: 0, stack: [], undefStack: true, hints: 0, firstStackClearing: true, seac: null, width: null, hasVStems: false };
      let u2 = true, d2 = null, f2 = n2;
      if (r2 && i2.length) {
        const e3 = r2.getFDIndex(l2);
        if (-1 === e3) {
          warn("Glyph index is not in fd select.");
          u2 = false;
        }
        if (e3 >= i2.length) {
          warn("Invalid fd index for glyph index.");
          u2 = false;
        }
        if (u2) {
          f2 = i2[e3].privateDict;
          d2 = f2.subrsIndex;
        }
      } else t2 && (d2 = t2);
      u2 && (u2 = this.parseCharString(h2, c3, d2, a2));
      if (null !== h2.width) {
        const e3 = f2.getByName("nominalWidthX");
        o2[l2] = e3 + h2.width;
      } else {
        const e3 = f2.getByName("defaultWidthX");
        o2[l2] = e3;
      }
      null !== h2.seac && (s2[l2] = h2.seac);
      u2 || e2.set(l2, new Uint8Array([14]));
    }
    return { charStrings: e2, seacs: s2, widths: o2 };
  }
  emptyPrivateDictionary(e2) {
    const t2 = this.createDict(CFFPrivateDict, [], e2.strings);
    e2.setByKey(18, [0, 0]);
    e2.privateDict = t2;
  }
  parsePrivateDict(e2) {
    if (!e2.hasName("Private")) {
      this.emptyPrivateDictionary(e2);
      return;
    }
    const t2 = e2.getByName("Private");
    if (!Array.isArray(t2) || 2 !== t2.length) {
      e2.removeByName("Private");
      return;
    }
    const a2 = t2[0], r2 = t2[1];
    if (0 === a2 || r2 >= this.bytes.length) {
      this.emptyPrivateDictionary(e2);
      return;
    }
    const i2 = r2 + a2, n2 = this.bytes.subarray(r2, i2), s2 = this.parseDict(n2), o2 = this.createDict(CFFPrivateDict, s2, e2.strings);
    e2.privateDict = o2;
    0 === o2.getByName("ExpansionFactor") && o2.setByName("ExpansionFactor", 0.06);
    if (!o2.getByName("Subrs")) return;
    const c2 = o2.getByName("Subrs"), l2 = r2 + c2;
    if (0 === c2 || l2 >= this.bytes.length) {
      this.emptyPrivateDictionary(e2);
      return;
    }
    const h2 = this.parseIndex(l2);
    o2.subrsIndex = h2.obj;
  }
  parseCharsets(e2, t2, a2, r2) {
    if (0 === e2) return new CFFCharset(true, Kr.ISO_ADOBE, Ur);
    if (1 === e2) return new CFFCharset(true, Kr.EXPERT, Xr);
    if (2 === e2) return new CFFCharset(true, Kr.EXPERT_SUBSET, qr);
    const i2 = this.bytes, n2 = e2, s2 = i2[e2++], o2 = [r2 ? 0 : ".notdef"];
    let c2, l2, h2;
    t2 -= 1;
    switch (s2) {
      case 0:
        for (h2 = 0; h2 < t2; h2++) {
          c2 = i2[e2++] << 8 | i2[e2++];
          o2.push(r2 ? c2 : a2.get(c2));
        }
        break;
      case 1:
        for (; o2.length <= t2; ) {
          c2 = i2[e2++] << 8 | i2[e2++];
          l2 = i2[e2++];
          for (h2 = 0; h2 <= l2; h2++) o2.push(r2 ? c2++ : a2.get(c2++));
        }
        break;
      case 2:
        for (; o2.length <= t2; ) {
          c2 = i2[e2++] << 8 | i2[e2++];
          l2 = i2[e2++] << 8 | i2[e2++];
          for (h2 = 0; h2 <= l2; h2++) o2.push(r2 ? c2++ : a2.get(c2++));
        }
        break;
      default:
        throw new FormatError("Unknown charset format");
    }
    const u2 = e2, d2 = i2.subarray(n2, u2);
    return new CFFCharset(false, s2, o2, d2);
  }
  parseEncoding(e2, t2, a2, r2) {
    const i2 = /* @__PURE__ */ Object.create(null), n2 = this.bytes;
    let s2, o2, c2, l2 = false, h2 = null;
    if (0 === e2 || 1 === e2) {
      l2 = true;
      s2 = e2;
      const t3 = e2 ? wr : Ar;
      for (o2 = 0, c2 = r2.length; o2 < c2; o2++) {
        const e3 = t3.indexOf(r2[o2]);
        -1 !== e3 && (i2[e3] = o2);
      }
    } else {
      const t3 = e2;
      s2 = n2[e2++];
      switch (127 & s2) {
        case 0:
          const t4 = n2[e2++];
          for (o2 = 1; o2 <= t4; o2++) i2[n2[e2++]] = o2;
          break;
        case 1:
          const a3 = n2[e2++];
          let r3 = 1;
          for (o2 = 0; o2 < a3; o2++) {
            const t5 = n2[e2++], a4 = n2[e2++];
            for (let e3 = t5; e3 <= t5 + a4; e3++) i2[e3] = r3++;
          }
          break;
        default:
          throw new FormatError(`Unknown encoding format: ${s2} in CFF`);
      }
      const c3 = e2;
      if (128 & s2) {
        n2[t3] &= 127;
        !(function readSupplement() {
          const t4 = n2[e2++];
          for (o2 = 0; o2 < t4; o2++) {
            const t5 = n2[e2++], s3 = (n2[e2++] << 8) + (255 & n2[e2++]);
            i2[t5] = r2.indexOf(a2.get(s3));
          }
        })();
      }
      h2 = n2.subarray(t3, c3);
    }
    s2 &= 127;
    return new CFFEncoding(l2, s2, i2, h2);
  }
  parseFDSelect(e2, t2) {
    const a2 = this.bytes, r2 = a2[e2++], i2 = [];
    let n2;
    switch (r2) {
      case 0:
        for (n2 = 0; n2 < t2; ++n2) {
          const t3 = a2[e2++];
          i2.push(t3);
        }
        break;
      case 3:
        const s2 = a2[e2++] << 8 | a2[e2++];
        for (n2 = 0; n2 < s2; ++n2) {
          let t3 = a2[e2++] << 8 | a2[e2++];
          if (0 === n2 && 0 !== t3) {
            warn("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
            t3 = 0;
          }
          const r3 = a2[e2++], s3 = a2[e2] << 8 | a2[e2 + 1];
          for (let e3 = t3; e3 < s3; ++e3) i2.push(r3);
        }
        e2 += 2;
        break;
      default:
        throw new FormatError(`parseFDSelect: Unknown format "${r2}".`);
    }
    if (i2.length !== t2) throw new FormatError("parseFDSelect: Invalid font data.");
    return new CFFFDSelect(r2, i2);
  }
};
var CFF = class {
  constructor() {
    this.header = null;
    this.names = [];
    this.topDict = null;
    this.strings = new CFFStrings();
    this.globalSubrIndex = null;
    this.encoding = null;
    this.charset = null;
    this.charStrings = null;
    this.fdArray = [];
    this.fdSelect = null;
    this.isCIDFont = false;
  }
  duplicateFirstGlyph() {
    if (this.charStrings.count >= 65535) {
      warn("Not enough space in charstrings to duplicate first glyph.");
      return;
    }
    const e2 = this.charStrings.get(0);
    this.charStrings.add(e2);
    this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
  }
  hasGlyphId(e2) {
    if (e2 < 0 || e2 >= this.charStrings.count) return false;
    return this.charStrings.get(e2).length > 0;
  }
};
var CFFHeader = class {
  constructor(e2, t2, a2, r2) {
    this.major = e2;
    this.minor = t2;
    this.hdrSize = a2;
    this.offSize = r2;
  }
};
var CFFStrings = class {
  constructor() {
    this.strings = [];
  }
  get(e2) {
    return e2 >= 0 && e2 <= 390 ? Hr[e2] : e2 - Wr <= this.strings.length ? this.strings[e2 - Wr] : Hr[0];
  }
  getSID(e2) {
    let t2 = Hr.indexOf(e2);
    if (-1 !== t2) return t2;
    t2 = this.strings.indexOf(e2);
    return -1 !== t2 ? t2 + Wr : -1;
  }
  add(e2) {
    this.strings.push(e2);
  }
  get count() {
    return this.strings.length;
  }
};
var CFFIndex = class {
  constructor() {
    this.objects = [];
    this.length = 0;
  }
  add(e2) {
    this.length += e2.length;
    this.objects.push(e2);
  }
  set(e2, t2) {
    this.length += t2.length - this.objects[e2].length;
    this.objects[e2] = t2;
  }
  get(e2) {
    return this.objects[e2];
  }
  get count() {
    return this.objects.length;
  }
};
var CFFDict = class {
  constructor(e2, t2) {
    this.keyToNameMap = e2.keyToNameMap;
    this.nameToKeyMap = e2.nameToKeyMap;
    this.defaults = e2.defaults;
    this.types = e2.types;
    this.opcodes = e2.opcodes;
    this.order = e2.order;
    this.strings = t2;
    this.values = /* @__PURE__ */ Object.create(null);
  }
  setByKey(e2, t2) {
    if (!(e2 in this.keyToNameMap)) return false;
    if (0 === t2.length) return true;
    for (const a3 of t2) if (isNaN(a3)) {
      warn(`Invalid CFFDict value: "${t2}" for key "${e2}".`);
      return true;
    }
    const a2 = this.types[e2];
    "num" !== a2 && "sid" !== a2 && "offset" !== a2 || (t2 = t2[0]);
    this.values[e2] = t2;
    return true;
  }
  setByName(e2, t2) {
    if (!(e2 in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name "${e2}"`);
    this.values[this.nameToKeyMap[e2]] = t2;
  }
  hasName(e2) {
    return this.nameToKeyMap[e2] in this.values;
  }
  getByName(e2) {
    if (!(e2 in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name ${e2}"`);
    const t2 = this.nameToKeyMap[e2];
    return t2 in this.values ? this.values[t2] : this.defaults[t2];
  }
  removeByName(e2) {
    delete this.values[this.nameToKeyMap[e2]];
  }
  static createTables(e2) {
    const t2 = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] };
    for (const a2 of e2) {
      const e3 = Array.isArray(a2[0]) ? (a2[0][0] << 8) + a2[0][1] : a2[0];
      t2.keyToNameMap[e3] = a2[1];
      t2.nameToKeyMap[a2[1]] = e3;
      t2.types[e3] = a2[2];
      t2.defaults[e3] = a2[3];
      t2.opcodes[e3] = Array.isArray(a2[0]) ? a2[0] : [a2[0]];
      t2.order.push(e3);
    }
    return t2;
  }
};
var Gr = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
var CFFTopDict = class _CFFTopDict extends CFFDict {
  static get tables() {
    return shadow(this, "tables", this.createTables(Gr));
  }
  constructor(e2) {
    super(_CFFTopDict.tables, e2);
    this.privateDict = null;
  }
};
var Vr = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
var CFFPrivateDict = class _CFFPrivateDict extends CFFDict {
  static get tables() {
    return shadow(this, "tables", this.createTables(Vr));
  }
  constructor(e2) {
    super(_CFFPrivateDict.tables, e2);
    this.subrsIndex = null;
  }
};
var Kr = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 };
var CFFCharset = class {
  constructor(e2, t2, a2, r2) {
    this.predefined = e2;
    this.format = t2;
    this.charset = a2;
    this.raw = r2;
  }
};
var CFFEncoding = class {
  constructor(e2, t2, a2, r2) {
    this.predefined = e2;
    this.format = t2;
    this.encoding = a2;
    this.raw = r2;
  }
};
var CFFFDSelect = class {
  constructor(e2, t2) {
    this.format = e2;
    this.fdSelect = t2;
  }
  getFDIndex(e2) {
    return e2 < 0 || e2 >= this.fdSelect.length ? -1 : this.fdSelect[e2];
  }
};
var CFFOffsetTracker = class {
  constructor() {
    this.offsets = /* @__PURE__ */ Object.create(null);
  }
  isTracking(e2) {
    return e2 in this.offsets;
  }
  track(e2, t2) {
    if (e2 in this.offsets) throw new FormatError(`Already tracking location of ${e2}`);
    this.offsets[e2] = t2;
  }
  offset(e2) {
    for (const t2 in this.offsets) this.offsets[t2] += e2;
  }
  setEntryLocation(e2, t2, a2) {
    if (!(e2 in this.offsets)) throw new FormatError(`Not tracking location of ${e2}`);
    const r2 = a2.data, i2 = this.offsets[e2];
    for (let e3 = 0, a3 = t2.length; e3 < a3; ++e3) {
      const a4 = 5 * e3 + i2, n2 = a4 + 1, s2 = a4 + 2, o2 = a4 + 3, c2 = a4 + 4;
      if (29 !== r2[a4] || 0 !== r2[n2] || 0 !== r2[s2] || 0 !== r2[o2] || 0 !== r2[c2]) throw new FormatError("writing to an offset that is not empty");
      const l2 = t2[e3];
      r2[a4] = 29;
      r2[n2] = l2 >> 24 & 255;
      r2[s2] = l2 >> 16 & 255;
      r2[o2] = l2 >> 8 & 255;
      r2[c2] = 255 & l2;
    }
  }
};
var CFFCompiler = class _CFFCompiler {
  constructor(e2) {
    this.cff = e2;
  }
  compile() {
    const e2 = this.cff, t2 = { data: [], length: 0, add(e3) {
      try {
        this.data.push(...e3);
      } catch {
        this.data = this.data.concat(e3);
      }
      this.length = this.data.length;
    } }, a2 = this.compileHeader(e2.header);
    t2.add(a2);
    const r2 = this.compileNameIndex(e2.names);
    t2.add(r2);
    if (e2.isCIDFont && e2.topDict.hasName("FontMatrix")) {
      const t3 = e2.topDict.getByName("FontMatrix");
      e2.topDict.removeByName("FontMatrix");
      for (const a3 of e2.fdArray) {
        let e3 = t3.slice(0);
        a3.hasName("FontMatrix") && (e3 = Util.transform(e3, a3.getByName("FontMatrix")));
        a3.setByName("FontMatrix", e3);
      }
    }
    const i2 = e2.topDict.getByName("XUID");
    i2?.length > 16 && e2.topDict.removeByName("XUID");
    e2.topDict.setByName("charset", 0);
    let n2 = this.compileTopDicts([e2.topDict], t2.length, e2.isCIDFont);
    t2.add(n2.output);
    const s2 = n2.trackers[0], o2 = this.compileStringIndex(e2.strings.strings);
    t2.add(o2);
    const c2 = this.compileIndex(e2.globalSubrIndex);
    t2.add(c2);
    if (e2.encoding && e2.topDict.hasName("Encoding")) if (e2.encoding.predefined) s2.setEntryLocation("Encoding", [e2.encoding.format], t2);
    else {
      const a3 = this.compileEncoding(e2.encoding);
      s2.setEntryLocation("Encoding", [t2.length], t2);
      t2.add(a3);
    }
    const l2 = this.compileCharset(e2.charset, e2.charStrings.count, e2.strings, e2.isCIDFont);
    s2.setEntryLocation("charset", [t2.length], t2);
    t2.add(l2);
    const h2 = this.compileCharStrings(e2.charStrings);
    s2.setEntryLocation("CharStrings", [t2.length], t2);
    t2.add(h2);
    if (e2.isCIDFont) {
      s2.setEntryLocation("FDSelect", [t2.length], t2);
      const a3 = this.compileFDSelect(e2.fdSelect);
      t2.add(a3);
      n2 = this.compileTopDicts(e2.fdArray, t2.length, true);
      s2.setEntryLocation("FDArray", [t2.length], t2);
      t2.add(n2.output);
      const r3 = n2.trackers;
      this.compilePrivateDicts(e2.fdArray, r3, t2);
    }
    this.compilePrivateDicts([e2.topDict], [s2], t2);
    t2.add([0]);
    return t2.data;
  }
  encodeNumber(e2) {
    return Number.isInteger(e2) ? this.encodeInteger(e2) : this.encodeFloat(e2);
  }
  static get EncodeFloatRegExp() {
    return shadow(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }
  encodeFloat(e2) {
    let t2 = e2.toString();
    const a2 = _CFFCompiler.EncodeFloatRegExp.exec(t2);
    if (a2) {
      const r3 = parseFloat("1e" + ((a2[2] ? +a2[2] : 0) + a2[1].length));
      t2 = (Math.round(e2 * r3) / r3).toString();
    }
    let r2, i2, n2 = "";
    for (r2 = 0, i2 = t2.length; r2 < i2; ++r2) {
      const e3 = t2[r2];
      n2 += "e" === e3 ? "-" === t2[++r2] ? "c" : "b" : "." === e3 ? "a" : "-" === e3 ? "e" : e3;
    }
    n2 += 1 & n2.length ? "f" : "ff";
    const s2 = [30];
    for (r2 = 0, i2 = n2.length; r2 < i2; r2 += 2) s2.push(parseInt(n2.substring(r2, r2 + 2), 16));
    return s2;
  }
  encodeInteger(e2) {
    let t2;
    t2 = e2 >= -107 && e2 <= 107 ? [e2 + 139] : e2 >= 108 && e2 <= 1131 ? [247 + ((e2 -= 108) >> 8), 255 & e2] : e2 >= -1131 && e2 <= -108 ? [251 + ((e2 = -e2 - 108) >> 8), 255 & e2] : e2 >= -32768 && e2 <= 32767 ? [28, e2 >> 8 & 255, 255 & e2] : [29, e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2];
    return t2;
  }
  compileHeader(e2) {
    return [e2.major, e2.minor, 4, e2.offSize];
  }
  compileNameIndex(e2) {
    const t2 = new CFFIndex();
    for (const a2 of e2) {
      const e3 = Math.min(a2.length, 127);
      let r2 = new Array(e3);
      for (let t3 = 0; t3 < e3; t3++) {
        let e4 = a2[t3];
        (e4 < "!" || e4 > "~" || "[" === e4 || "]" === e4 || "(" === e4 || ")" === e4 || "{" === e4 || "}" === e4 || "<" === e4 || ">" === e4 || "/" === e4 || "%" === e4) && (e4 = "_");
        r2[t3] = e4;
      }
      r2 = r2.join("");
      "" === r2 && (r2 = "Bad_Font_Name");
      t2.add(stringToBytes(r2));
    }
    return this.compileIndex(t2);
  }
  compileTopDicts(e2, t2, a2) {
    const r2 = [];
    let i2 = new CFFIndex();
    for (const n2 of e2) {
      if (a2) {
        n2.removeByName("CIDFontVersion");
        n2.removeByName("CIDFontRevision");
        n2.removeByName("CIDFontType");
        n2.removeByName("CIDCount");
        n2.removeByName("UIDBase");
      }
      const e3 = new CFFOffsetTracker(), s2 = this.compileDict(n2, e3);
      r2.push(e3);
      i2.add(s2);
      e3.offset(t2);
    }
    i2 = this.compileIndex(i2, r2);
    return { trackers: r2, output: i2 };
  }
  compilePrivateDicts(e2, t2, a2) {
    for (let r2 = 0, i2 = e2.length; r2 < i2; ++r2) {
      const i3 = e2[r2], n2 = i3.privateDict;
      if (!n2 || !i3.hasName("Private")) throw new FormatError("There must be a private dictionary.");
      const s2 = new CFFOffsetTracker(), o2 = this.compileDict(n2, s2);
      let c2 = a2.length;
      s2.offset(c2);
      o2.length || (c2 = 0);
      t2[r2].setEntryLocation("Private", [o2.length, c2], a2);
      a2.add(o2);
      if (n2.subrsIndex && n2.hasName("Subrs")) {
        const e3 = this.compileIndex(n2.subrsIndex);
        s2.setEntryLocation("Subrs", [o2.length], a2);
        a2.add(e3);
      }
    }
  }
  compileDict(e2, t2) {
    const a2 = [];
    for (const r2 of e2.order) {
      if (!(r2 in e2.values)) continue;
      let i2 = e2.values[r2], n2 = e2.types[r2];
      Array.isArray(n2) || (n2 = [n2]);
      Array.isArray(i2) || (i2 = [i2]);
      if (0 !== i2.length) {
        for (let s2 = 0, o2 = n2.length; s2 < o2; ++s2) {
          const o3 = n2[s2], c2 = i2[s2];
          switch (o3) {
            case "num":
            case "sid":
              a2.push(...this.encodeNumber(c2));
              break;
            case "offset":
              const n3 = e2.keyToNameMap[r2];
              t2.isTracking(n3) || t2.track(n3, a2.length);
              a2.push(29, 0, 0, 0, 0);
              break;
            case "array":
            case "delta":
              a2.push(...this.encodeNumber(c2));
              for (let e3 = 1, t3 = i2.length; e3 < t3; ++e3) a2.push(...this.encodeNumber(i2[e3]));
              break;
            default:
              throw new FormatError(`Unknown data type of ${o3}`);
          }
        }
        a2.push(...e2.opcodes[r2]);
      }
    }
    return a2;
  }
  compileStringIndex(e2) {
    const t2 = new CFFIndex();
    for (const a2 of e2) t2.add(stringToBytes(a2));
    return this.compileIndex(t2);
  }
  compileCharStrings(e2) {
    const t2 = new CFFIndex();
    for (let a2 = 0; a2 < e2.count; a2++) {
      const r2 = e2.get(a2);
      0 !== r2.length ? t2.add(r2) : t2.add(new Uint8Array([139, 14]));
    }
    return this.compileIndex(t2);
  }
  compileCharset(e2, t2, a2, r2) {
    let i2;
    const n2 = t2 - 1;
    if (r2) {
      const e3 = n2 - 1;
      i2 = new Uint8Array([2, 0, 1, e3 >> 8 & 255, 255 & e3]);
    } else {
      i2 = new Uint8Array(1 + 2 * n2);
      i2[0] = 0;
      let t3 = 0;
      const r3 = e2.charset.length;
      let s2 = false;
      for (let n3 = 1; n3 < i2.length; n3 += 2) {
        let o2 = 0;
        if (t3 < r3) {
          const r4 = e2.charset[t3++];
          o2 = a2.getSID(r4);
          if (-1 === o2) {
            o2 = 0;
            if (!s2) {
              s2 = true;
              warn(`Couldn't find ${r4} in CFF strings`);
            }
          }
        }
        i2[n3] = o2 >> 8 & 255;
        i2[n3 + 1] = 255 & o2;
      }
    }
    return this.compileTypedArray(i2);
  }
  compileEncoding(e2) {
    return this.compileTypedArray(e2.raw);
  }
  compileFDSelect(e2) {
    const t2 = e2.format;
    let a2, r2;
    switch (t2) {
      case 0:
        a2 = new Uint8Array(1 + e2.fdSelect.length);
        a2[0] = t2;
        for (r2 = 0; r2 < e2.fdSelect.length; r2++) a2[r2 + 1] = e2.fdSelect[r2];
        break;
      case 3:
        const i2 = 0;
        let n2 = e2.fdSelect[0];
        const s2 = [t2, 0, 0, i2 >> 8 & 255, 255 & i2, n2];
        for (r2 = 1; r2 < e2.fdSelect.length; r2++) {
          const t3 = e2.fdSelect[r2];
          if (t3 !== n2) {
            s2.push(r2 >> 8 & 255, 255 & r2, t3);
            n2 = t3;
          }
        }
        const o2 = (s2.length - 3) / 3;
        s2[1] = o2 >> 8 & 255;
        s2[2] = 255 & o2;
        s2.push(r2 >> 8 & 255, 255 & r2);
        a2 = new Uint8Array(s2);
    }
    return this.compileTypedArray(a2);
  }
  compileTypedArray(e2) {
    return Array.from(e2);
  }
  compileIndex(e2, t2 = []) {
    const a2 = e2.objects, r2 = a2.length;
    if (0 === r2) return [0, 0];
    const i2 = [r2 >> 8 & 255, 255 & r2];
    let n2, s2, o2 = 1;
    for (n2 = 0; n2 < r2; ++n2) o2 += a2[n2].length;
    s2 = o2 < 256 ? 1 : o2 < 65536 ? 2 : o2 < 16777216 ? 3 : 4;
    i2.push(s2);
    let c2 = 1;
    for (n2 = 0; n2 < r2 + 1; n2++) {
      1 === s2 ? i2.push(255 & c2) : 2 === s2 ? i2.push(c2 >> 8 & 255, 255 & c2) : 3 === s2 ? i2.push(c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2) : i2.push(c2 >>> 24 & 255, c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2);
      a2[n2] && (c2 += a2[n2].length);
    }
    for (n2 = 0; n2 < r2; n2++) {
      t2[n2] && t2[n2].offset(i2.length);
      i2.push(...a2[n2]);
    }
    return i2;
  }
};
var Jr = getLookupTableFactory((function(e2) {
  e2["Times-Roman"] = "Times-Roman";
  e2.Helvetica = "Helvetica";
  e2.Courier = "Courier";
  e2.Symbol = "Symbol";
  e2["Times-Bold"] = "Times-Bold";
  e2["Helvetica-Bold"] = "Helvetica-Bold";
  e2["Courier-Bold"] = "Courier-Bold";
  e2.ZapfDingbats = "ZapfDingbats";
  e2["Times-Italic"] = "Times-Italic";
  e2["Helvetica-Oblique"] = "Helvetica-Oblique";
  e2["Courier-Oblique"] = "Courier-Oblique";
  e2["Times-BoldItalic"] = "Times-BoldItalic";
  e2["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
  e2["Courier-BoldOblique"] = "Courier-BoldOblique";
  e2.ArialNarrow = "Helvetica";
  e2["ArialNarrow-Bold"] = "Helvetica-Bold";
  e2["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
  e2["ArialNarrow-Italic"] = "Helvetica-Oblique";
  e2.ArialBlack = "Helvetica";
  e2["ArialBlack-Bold"] = "Helvetica-Bold";
  e2["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
  e2["ArialBlack-Italic"] = "Helvetica-Oblique";
  e2["Arial-Black"] = "Helvetica";
  e2["Arial-Black-Bold"] = "Helvetica-Bold";
  e2["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
  e2["Arial-Black-Italic"] = "Helvetica-Oblique";
  e2.Arial = "Helvetica";
  e2["Arial-Bold"] = "Helvetica-Bold";
  e2["Arial-BoldItalic"] = "Helvetica-BoldOblique";
  e2["Arial-Italic"] = "Helvetica-Oblique";
  e2.ArialMT = "Helvetica";
  e2["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
  e2["Arial-BoldMT"] = "Helvetica-Bold";
  e2["Arial-ItalicMT"] = "Helvetica-Oblique";
  e2["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique";
  e2["Arial-BoldMT-Bold"] = "Helvetica-Bold";
  e2["Arial-ItalicMT-Italic"] = "Helvetica-Oblique";
  e2.ArialUnicodeMS = "Helvetica";
  e2["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
  e2["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
  e2["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
  e2["Courier-BoldItalic"] = "Courier-BoldOblique";
  e2["Courier-Italic"] = "Courier-Oblique";
  e2.CourierNew = "Courier";
  e2["CourierNew-Bold"] = "Courier-Bold";
  e2["CourierNew-BoldItalic"] = "Courier-BoldOblique";
  e2["CourierNew-Italic"] = "Courier-Oblique";
  e2["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
  e2["CourierNewPS-BoldMT"] = "Courier-Bold";
  e2["CourierNewPS-ItalicMT"] = "Courier-Oblique";
  e2.CourierNewPSMT = "Courier";
  e2["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
  e2["Helvetica-Italic"] = "Helvetica-Oblique";
  e2["HelveticaLTStd-Bold"] = "Helvetica-Bold";
  e2["Symbol-Bold"] = "Symbol";
  e2["Symbol-BoldItalic"] = "Symbol";
  e2["Symbol-Italic"] = "Symbol";
  e2.TimesNewRoman = "Times-Roman";
  e2["TimesNewRoman-Bold"] = "Times-Bold";
  e2["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
  e2["TimesNewRoman-Italic"] = "Times-Italic";
  e2.TimesNewRomanPS = "Times-Roman";
  e2["TimesNewRomanPS-Bold"] = "Times-Bold";
  e2["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
  e2["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
  e2["TimesNewRomanPS-BoldMT"] = "Times-Bold";
  e2["TimesNewRomanPS-Italic"] = "Times-Italic";
  e2["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
  e2.TimesNewRomanPSMT = "Times-Roman";
  e2["TimesNewRomanPSMT-Bold"] = "Times-Bold";
  e2["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
  e2["TimesNewRomanPSMT-Italic"] = "Times-Italic";
}));
var Yr = getLookupTableFactory((function(e2) {
  e2.Courier = "FoxitFixed.pfb";
  e2["Courier-Bold"] = "FoxitFixedBold.pfb";
  e2["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
  e2["Courier-Oblique"] = "FoxitFixedItalic.pfb";
  e2.Helvetica = "LiberationSans-Regular.ttf";
  e2["Helvetica-Bold"] = "LiberationSans-Bold.ttf";
  e2["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf";
  e2["Helvetica-Oblique"] = "LiberationSans-Italic.ttf";
  e2["Times-Roman"] = "FoxitSerif.pfb";
  e2["Times-Bold"] = "FoxitSerifBold.pfb";
  e2["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
  e2["Times-Italic"] = "FoxitSerifItalic.pfb";
  e2.Symbol = "FoxitSymbol.pfb";
  e2.ZapfDingbats = "FoxitDingbats.pfb";
  e2["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
  e2["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
  e2["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
  e2["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
}));
var Zr = getLookupTableFactory((function(e2) {
  e2.Calibri = "Helvetica";
  e2["Calibri-Bold"] = "Helvetica-Bold";
  e2["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
  e2["Calibri-Italic"] = "Helvetica-Oblique";
  e2.CenturyGothic = "Helvetica";
  e2["CenturyGothic-Bold"] = "Helvetica-Bold";
  e2["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
  e2["CenturyGothic-Italic"] = "Helvetica-Oblique";
  e2.ComicSansMS = "Comic Sans MS";
  e2["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
  e2["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
  e2["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
  e2.GillSansMT = "Helvetica";
  e2["GillSansMT-Bold"] = "Helvetica-Bold";
  e2["GillSansMT-BoldItalic"] = "Helvetica-BoldOblique";
  e2["GillSansMT-Italic"] = "Helvetica-Oblique";
  e2.Impact = "Helvetica";
  e2["ItcSymbol-Bold"] = "Helvetica-Bold";
  e2["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
  e2["ItcSymbol-Book"] = "Helvetica";
  e2["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
  e2["ItcSymbol-Medium"] = "Helvetica";
  e2["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
  e2.LucidaConsole = "Courier";
  e2["LucidaConsole-Bold"] = "Courier-Bold";
  e2["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
  e2["LucidaConsole-Italic"] = "Courier-Oblique";
  e2["LucidaSans-Demi"] = "Helvetica-Bold";
  e2["MS-Gothic"] = "MS Gothic";
  e2["MS-Gothic-Bold"] = "MS Gothic-Bold";
  e2["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
  e2["MS-Gothic-Italic"] = "MS Gothic-Italic";
  e2["MS-Mincho"] = "MS Mincho";
  e2["MS-Mincho-Bold"] = "MS Mincho-Bold";
  e2["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
  e2["MS-Mincho-Italic"] = "MS Mincho-Italic";
  e2["MS-PGothic"] = "MS PGothic";
  e2["MS-PGothic-Bold"] = "MS PGothic-Bold";
  e2["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
  e2["MS-PGothic-Italic"] = "MS PGothic-Italic";
  e2["MS-PMincho"] = "MS PMincho";
  e2["MS-PMincho-Bold"] = "MS PMincho-Bold";
  e2["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
  e2["MS-PMincho-Italic"] = "MS PMincho-Italic";
  e2.NuptialScript = "Times-Italic";
  e2.SegoeUISymbol = "Helvetica";
}));
var Qr = getLookupTableFactory((function(e2) {
  e2["Adobe Jenson"] = true;
  e2["Adobe Text"] = true;
  e2.Albertus = true;
  e2.Aldus = true;
  e2.Alexandria = true;
  e2.Algerian = true;
  e2["American Typewriter"] = true;
  e2.Antiqua = true;
  e2.Apex = true;
  e2.Arno = true;
  e2.Aster = true;
  e2.Aurora = true;
  e2.Baskerville = true;
  e2.Bell = true;
  e2.Bembo = true;
  e2["Bembo Schoolbook"] = true;
  e2.Benguiat = true;
  e2["Berkeley Old Style"] = true;
  e2["Bernhard Modern"] = true;
  e2["Berthold City"] = true;
  e2.Bodoni = true;
  e2["Bauer Bodoni"] = true;
  e2["Book Antiqua"] = true;
  e2.Bookman = true;
  e2["Bordeaux Roman"] = true;
  e2["Californian FB"] = true;
  e2.Calisto = true;
  e2.Calvert = true;
  e2.Capitals = true;
  e2.Cambria = true;
  e2.Cartier = true;
  e2.Caslon = true;
  e2.Catull = true;
  e2.Centaur = true;
  e2["Century Old Style"] = true;
  e2["Century Schoolbook"] = true;
  e2.Chaparral = true;
  e2["Charis SIL"] = true;
  e2.Cheltenham = true;
  e2["Cholla Slab"] = true;
  e2.Clarendon = true;
  e2.Clearface = true;
  e2.Cochin = true;
  e2.Colonna = true;
  e2["Computer Modern"] = true;
  e2["Concrete Roman"] = true;
  e2.Constantia = true;
  e2["Cooper Black"] = true;
  e2.Corona = true;
  e2.Ecotype = true;
  e2.Egyptienne = true;
  e2.Elephant = true;
  e2.Excelsior = true;
  e2.Fairfield = true;
  e2["FF Scala"] = true;
  e2.Folkard = true;
  e2.Footlight = true;
  e2.FreeSerif = true;
  e2["Friz Quadrata"] = true;
  e2.Garamond = true;
  e2.Gentium = true;
  e2.Georgia = true;
  e2.Gloucester = true;
  e2["Goudy Old Style"] = true;
  e2["Goudy Schoolbook"] = true;
  e2["Goudy Pro Font"] = true;
  e2.Granjon = true;
  e2["Guardian Egyptian"] = true;
  e2.Heather = true;
  e2.Hercules = true;
  e2["High Tower Text"] = true;
  e2.Hiroshige = true;
  e2["Hoefler Text"] = true;
  e2["Humana Serif"] = true;
  e2.Imprint = true;
  e2["Ionic No. 5"] = true;
  e2.Janson = true;
  e2.Joanna = true;
  e2.Korinna = true;
  e2.Lexicon = true;
  e2.LiberationSerif = true;
  e2["Liberation Serif"] = true;
  e2["Linux Libertine"] = true;
  e2.Literaturnaya = true;
  e2.Lucida = true;
  e2["Lucida Bright"] = true;
  e2.Melior = true;
  e2.Memphis = true;
  e2.Miller = true;
  e2.Minion = true;
  e2.Modern = true;
  e2["Mona Lisa"] = true;
  e2["Mrs Eaves"] = true;
  e2["MS Serif"] = true;
  e2["Museo Slab"] = true;
  e2["New York"] = true;
  e2["Nimbus Roman"] = true;
  e2["NPS Rawlinson Roadway"] = true;
  e2.NuptialScript = true;
  e2.Palatino = true;
  e2.Perpetua = true;
  e2.Plantin = true;
  e2["Plantin Schoolbook"] = true;
  e2.Playbill = true;
  e2["Poor Richard"] = true;
  e2["Rawlinson Roadway"] = true;
  e2.Renault = true;
  e2.Requiem = true;
  e2.Rockwell = true;
  e2.Roman = true;
  e2["Rotis Serif"] = true;
  e2.Sabon = true;
  e2.Scala = true;
  e2.Seagull = true;
  e2.Sistina = true;
  e2.Souvenir = true;
  e2.STIX = true;
  e2["Stone Informal"] = true;
  e2["Stone Serif"] = true;
  e2.Sylfaen = true;
  e2.Times = true;
  e2.Trajan = true;
  e2["Trinité"] = true;
  e2["Trump Mediaeval"] = true;
  e2.Utopia = true;
  e2["Vale Type"] = true;
  e2["Bitstream Vera"] = true;
  e2["Vera Serif"] = true;
  e2.Versailles = true;
  e2.Wanted = true;
  e2.Weiss = true;
  e2["Wide Latin"] = true;
  e2.Windsor = true;
  e2.XITS = true;
}));
var ei = getLookupTableFactory((function(e2) {
  e2.Dingbats = true;
  e2.Symbol = true;
  e2.ZapfDingbats = true;
  e2.Wingdings = true;
  e2["Wingdings-Bold"] = true;
  e2["Wingdings-Regular"] = true;
}));
var ti = getLookupTableFactory((function(e2) {
  e2[2] = 10;
  e2[3] = 32;
  e2[4] = 33;
  e2[5] = 34;
  e2[6] = 35;
  e2[7] = 36;
  e2[8] = 37;
  e2[9] = 38;
  e2[10] = 39;
  e2[11] = 40;
  e2[12] = 41;
  e2[13] = 42;
  e2[14] = 43;
  e2[15] = 44;
  e2[16] = 45;
  e2[17] = 46;
  e2[18] = 47;
  e2[19] = 48;
  e2[20] = 49;
  e2[21] = 50;
  e2[22] = 51;
  e2[23] = 52;
  e2[24] = 53;
  e2[25] = 54;
  e2[26] = 55;
  e2[27] = 56;
  e2[28] = 57;
  e2[29] = 58;
  e2[30] = 894;
  e2[31] = 60;
  e2[32] = 61;
  e2[33] = 62;
  e2[34] = 63;
  e2[35] = 64;
  e2[36] = 65;
  e2[37] = 66;
  e2[38] = 67;
  e2[39] = 68;
  e2[40] = 69;
  e2[41] = 70;
  e2[42] = 71;
  e2[43] = 72;
  e2[44] = 73;
  e2[45] = 74;
  e2[46] = 75;
  e2[47] = 76;
  e2[48] = 77;
  e2[49] = 78;
  e2[50] = 79;
  e2[51] = 80;
  e2[52] = 81;
  e2[53] = 82;
  e2[54] = 83;
  e2[55] = 84;
  e2[56] = 85;
  e2[57] = 86;
  e2[58] = 87;
  e2[59] = 88;
  e2[60] = 89;
  e2[61] = 90;
  e2[62] = 91;
  e2[63] = 92;
  e2[64] = 93;
  e2[65] = 94;
  e2[66] = 95;
  e2[67] = 96;
  e2[68] = 97;
  e2[69] = 98;
  e2[70] = 99;
  e2[71] = 100;
  e2[72] = 101;
  e2[73] = 102;
  e2[74] = 103;
  e2[75] = 104;
  e2[76] = 105;
  e2[77] = 106;
  e2[78] = 107;
  e2[79] = 108;
  e2[80] = 109;
  e2[81] = 110;
  e2[82] = 111;
  e2[83] = 112;
  e2[84] = 113;
  e2[85] = 114;
  e2[86] = 115;
  e2[87] = 116;
  e2[88] = 117;
  e2[89] = 118;
  e2[90] = 119;
  e2[91] = 120;
  e2[92] = 121;
  e2[93] = 122;
  e2[94] = 123;
  e2[95] = 124;
  e2[96] = 125;
  e2[97] = 126;
  e2[98] = 196;
  e2[99] = 197;
  e2[100] = 199;
  e2[101] = 201;
  e2[102] = 209;
  e2[103] = 214;
  e2[104] = 220;
  e2[105] = 225;
  e2[106] = 224;
  e2[107] = 226;
  e2[108] = 228;
  e2[109] = 227;
  e2[110] = 229;
  e2[111] = 231;
  e2[112] = 233;
  e2[113] = 232;
  e2[114] = 234;
  e2[115] = 235;
  e2[116] = 237;
  e2[117] = 236;
  e2[118] = 238;
  e2[119] = 239;
  e2[120] = 241;
  e2[121] = 243;
  e2[122] = 242;
  e2[123] = 244;
  e2[124] = 246;
  e2[125] = 245;
  e2[126] = 250;
  e2[127] = 249;
  e2[128] = 251;
  e2[129] = 252;
  e2[130] = 8224;
  e2[131] = 176;
  e2[132] = 162;
  e2[133] = 163;
  e2[134] = 167;
  e2[135] = 8226;
  e2[136] = 182;
  e2[137] = 223;
  e2[138] = 174;
  e2[139] = 169;
  e2[140] = 8482;
  e2[141] = 180;
  e2[142] = 168;
  e2[143] = 8800;
  e2[144] = 198;
  e2[145] = 216;
  e2[146] = 8734;
  e2[147] = 177;
  e2[148] = 8804;
  e2[149] = 8805;
  e2[150] = 165;
  e2[151] = 181;
  e2[152] = 8706;
  e2[153] = 8721;
  e2[154] = 8719;
  e2[156] = 8747;
  e2[157] = 170;
  e2[158] = 186;
  e2[159] = 8486;
  e2[160] = 230;
  e2[161] = 248;
  e2[162] = 191;
  e2[163] = 161;
  e2[164] = 172;
  e2[165] = 8730;
  e2[166] = 402;
  e2[167] = 8776;
  e2[168] = 8710;
  e2[169] = 171;
  e2[170] = 187;
  e2[171] = 8230;
  e2[179] = 8220;
  e2[180] = 8221;
  e2[181] = 8216;
  e2[182] = 8217;
  e2[200] = 193;
  e2[203] = 205;
  e2[207] = 211;
  e2[210] = 218;
  e2[223] = 711;
  e2[224] = 321;
  e2[225] = 322;
  e2[226] = 352;
  e2[227] = 353;
  e2[228] = 381;
  e2[229] = 382;
  e2[233] = 221;
  e2[234] = 253;
  e2[252] = 263;
  e2[253] = 268;
  e2[254] = 269;
  e2[258] = 258;
  e2[260] = 260;
  e2[261] = 261;
  e2[265] = 280;
  e2[266] = 281;
  e2[267] = 282;
  e2[268] = 283;
  e2[269] = 313;
  e2[275] = 323;
  e2[276] = 324;
  e2[278] = 328;
  e2[283] = 344;
  e2[284] = 345;
  e2[285] = 346;
  e2[286] = 347;
  e2[292] = 367;
  e2[295] = 377;
  e2[296] = 378;
  e2[298] = 380;
  e2[305] = 963;
  e2[306] = 964;
  e2[307] = 966;
  e2[308] = 8215;
  e2[309] = 8252;
  e2[310] = 8319;
  e2[311] = 8359;
  e2[312] = 8592;
  e2[313] = 8593;
  e2[337] = 9552;
  e2[493] = 1039;
  e2[494] = 1040;
  e2[570] = 1040;
  e2[571] = 1041;
  e2[572] = 1042;
  e2[573] = 1043;
  e2[574] = 1044;
  e2[575] = 1045;
  e2[576] = 1046;
  e2[577] = 1047;
  e2[578] = 1048;
  e2[579] = 1049;
  e2[580] = 1050;
  e2[581] = 1051;
  e2[582] = 1052;
  e2[583] = 1053;
  e2[584] = 1054;
  e2[585] = 1055;
  e2[586] = 1056;
  e2[587] = 1057;
  e2[588] = 1058;
  e2[589] = 1059;
  e2[590] = 1060;
  e2[591] = 1061;
  e2[592] = 1062;
  e2[593] = 1063;
  e2[594] = 1064;
  e2[595] = 1065;
  e2[596] = 1066;
  e2[597] = 1067;
  e2[598] = 1068;
  e2[599] = 1069;
  e2[600] = 1070;
  e2[672] = 1488;
  e2[673] = 1489;
  e2[674] = 1490;
  e2[675] = 1491;
  e2[676] = 1492;
  e2[677] = 1493;
  e2[678] = 1494;
  e2[679] = 1495;
  e2[680] = 1496;
  e2[681] = 1497;
  e2[682] = 1498;
  e2[683] = 1499;
  e2[684] = 1500;
  e2[685] = 1501;
  e2[686] = 1502;
  e2[687] = 1503;
  e2[688] = 1504;
  e2[689] = 1505;
  e2[690] = 1506;
  e2[691] = 1507;
  e2[692] = 1508;
  e2[693] = 1509;
  e2[694] = 1510;
  e2[695] = 1511;
  e2[696] = 1512;
  e2[697] = 1513;
  e2[698] = 1514;
  e2[705] = 1524;
  e2[706] = 8362;
  e2[710] = 64288;
  e2[711] = 64298;
  e2[759] = 1617;
  e2[761] = 1776;
  e2[763] = 1778;
  e2[775] = 1652;
  e2[777] = 1764;
  e2[778] = 1780;
  e2[779] = 1781;
  e2[780] = 1782;
  e2[782] = 771;
  e2[783] = 64726;
  e2[786] = 8363;
  e2[788] = 8532;
  e2[790] = 768;
  e2[791] = 769;
  e2[792] = 768;
  e2[795] = 803;
  e2[797] = 64336;
  e2[798] = 64337;
  e2[799] = 64342;
  e2[800] = 64343;
  e2[801] = 64344;
  e2[802] = 64345;
  e2[803] = 64362;
  e2[804] = 64363;
  e2[805] = 64364;
  e2[2424] = 7821;
  e2[2425] = 7822;
  e2[2426] = 7823;
  e2[2427] = 7824;
  e2[2428] = 7825;
  e2[2429] = 7826;
  e2[2430] = 7827;
  e2[2433] = 7682;
  e2[2678] = 8045;
  e2[2679] = 8046;
  e2[2830] = 1552;
  e2[2838] = 686;
  e2[2840] = 751;
  e2[2842] = 753;
  e2[2843] = 754;
  e2[2844] = 755;
  e2[2846] = 757;
  e2[2856] = 767;
  e2[2857] = 848;
  e2[2858] = 849;
  e2[2862] = 853;
  e2[2863] = 854;
  e2[2864] = 855;
  e2[2865] = 861;
  e2[2866] = 862;
  e2[2906] = 7460;
  e2[2908] = 7462;
  e2[2909] = 7463;
  e2[2910] = 7464;
  e2[2912] = 7466;
  e2[2913] = 7467;
  e2[2914] = 7468;
  e2[2916] = 7470;
  e2[2917] = 7471;
  e2[2918] = 7472;
  e2[2920] = 7474;
  e2[2921] = 7475;
  e2[2922] = 7476;
  e2[2924] = 7478;
  e2[2925] = 7479;
  e2[2926] = 7480;
  e2[2928] = 7482;
  e2[2929] = 7483;
  e2[2930] = 7484;
  e2[2932] = 7486;
  e2[2933] = 7487;
  e2[2934] = 7488;
  e2[2936] = 7490;
  e2[2937] = 7491;
  e2[2938] = 7492;
  e2[2940] = 7494;
  e2[2941] = 7495;
  e2[2942] = 7496;
  e2[2944] = 7498;
  e2[2946] = 7500;
  e2[2948] = 7502;
  e2[2950] = 7504;
  e2[2951] = 7505;
  e2[2952] = 7506;
  e2[2954] = 7508;
  e2[2955] = 7509;
  e2[2956] = 7510;
  e2[2958] = 7512;
  e2[2959] = 7513;
  e2[2960] = 7514;
  e2[2962] = 7516;
  e2[2963] = 7517;
  e2[2964] = 7518;
  e2[2966] = 7520;
  e2[2967] = 7521;
  e2[2968] = 7522;
  e2[2970] = 7524;
  e2[2971] = 7525;
  e2[2972] = 7526;
  e2[2974] = 7528;
  e2[2975] = 7529;
  e2[2976] = 7530;
  e2[2978] = 1537;
  e2[2979] = 1538;
  e2[2980] = 1539;
  e2[2982] = 1549;
  e2[2983] = 1551;
  e2[2984] = 1552;
  e2[2986] = 1554;
  e2[2987] = 1555;
  e2[2988] = 1556;
  e2[2990] = 1623;
  e2[2991] = 1624;
  e2[2995] = 1775;
  e2[2999] = 1791;
  e2[3002] = 64290;
  e2[3003] = 64291;
  e2[3004] = 64292;
  e2[3006] = 64294;
  e2[3007] = 64295;
  e2[3008] = 64296;
  e2[3011] = 1900;
  e2[3014] = 8223;
  e2[3015] = 8244;
  e2[3017] = 7532;
  e2[3018] = 7533;
  e2[3019] = 7534;
  e2[3075] = 7590;
  e2[3076] = 7591;
  e2[3079] = 7594;
  e2[3080] = 7595;
  e2[3083] = 7598;
  e2[3084] = 7599;
  e2[3087] = 7602;
  e2[3088] = 7603;
  e2[3091] = 7606;
  e2[3092] = 7607;
  e2[3095] = 7610;
  e2[3096] = 7611;
  e2[3099] = 7614;
  e2[3100] = 7615;
  e2[3103] = 7618;
  e2[3104] = 7619;
  e2[3107] = 8337;
  e2[3108] = 8338;
  e2[3116] = 1884;
  e2[3119] = 1885;
  e2[3120] = 1885;
  e2[3123] = 1886;
  e2[3124] = 1886;
  e2[3127] = 1887;
  e2[3128] = 1887;
  e2[3131] = 1888;
  e2[3132] = 1888;
  e2[3135] = 1889;
  e2[3136] = 1889;
  e2[3139] = 1890;
  e2[3140] = 1890;
  e2[3143] = 1891;
  e2[3144] = 1891;
  e2[3147] = 1892;
  e2[3148] = 1892;
  e2[3153] = 580;
  e2[3154] = 581;
  e2[3157] = 584;
  e2[3158] = 585;
  e2[3161] = 588;
  e2[3162] = 589;
  e2[3165] = 891;
  e2[3166] = 892;
  e2[3169] = 1274;
  e2[3170] = 1275;
  e2[3173] = 1278;
  e2[3174] = 1279;
  e2[3181] = 7622;
  e2[3182] = 7623;
  e2[3282] = 11799;
  e2[3316] = 578;
  e2[3379] = 42785;
  e2[3393] = 1159;
  e2[3416] = 8377;
}));
var ai = getLookupTableFactory((function(e2) {
  e2[227] = 322;
  e2[264] = 261;
  e2[291] = 346;
}));
var ri = getLookupTableFactory((function(e2) {
  e2[1] = 32;
  e2[4] = 65;
  e2[5] = 192;
  e2[6] = 193;
  e2[9] = 196;
  e2[17] = 66;
  e2[18] = 67;
  e2[21] = 268;
  e2[24] = 68;
  e2[28] = 69;
  e2[29] = 200;
  e2[30] = 201;
  e2[32] = 282;
  e2[38] = 70;
  e2[39] = 71;
  e2[44] = 72;
  e2[47] = 73;
  e2[48] = 204;
  e2[49] = 205;
  e2[58] = 74;
  e2[60] = 75;
  e2[62] = 76;
  e2[68] = 77;
  e2[69] = 78;
  e2[75] = 79;
  e2[76] = 210;
  e2[80] = 214;
  e2[87] = 80;
  e2[89] = 81;
  e2[90] = 82;
  e2[92] = 344;
  e2[94] = 83;
  e2[97] = 352;
  e2[100] = 84;
  e2[104] = 85;
  e2[109] = 220;
  e2[115] = 86;
  e2[116] = 87;
  e2[121] = 88;
  e2[122] = 89;
  e2[124] = 221;
  e2[127] = 90;
  e2[129] = 381;
  e2[258] = 97;
  e2[259] = 224;
  e2[260] = 225;
  e2[263] = 228;
  e2[268] = 261;
  e2[271] = 98;
  e2[272] = 99;
  e2[273] = 263;
  e2[275] = 269;
  e2[282] = 100;
  e2[286] = 101;
  e2[287] = 232;
  e2[288] = 233;
  e2[290] = 283;
  e2[295] = 281;
  e2[296] = 102;
  e2[336] = 103;
  e2[346] = 104;
  e2[349] = 105;
  e2[350] = 236;
  e2[351] = 237;
  e2[361] = 106;
  e2[364] = 107;
  e2[367] = 108;
  e2[371] = 322;
  e2[373] = 109;
  e2[374] = 110;
  e2[381] = 111;
  e2[382] = 242;
  e2[383] = 243;
  e2[386] = 246;
  e2[393] = 112;
  e2[395] = 113;
  e2[396] = 114;
  e2[398] = 345;
  e2[400] = 115;
  e2[401] = 347;
  e2[403] = 353;
  e2[410] = 116;
  e2[437] = 117;
  e2[442] = 252;
  e2[448] = 118;
  e2[449] = 119;
  e2[454] = 120;
  e2[455] = 121;
  e2[457] = 253;
  e2[460] = 122;
  e2[462] = 382;
  e2[463] = 380;
  e2[853] = 44;
  e2[855] = 58;
  e2[856] = 46;
  e2[876] = 47;
  e2[878] = 45;
  e2[882] = 45;
  e2[894] = 40;
  e2[895] = 41;
  e2[896] = 91;
  e2[897] = 93;
  e2[923] = 64;
  e2[940] = 163;
  e2[1004] = 48;
  e2[1005] = 49;
  e2[1006] = 50;
  e2[1007] = 51;
  e2[1008] = 52;
  e2[1009] = 53;
  e2[1010] = 54;
  e2[1011] = 55;
  e2[1012] = 56;
  e2[1013] = 57;
  e2[1081] = 37;
  e2[1085] = 43;
  e2[1086] = 45;
}));
function getStandardFontName(e2) {
  const t2 = normalizeFontName(e2);
  return Jr()[t2];
}
function isKnownFontName(e2) {
  const t2 = normalizeFontName(e2);
  return !!(Jr()[t2] || Zr()[t2] || Qr()[t2] || ei()[t2]);
}
var ToUnicodeMap = class {
  constructor(e2 = []) {
    this._map = e2;
  }
  get length() {
    return this._map.length;
  }
  forEach(e2) {
    for (const t2 in this._map) e2(t2, this._map[t2].codePointAt(0));
  }
  has(e2) {
    return void 0 !== this._map[e2];
  }
  get(e2) {
    return this._map[e2];
  }
  charCodeOf(e2) {
    const t2 = this._map;
    if (t2.length <= 65536) return t2.indexOf(e2);
    for (const a2 in t2) if (t2[a2] === e2) return 0 | a2;
    return -1;
  }
  amend(e2) {
    for (const t2 in e2) this._map[t2] = e2[t2];
  }
};
var IdentityToUnicodeMap = class {
  constructor(e2, t2) {
    this.firstChar = e2;
    this.lastChar = t2;
  }
  get length() {
    return this.lastChar + 1 - this.firstChar;
  }
  forEach(e2) {
    for (let t2 = this.firstChar, a2 = this.lastChar; t2 <= a2; t2++) e2(t2, t2);
  }
  has(e2) {
    return this.firstChar <= e2 && e2 <= this.lastChar;
  }
  get(e2) {
    if (this.firstChar <= e2 && e2 <= this.lastChar) return String.fromCharCode(e2);
  }
  charCodeOf(e2) {
    return Number.isInteger(e2) && e2 >= this.firstChar && e2 <= this.lastChar ? e2 : -1;
  }
  amend(e2) {
    unreachable("Should not call amend()");
  }
};
var CFFFont = class {
  constructor(e2, t2) {
    this.properties = t2;
    const a2 = new CFFParser(e2, t2, Rr);
    this.cff = a2.parse();
    this.cff.duplicateFirstGlyph();
    const r2 = new CFFCompiler(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = r2.compile();
    } catch {
      warn("Failed to compile font " + t2.loadedName);
      this.data = e2;
    }
    this._createBuiltInEncoding();
  }
  get numGlyphs() {
    return this.cff.charStrings.count;
  }
  getCharset() {
    return this.cff.charset.charset;
  }
  getGlyphMapping() {
    const e2 = this.cff, t2 = this.properties, { cidToGidMap: a2, cMap: r2 } = t2, i2 = e2.charset.charset;
    let n2, s2;
    if (t2.composite) {
      let t3, o3;
      if (a2?.length > 0) {
        t3 = /* @__PURE__ */ Object.create(null);
        for (let e3 = 0, r3 = a2.length; e3 < r3; e3++) {
          const r4 = a2[e3];
          void 0 !== r4 && (t3[r4] = e3);
        }
      }
      n2 = /* @__PURE__ */ Object.create(null);
      if (e2.isCIDFont) for (s2 = 0; s2 < i2.length; s2++) {
        const e3 = i2[s2];
        o3 = r2.charCodeOf(e3);
        void 0 !== t3?.[o3] && (o3 = t3[o3]);
        n2[o3] = s2;
      }
      else for (s2 = 0; s2 < e2.charStrings.count; s2++) {
        o3 = r2.charCodeOf(s2);
        n2[o3] = s2;
      }
      return n2;
    }
    let o2 = e2.encoding ? e2.encoding.encoding : null;
    t2.isInternalFont && (o2 = t2.defaultEncoding);
    n2 = type1FontGlyphMapping(t2, o2, i2);
    return n2;
  }
  hasGlyphId(e2) {
    return this.cff.hasGlyphId(e2);
  }
  _createBuiltInEncoding() {
    const { charset: e2, encoding: t2 } = this.cff;
    if (!e2 || !t2) return;
    const a2 = e2.charset, r2 = t2.encoding, i2 = [];
    for (const e3 in r2) {
      const t3 = r2[e3];
      if (t3 >= 0) {
        const r3 = a2[t3];
        r3 && (i2[e3] = r3);
      }
    }
    i2.length > 0 && (this.properties.builtInEncoding = i2);
  }
};
function getFloat214(e2, t2) {
  return readInt16(e2, t2) / 16384;
}
function getSubroutineBias(e2) {
  const t2 = e2.length;
  let a2 = 32768;
  t2 < 1240 ? a2 = 107 : t2 < 33900 && (a2 = 1131);
  return a2;
}
function parseCmap(e2, t2, a2) {
  const r2 = 1 === readUint16(e2, t2 + 2) ? readUint32(e2, t2 + 8) : readUint32(e2, t2 + 16), i2 = readUint16(e2, t2 + r2);
  let n2, s2, o2;
  if (4 === i2) {
    readUint16(e2, t2 + r2 + 2);
    const a3 = readUint16(e2, t2 + r2 + 6) >> 1;
    s2 = t2 + r2 + 14;
    n2 = [];
    for (o2 = 0; o2 < a3; o2++, s2 += 2) n2[o2] = { end: readUint16(e2, s2) };
    s2 += 2;
    for (o2 = 0; o2 < a3; o2++, s2 += 2) n2[o2].start = readUint16(e2, s2);
    for (o2 = 0; o2 < a3; o2++, s2 += 2) n2[o2].idDelta = readUint16(e2, s2);
    for (o2 = 0; o2 < a3; o2++, s2 += 2) {
      let t3 = readUint16(e2, s2);
      if (0 !== t3) {
        n2[o2].ids = [];
        for (let a4 = 0, r3 = n2[o2].end - n2[o2].start + 1; a4 < r3; a4++) {
          n2[o2].ids[a4] = readUint16(e2, s2 + t3);
          t3 += 2;
        }
      }
    }
    return n2;
  }
  if (12 === i2) {
    const a3 = readUint32(e2, t2 + r2 + 12);
    s2 = t2 + r2 + 16;
    n2 = [];
    for (o2 = 0; o2 < a3; o2++) {
      t2 = readUint32(e2, s2);
      n2.push({ start: t2, end: readUint32(e2, s2 + 4), idDelta: readUint32(e2, s2 + 8) - t2 });
      s2 += 12;
    }
    return n2;
  }
  throw new FormatError(`unsupported cmap: ${i2}`);
}
function parseCff(e2, t2, a2, r2) {
  const i2 = new CFFParser(new Stream(e2, t2, a2 - t2), {}, r2).parse();
  return { glyphs: i2.charStrings.objects, subrs: i2.topDict.privateDict?.subrsIndex?.objects, gsubrs: i2.globalSubrIndex?.objects, isCFFCIDFont: i2.isCIDFont, fdSelect: i2.fdSelect, fdArray: i2.fdArray };
}
function lookupCmap(e2, t2) {
  const a2 = t2.codePointAt(0);
  let r2 = 0, i2 = 0, n2 = e2.length - 1;
  for (; i2 < n2; ) {
    const t3 = i2 + n2 + 1 >> 1;
    a2 < e2[t3].start ? n2 = t3 - 1 : i2 = t3;
  }
  e2[i2].start <= a2 && a2 <= e2[i2].end && (r2 = e2[i2].idDelta + (e2[i2].ids ? e2[i2].ids[a2 - e2[i2].start] : a2) & 65535);
  return { charCode: a2, glyphId: r2 };
}
function compileGlyf(e2, t2, a2) {
  function moveTo(e3, a3) {
    s2 && t2.add("L", s2);
    s2 = [e3, a3];
    t2.add("M", [e3, a3]);
  }
  function lineTo(e3, a3) {
    t2.add("L", [e3, a3]);
  }
  function quadraticCurveTo(e3, a3, r3, i3) {
    t2.add("Q", [e3, a3, r3, i3]);
  }
  let r2 = 0;
  const i2 = readInt16(e2, r2);
  let n2, s2 = null, o2 = 0, c2 = 0;
  r2 += 10;
  if (i2 < 0) do {
    n2 = readUint16(e2, r2);
    const i3 = readUint16(e2, r2 + 2);
    r2 += 4;
    let s3, l2;
    if (1 & n2) {
      if (2 & n2) {
        s3 = readInt16(e2, r2);
        l2 = readInt16(e2, r2 + 2);
      } else {
        s3 = readUint16(e2, r2);
        l2 = readUint16(e2, r2 + 2);
      }
      r2 += 4;
    } else if (2 & n2) {
      s3 = readInt8(e2, r2++);
      l2 = readInt8(e2, r2++);
    } else {
      s3 = e2[r2++];
      l2 = e2[r2++];
    }
    if (2 & n2) {
      o2 = s3;
      c2 = l2;
    } else {
      o2 = 0;
      c2 = 0;
    }
    let h2 = 1, u2 = 1, d2 = 0, f2 = 0;
    if (8 & n2) {
      h2 = u2 = getFloat214(e2, r2);
      r2 += 2;
    } else if (64 & n2) {
      h2 = getFloat214(e2, r2);
      u2 = getFloat214(e2, r2 + 2);
      r2 += 4;
    } else if (128 & n2) {
      h2 = getFloat214(e2, r2);
      d2 = getFloat214(e2, r2 + 2);
      f2 = getFloat214(e2, r2 + 4);
      u2 = getFloat214(e2, r2 + 6);
      r2 += 8;
    }
    const g2 = a2.glyphs[i3];
    if (g2) {
      t2.save();
      t2.transform([h2, d2, f2, u2, o2, c2]);
      compileGlyf(g2, t2, a2);
      t2.restore();
    }
  } while (32 & n2);
  else {
    const t3 = [];
    let a3, s3;
    for (a3 = 0; a3 < i2; a3++) {
      t3.push(readUint16(e2, r2));
      r2 += 2;
    }
    r2 += 2 + readUint16(e2, r2);
    const l2 = t3.at(-1) + 1, h2 = [];
    for (; h2.length < l2; ) {
      n2 = e2[r2++];
      let t4 = 1;
      8 & n2 && (t4 += e2[r2++]);
      for (; t4-- > 0; ) h2.push({ flags: n2 });
    }
    for (a3 = 0; a3 < l2; a3++) {
      switch (18 & h2[a3].flags) {
        case 0:
          o2 += readInt16(e2, r2);
          r2 += 2;
          break;
        case 2:
          o2 -= e2[r2++];
          break;
        case 18:
          o2 += e2[r2++];
      }
      h2[a3].x = o2;
    }
    for (a3 = 0; a3 < l2; a3++) {
      switch (36 & h2[a3].flags) {
        case 0:
          c2 += readInt16(e2, r2);
          r2 += 2;
          break;
        case 4:
          c2 -= e2[r2++];
          break;
        case 36:
          c2 += e2[r2++];
      }
      h2[a3].y = c2;
    }
    let u2 = 0;
    for (r2 = 0; r2 < i2; r2++) {
      const e3 = t3[r2], i3 = h2.slice(u2, e3 + 1);
      if (1 & i3[0].flags) i3.push(i3[0]);
      else if (1 & i3.at(-1).flags) i3.unshift(i3.at(-1));
      else {
        const e4 = { flags: 1, x: (i3[0].x + i3.at(-1).x) / 2, y: (i3[0].y + i3.at(-1).y) / 2 };
        i3.unshift(e4);
        i3.push(e4);
      }
      moveTo(i3[0].x, i3[0].y);
      for (a3 = 1, s3 = i3.length; a3 < s3; a3++) if (1 & i3[a3].flags) lineTo(i3[a3].x, i3[a3].y);
      else if (1 & i3[a3 + 1].flags) {
        quadraticCurveTo(i3[a3].x, i3[a3].y, i3[a3 + 1].x, i3[a3 + 1].y);
        a3++;
      } else quadraticCurveTo(i3[a3].x, i3[a3].y, (i3[a3].x + i3[a3 + 1].x) / 2, (i3[a3].y + i3[a3 + 1].y) / 2);
      u2 = e3 + 1;
    }
  }
}
function compileCharString(e2, t2, a2, r2) {
  function moveTo(e3, a3) {
    c2 && t2.add("L", c2);
    c2 = [e3, a3];
    t2.add("M", [e3, a3]);
  }
  function lineTo(e3, a3) {
    t2.add("L", [e3, a3]);
  }
  function bezierCurveTo(e3, a3, r3, i3, n3, s3) {
    t2.add("C", [e3, a3, r3, i3, n3, s3]);
  }
  const i2 = [];
  let n2 = 0, s2 = 0, o2 = 0, c2 = null;
  !(function parse(e3) {
    let c3 = 0;
    for (; c3 < e3.length; ) {
      let l2, h2, u2, d2, f2, g2, p2, m2, b2, y2 = false, w2 = e3[c3++];
      switch (w2) {
        case 1:
        case 3:
        case 18:
        case 23:
          o2 += i2.length >> 1;
          y2 = true;
          break;
        case 4:
          s2 += i2.pop();
          moveTo(n2, s2);
          y2 = true;
          break;
        case 5:
          for (; i2.length > 0; ) {
            n2 += i2.shift();
            s2 += i2.shift();
            lineTo(n2, s2);
          }
          break;
        case 6:
          for (; i2.length > 0; ) {
            n2 += i2.shift();
            lineTo(n2, s2);
            if (0 === i2.length) break;
            s2 += i2.shift();
            lineTo(n2, s2);
          }
          break;
        case 7:
          for (; i2.length > 0; ) {
            s2 += i2.shift();
            lineTo(n2, s2);
            if (0 === i2.length) break;
            n2 += i2.shift();
            lineTo(n2, s2);
          }
          break;
        case 8:
          for (; i2.length > 0; ) {
            l2 = n2 + i2.shift();
            u2 = s2 + i2.shift();
            h2 = l2 + i2.shift();
            d2 = u2 + i2.shift();
            n2 = h2 + i2.shift();
            s2 = d2 + i2.shift();
            bezierCurveTo(l2, u2, h2, d2, n2, s2);
          }
          break;
        case 10:
          m2 = i2.pop();
          b2 = null;
          if (a2.isCFFCIDFont) {
            const e4 = a2.fdSelect.getFDIndex(r2);
            if (e4 >= 0 && e4 < a2.fdArray.length) {
              const t3 = a2.fdArray[e4];
              let r3;
              t3.privateDict?.subrsIndex && (r3 = t3.privateDict.subrsIndex.objects);
              if (r3) {
                m2 += getSubroutineBias(r3);
                b2 = r3[m2];
              }
            } else warn("Invalid fd index for glyph index.");
          } else b2 = a2.subrs[m2 + a2.subrsBias];
          b2 && parse(b2);
          break;
        case 11:
          return;
        case 12:
          w2 = e3[c3++];
          switch (w2) {
            case 34:
              l2 = n2 + i2.shift();
              h2 = l2 + i2.shift();
              f2 = s2 + i2.shift();
              n2 = h2 + i2.shift();
              bezierCurveTo(l2, s2, h2, f2, n2, f2);
              l2 = n2 + i2.shift();
              h2 = l2 + i2.shift();
              n2 = h2 + i2.shift();
              bezierCurveTo(l2, f2, h2, s2, n2, s2);
              break;
            case 35:
              l2 = n2 + i2.shift();
              u2 = s2 + i2.shift();
              h2 = l2 + i2.shift();
              d2 = u2 + i2.shift();
              n2 = h2 + i2.shift();
              s2 = d2 + i2.shift();
              bezierCurveTo(l2, u2, h2, d2, n2, s2);
              l2 = n2 + i2.shift();
              u2 = s2 + i2.shift();
              h2 = l2 + i2.shift();
              d2 = u2 + i2.shift();
              n2 = h2 + i2.shift();
              s2 = d2 + i2.shift();
              bezierCurveTo(l2, u2, h2, d2, n2, s2);
              i2.pop();
              break;
            case 36:
              l2 = n2 + i2.shift();
              f2 = s2 + i2.shift();
              h2 = l2 + i2.shift();
              g2 = f2 + i2.shift();
              n2 = h2 + i2.shift();
              bezierCurveTo(l2, f2, h2, g2, n2, g2);
              l2 = n2 + i2.shift();
              h2 = l2 + i2.shift();
              p2 = g2 + i2.shift();
              n2 = h2 + i2.shift();
              bezierCurveTo(l2, g2, h2, p2, n2, s2);
              break;
            case 37:
              const e4 = n2, t3 = s2;
              l2 = n2 + i2.shift();
              u2 = s2 + i2.shift();
              h2 = l2 + i2.shift();
              d2 = u2 + i2.shift();
              n2 = h2 + i2.shift();
              s2 = d2 + i2.shift();
              bezierCurveTo(l2, u2, h2, d2, n2, s2);
              l2 = n2 + i2.shift();
              u2 = s2 + i2.shift();
              h2 = l2 + i2.shift();
              d2 = u2 + i2.shift();
              n2 = h2;
              s2 = d2;
              Math.abs(n2 - e4) > Math.abs(s2 - t3) ? n2 += i2.shift() : s2 += i2.shift();
              bezierCurveTo(l2, u2, h2, d2, n2, s2);
              break;
            default:
              throw new FormatError(`unknown operator: 12 ${w2}`);
          }
          break;
        case 14:
          if (i2.length >= 4) {
            const e4 = i2.pop(), r3 = i2.pop();
            s2 = i2.pop();
            n2 = i2.pop();
            t2.save();
            t2.translate(n2, s2);
            let o3 = lookupCmap(a2.cmap, String.fromCharCode(a2.glyphNameMap[Ar[e4]]));
            compileCharString(a2.glyphs[o3.glyphId], t2, a2, o3.glyphId);
            t2.restore();
            o3 = lookupCmap(a2.cmap, String.fromCharCode(a2.glyphNameMap[Ar[r3]]));
            compileCharString(a2.glyphs[o3.glyphId], t2, a2, o3.glyphId);
          }
          return;
        case 19:
        case 20:
          o2 += i2.length >> 1;
          c3 += o2 + 7 >> 3;
          y2 = true;
          break;
        case 21:
          s2 += i2.pop();
          n2 += i2.pop();
          moveTo(n2, s2);
          y2 = true;
          break;
        case 22:
          n2 += i2.pop();
          moveTo(n2, s2);
          y2 = true;
          break;
        case 24:
          for (; i2.length > 2; ) {
            l2 = n2 + i2.shift();
            u2 = s2 + i2.shift();
            h2 = l2 + i2.shift();
            d2 = u2 + i2.shift();
            n2 = h2 + i2.shift();
            s2 = d2 + i2.shift();
            bezierCurveTo(l2, u2, h2, d2, n2, s2);
          }
          n2 += i2.shift();
          s2 += i2.shift();
          lineTo(n2, s2);
          break;
        case 25:
          for (; i2.length > 6; ) {
            n2 += i2.shift();
            s2 += i2.shift();
            lineTo(n2, s2);
          }
          l2 = n2 + i2.shift();
          u2 = s2 + i2.shift();
          h2 = l2 + i2.shift();
          d2 = u2 + i2.shift();
          n2 = h2 + i2.shift();
          s2 = d2 + i2.shift();
          bezierCurveTo(l2, u2, h2, d2, n2, s2);
          break;
        case 26:
          i2.length % 2 && (n2 += i2.shift());
          for (; i2.length > 0; ) {
            l2 = n2;
            u2 = s2 + i2.shift();
            h2 = l2 + i2.shift();
            d2 = u2 + i2.shift();
            n2 = h2;
            s2 = d2 + i2.shift();
            bezierCurveTo(l2, u2, h2, d2, n2, s2);
          }
          break;
        case 27:
          i2.length % 2 && (s2 += i2.shift());
          for (; i2.length > 0; ) {
            l2 = n2 + i2.shift();
            u2 = s2;
            h2 = l2 + i2.shift();
            d2 = u2 + i2.shift();
            n2 = h2 + i2.shift();
            s2 = d2;
            bezierCurveTo(l2, u2, h2, d2, n2, s2);
          }
          break;
        case 28:
          i2.push(readInt16(e3, c3));
          c3 += 2;
          break;
        case 29:
          m2 = i2.pop() + a2.gsubrsBias;
          b2 = a2.gsubrs[m2];
          b2 && parse(b2);
          break;
        case 30:
          for (; i2.length > 0; ) {
            l2 = n2;
            u2 = s2 + i2.shift();
            h2 = l2 + i2.shift();
            d2 = u2 + i2.shift();
            n2 = h2 + i2.shift();
            s2 = d2 + (1 === i2.length ? i2.shift() : 0);
            bezierCurveTo(l2, u2, h2, d2, n2, s2);
            if (0 === i2.length) break;
            l2 = n2 + i2.shift();
            u2 = s2;
            h2 = l2 + i2.shift();
            d2 = u2 + i2.shift();
            s2 = d2 + i2.shift();
            n2 = h2 + (1 === i2.length ? i2.shift() : 0);
            bezierCurveTo(l2, u2, h2, d2, n2, s2);
          }
          break;
        case 31:
          for (; i2.length > 0; ) {
            l2 = n2 + i2.shift();
            u2 = s2;
            h2 = l2 + i2.shift();
            d2 = u2 + i2.shift();
            s2 = d2 + i2.shift();
            n2 = h2 + (1 === i2.length ? i2.shift() : 0);
            bezierCurveTo(l2, u2, h2, d2, n2, s2);
            if (0 === i2.length) break;
            l2 = n2;
            u2 = s2 + i2.shift();
            h2 = l2 + i2.shift();
            d2 = u2 + i2.shift();
            n2 = h2 + i2.shift();
            s2 = d2 + (1 === i2.length ? i2.shift() : 0);
            bezierCurveTo(l2, u2, h2, d2, n2, s2);
          }
          break;
        default:
          if (w2 < 32) throw new FormatError(`unknown operator: ${w2}`);
          if (w2 < 247) i2.push(w2 - 139);
          else if (w2 < 251) i2.push(256 * (w2 - 247) + e3[c3++] + 108);
          else if (w2 < 255) i2.push(256 * -(w2 - 251) - e3[c3++] - 108);
          else {
            i2.push((e3[c3] << 24 | e3[c3 + 1] << 16 | e3[c3 + 2] << 8 | e3[c3 + 3]) / 65536);
            c3 += 4;
          }
      }
      y2 && (i2.length = 0);
    }
  })(e2);
}
var Commands = class {
  cmds = [];
  transformStack = [];
  currentTransform = [1, 0, 0, 1, 0, 0];
  add(e2, t2) {
    if (t2) {
      const { currentTransform: a2 } = this;
      for (let e3 = 0, r2 = t2.length; e3 < r2; e3 += 2) Util.applyTransform(t2, a2, e3);
      this.cmds.push(`${e2}${t2.join(" ")}`);
    } else this.cmds.push(e2);
  }
  transform(e2) {
    this.currentTransform = Util.transform(this.currentTransform, e2);
  }
  translate(e2, t2) {
    this.transform([1, 0, 0, 1, e2, t2]);
  }
  save() {
    this.transformStack.push(this.currentTransform.slice());
  }
  restore() {
    this.currentTransform = this.transformStack.pop() || [1, 0, 0, 1, 0, 0];
  }
  getSVG() {
    return this.cmds.join("");
  }
};
var CompiledFont = class {
  constructor(e2) {
    this.fontMatrix = e2;
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
  }
  getPathJs(e2) {
    const { charCode: t2, glyphId: a2 } = lookupCmap(this.cmap, e2);
    let r2, i2 = this.compiledGlyphs[a2];
    if (void 0 === i2) {
      try {
        i2 = this.compileGlyph(this.glyphs[a2], a2);
      } catch (e3) {
        i2 = "";
        r2 = e3;
      }
      this.compiledGlyphs[a2] = i2;
    }
    this.compiledCharCodeToGlyphId[t2] ??= a2;
    if (r2) throw r2;
    return i2;
  }
  compileGlyph(e2, a2) {
    if (!e2?.length || 14 === e2[0]) return "";
    let r2 = this.fontMatrix;
    if (this.isCFFCIDFont) {
      const e3 = this.fdSelect.getFDIndex(a2);
      if (e3 >= 0 && e3 < this.fdArray.length) {
        r2 = this.fdArray[e3].getByName("FontMatrix") || t;
      } else warn("Invalid fd index for glyph index.");
    }
    assert(isNumberArray(r2, 6), "Expected a valid fontMatrix.");
    const i2 = new Commands();
    i2.transform(r2.slice());
    this.compileGlyphImpl(e2, i2, a2);
    i2.add("Z");
    return i2.getSVG();
  }
  compileGlyphImpl() {
    unreachable("Children classes should implement this.");
  }
  hasBuiltPath(e2) {
    const { charCode: t2, glyphId: a2 } = lookupCmap(this.cmap, e2);
    return void 0 !== this.compiledGlyphs[a2] && void 0 !== this.compiledCharCodeToGlyphId[t2];
  }
};
var TrueTypeCompiled = class extends CompiledFont {
  constructor(e2, t2, a2) {
    super(a2 || [488e-6, 0, 0, 488e-6, 0, 0]);
    this.glyphs = e2;
    this.cmap = t2;
  }
  compileGlyphImpl(e2, t2) {
    compileGlyf(e2, t2, this);
  }
};
var Type2Compiled = class extends CompiledFont {
  constructor(e2, t2, a2) {
    super(a2 || [1e-3, 0, 0, 1e-3, 0, 0]);
    this.glyphs = e2.glyphs;
    this.gsubrs = e2.gsubrs || [];
    this.subrs = e2.subrs || [];
    this.cmap = t2;
    this.glyphNameMap = Fr();
    this.gsubrsBias = getSubroutineBias(this.gsubrs);
    this.subrsBias = getSubroutineBias(this.subrs);
    this.isCFFCIDFont = e2.isCFFCIDFont;
    this.fdSelect = e2.fdSelect;
    this.fdArray = e2.fdArray;
  }
  compileGlyphImpl(e2, t2, a2) {
    compileCharString(e2, t2, this, a2);
  }
};
var FontRendererFactory = class {
  static create(e2, t2) {
    const a2 = new Uint8Array(e2.data);
    let r2, i2, n2, s2, o2, c2;
    const l2 = readUint16(a2, 4);
    for (let e3 = 0, h2 = 12; e3 < l2; e3++, h2 += 16) {
      const e4 = bytesToString(a2.subarray(h2, h2 + 4)), l3 = readUint32(a2, h2 + 8), u2 = readUint32(a2, h2 + 12);
      switch (e4) {
        case "cmap":
          r2 = parseCmap(a2, l3);
          break;
        case "glyf":
          i2 = a2.subarray(l3, l3 + u2);
          break;
        case "loca":
          n2 = a2.subarray(l3, l3 + u2);
          break;
        case "head":
          c2 = readUint16(a2, l3 + 18);
          o2 = readUint16(a2, l3 + 50);
          break;
        case "CFF ":
          s2 = parseCff(a2, l3, l3 + u2, t2);
      }
    }
    if (i2) {
      const t3 = c2 ? [1 / c2, 0, 0, 1 / c2, 0, 0] : e2.fontMatrix;
      return new TrueTypeCompiled((function parseGlyfTable(e3, t4, a3) {
        let r3, i3;
        if (a3) {
          r3 = 4;
          i3 = readUint32;
        } else {
          r3 = 2;
          i3 = (e4, t5) => 2 * readUint16(e4, t5);
        }
        const n3 = [];
        let s3 = i3(t4, 0);
        for (let a4 = r3; a4 < t4.length; a4 += r3) {
          const r4 = i3(t4, a4);
          n3.push(e3.subarray(s3, r4));
          s3 = r4;
        }
        return n3;
      })(i2, n2, o2), r2, t3);
    }
    return new Type2Compiled(s2, r2, e2.fontMatrix);
  }
};
var ii = getLookupTableFactory((function(e2) {
  e2.Courier = 600;
  e2["Courier-Bold"] = 600;
  e2["Courier-BoldOblique"] = 600;
  e2["Courier-Oblique"] = 600;
  e2.Helvetica = getLookupTableFactory((function(e3) {
    e3.space = 278;
    e3.exclam = 278;
    e3.quotedbl = 355;
    e3.numbersign = 556;
    e3.dollar = 556;
    e3.percent = 889;
    e3.ampersand = 667;
    e3.quoteright = 222;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 389;
    e3.plus = 584;
    e3.comma = 278;
    e3.hyphen = 333;
    e3.period = 278;
    e3.slash = 278;
    e3.zero = 556;
    e3.one = 556;
    e3.two = 556;
    e3.three = 556;
    e3.four = 556;
    e3.five = 556;
    e3.six = 556;
    e3.seven = 556;
    e3.eight = 556;
    e3.nine = 556;
    e3.colon = 278;
    e3.semicolon = 278;
    e3.less = 584;
    e3.equal = 584;
    e3.greater = 584;
    e3.question = 556;
    e3.at = 1015;
    e3.A = 667;
    e3.B = 667;
    e3.C = 722;
    e3.D = 722;
    e3.E = 667;
    e3.F = 611;
    e3.G = 778;
    e3.H = 722;
    e3.I = 278;
    e3.J = 500;
    e3.K = 667;
    e3.L = 556;
    e3.M = 833;
    e3.N = 722;
    e3.O = 778;
    e3.P = 667;
    e3.Q = 778;
    e3.R = 722;
    e3.S = 667;
    e3.T = 611;
    e3.U = 722;
    e3.V = 667;
    e3.W = 944;
    e3.X = 667;
    e3.Y = 667;
    e3.Z = 611;
    e3.bracketleft = 278;
    e3.backslash = 278;
    e3.bracketright = 278;
    e3.asciicircum = 469;
    e3.underscore = 556;
    e3.quoteleft = 222;
    e3.a = 556;
    e3.b = 556;
    e3.c = 500;
    e3.d = 556;
    e3.e = 556;
    e3.f = 278;
    e3.g = 556;
    e3.h = 556;
    e3.i = 222;
    e3.j = 222;
    e3.k = 500;
    e3.l = 222;
    e3.m = 833;
    e3.n = 556;
    e3.o = 556;
    e3.p = 556;
    e3.q = 556;
    e3.r = 333;
    e3.s = 500;
    e3.t = 278;
    e3.u = 556;
    e3.v = 500;
    e3.w = 722;
    e3.x = 500;
    e3.y = 500;
    e3.z = 500;
    e3.braceleft = 334;
    e3.bar = 260;
    e3.braceright = 334;
    e3.asciitilde = 584;
    e3.exclamdown = 333;
    e3.cent = 556;
    e3.sterling = 556;
    e3.fraction = 167;
    e3.yen = 556;
    e3.florin = 556;
    e3.section = 556;
    e3.currency = 556;
    e3.quotesingle = 191;
    e3.quotedblleft = 333;
    e3.guillemotleft = 556;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 500;
    e3.fl = 500;
    e3.endash = 556;
    e3.dagger = 556;
    e3.daggerdbl = 556;
    e3.periodcentered = 278;
    e3.paragraph = 537;
    e3.bullet = 350;
    e3.quotesinglbase = 222;
    e3.quotedblbase = 333;
    e3.quotedblright = 333;
    e3.guillemotright = 556;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 611;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 1e3;
    e3.ordfeminine = 370;
    e3.Lslash = 556;
    e3.Oslash = 778;
    e3.OE = 1e3;
    e3.ordmasculine = 365;
    e3.ae = 889;
    e3.dotlessi = 278;
    e3.lslash = 222;
    e3.oslash = 611;
    e3.oe = 944;
    e3.germandbls = 611;
    e3.Idieresis = 278;
    e3.eacute = 556;
    e3.abreve = 556;
    e3.uhungarumlaut = 556;
    e3.ecaron = 556;
    e3.Ydieresis = 667;
    e3.divide = 584;
    e3.Yacute = 667;
    e3.Acircumflex = 667;
    e3.aacute = 556;
    e3.Ucircumflex = 722;
    e3.yacute = 500;
    e3.scommaaccent = 500;
    e3.ecircumflex = 556;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 556;
    e3.Uacute = 722;
    e3.uogonek = 556;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 737;
    e3.Emacron = 667;
    e3.ccaron = 500;
    e3.aring = 556;
    e3.Ncommaaccent = 722;
    e3.lacute = 222;
    e3.agrave = 556;
    e3.Tcommaaccent = 611;
    e3.Cacute = 722;
    e3.atilde = 556;
    e3.Edotaccent = 667;
    e3.scaron = 500;
    e3.scedilla = 500;
    e3.iacute = 278;
    e3.lozenge = 471;
    e3.Rcaron = 722;
    e3.Gcommaaccent = 778;
    e3.ucircumflex = 556;
    e3.acircumflex = 556;
    e3.Amacron = 667;
    e3.rcaron = 333;
    e3.ccedilla = 500;
    e3.Zdotaccent = 611;
    e3.Thorn = 667;
    e3.Omacron = 778;
    e3.Racute = 722;
    e3.Sacute = 667;
    e3.dcaron = 643;
    e3.Umacron = 722;
    e3.uring = 556;
    e3.threesuperior = 333;
    e3.Ograve = 778;
    e3.Agrave = 667;
    e3.Abreve = 667;
    e3.multiply = 584;
    e3.uacute = 556;
    e3.Tcaron = 611;
    e3.partialdiff = 476;
    e3.ydieresis = 500;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 556;
    e3.edieresis = 556;
    e3.cacute = 500;
    e3.nacute = 556;
    e3.umacron = 556;
    e3.Ncaron = 722;
    e3.Iacute = 278;
    e3.plusminus = 584;
    e3.brokenbar = 260;
    e3.registered = 737;
    e3.Gbreve = 778;
    e3.Idotaccent = 278;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 333;
    e3.omacron = 556;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 722;
    e3.lcommaaccent = 222;
    e3.tcaron = 317;
    e3.eogonek = 556;
    e3.Uogonek = 722;
    e3.Aacute = 667;
    e3.Adieresis = 667;
    e3.egrave = 556;
    e3.zacute = 500;
    e3.iogonek = 222;
    e3.Oacute = 778;
    e3.oacute = 556;
    e3.amacron = 556;
    e3.sacute = 500;
    e3.idieresis = 278;
    e3.Ocircumflex = 778;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 556;
    e3.twosuperior = 333;
    e3.Odieresis = 778;
    e3.mu = 556;
    e3.igrave = 278;
    e3.ohungarumlaut = 556;
    e3.Eogonek = 667;
    e3.dcroat = 556;
    e3.threequarters = 834;
    e3.Scedilla = 667;
    e3.lcaron = 299;
    e3.Kcommaaccent = 667;
    e3.Lacute = 556;
    e3.trademark = 1e3;
    e3.edotaccent = 556;
    e3.Igrave = 278;
    e3.Imacron = 278;
    e3.Lcaron = 556;
    e3.onehalf = 834;
    e3.lessequal = 549;
    e3.ocircumflex = 556;
    e3.ntilde = 556;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 556;
    e3.gbreve = 556;
    e3.onequarter = 834;
    e3.Scaron = 667;
    e3.Scommaaccent = 667;
    e3.Ohungarumlaut = 778;
    e3.degree = 400;
    e3.ograve = 556;
    e3.Ccaron = 722;
    e3.ugrave = 556;
    e3.radical = 453;
    e3.Dcaron = 722;
    e3.rcommaaccent = 333;
    e3.Ntilde = 722;
    e3.otilde = 556;
    e3.Rcommaaccent = 722;
    e3.Lcommaaccent = 556;
    e3.Atilde = 667;
    e3.Aogonek = 667;
    e3.Aring = 667;
    e3.Otilde = 778;
    e3.zdotaccent = 500;
    e3.Ecaron = 667;
    e3.Iogonek = 278;
    e3.kcommaaccent = 500;
    e3.minus = 584;
    e3.Icircumflex = 278;
    e3.ncaron = 556;
    e3.tcommaaccent = 278;
    e3.logicalnot = 584;
    e3.odieresis = 556;
    e3.udieresis = 556;
    e3.notequal = 549;
    e3.gcommaaccent = 556;
    e3.eth = 556;
    e3.zcaron = 500;
    e3.ncommaaccent = 556;
    e3.onesuperior = 333;
    e3.imacron = 278;
    e3.Euro = 556;
  }));
  e2["Helvetica-Bold"] = getLookupTableFactory((function(e3) {
    e3.space = 278;
    e3.exclam = 333;
    e3.quotedbl = 474;
    e3.numbersign = 556;
    e3.dollar = 556;
    e3.percent = 889;
    e3.ampersand = 722;
    e3.quoteright = 278;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 389;
    e3.plus = 584;
    e3.comma = 278;
    e3.hyphen = 333;
    e3.period = 278;
    e3.slash = 278;
    e3.zero = 556;
    e3.one = 556;
    e3.two = 556;
    e3.three = 556;
    e3.four = 556;
    e3.five = 556;
    e3.six = 556;
    e3.seven = 556;
    e3.eight = 556;
    e3.nine = 556;
    e3.colon = 333;
    e3.semicolon = 333;
    e3.less = 584;
    e3.equal = 584;
    e3.greater = 584;
    e3.question = 611;
    e3.at = 975;
    e3.A = 722;
    e3.B = 722;
    e3.C = 722;
    e3.D = 722;
    e3.E = 667;
    e3.F = 611;
    e3.G = 778;
    e3.H = 722;
    e3.I = 278;
    e3.J = 556;
    e3.K = 722;
    e3.L = 611;
    e3.M = 833;
    e3.N = 722;
    e3.O = 778;
    e3.P = 667;
    e3.Q = 778;
    e3.R = 722;
    e3.S = 667;
    e3.T = 611;
    e3.U = 722;
    e3.V = 667;
    e3.W = 944;
    e3.X = 667;
    e3.Y = 667;
    e3.Z = 611;
    e3.bracketleft = 333;
    e3.backslash = 278;
    e3.bracketright = 333;
    e3.asciicircum = 584;
    e3.underscore = 556;
    e3.quoteleft = 278;
    e3.a = 556;
    e3.b = 611;
    e3.c = 556;
    e3.d = 611;
    e3.e = 556;
    e3.f = 333;
    e3.g = 611;
    e3.h = 611;
    e3.i = 278;
    e3.j = 278;
    e3.k = 556;
    e3.l = 278;
    e3.m = 889;
    e3.n = 611;
    e3.o = 611;
    e3.p = 611;
    e3.q = 611;
    e3.r = 389;
    e3.s = 556;
    e3.t = 333;
    e3.u = 611;
    e3.v = 556;
    e3.w = 778;
    e3.x = 556;
    e3.y = 556;
    e3.z = 500;
    e3.braceleft = 389;
    e3.bar = 280;
    e3.braceright = 389;
    e3.asciitilde = 584;
    e3.exclamdown = 333;
    e3.cent = 556;
    e3.sterling = 556;
    e3.fraction = 167;
    e3.yen = 556;
    e3.florin = 556;
    e3.section = 556;
    e3.currency = 556;
    e3.quotesingle = 238;
    e3.quotedblleft = 500;
    e3.guillemotleft = 556;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 611;
    e3.fl = 611;
    e3.endash = 556;
    e3.dagger = 556;
    e3.daggerdbl = 556;
    e3.periodcentered = 278;
    e3.paragraph = 556;
    e3.bullet = 350;
    e3.quotesinglbase = 278;
    e3.quotedblbase = 500;
    e3.quotedblright = 500;
    e3.guillemotright = 556;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 611;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 1e3;
    e3.ordfeminine = 370;
    e3.Lslash = 611;
    e3.Oslash = 778;
    e3.OE = 1e3;
    e3.ordmasculine = 365;
    e3.ae = 889;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 611;
    e3.oe = 944;
    e3.germandbls = 611;
    e3.Idieresis = 278;
    e3.eacute = 556;
    e3.abreve = 556;
    e3.uhungarumlaut = 611;
    e3.ecaron = 556;
    e3.Ydieresis = 667;
    e3.divide = 584;
    e3.Yacute = 667;
    e3.Acircumflex = 722;
    e3.aacute = 556;
    e3.Ucircumflex = 722;
    e3.yacute = 556;
    e3.scommaaccent = 556;
    e3.ecircumflex = 556;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 556;
    e3.Uacute = 722;
    e3.uogonek = 611;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 737;
    e3.Emacron = 667;
    e3.ccaron = 556;
    e3.aring = 556;
    e3.Ncommaaccent = 722;
    e3.lacute = 278;
    e3.agrave = 556;
    e3.Tcommaaccent = 611;
    e3.Cacute = 722;
    e3.atilde = 556;
    e3.Edotaccent = 667;
    e3.scaron = 556;
    e3.scedilla = 556;
    e3.iacute = 278;
    e3.lozenge = 494;
    e3.Rcaron = 722;
    e3.Gcommaaccent = 778;
    e3.ucircumflex = 611;
    e3.acircumflex = 556;
    e3.Amacron = 722;
    e3.rcaron = 389;
    e3.ccedilla = 556;
    e3.Zdotaccent = 611;
    e3.Thorn = 667;
    e3.Omacron = 778;
    e3.Racute = 722;
    e3.Sacute = 667;
    e3.dcaron = 743;
    e3.Umacron = 722;
    e3.uring = 611;
    e3.threesuperior = 333;
    e3.Ograve = 778;
    e3.Agrave = 722;
    e3.Abreve = 722;
    e3.multiply = 584;
    e3.uacute = 611;
    e3.Tcaron = 611;
    e3.partialdiff = 494;
    e3.ydieresis = 556;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 556;
    e3.edieresis = 556;
    e3.cacute = 556;
    e3.nacute = 611;
    e3.umacron = 611;
    e3.Ncaron = 722;
    e3.Iacute = 278;
    e3.plusminus = 584;
    e3.brokenbar = 280;
    e3.registered = 737;
    e3.Gbreve = 778;
    e3.Idotaccent = 278;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 389;
    e3.omacron = 611;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 722;
    e3.lcommaaccent = 278;
    e3.tcaron = 389;
    e3.eogonek = 556;
    e3.Uogonek = 722;
    e3.Aacute = 722;
    e3.Adieresis = 722;
    e3.egrave = 556;
    e3.zacute = 500;
    e3.iogonek = 278;
    e3.Oacute = 778;
    e3.oacute = 611;
    e3.amacron = 556;
    e3.sacute = 556;
    e3.idieresis = 278;
    e3.Ocircumflex = 778;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 611;
    e3.twosuperior = 333;
    e3.Odieresis = 778;
    e3.mu = 611;
    e3.igrave = 278;
    e3.ohungarumlaut = 611;
    e3.Eogonek = 667;
    e3.dcroat = 611;
    e3.threequarters = 834;
    e3.Scedilla = 667;
    e3.lcaron = 400;
    e3.Kcommaaccent = 722;
    e3.Lacute = 611;
    e3.trademark = 1e3;
    e3.edotaccent = 556;
    e3.Igrave = 278;
    e3.Imacron = 278;
    e3.Lcaron = 611;
    e3.onehalf = 834;
    e3.lessequal = 549;
    e3.ocircumflex = 611;
    e3.ntilde = 611;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 556;
    e3.gbreve = 611;
    e3.onequarter = 834;
    e3.Scaron = 667;
    e3.Scommaaccent = 667;
    e3.Ohungarumlaut = 778;
    e3.degree = 400;
    e3.ograve = 611;
    e3.Ccaron = 722;
    e3.ugrave = 611;
    e3.radical = 549;
    e3.Dcaron = 722;
    e3.rcommaaccent = 389;
    e3.Ntilde = 722;
    e3.otilde = 611;
    e3.Rcommaaccent = 722;
    e3.Lcommaaccent = 611;
    e3.Atilde = 722;
    e3.Aogonek = 722;
    e3.Aring = 722;
    e3.Otilde = 778;
    e3.zdotaccent = 500;
    e3.Ecaron = 667;
    e3.Iogonek = 278;
    e3.kcommaaccent = 556;
    e3.minus = 584;
    e3.Icircumflex = 278;
    e3.ncaron = 611;
    e3.tcommaaccent = 333;
    e3.logicalnot = 584;
    e3.odieresis = 611;
    e3.udieresis = 611;
    e3.notequal = 549;
    e3.gcommaaccent = 611;
    e3.eth = 611;
    e3.zcaron = 500;
    e3.ncommaaccent = 611;
    e3.onesuperior = 333;
    e3.imacron = 278;
    e3.Euro = 556;
  }));
  e2["Helvetica-BoldOblique"] = getLookupTableFactory((function(e3) {
    e3.space = 278;
    e3.exclam = 333;
    e3.quotedbl = 474;
    e3.numbersign = 556;
    e3.dollar = 556;
    e3.percent = 889;
    e3.ampersand = 722;
    e3.quoteright = 278;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 389;
    e3.plus = 584;
    e3.comma = 278;
    e3.hyphen = 333;
    e3.period = 278;
    e3.slash = 278;
    e3.zero = 556;
    e3.one = 556;
    e3.two = 556;
    e3.three = 556;
    e3.four = 556;
    e3.five = 556;
    e3.six = 556;
    e3.seven = 556;
    e3.eight = 556;
    e3.nine = 556;
    e3.colon = 333;
    e3.semicolon = 333;
    e3.less = 584;
    e3.equal = 584;
    e3.greater = 584;
    e3.question = 611;
    e3.at = 975;
    e3.A = 722;
    e3.B = 722;
    e3.C = 722;
    e3.D = 722;
    e3.E = 667;
    e3.F = 611;
    e3.G = 778;
    e3.H = 722;
    e3.I = 278;
    e3.J = 556;
    e3.K = 722;
    e3.L = 611;
    e3.M = 833;
    e3.N = 722;
    e3.O = 778;
    e3.P = 667;
    e3.Q = 778;
    e3.R = 722;
    e3.S = 667;
    e3.T = 611;
    e3.U = 722;
    e3.V = 667;
    e3.W = 944;
    e3.X = 667;
    e3.Y = 667;
    e3.Z = 611;
    e3.bracketleft = 333;
    e3.backslash = 278;
    e3.bracketright = 333;
    e3.asciicircum = 584;
    e3.underscore = 556;
    e3.quoteleft = 278;
    e3.a = 556;
    e3.b = 611;
    e3.c = 556;
    e3.d = 611;
    e3.e = 556;
    e3.f = 333;
    e3.g = 611;
    e3.h = 611;
    e3.i = 278;
    e3.j = 278;
    e3.k = 556;
    e3.l = 278;
    e3.m = 889;
    e3.n = 611;
    e3.o = 611;
    e3.p = 611;
    e3.q = 611;
    e3.r = 389;
    e3.s = 556;
    e3.t = 333;
    e3.u = 611;
    e3.v = 556;
    e3.w = 778;
    e3.x = 556;
    e3.y = 556;
    e3.z = 500;
    e3.braceleft = 389;
    e3.bar = 280;
    e3.braceright = 389;
    e3.asciitilde = 584;
    e3.exclamdown = 333;
    e3.cent = 556;
    e3.sterling = 556;
    e3.fraction = 167;
    e3.yen = 556;
    e3.florin = 556;
    e3.section = 556;
    e3.currency = 556;
    e3.quotesingle = 238;
    e3.quotedblleft = 500;
    e3.guillemotleft = 556;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 611;
    e3.fl = 611;
    e3.endash = 556;
    e3.dagger = 556;
    e3.daggerdbl = 556;
    e3.periodcentered = 278;
    e3.paragraph = 556;
    e3.bullet = 350;
    e3.quotesinglbase = 278;
    e3.quotedblbase = 500;
    e3.quotedblright = 500;
    e3.guillemotright = 556;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 611;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 1e3;
    e3.ordfeminine = 370;
    e3.Lslash = 611;
    e3.Oslash = 778;
    e3.OE = 1e3;
    e3.ordmasculine = 365;
    e3.ae = 889;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 611;
    e3.oe = 944;
    e3.germandbls = 611;
    e3.Idieresis = 278;
    e3.eacute = 556;
    e3.abreve = 556;
    e3.uhungarumlaut = 611;
    e3.ecaron = 556;
    e3.Ydieresis = 667;
    e3.divide = 584;
    e3.Yacute = 667;
    e3.Acircumflex = 722;
    e3.aacute = 556;
    e3.Ucircumflex = 722;
    e3.yacute = 556;
    e3.scommaaccent = 556;
    e3.ecircumflex = 556;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 556;
    e3.Uacute = 722;
    e3.uogonek = 611;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 737;
    e3.Emacron = 667;
    e3.ccaron = 556;
    e3.aring = 556;
    e3.Ncommaaccent = 722;
    e3.lacute = 278;
    e3.agrave = 556;
    e3.Tcommaaccent = 611;
    e3.Cacute = 722;
    e3.atilde = 556;
    e3.Edotaccent = 667;
    e3.scaron = 556;
    e3.scedilla = 556;
    e3.iacute = 278;
    e3.lozenge = 494;
    e3.Rcaron = 722;
    e3.Gcommaaccent = 778;
    e3.ucircumflex = 611;
    e3.acircumflex = 556;
    e3.Amacron = 722;
    e3.rcaron = 389;
    e3.ccedilla = 556;
    e3.Zdotaccent = 611;
    e3.Thorn = 667;
    e3.Omacron = 778;
    e3.Racute = 722;
    e3.Sacute = 667;
    e3.dcaron = 743;
    e3.Umacron = 722;
    e3.uring = 611;
    e3.threesuperior = 333;
    e3.Ograve = 778;
    e3.Agrave = 722;
    e3.Abreve = 722;
    e3.multiply = 584;
    e3.uacute = 611;
    e3.Tcaron = 611;
    e3.partialdiff = 494;
    e3.ydieresis = 556;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 556;
    e3.edieresis = 556;
    e3.cacute = 556;
    e3.nacute = 611;
    e3.umacron = 611;
    e3.Ncaron = 722;
    e3.Iacute = 278;
    e3.plusminus = 584;
    e3.brokenbar = 280;
    e3.registered = 737;
    e3.Gbreve = 778;
    e3.Idotaccent = 278;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 389;
    e3.omacron = 611;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 722;
    e3.lcommaaccent = 278;
    e3.tcaron = 389;
    e3.eogonek = 556;
    e3.Uogonek = 722;
    e3.Aacute = 722;
    e3.Adieresis = 722;
    e3.egrave = 556;
    e3.zacute = 500;
    e3.iogonek = 278;
    e3.Oacute = 778;
    e3.oacute = 611;
    e3.amacron = 556;
    e3.sacute = 556;
    e3.idieresis = 278;
    e3.Ocircumflex = 778;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 611;
    e3.twosuperior = 333;
    e3.Odieresis = 778;
    e3.mu = 611;
    e3.igrave = 278;
    e3.ohungarumlaut = 611;
    e3.Eogonek = 667;
    e3.dcroat = 611;
    e3.threequarters = 834;
    e3.Scedilla = 667;
    e3.lcaron = 400;
    e3.Kcommaaccent = 722;
    e3.Lacute = 611;
    e3.trademark = 1e3;
    e3.edotaccent = 556;
    e3.Igrave = 278;
    e3.Imacron = 278;
    e3.Lcaron = 611;
    e3.onehalf = 834;
    e3.lessequal = 549;
    e3.ocircumflex = 611;
    e3.ntilde = 611;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 556;
    e3.gbreve = 611;
    e3.onequarter = 834;
    e3.Scaron = 667;
    e3.Scommaaccent = 667;
    e3.Ohungarumlaut = 778;
    e3.degree = 400;
    e3.ograve = 611;
    e3.Ccaron = 722;
    e3.ugrave = 611;
    e3.radical = 549;
    e3.Dcaron = 722;
    e3.rcommaaccent = 389;
    e3.Ntilde = 722;
    e3.otilde = 611;
    e3.Rcommaaccent = 722;
    e3.Lcommaaccent = 611;
    e3.Atilde = 722;
    e3.Aogonek = 722;
    e3.Aring = 722;
    e3.Otilde = 778;
    e3.zdotaccent = 500;
    e3.Ecaron = 667;
    e3.Iogonek = 278;
    e3.kcommaaccent = 556;
    e3.minus = 584;
    e3.Icircumflex = 278;
    e3.ncaron = 611;
    e3.tcommaaccent = 333;
    e3.logicalnot = 584;
    e3.odieresis = 611;
    e3.udieresis = 611;
    e3.notequal = 549;
    e3.gcommaaccent = 611;
    e3.eth = 611;
    e3.zcaron = 500;
    e3.ncommaaccent = 611;
    e3.onesuperior = 333;
    e3.imacron = 278;
    e3.Euro = 556;
  }));
  e2["Helvetica-Oblique"] = getLookupTableFactory((function(e3) {
    e3.space = 278;
    e3.exclam = 278;
    e3.quotedbl = 355;
    e3.numbersign = 556;
    e3.dollar = 556;
    e3.percent = 889;
    e3.ampersand = 667;
    e3.quoteright = 222;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 389;
    e3.plus = 584;
    e3.comma = 278;
    e3.hyphen = 333;
    e3.period = 278;
    e3.slash = 278;
    e3.zero = 556;
    e3.one = 556;
    e3.two = 556;
    e3.three = 556;
    e3.four = 556;
    e3.five = 556;
    e3.six = 556;
    e3.seven = 556;
    e3.eight = 556;
    e3.nine = 556;
    e3.colon = 278;
    e3.semicolon = 278;
    e3.less = 584;
    e3.equal = 584;
    e3.greater = 584;
    e3.question = 556;
    e3.at = 1015;
    e3.A = 667;
    e3.B = 667;
    e3.C = 722;
    e3.D = 722;
    e3.E = 667;
    e3.F = 611;
    e3.G = 778;
    e3.H = 722;
    e3.I = 278;
    e3.J = 500;
    e3.K = 667;
    e3.L = 556;
    e3.M = 833;
    e3.N = 722;
    e3.O = 778;
    e3.P = 667;
    e3.Q = 778;
    e3.R = 722;
    e3.S = 667;
    e3.T = 611;
    e3.U = 722;
    e3.V = 667;
    e3.W = 944;
    e3.X = 667;
    e3.Y = 667;
    e3.Z = 611;
    e3.bracketleft = 278;
    e3.backslash = 278;
    e3.bracketright = 278;
    e3.asciicircum = 469;
    e3.underscore = 556;
    e3.quoteleft = 222;
    e3.a = 556;
    e3.b = 556;
    e3.c = 500;
    e3.d = 556;
    e3.e = 556;
    e3.f = 278;
    e3.g = 556;
    e3.h = 556;
    e3.i = 222;
    e3.j = 222;
    e3.k = 500;
    e3.l = 222;
    e3.m = 833;
    e3.n = 556;
    e3.o = 556;
    e3.p = 556;
    e3.q = 556;
    e3.r = 333;
    e3.s = 500;
    e3.t = 278;
    e3.u = 556;
    e3.v = 500;
    e3.w = 722;
    e3.x = 500;
    e3.y = 500;
    e3.z = 500;
    e3.braceleft = 334;
    e3.bar = 260;
    e3.braceright = 334;
    e3.asciitilde = 584;
    e3.exclamdown = 333;
    e3.cent = 556;
    e3.sterling = 556;
    e3.fraction = 167;
    e3.yen = 556;
    e3.florin = 556;
    e3.section = 556;
    e3.currency = 556;
    e3.quotesingle = 191;
    e3.quotedblleft = 333;
    e3.guillemotleft = 556;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 500;
    e3.fl = 500;
    e3.endash = 556;
    e3.dagger = 556;
    e3.daggerdbl = 556;
    e3.periodcentered = 278;
    e3.paragraph = 537;
    e3.bullet = 350;
    e3.quotesinglbase = 222;
    e3.quotedblbase = 333;
    e3.quotedblright = 333;
    e3.guillemotright = 556;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 611;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 1e3;
    e3.ordfeminine = 370;
    e3.Lslash = 556;
    e3.Oslash = 778;
    e3.OE = 1e3;
    e3.ordmasculine = 365;
    e3.ae = 889;
    e3.dotlessi = 278;
    e3.lslash = 222;
    e3.oslash = 611;
    e3.oe = 944;
    e3.germandbls = 611;
    e3.Idieresis = 278;
    e3.eacute = 556;
    e3.abreve = 556;
    e3.uhungarumlaut = 556;
    e3.ecaron = 556;
    e3.Ydieresis = 667;
    e3.divide = 584;
    e3.Yacute = 667;
    e3.Acircumflex = 667;
    e3.aacute = 556;
    e3.Ucircumflex = 722;
    e3.yacute = 500;
    e3.scommaaccent = 500;
    e3.ecircumflex = 556;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 556;
    e3.Uacute = 722;
    e3.uogonek = 556;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 737;
    e3.Emacron = 667;
    e3.ccaron = 500;
    e3.aring = 556;
    e3.Ncommaaccent = 722;
    e3.lacute = 222;
    e3.agrave = 556;
    e3.Tcommaaccent = 611;
    e3.Cacute = 722;
    e3.atilde = 556;
    e3.Edotaccent = 667;
    e3.scaron = 500;
    e3.scedilla = 500;
    e3.iacute = 278;
    e3.lozenge = 471;
    e3.Rcaron = 722;
    e3.Gcommaaccent = 778;
    e3.ucircumflex = 556;
    e3.acircumflex = 556;
    e3.Amacron = 667;
    e3.rcaron = 333;
    e3.ccedilla = 500;
    e3.Zdotaccent = 611;
    e3.Thorn = 667;
    e3.Omacron = 778;
    e3.Racute = 722;
    e3.Sacute = 667;
    e3.dcaron = 643;
    e3.Umacron = 722;
    e3.uring = 556;
    e3.threesuperior = 333;
    e3.Ograve = 778;
    e3.Agrave = 667;
    e3.Abreve = 667;
    e3.multiply = 584;
    e3.uacute = 556;
    e3.Tcaron = 611;
    e3.partialdiff = 476;
    e3.ydieresis = 500;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 556;
    e3.edieresis = 556;
    e3.cacute = 500;
    e3.nacute = 556;
    e3.umacron = 556;
    e3.Ncaron = 722;
    e3.Iacute = 278;
    e3.plusminus = 584;
    e3.brokenbar = 260;
    e3.registered = 737;
    e3.Gbreve = 778;
    e3.Idotaccent = 278;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 333;
    e3.omacron = 556;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 722;
    e3.lcommaaccent = 222;
    e3.tcaron = 317;
    e3.eogonek = 556;
    e3.Uogonek = 722;
    e3.Aacute = 667;
    e3.Adieresis = 667;
    e3.egrave = 556;
    e3.zacute = 500;
    e3.iogonek = 222;
    e3.Oacute = 778;
    e3.oacute = 556;
    e3.amacron = 556;
    e3.sacute = 500;
    e3.idieresis = 278;
    e3.Ocircumflex = 778;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 556;
    e3.twosuperior = 333;
    e3.Odieresis = 778;
    e3.mu = 556;
    e3.igrave = 278;
    e3.ohungarumlaut = 556;
    e3.Eogonek = 667;
    e3.dcroat = 556;
    e3.threequarters = 834;
    e3.Scedilla = 667;
    e3.lcaron = 299;
    e3.Kcommaaccent = 667;
    e3.Lacute = 556;
    e3.trademark = 1e3;
    e3.edotaccent = 556;
    e3.Igrave = 278;
    e3.Imacron = 278;
    e3.Lcaron = 556;
    e3.onehalf = 834;
    e3.lessequal = 549;
    e3.ocircumflex = 556;
    e3.ntilde = 556;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 556;
    e3.gbreve = 556;
    e3.onequarter = 834;
    e3.Scaron = 667;
    e3.Scommaaccent = 667;
    e3.Ohungarumlaut = 778;
    e3.degree = 400;
    e3.ograve = 556;
    e3.Ccaron = 722;
    e3.ugrave = 556;
    e3.radical = 453;
    e3.Dcaron = 722;
    e3.rcommaaccent = 333;
    e3.Ntilde = 722;
    e3.otilde = 556;
    e3.Rcommaaccent = 722;
    e3.Lcommaaccent = 556;
    e3.Atilde = 667;
    e3.Aogonek = 667;
    e3.Aring = 667;
    e3.Otilde = 778;
    e3.zdotaccent = 500;
    e3.Ecaron = 667;
    e3.Iogonek = 278;
    e3.kcommaaccent = 500;
    e3.minus = 584;
    e3.Icircumflex = 278;
    e3.ncaron = 556;
    e3.tcommaaccent = 278;
    e3.logicalnot = 584;
    e3.odieresis = 556;
    e3.udieresis = 556;
    e3.notequal = 549;
    e3.gcommaaccent = 556;
    e3.eth = 556;
    e3.zcaron = 500;
    e3.ncommaaccent = 556;
    e3.onesuperior = 333;
    e3.imacron = 278;
    e3.Euro = 556;
  }));
  e2.Symbol = getLookupTableFactory((function(e3) {
    e3.space = 250;
    e3.exclam = 333;
    e3.universal = 713;
    e3.numbersign = 500;
    e3.existential = 549;
    e3.percent = 833;
    e3.ampersand = 778;
    e3.suchthat = 439;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asteriskmath = 500;
    e3.plus = 549;
    e3.comma = 250;
    e3.minus = 549;
    e3.period = 250;
    e3.slash = 278;
    e3.zero = 500;
    e3.one = 500;
    e3.two = 500;
    e3.three = 500;
    e3.four = 500;
    e3.five = 500;
    e3.six = 500;
    e3.seven = 500;
    e3.eight = 500;
    e3.nine = 500;
    e3.colon = 278;
    e3.semicolon = 278;
    e3.less = 549;
    e3.equal = 549;
    e3.greater = 549;
    e3.question = 444;
    e3.congruent = 549;
    e3.Alpha = 722;
    e3.Beta = 667;
    e3.Chi = 722;
    e3.Delta = 612;
    e3.Epsilon = 611;
    e3.Phi = 763;
    e3.Gamma = 603;
    e3.Eta = 722;
    e3.Iota = 333;
    e3.theta1 = 631;
    e3.Kappa = 722;
    e3.Lambda = 686;
    e3.Mu = 889;
    e3.Nu = 722;
    e3.Omicron = 722;
    e3.Pi = 768;
    e3.Theta = 741;
    e3.Rho = 556;
    e3.Sigma = 592;
    e3.Tau = 611;
    e3.Upsilon = 690;
    e3.sigma1 = 439;
    e3.Omega = 768;
    e3.Xi = 645;
    e3.Psi = 795;
    e3.Zeta = 611;
    e3.bracketleft = 333;
    e3.therefore = 863;
    e3.bracketright = 333;
    e3.perpendicular = 658;
    e3.underscore = 500;
    e3.radicalex = 500;
    e3.alpha = 631;
    e3.beta = 549;
    e3.chi = 549;
    e3.delta = 494;
    e3.epsilon = 439;
    e3.phi = 521;
    e3.gamma = 411;
    e3.eta = 603;
    e3.iota = 329;
    e3.phi1 = 603;
    e3.kappa = 549;
    e3.lambda = 549;
    e3.mu = 576;
    e3.nu = 521;
    e3.omicron = 549;
    e3.pi = 549;
    e3.theta = 521;
    e3.rho = 549;
    e3.sigma = 603;
    e3.tau = 439;
    e3.upsilon = 576;
    e3.omega1 = 713;
    e3.omega = 686;
    e3.xi = 493;
    e3.psi = 686;
    e3.zeta = 494;
    e3.braceleft = 480;
    e3.bar = 200;
    e3.braceright = 480;
    e3.similar = 549;
    e3.Euro = 750;
    e3.Upsilon1 = 620;
    e3.minute = 247;
    e3.lessequal = 549;
    e3.fraction = 167;
    e3.infinity = 713;
    e3.florin = 500;
    e3.club = 753;
    e3.diamond = 753;
    e3.heart = 753;
    e3.spade = 753;
    e3.arrowboth = 1042;
    e3.arrowleft = 987;
    e3.arrowup = 603;
    e3.arrowright = 987;
    e3.arrowdown = 603;
    e3.degree = 400;
    e3.plusminus = 549;
    e3.second = 411;
    e3.greaterequal = 549;
    e3.multiply = 549;
    e3.proportional = 713;
    e3.partialdiff = 494;
    e3.bullet = 460;
    e3.divide = 549;
    e3.notequal = 549;
    e3.equivalence = 549;
    e3.approxequal = 549;
    e3.ellipsis = 1e3;
    e3.arrowvertex = 603;
    e3.arrowhorizex = 1e3;
    e3.carriagereturn = 658;
    e3.aleph = 823;
    e3.Ifraktur = 686;
    e3.Rfraktur = 795;
    e3.weierstrass = 987;
    e3.circlemultiply = 768;
    e3.circleplus = 768;
    e3.emptyset = 823;
    e3.intersection = 768;
    e3.union = 768;
    e3.propersuperset = 713;
    e3.reflexsuperset = 713;
    e3.notsubset = 713;
    e3.propersubset = 713;
    e3.reflexsubset = 713;
    e3.element = 713;
    e3.notelement = 713;
    e3.angle = 768;
    e3.gradient = 713;
    e3.registerserif = 790;
    e3.copyrightserif = 790;
    e3.trademarkserif = 890;
    e3.product = 823;
    e3.radical = 549;
    e3.dotmath = 250;
    e3.logicalnot = 713;
    e3.logicaland = 603;
    e3.logicalor = 603;
    e3.arrowdblboth = 1042;
    e3.arrowdblleft = 987;
    e3.arrowdblup = 603;
    e3.arrowdblright = 987;
    e3.arrowdbldown = 603;
    e3.lozenge = 494;
    e3.angleleft = 329;
    e3.registersans = 790;
    e3.copyrightsans = 790;
    e3.trademarksans = 786;
    e3.summation = 713;
    e3.parenlefttp = 384;
    e3.parenleftex = 384;
    e3.parenleftbt = 384;
    e3.bracketlefttp = 384;
    e3.bracketleftex = 384;
    e3.bracketleftbt = 384;
    e3.bracelefttp = 494;
    e3.braceleftmid = 494;
    e3.braceleftbt = 494;
    e3.braceex = 494;
    e3.angleright = 329;
    e3.integral = 274;
    e3.integraltp = 686;
    e3.integralex = 686;
    e3.integralbt = 686;
    e3.parenrighttp = 384;
    e3.parenrightex = 384;
    e3.parenrightbt = 384;
    e3.bracketrighttp = 384;
    e3.bracketrightex = 384;
    e3.bracketrightbt = 384;
    e3.bracerighttp = 494;
    e3.bracerightmid = 494;
    e3.bracerightbt = 494;
    e3.apple = 790;
  }));
  e2["Times-Roman"] = getLookupTableFactory((function(e3) {
    e3.space = 250;
    e3.exclam = 333;
    e3.quotedbl = 408;
    e3.numbersign = 500;
    e3.dollar = 500;
    e3.percent = 833;
    e3.ampersand = 778;
    e3.quoteright = 333;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 500;
    e3.plus = 564;
    e3.comma = 250;
    e3.hyphen = 333;
    e3.period = 250;
    e3.slash = 278;
    e3.zero = 500;
    e3.one = 500;
    e3.two = 500;
    e3.three = 500;
    e3.four = 500;
    e3.five = 500;
    e3.six = 500;
    e3.seven = 500;
    e3.eight = 500;
    e3.nine = 500;
    e3.colon = 278;
    e3.semicolon = 278;
    e3.less = 564;
    e3.equal = 564;
    e3.greater = 564;
    e3.question = 444;
    e3.at = 921;
    e3.A = 722;
    e3.B = 667;
    e3.C = 667;
    e3.D = 722;
    e3.E = 611;
    e3.F = 556;
    e3.G = 722;
    e3.H = 722;
    e3.I = 333;
    e3.J = 389;
    e3.K = 722;
    e3.L = 611;
    e3.M = 889;
    e3.N = 722;
    e3.O = 722;
    e3.P = 556;
    e3.Q = 722;
    e3.R = 667;
    e3.S = 556;
    e3.T = 611;
    e3.U = 722;
    e3.V = 722;
    e3.W = 944;
    e3.X = 722;
    e3.Y = 722;
    e3.Z = 611;
    e3.bracketleft = 333;
    e3.backslash = 278;
    e3.bracketright = 333;
    e3.asciicircum = 469;
    e3.underscore = 500;
    e3.quoteleft = 333;
    e3.a = 444;
    e3.b = 500;
    e3.c = 444;
    e3.d = 500;
    e3.e = 444;
    e3.f = 333;
    e3.g = 500;
    e3.h = 500;
    e3.i = 278;
    e3.j = 278;
    e3.k = 500;
    e3.l = 278;
    e3.m = 778;
    e3.n = 500;
    e3.o = 500;
    e3.p = 500;
    e3.q = 500;
    e3.r = 333;
    e3.s = 389;
    e3.t = 278;
    e3.u = 500;
    e3.v = 500;
    e3.w = 722;
    e3.x = 500;
    e3.y = 500;
    e3.z = 444;
    e3.braceleft = 480;
    e3.bar = 200;
    e3.braceright = 480;
    e3.asciitilde = 541;
    e3.exclamdown = 333;
    e3.cent = 500;
    e3.sterling = 500;
    e3.fraction = 167;
    e3.yen = 500;
    e3.florin = 500;
    e3.section = 500;
    e3.currency = 500;
    e3.quotesingle = 180;
    e3.quotedblleft = 444;
    e3.guillemotleft = 500;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 556;
    e3.fl = 556;
    e3.endash = 500;
    e3.dagger = 500;
    e3.daggerdbl = 500;
    e3.periodcentered = 250;
    e3.paragraph = 453;
    e3.bullet = 350;
    e3.quotesinglbase = 333;
    e3.quotedblbase = 444;
    e3.quotedblright = 444;
    e3.guillemotright = 500;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 444;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 889;
    e3.ordfeminine = 276;
    e3.Lslash = 611;
    e3.Oslash = 722;
    e3.OE = 889;
    e3.ordmasculine = 310;
    e3.ae = 667;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 500;
    e3.oe = 722;
    e3.germandbls = 500;
    e3.Idieresis = 333;
    e3.eacute = 444;
    e3.abreve = 444;
    e3.uhungarumlaut = 500;
    e3.ecaron = 444;
    e3.Ydieresis = 722;
    e3.divide = 564;
    e3.Yacute = 722;
    e3.Acircumflex = 722;
    e3.aacute = 444;
    e3.Ucircumflex = 722;
    e3.yacute = 500;
    e3.scommaaccent = 389;
    e3.ecircumflex = 444;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 444;
    e3.Uacute = 722;
    e3.uogonek = 500;
    e3.Edieresis = 611;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 760;
    e3.Emacron = 611;
    e3.ccaron = 444;
    e3.aring = 444;
    e3.Ncommaaccent = 722;
    e3.lacute = 278;
    e3.agrave = 444;
    e3.Tcommaaccent = 611;
    e3.Cacute = 667;
    e3.atilde = 444;
    e3.Edotaccent = 611;
    e3.scaron = 389;
    e3.scedilla = 389;
    e3.iacute = 278;
    e3.lozenge = 471;
    e3.Rcaron = 667;
    e3.Gcommaaccent = 722;
    e3.ucircumflex = 500;
    e3.acircumflex = 444;
    e3.Amacron = 722;
    e3.rcaron = 333;
    e3.ccedilla = 444;
    e3.Zdotaccent = 611;
    e3.Thorn = 556;
    e3.Omacron = 722;
    e3.Racute = 667;
    e3.Sacute = 556;
    e3.dcaron = 588;
    e3.Umacron = 722;
    e3.uring = 500;
    e3.threesuperior = 300;
    e3.Ograve = 722;
    e3.Agrave = 722;
    e3.Abreve = 722;
    e3.multiply = 564;
    e3.uacute = 500;
    e3.Tcaron = 611;
    e3.partialdiff = 476;
    e3.ydieresis = 500;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 611;
    e3.adieresis = 444;
    e3.edieresis = 444;
    e3.cacute = 444;
    e3.nacute = 500;
    e3.umacron = 500;
    e3.Ncaron = 722;
    e3.Iacute = 333;
    e3.plusminus = 564;
    e3.brokenbar = 200;
    e3.registered = 760;
    e3.Gbreve = 722;
    e3.Idotaccent = 333;
    e3.summation = 600;
    e3.Egrave = 611;
    e3.racute = 333;
    e3.omacron = 500;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 667;
    e3.lcommaaccent = 278;
    e3.tcaron = 326;
    e3.eogonek = 444;
    e3.Uogonek = 722;
    e3.Aacute = 722;
    e3.Adieresis = 722;
    e3.egrave = 444;
    e3.zacute = 444;
    e3.iogonek = 278;
    e3.Oacute = 722;
    e3.oacute = 500;
    e3.amacron = 444;
    e3.sacute = 389;
    e3.idieresis = 278;
    e3.Ocircumflex = 722;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 500;
    e3.twosuperior = 300;
    e3.Odieresis = 722;
    e3.mu = 500;
    e3.igrave = 278;
    e3.ohungarumlaut = 500;
    e3.Eogonek = 611;
    e3.dcroat = 500;
    e3.threequarters = 750;
    e3.Scedilla = 556;
    e3.lcaron = 344;
    e3.Kcommaaccent = 722;
    e3.Lacute = 611;
    e3.trademark = 980;
    e3.edotaccent = 444;
    e3.Igrave = 333;
    e3.Imacron = 333;
    e3.Lcaron = 611;
    e3.onehalf = 750;
    e3.lessequal = 549;
    e3.ocircumflex = 500;
    e3.ntilde = 500;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 611;
    e3.emacron = 444;
    e3.gbreve = 500;
    e3.onequarter = 750;
    e3.Scaron = 556;
    e3.Scommaaccent = 556;
    e3.Ohungarumlaut = 722;
    e3.degree = 400;
    e3.ograve = 500;
    e3.Ccaron = 667;
    e3.ugrave = 500;
    e3.radical = 453;
    e3.Dcaron = 722;
    e3.rcommaaccent = 333;
    e3.Ntilde = 722;
    e3.otilde = 500;
    e3.Rcommaaccent = 667;
    e3.Lcommaaccent = 611;
    e3.Atilde = 722;
    e3.Aogonek = 722;
    e3.Aring = 722;
    e3.Otilde = 722;
    e3.zdotaccent = 444;
    e3.Ecaron = 611;
    e3.Iogonek = 333;
    e3.kcommaaccent = 500;
    e3.minus = 564;
    e3.Icircumflex = 333;
    e3.ncaron = 500;
    e3.tcommaaccent = 278;
    e3.logicalnot = 564;
    e3.odieresis = 500;
    e3.udieresis = 500;
    e3.notequal = 549;
    e3.gcommaaccent = 500;
    e3.eth = 500;
    e3.zcaron = 444;
    e3.ncommaaccent = 500;
    e3.onesuperior = 300;
    e3.imacron = 278;
    e3.Euro = 500;
  }));
  e2["Times-Bold"] = getLookupTableFactory((function(e3) {
    e3.space = 250;
    e3.exclam = 333;
    e3.quotedbl = 555;
    e3.numbersign = 500;
    e3.dollar = 500;
    e3.percent = 1e3;
    e3.ampersand = 833;
    e3.quoteright = 333;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 500;
    e3.plus = 570;
    e3.comma = 250;
    e3.hyphen = 333;
    e3.period = 250;
    e3.slash = 278;
    e3.zero = 500;
    e3.one = 500;
    e3.two = 500;
    e3.three = 500;
    e3.four = 500;
    e3.five = 500;
    e3.six = 500;
    e3.seven = 500;
    e3.eight = 500;
    e3.nine = 500;
    e3.colon = 333;
    e3.semicolon = 333;
    e3.less = 570;
    e3.equal = 570;
    e3.greater = 570;
    e3.question = 500;
    e3.at = 930;
    e3.A = 722;
    e3.B = 667;
    e3.C = 722;
    e3.D = 722;
    e3.E = 667;
    e3.F = 611;
    e3.G = 778;
    e3.H = 778;
    e3.I = 389;
    e3.J = 500;
    e3.K = 778;
    e3.L = 667;
    e3.M = 944;
    e3.N = 722;
    e3.O = 778;
    e3.P = 611;
    e3.Q = 778;
    e3.R = 722;
    e3.S = 556;
    e3.T = 667;
    e3.U = 722;
    e3.V = 722;
    e3.W = 1e3;
    e3.X = 722;
    e3.Y = 722;
    e3.Z = 667;
    e3.bracketleft = 333;
    e3.backslash = 278;
    e3.bracketright = 333;
    e3.asciicircum = 581;
    e3.underscore = 500;
    e3.quoteleft = 333;
    e3.a = 500;
    e3.b = 556;
    e3.c = 444;
    e3.d = 556;
    e3.e = 444;
    e3.f = 333;
    e3.g = 500;
    e3.h = 556;
    e3.i = 278;
    e3.j = 333;
    e3.k = 556;
    e3.l = 278;
    e3.m = 833;
    e3.n = 556;
    e3.o = 500;
    e3.p = 556;
    e3.q = 556;
    e3.r = 444;
    e3.s = 389;
    e3.t = 333;
    e3.u = 556;
    e3.v = 500;
    e3.w = 722;
    e3.x = 500;
    e3.y = 500;
    e3.z = 444;
    e3.braceleft = 394;
    e3.bar = 220;
    e3.braceright = 394;
    e3.asciitilde = 520;
    e3.exclamdown = 333;
    e3.cent = 500;
    e3.sterling = 500;
    e3.fraction = 167;
    e3.yen = 500;
    e3.florin = 500;
    e3.section = 500;
    e3.currency = 500;
    e3.quotesingle = 278;
    e3.quotedblleft = 500;
    e3.guillemotleft = 500;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 556;
    e3.fl = 556;
    e3.endash = 500;
    e3.dagger = 500;
    e3.daggerdbl = 500;
    e3.periodcentered = 250;
    e3.paragraph = 540;
    e3.bullet = 350;
    e3.quotesinglbase = 333;
    e3.quotedblbase = 500;
    e3.quotedblright = 500;
    e3.guillemotright = 500;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 500;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 1e3;
    e3.ordfeminine = 300;
    e3.Lslash = 667;
    e3.Oslash = 778;
    e3.OE = 1e3;
    e3.ordmasculine = 330;
    e3.ae = 722;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 500;
    e3.oe = 722;
    e3.germandbls = 556;
    e3.Idieresis = 389;
    e3.eacute = 444;
    e3.abreve = 500;
    e3.uhungarumlaut = 556;
    e3.ecaron = 444;
    e3.Ydieresis = 722;
    e3.divide = 570;
    e3.Yacute = 722;
    e3.Acircumflex = 722;
    e3.aacute = 500;
    e3.Ucircumflex = 722;
    e3.yacute = 500;
    e3.scommaaccent = 389;
    e3.ecircumflex = 444;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 500;
    e3.Uacute = 722;
    e3.uogonek = 556;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 747;
    e3.Emacron = 667;
    e3.ccaron = 444;
    e3.aring = 500;
    e3.Ncommaaccent = 722;
    e3.lacute = 278;
    e3.agrave = 500;
    e3.Tcommaaccent = 667;
    e3.Cacute = 722;
    e3.atilde = 500;
    e3.Edotaccent = 667;
    e3.scaron = 389;
    e3.scedilla = 389;
    e3.iacute = 278;
    e3.lozenge = 494;
    e3.Rcaron = 722;
    e3.Gcommaaccent = 778;
    e3.ucircumflex = 556;
    e3.acircumflex = 500;
    e3.Amacron = 722;
    e3.rcaron = 444;
    e3.ccedilla = 444;
    e3.Zdotaccent = 667;
    e3.Thorn = 611;
    e3.Omacron = 778;
    e3.Racute = 722;
    e3.Sacute = 556;
    e3.dcaron = 672;
    e3.Umacron = 722;
    e3.uring = 556;
    e3.threesuperior = 300;
    e3.Ograve = 778;
    e3.Agrave = 722;
    e3.Abreve = 722;
    e3.multiply = 570;
    e3.uacute = 556;
    e3.Tcaron = 667;
    e3.partialdiff = 494;
    e3.ydieresis = 500;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 500;
    e3.edieresis = 444;
    e3.cacute = 444;
    e3.nacute = 556;
    e3.umacron = 556;
    e3.Ncaron = 722;
    e3.Iacute = 389;
    e3.plusminus = 570;
    e3.brokenbar = 220;
    e3.registered = 747;
    e3.Gbreve = 778;
    e3.Idotaccent = 389;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 444;
    e3.omacron = 500;
    e3.Zacute = 667;
    e3.Zcaron = 667;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 722;
    e3.lcommaaccent = 278;
    e3.tcaron = 416;
    e3.eogonek = 444;
    e3.Uogonek = 722;
    e3.Aacute = 722;
    e3.Adieresis = 722;
    e3.egrave = 444;
    e3.zacute = 444;
    e3.iogonek = 278;
    e3.Oacute = 778;
    e3.oacute = 500;
    e3.amacron = 500;
    e3.sacute = 389;
    e3.idieresis = 278;
    e3.Ocircumflex = 778;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 556;
    e3.twosuperior = 300;
    e3.Odieresis = 778;
    e3.mu = 556;
    e3.igrave = 278;
    e3.ohungarumlaut = 500;
    e3.Eogonek = 667;
    e3.dcroat = 556;
    e3.threequarters = 750;
    e3.Scedilla = 556;
    e3.lcaron = 394;
    e3.Kcommaaccent = 778;
    e3.Lacute = 667;
    e3.trademark = 1e3;
    e3.edotaccent = 444;
    e3.Igrave = 389;
    e3.Imacron = 389;
    e3.Lcaron = 667;
    e3.onehalf = 750;
    e3.lessequal = 549;
    e3.ocircumflex = 500;
    e3.ntilde = 556;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 444;
    e3.gbreve = 500;
    e3.onequarter = 750;
    e3.Scaron = 556;
    e3.Scommaaccent = 556;
    e3.Ohungarumlaut = 778;
    e3.degree = 400;
    e3.ograve = 500;
    e3.Ccaron = 722;
    e3.ugrave = 556;
    e3.radical = 549;
    e3.Dcaron = 722;
    e3.rcommaaccent = 444;
    e3.Ntilde = 722;
    e3.otilde = 500;
    e3.Rcommaaccent = 722;
    e3.Lcommaaccent = 667;
    e3.Atilde = 722;
    e3.Aogonek = 722;
    e3.Aring = 722;
    e3.Otilde = 778;
    e3.zdotaccent = 444;
    e3.Ecaron = 667;
    e3.Iogonek = 389;
    e3.kcommaaccent = 556;
    e3.minus = 570;
    e3.Icircumflex = 389;
    e3.ncaron = 556;
    e3.tcommaaccent = 333;
    e3.logicalnot = 570;
    e3.odieresis = 500;
    e3.udieresis = 556;
    e3.notequal = 549;
    e3.gcommaaccent = 500;
    e3.eth = 500;
    e3.zcaron = 444;
    e3.ncommaaccent = 556;
    e3.onesuperior = 300;
    e3.imacron = 278;
    e3.Euro = 500;
  }));
  e2["Times-BoldItalic"] = getLookupTableFactory((function(e3) {
    e3.space = 250;
    e3.exclam = 389;
    e3.quotedbl = 555;
    e3.numbersign = 500;
    e3.dollar = 500;
    e3.percent = 833;
    e3.ampersand = 778;
    e3.quoteright = 333;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 500;
    e3.plus = 570;
    e3.comma = 250;
    e3.hyphen = 333;
    e3.period = 250;
    e3.slash = 278;
    e3.zero = 500;
    e3.one = 500;
    e3.two = 500;
    e3.three = 500;
    e3.four = 500;
    e3.five = 500;
    e3.six = 500;
    e3.seven = 500;
    e3.eight = 500;
    e3.nine = 500;
    e3.colon = 333;
    e3.semicolon = 333;
    e3.less = 570;
    e3.equal = 570;
    e3.greater = 570;
    e3.question = 500;
    e3.at = 832;
    e3.A = 667;
    e3.B = 667;
    e3.C = 667;
    e3.D = 722;
    e3.E = 667;
    e3.F = 667;
    e3.G = 722;
    e3.H = 778;
    e3.I = 389;
    e3.J = 500;
    e3.K = 667;
    e3.L = 611;
    e3.M = 889;
    e3.N = 722;
    e3.O = 722;
    e3.P = 611;
    e3.Q = 722;
    e3.R = 667;
    e3.S = 556;
    e3.T = 611;
    e3.U = 722;
    e3.V = 667;
    e3.W = 889;
    e3.X = 667;
    e3.Y = 611;
    e3.Z = 611;
    e3.bracketleft = 333;
    e3.backslash = 278;
    e3.bracketright = 333;
    e3.asciicircum = 570;
    e3.underscore = 500;
    e3.quoteleft = 333;
    e3.a = 500;
    e3.b = 500;
    e3.c = 444;
    e3.d = 500;
    e3.e = 444;
    e3.f = 333;
    e3.g = 500;
    e3.h = 556;
    e3.i = 278;
    e3.j = 278;
    e3.k = 500;
    e3.l = 278;
    e3.m = 778;
    e3.n = 556;
    e3.o = 500;
    e3.p = 500;
    e3.q = 500;
    e3.r = 389;
    e3.s = 389;
    e3.t = 278;
    e3.u = 556;
    e3.v = 444;
    e3.w = 667;
    e3.x = 500;
    e3.y = 444;
    e3.z = 389;
    e3.braceleft = 348;
    e3.bar = 220;
    e3.braceright = 348;
    e3.asciitilde = 570;
    e3.exclamdown = 389;
    e3.cent = 500;
    e3.sterling = 500;
    e3.fraction = 167;
    e3.yen = 500;
    e3.florin = 500;
    e3.section = 500;
    e3.currency = 500;
    e3.quotesingle = 278;
    e3.quotedblleft = 500;
    e3.guillemotleft = 500;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 556;
    e3.fl = 556;
    e3.endash = 500;
    e3.dagger = 500;
    e3.daggerdbl = 500;
    e3.periodcentered = 250;
    e3.paragraph = 500;
    e3.bullet = 350;
    e3.quotesinglbase = 333;
    e3.quotedblbase = 500;
    e3.quotedblright = 500;
    e3.guillemotright = 500;
    e3.ellipsis = 1e3;
    e3.perthousand = 1e3;
    e3.questiondown = 500;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 1e3;
    e3.AE = 944;
    e3.ordfeminine = 266;
    e3.Lslash = 611;
    e3.Oslash = 722;
    e3.OE = 944;
    e3.ordmasculine = 300;
    e3.ae = 722;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 500;
    e3.oe = 722;
    e3.germandbls = 500;
    e3.Idieresis = 389;
    e3.eacute = 444;
    e3.abreve = 500;
    e3.uhungarumlaut = 556;
    e3.ecaron = 444;
    e3.Ydieresis = 611;
    e3.divide = 570;
    e3.Yacute = 611;
    e3.Acircumflex = 667;
    e3.aacute = 500;
    e3.Ucircumflex = 722;
    e3.yacute = 444;
    e3.scommaaccent = 389;
    e3.ecircumflex = 444;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 500;
    e3.Uacute = 722;
    e3.uogonek = 556;
    e3.Edieresis = 667;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 747;
    e3.Emacron = 667;
    e3.ccaron = 444;
    e3.aring = 500;
    e3.Ncommaaccent = 722;
    e3.lacute = 278;
    e3.agrave = 500;
    e3.Tcommaaccent = 611;
    e3.Cacute = 667;
    e3.atilde = 500;
    e3.Edotaccent = 667;
    e3.scaron = 389;
    e3.scedilla = 389;
    e3.iacute = 278;
    e3.lozenge = 494;
    e3.Rcaron = 667;
    e3.Gcommaaccent = 722;
    e3.ucircumflex = 556;
    e3.acircumflex = 500;
    e3.Amacron = 667;
    e3.rcaron = 389;
    e3.ccedilla = 444;
    e3.Zdotaccent = 611;
    e3.Thorn = 611;
    e3.Omacron = 722;
    e3.Racute = 667;
    e3.Sacute = 556;
    e3.dcaron = 608;
    e3.Umacron = 722;
    e3.uring = 556;
    e3.threesuperior = 300;
    e3.Ograve = 722;
    e3.Agrave = 667;
    e3.Abreve = 667;
    e3.multiply = 570;
    e3.uacute = 556;
    e3.Tcaron = 611;
    e3.partialdiff = 494;
    e3.ydieresis = 444;
    e3.Nacute = 722;
    e3.icircumflex = 278;
    e3.Ecircumflex = 667;
    e3.adieresis = 500;
    e3.edieresis = 444;
    e3.cacute = 444;
    e3.nacute = 556;
    e3.umacron = 556;
    e3.Ncaron = 722;
    e3.Iacute = 389;
    e3.plusminus = 570;
    e3.brokenbar = 220;
    e3.registered = 747;
    e3.Gbreve = 722;
    e3.Idotaccent = 389;
    e3.summation = 600;
    e3.Egrave = 667;
    e3.racute = 389;
    e3.omacron = 500;
    e3.Zacute = 611;
    e3.Zcaron = 611;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 667;
    e3.lcommaaccent = 278;
    e3.tcaron = 366;
    e3.eogonek = 444;
    e3.Uogonek = 722;
    e3.Aacute = 667;
    e3.Adieresis = 667;
    e3.egrave = 444;
    e3.zacute = 389;
    e3.iogonek = 278;
    e3.Oacute = 722;
    e3.oacute = 500;
    e3.amacron = 500;
    e3.sacute = 389;
    e3.idieresis = 278;
    e3.Ocircumflex = 722;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 500;
    e3.twosuperior = 300;
    e3.Odieresis = 722;
    e3.mu = 576;
    e3.igrave = 278;
    e3.ohungarumlaut = 500;
    e3.Eogonek = 667;
    e3.dcroat = 500;
    e3.threequarters = 750;
    e3.Scedilla = 556;
    e3.lcaron = 382;
    e3.Kcommaaccent = 667;
    e3.Lacute = 611;
    e3.trademark = 1e3;
    e3.edotaccent = 444;
    e3.Igrave = 389;
    e3.Imacron = 389;
    e3.Lcaron = 611;
    e3.onehalf = 750;
    e3.lessequal = 549;
    e3.ocircumflex = 500;
    e3.ntilde = 556;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 667;
    e3.emacron = 444;
    e3.gbreve = 500;
    e3.onequarter = 750;
    e3.Scaron = 556;
    e3.Scommaaccent = 556;
    e3.Ohungarumlaut = 722;
    e3.degree = 400;
    e3.ograve = 500;
    e3.Ccaron = 667;
    e3.ugrave = 556;
    e3.radical = 549;
    e3.Dcaron = 722;
    e3.rcommaaccent = 389;
    e3.Ntilde = 722;
    e3.otilde = 500;
    e3.Rcommaaccent = 667;
    e3.Lcommaaccent = 611;
    e3.Atilde = 667;
    e3.Aogonek = 667;
    e3.Aring = 667;
    e3.Otilde = 722;
    e3.zdotaccent = 389;
    e3.Ecaron = 667;
    e3.Iogonek = 389;
    e3.kcommaaccent = 500;
    e3.minus = 606;
    e3.Icircumflex = 389;
    e3.ncaron = 556;
    e3.tcommaaccent = 278;
    e3.logicalnot = 606;
    e3.odieresis = 500;
    e3.udieresis = 556;
    e3.notequal = 549;
    e3.gcommaaccent = 500;
    e3.eth = 500;
    e3.zcaron = 389;
    e3.ncommaaccent = 556;
    e3.onesuperior = 300;
    e3.imacron = 278;
    e3.Euro = 500;
  }));
  e2["Times-Italic"] = getLookupTableFactory((function(e3) {
    e3.space = 250;
    e3.exclam = 333;
    e3.quotedbl = 420;
    e3.numbersign = 500;
    e3.dollar = 500;
    e3.percent = 833;
    e3.ampersand = 778;
    e3.quoteright = 333;
    e3.parenleft = 333;
    e3.parenright = 333;
    e3.asterisk = 500;
    e3.plus = 675;
    e3.comma = 250;
    e3.hyphen = 333;
    e3.period = 250;
    e3.slash = 278;
    e3.zero = 500;
    e3.one = 500;
    e3.two = 500;
    e3.three = 500;
    e3.four = 500;
    e3.five = 500;
    e3.six = 500;
    e3.seven = 500;
    e3.eight = 500;
    e3.nine = 500;
    e3.colon = 333;
    e3.semicolon = 333;
    e3.less = 675;
    e3.equal = 675;
    e3.greater = 675;
    e3.question = 500;
    e3.at = 920;
    e3.A = 611;
    e3.B = 611;
    e3.C = 667;
    e3.D = 722;
    e3.E = 611;
    e3.F = 611;
    e3.G = 722;
    e3.H = 722;
    e3.I = 333;
    e3.J = 444;
    e3.K = 667;
    e3.L = 556;
    e3.M = 833;
    e3.N = 667;
    e3.O = 722;
    e3.P = 611;
    e3.Q = 722;
    e3.R = 611;
    e3.S = 500;
    e3.T = 556;
    e3.U = 722;
    e3.V = 611;
    e3.W = 833;
    e3.X = 611;
    e3.Y = 556;
    e3.Z = 556;
    e3.bracketleft = 389;
    e3.backslash = 278;
    e3.bracketright = 389;
    e3.asciicircum = 422;
    e3.underscore = 500;
    e3.quoteleft = 333;
    e3.a = 500;
    e3.b = 500;
    e3.c = 444;
    e3.d = 500;
    e3.e = 444;
    e3.f = 278;
    e3.g = 500;
    e3.h = 500;
    e3.i = 278;
    e3.j = 278;
    e3.k = 444;
    e3.l = 278;
    e3.m = 722;
    e3.n = 500;
    e3.o = 500;
    e3.p = 500;
    e3.q = 500;
    e3.r = 389;
    e3.s = 389;
    e3.t = 278;
    e3.u = 500;
    e3.v = 444;
    e3.w = 667;
    e3.x = 444;
    e3.y = 444;
    e3.z = 389;
    e3.braceleft = 400;
    e3.bar = 275;
    e3.braceright = 400;
    e3.asciitilde = 541;
    e3.exclamdown = 389;
    e3.cent = 500;
    e3.sterling = 500;
    e3.fraction = 167;
    e3.yen = 500;
    e3.florin = 500;
    e3.section = 500;
    e3.currency = 500;
    e3.quotesingle = 214;
    e3.quotedblleft = 556;
    e3.guillemotleft = 500;
    e3.guilsinglleft = 333;
    e3.guilsinglright = 333;
    e3.fi = 500;
    e3.fl = 500;
    e3.endash = 500;
    e3.dagger = 500;
    e3.daggerdbl = 500;
    e3.periodcentered = 250;
    e3.paragraph = 523;
    e3.bullet = 350;
    e3.quotesinglbase = 333;
    e3.quotedblbase = 556;
    e3.quotedblright = 556;
    e3.guillemotright = 500;
    e3.ellipsis = 889;
    e3.perthousand = 1e3;
    e3.questiondown = 500;
    e3.grave = 333;
    e3.acute = 333;
    e3.circumflex = 333;
    e3.tilde = 333;
    e3.macron = 333;
    e3.breve = 333;
    e3.dotaccent = 333;
    e3.dieresis = 333;
    e3.ring = 333;
    e3.cedilla = 333;
    e3.hungarumlaut = 333;
    e3.ogonek = 333;
    e3.caron = 333;
    e3.emdash = 889;
    e3.AE = 889;
    e3.ordfeminine = 276;
    e3.Lslash = 556;
    e3.Oslash = 722;
    e3.OE = 944;
    e3.ordmasculine = 310;
    e3.ae = 667;
    e3.dotlessi = 278;
    e3.lslash = 278;
    e3.oslash = 500;
    e3.oe = 667;
    e3.germandbls = 500;
    e3.Idieresis = 333;
    e3.eacute = 444;
    e3.abreve = 500;
    e3.uhungarumlaut = 500;
    e3.ecaron = 444;
    e3.Ydieresis = 556;
    e3.divide = 675;
    e3.Yacute = 556;
    e3.Acircumflex = 611;
    e3.aacute = 500;
    e3.Ucircumflex = 722;
    e3.yacute = 444;
    e3.scommaaccent = 389;
    e3.ecircumflex = 444;
    e3.Uring = 722;
    e3.Udieresis = 722;
    e3.aogonek = 500;
    e3.Uacute = 722;
    e3.uogonek = 500;
    e3.Edieresis = 611;
    e3.Dcroat = 722;
    e3.commaaccent = 250;
    e3.copyright = 760;
    e3.Emacron = 611;
    e3.ccaron = 444;
    e3.aring = 500;
    e3.Ncommaaccent = 667;
    e3.lacute = 278;
    e3.agrave = 500;
    e3.Tcommaaccent = 556;
    e3.Cacute = 667;
    e3.atilde = 500;
    e3.Edotaccent = 611;
    e3.scaron = 389;
    e3.scedilla = 389;
    e3.iacute = 278;
    e3.lozenge = 471;
    e3.Rcaron = 611;
    e3.Gcommaaccent = 722;
    e3.ucircumflex = 500;
    e3.acircumflex = 500;
    e3.Amacron = 611;
    e3.rcaron = 389;
    e3.ccedilla = 444;
    e3.Zdotaccent = 556;
    e3.Thorn = 611;
    e3.Omacron = 722;
    e3.Racute = 611;
    e3.Sacute = 500;
    e3.dcaron = 544;
    e3.Umacron = 722;
    e3.uring = 500;
    e3.threesuperior = 300;
    e3.Ograve = 722;
    e3.Agrave = 611;
    e3.Abreve = 611;
    e3.multiply = 675;
    e3.uacute = 500;
    e3.Tcaron = 556;
    e3.partialdiff = 476;
    e3.ydieresis = 444;
    e3.Nacute = 667;
    e3.icircumflex = 278;
    e3.Ecircumflex = 611;
    e3.adieresis = 500;
    e3.edieresis = 444;
    e3.cacute = 444;
    e3.nacute = 500;
    e3.umacron = 500;
    e3.Ncaron = 667;
    e3.Iacute = 333;
    e3.plusminus = 675;
    e3.brokenbar = 275;
    e3.registered = 760;
    e3.Gbreve = 722;
    e3.Idotaccent = 333;
    e3.summation = 600;
    e3.Egrave = 611;
    e3.racute = 389;
    e3.omacron = 500;
    e3.Zacute = 556;
    e3.Zcaron = 556;
    e3.greaterequal = 549;
    e3.Eth = 722;
    e3.Ccedilla = 667;
    e3.lcommaaccent = 278;
    e3.tcaron = 300;
    e3.eogonek = 444;
    e3.Uogonek = 722;
    e3.Aacute = 611;
    e3.Adieresis = 611;
    e3.egrave = 444;
    e3.zacute = 389;
    e3.iogonek = 278;
    e3.Oacute = 722;
    e3.oacute = 500;
    e3.amacron = 500;
    e3.sacute = 389;
    e3.idieresis = 278;
    e3.Ocircumflex = 722;
    e3.Ugrave = 722;
    e3.Delta = 612;
    e3.thorn = 500;
    e3.twosuperior = 300;
    e3.Odieresis = 722;
    e3.mu = 500;
    e3.igrave = 278;
    e3.ohungarumlaut = 500;
    e3.Eogonek = 611;
    e3.dcroat = 500;
    e3.threequarters = 750;
    e3.Scedilla = 500;
    e3.lcaron = 300;
    e3.Kcommaaccent = 667;
    e3.Lacute = 556;
    e3.trademark = 980;
    e3.edotaccent = 444;
    e3.Igrave = 333;
    e3.Imacron = 333;
    e3.Lcaron = 611;
    e3.onehalf = 750;
    e3.lessequal = 549;
    e3.ocircumflex = 500;
    e3.ntilde = 500;
    e3.Uhungarumlaut = 722;
    e3.Eacute = 611;
    e3.emacron = 444;
    e3.gbreve = 500;
    e3.onequarter = 750;
    e3.Scaron = 500;
    e3.Scommaaccent = 500;
    e3.Ohungarumlaut = 722;
    e3.degree = 400;
    e3.ograve = 500;
    e3.Ccaron = 667;
    e3.ugrave = 500;
    e3.radical = 453;
    e3.Dcaron = 722;
    e3.rcommaaccent = 389;
    e3.Ntilde = 667;
    e3.otilde = 500;
    e3.Rcommaaccent = 611;
    e3.Lcommaaccent = 556;
    e3.Atilde = 611;
    e3.Aogonek = 611;
    e3.Aring = 611;
    e3.Otilde = 722;
    e3.zdotaccent = 389;
    e3.Ecaron = 611;
    e3.Iogonek = 333;
    e3.kcommaaccent = 444;
    e3.minus = 675;
    e3.Icircumflex = 333;
    e3.ncaron = 500;
    e3.tcommaaccent = 278;
    e3.logicalnot = 675;
    e3.odieresis = 500;
    e3.udieresis = 500;
    e3.notequal = 549;
    e3.gcommaaccent = 500;
    e3.eth = 500;
    e3.zcaron = 389;
    e3.ncommaaccent = 500;
    e3.onesuperior = 300;
    e3.imacron = 278;
    e3.Euro = 500;
  }));
  e2.ZapfDingbats = getLookupTableFactory((function(e3) {
    e3.space = 278;
    e3.a1 = 974;
    e3.a2 = 961;
    e3.a202 = 974;
    e3.a3 = 980;
    e3.a4 = 719;
    e3.a5 = 789;
    e3.a119 = 790;
    e3.a118 = 791;
    e3.a117 = 690;
    e3.a11 = 960;
    e3.a12 = 939;
    e3.a13 = 549;
    e3.a14 = 855;
    e3.a15 = 911;
    e3.a16 = 933;
    e3.a105 = 911;
    e3.a17 = 945;
    e3.a18 = 974;
    e3.a19 = 755;
    e3.a20 = 846;
    e3.a21 = 762;
    e3.a22 = 761;
    e3.a23 = 571;
    e3.a24 = 677;
    e3.a25 = 763;
    e3.a26 = 760;
    e3.a27 = 759;
    e3.a28 = 754;
    e3.a6 = 494;
    e3.a7 = 552;
    e3.a8 = 537;
    e3.a9 = 577;
    e3.a10 = 692;
    e3.a29 = 786;
    e3.a30 = 788;
    e3.a31 = 788;
    e3.a32 = 790;
    e3.a33 = 793;
    e3.a34 = 794;
    e3.a35 = 816;
    e3.a36 = 823;
    e3.a37 = 789;
    e3.a38 = 841;
    e3.a39 = 823;
    e3.a40 = 833;
    e3.a41 = 816;
    e3.a42 = 831;
    e3.a43 = 923;
    e3.a44 = 744;
    e3.a45 = 723;
    e3.a46 = 749;
    e3.a47 = 790;
    e3.a48 = 792;
    e3.a49 = 695;
    e3.a50 = 776;
    e3.a51 = 768;
    e3.a52 = 792;
    e3.a53 = 759;
    e3.a54 = 707;
    e3.a55 = 708;
    e3.a56 = 682;
    e3.a57 = 701;
    e3.a58 = 826;
    e3.a59 = 815;
    e3.a60 = 789;
    e3.a61 = 789;
    e3.a62 = 707;
    e3.a63 = 687;
    e3.a64 = 696;
    e3.a65 = 689;
    e3.a66 = 786;
    e3.a67 = 787;
    e3.a68 = 713;
    e3.a69 = 791;
    e3.a70 = 785;
    e3.a71 = 791;
    e3.a72 = 873;
    e3.a73 = 761;
    e3.a74 = 762;
    e3.a203 = 762;
    e3.a75 = 759;
    e3.a204 = 759;
    e3.a76 = 892;
    e3.a77 = 892;
    e3.a78 = 788;
    e3.a79 = 784;
    e3.a81 = 438;
    e3.a82 = 138;
    e3.a83 = 277;
    e3.a84 = 415;
    e3.a97 = 392;
    e3.a98 = 392;
    e3.a99 = 668;
    e3.a100 = 668;
    e3.a89 = 390;
    e3.a90 = 390;
    e3.a93 = 317;
    e3.a94 = 317;
    e3.a91 = 276;
    e3.a92 = 276;
    e3.a205 = 509;
    e3.a85 = 509;
    e3.a206 = 410;
    e3.a86 = 410;
    e3.a87 = 234;
    e3.a88 = 234;
    e3.a95 = 334;
    e3.a96 = 334;
    e3.a101 = 732;
    e3.a102 = 544;
    e3.a103 = 544;
    e3.a104 = 910;
    e3.a106 = 667;
    e3.a107 = 760;
    e3.a108 = 760;
    e3.a112 = 776;
    e3.a111 = 595;
    e3.a110 = 694;
    e3.a109 = 626;
    e3.a120 = 788;
    e3.a121 = 788;
    e3.a122 = 788;
    e3.a123 = 788;
    e3.a124 = 788;
    e3.a125 = 788;
    e3.a126 = 788;
    e3.a127 = 788;
    e3.a128 = 788;
    e3.a129 = 788;
    e3.a130 = 788;
    e3.a131 = 788;
    e3.a132 = 788;
    e3.a133 = 788;
    e3.a134 = 788;
    e3.a135 = 788;
    e3.a136 = 788;
    e3.a137 = 788;
    e3.a138 = 788;
    e3.a139 = 788;
    e3.a140 = 788;
    e3.a141 = 788;
    e3.a142 = 788;
    e3.a143 = 788;
    e3.a144 = 788;
    e3.a145 = 788;
    e3.a146 = 788;
    e3.a147 = 788;
    e3.a148 = 788;
    e3.a149 = 788;
    e3.a150 = 788;
    e3.a151 = 788;
    e3.a152 = 788;
    e3.a153 = 788;
    e3.a154 = 788;
    e3.a155 = 788;
    e3.a156 = 788;
    e3.a157 = 788;
    e3.a158 = 788;
    e3.a159 = 788;
    e3.a160 = 894;
    e3.a161 = 838;
    e3.a163 = 1016;
    e3.a164 = 458;
    e3.a196 = 748;
    e3.a165 = 924;
    e3.a192 = 748;
    e3.a166 = 918;
    e3.a167 = 927;
    e3.a168 = 928;
    e3.a169 = 928;
    e3.a170 = 834;
    e3.a171 = 873;
    e3.a172 = 828;
    e3.a173 = 924;
    e3.a162 = 924;
    e3.a174 = 917;
    e3.a175 = 930;
    e3.a176 = 931;
    e3.a177 = 463;
    e3.a178 = 883;
    e3.a179 = 836;
    e3.a193 = 836;
    e3.a180 = 867;
    e3.a199 = 867;
    e3.a181 = 696;
    e3.a200 = 696;
    e3.a182 = 874;
    e3.a201 = 874;
    e3.a183 = 760;
    e3.a184 = 946;
    e3.a197 = 771;
    e3.a185 = 865;
    e3.a194 = 771;
    e3.a198 = 888;
    e3.a186 = 967;
    e3.a195 = 888;
    e3.a187 = 831;
    e3.a188 = 873;
    e3.a189 = 927;
    e3.a190 = 970;
    e3.a191 = 918;
  }));
}));
var ni = getLookupTableFactory((function(e2) {
  e2.Courier = { ascent: 629, descent: -157, capHeight: 562, xHeight: -426 };
  e2["Courier-Bold"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 439 };
  e2["Courier-Oblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 };
  e2["Courier-BoldOblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 };
  e2.Helvetica = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 };
  e2["Helvetica-Bold"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 };
  e2["Helvetica-Oblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 };
  e2["Helvetica-BoldOblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 };
  e2["Times-Roman"] = { ascent: 683, descent: -217, capHeight: 662, xHeight: 450 };
  e2["Times-Bold"] = { ascent: 683, descent: -217, capHeight: 676, xHeight: 461 };
  e2["Times-Italic"] = { ascent: 683, descent: -217, capHeight: 653, xHeight: 441 };
  e2["Times-BoldItalic"] = { ascent: 683, descent: -217, capHeight: 669, xHeight: 462 };
  e2.Symbol = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
  e2.ZapfDingbats = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
}));
var GlyfTable = class {
  constructor({ glyfTable: e2, isGlyphLocationsLong: t2, locaTable: a2, numGlyphs: r2 }) {
    this.glyphs = [];
    const i2 = new DataView(a2.buffer, a2.byteOffset, a2.byteLength), n2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength), s2 = t2 ? 4 : 2;
    let o2 = t2 ? i2.getUint32(0) : 2 * i2.getUint16(0), c2 = 0;
    for (let e3 = 0; e3 < r2; e3++) {
      c2 += s2;
      const e4 = t2 ? i2.getUint32(c2) : 2 * i2.getUint16(c2);
      if (e4 === o2) {
        this.glyphs.push(new Glyph({}));
        continue;
      }
      const a3 = Glyph.parse(o2, n2);
      this.glyphs.push(a3);
      o2 = e4;
    }
  }
  getSize() {
    return Math.sumPrecise(this.glyphs.map(((e2) => e2.getSize() + 3 & -4)));
  }
  write() {
    const e2 = this.getSize(), t2 = new DataView(new ArrayBuffer(e2)), a2 = e2 > 131070, r2 = a2 ? 4 : 2, i2 = new DataView(new ArrayBuffer((this.glyphs.length + 1) * r2));
    a2 ? i2.setUint32(0, 0) : i2.setUint16(0, 0);
    let n2 = 0, s2 = 0;
    for (const e3 of this.glyphs) {
      n2 += e3.write(n2, t2);
      n2 = n2 + 3 & -4;
      s2 += r2;
      a2 ? i2.setUint32(s2, n2) : i2.setUint16(s2, n2 >> 1);
    }
    return { isLocationLong: a2, loca: new Uint8Array(i2.buffer), glyf: new Uint8Array(t2.buffer) };
  }
  scale(e2) {
    for (let t2 = 0, a2 = this.glyphs.length; t2 < a2; t2++) this.glyphs[t2].scale(e2[t2]);
  }
};
var Glyph = class _Glyph {
  constructor({ header: e2 = null, simple: t2 = null, composites: a2 = null }) {
    this.header = e2;
    this.simple = t2;
    this.composites = a2;
  }
  static parse(e2, t2) {
    const [a2, r2] = GlyphHeader.parse(e2, t2);
    e2 += a2;
    if (r2.numberOfContours < 0) {
      const a3 = [];
      for (; ; ) {
        const [r3, i3] = CompositeGlyph.parse(e2, t2);
        e2 += r3;
        a3.push(i3);
        if (!(32 & i3.flags)) break;
      }
      return new _Glyph({ header: r2, composites: a3 });
    }
    const i2 = SimpleGlyph.parse(e2, t2, r2.numberOfContours);
    return new _Glyph({ header: r2, simple: i2 });
  }
  getSize() {
    if (!this.header) return 0;
    const e2 = this.simple ? this.simple.getSize() : Math.sumPrecise(this.composites.map(((e3) => e3.getSize())));
    return this.header.getSize() + e2;
  }
  write(e2, t2) {
    if (!this.header) return 0;
    const a2 = e2;
    e2 += this.header.write(e2, t2);
    if (this.simple) e2 += this.simple.write(e2, t2);
    else for (const a3 of this.composites) e2 += a3.write(e2, t2);
    return e2 - a2;
  }
  scale(e2) {
    if (!this.header) return;
    const t2 = (this.header.xMin + this.header.xMax) / 2;
    this.header.scale(t2, e2);
    if (this.simple) this.simple.scale(t2, e2);
    else for (const a2 of this.composites) a2.scale(t2, e2);
  }
};
var GlyphHeader = class _GlyphHeader {
  constructor({ numberOfContours: e2, xMin: t2, yMin: a2, xMax: r2, yMax: i2 }) {
    this.numberOfContours = e2;
    this.xMin = t2;
    this.yMin = a2;
    this.xMax = r2;
    this.yMax = i2;
  }
  static parse(e2, t2) {
    return [10, new _GlyphHeader({ numberOfContours: t2.getInt16(e2), xMin: t2.getInt16(e2 + 2), yMin: t2.getInt16(e2 + 4), xMax: t2.getInt16(e2 + 6), yMax: t2.getInt16(e2 + 8) })];
  }
  getSize() {
    return 10;
  }
  write(e2, t2) {
    t2.setInt16(e2, this.numberOfContours);
    t2.setInt16(e2 + 2, this.xMin);
    t2.setInt16(e2 + 4, this.yMin);
    t2.setInt16(e2 + 6, this.xMax);
    t2.setInt16(e2 + 8, this.yMax);
    return 10;
  }
  scale(e2, t2) {
    this.xMin = Math.round(e2 + (this.xMin - e2) * t2);
    this.xMax = Math.round(e2 + (this.xMax - e2) * t2);
  }
};
var Contour = class {
  constructor({ flags: e2, xCoordinates: t2, yCoordinates: a2 }) {
    this.xCoordinates = t2;
    this.yCoordinates = a2;
    this.flags = e2;
  }
};
var SimpleGlyph = class _SimpleGlyph {
  constructor({ contours: e2, instructions: t2 }) {
    this.contours = e2;
    this.instructions = t2;
  }
  static parse(e2, t2, a2) {
    const r2 = [];
    for (let i3 = 0; i3 < a2; i3++) {
      const a3 = t2.getUint16(e2);
      e2 += 2;
      r2.push(a3);
    }
    const i2 = r2[a2 - 1] + 1, n2 = t2.getUint16(e2);
    e2 += 2;
    const s2 = new Uint8Array(t2).slice(e2, e2 + n2);
    e2 += n2;
    const o2 = [];
    for (let a3 = 0; a3 < i2; e2++, a3++) {
      let r3 = t2.getUint8(e2);
      o2.push(r3);
      if (8 & r3) {
        const i3 = t2.getUint8(++e2);
        r3 ^= 8;
        for (let e3 = 0; e3 < i3; e3++) o2.push(r3);
        a3 += i3;
      }
    }
    const c2 = [];
    let l2 = [], h2 = [], u2 = [];
    const d2 = [];
    let f2 = 0, g2 = 0;
    for (let a3 = 0; a3 < i2; a3++) {
      const i3 = o2[a3];
      if (2 & i3) {
        const a4 = t2.getUint8(e2++);
        g2 += 16 & i3 ? a4 : -a4;
        l2.push(g2);
      } else if (16 & i3) l2.push(g2);
      else {
        g2 += t2.getInt16(e2);
        e2 += 2;
        l2.push(g2);
      }
      if (r2[f2] === a3) {
        f2++;
        c2.push(l2);
        l2 = [];
      }
    }
    g2 = 0;
    f2 = 0;
    for (let a3 = 0; a3 < i2; a3++) {
      const i3 = o2[a3];
      if (4 & i3) {
        const a4 = t2.getUint8(e2++);
        g2 += 32 & i3 ? a4 : -a4;
        h2.push(g2);
      } else if (32 & i3) h2.push(g2);
      else {
        g2 += t2.getInt16(e2);
        e2 += 2;
        h2.push(g2);
      }
      u2.push(1 & i3 | 64 & i3);
      if (r2[f2] === a3) {
        l2 = c2[f2];
        f2++;
        d2.push(new Contour({ flags: u2, xCoordinates: l2, yCoordinates: h2 }));
        h2 = [];
        u2 = [];
      }
    }
    return new _SimpleGlyph({ contours: d2, instructions: s2 });
  }
  getSize() {
    let e2 = 2 * this.contours.length + 2 + this.instructions.length, t2 = 0, a2 = 0;
    for (const r2 of this.contours) {
      e2 += r2.flags.length;
      for (let i2 = 0, n2 = r2.xCoordinates.length; i2 < n2; i2++) {
        const n3 = r2.xCoordinates[i2], s2 = r2.yCoordinates[i2];
        let o2 = Math.abs(n3 - t2);
        o2 > 255 ? e2 += 2 : o2 > 0 && (e2 += 1);
        t2 = n3;
        o2 = Math.abs(s2 - a2);
        o2 > 255 ? e2 += 2 : o2 > 0 && (e2 += 1);
        a2 = s2;
      }
    }
    return e2;
  }
  write(e2, t2) {
    const a2 = e2, r2 = [], i2 = [], n2 = [];
    let s2 = 0, o2 = 0;
    for (const a3 of this.contours) {
      for (let e3 = 0, t3 = a3.xCoordinates.length; e3 < t3; e3++) {
        let t4 = a3.flags[e3];
        const c2 = a3.xCoordinates[e3];
        let l2 = c2 - s2;
        if (0 === l2) {
          t4 |= 16;
          r2.push(0);
        } else {
          const e4 = Math.abs(l2);
          if (e4 <= 255) {
            t4 |= l2 >= 0 ? 18 : 2;
            r2.push(e4);
          } else r2.push(l2);
        }
        s2 = c2;
        const h2 = a3.yCoordinates[e3];
        l2 = h2 - o2;
        if (0 === l2) {
          t4 |= 32;
          i2.push(0);
        } else {
          const e4 = Math.abs(l2);
          if (e4 <= 255) {
            t4 |= l2 >= 0 ? 36 : 4;
            i2.push(e4);
          } else i2.push(l2);
        }
        o2 = h2;
        n2.push(t4);
      }
      t2.setUint16(e2, r2.length - 1);
      e2 += 2;
    }
    t2.setUint16(e2, this.instructions.length);
    e2 += 2;
    if (this.instructions.length) {
      new Uint8Array(t2.buffer, 0, t2.buffer.byteLength).set(this.instructions, e2);
      e2 += this.instructions.length;
    }
    for (const a3 of n2) t2.setUint8(e2++, a3);
    for (let a3 = 0, i3 = r2.length; a3 < i3; a3++) {
      const i4 = r2[a3], s3 = n2[a3];
      if (2 & s3) t2.setUint8(e2++, i4);
      else if (!(16 & s3)) {
        t2.setInt16(e2, i4);
        e2 += 2;
      }
    }
    for (let a3 = 0, r3 = i2.length; a3 < r3; a3++) {
      const r4 = i2[a3], s3 = n2[a3];
      if (4 & s3) t2.setUint8(e2++, r4);
      else if (!(32 & s3)) {
        t2.setInt16(e2, r4);
        e2 += 2;
      }
    }
    return e2 - a2;
  }
  scale(e2, t2) {
    for (const a2 of this.contours) if (0 !== a2.xCoordinates.length) for (let r2 = 0, i2 = a2.xCoordinates.length; r2 < i2; r2++) a2.xCoordinates[r2] = Math.round(e2 + (a2.xCoordinates[r2] - e2) * t2);
  }
};
var CompositeGlyph = class _CompositeGlyph {
  constructor({ flags: e2, glyphIndex: t2, argument1: a2, argument2: r2, transf: i2, instructions: n2 }) {
    this.flags = e2;
    this.glyphIndex = t2;
    this.argument1 = a2;
    this.argument2 = r2;
    this.transf = i2;
    this.instructions = n2;
  }
  static parse(e2, t2) {
    const a2 = e2, r2 = [];
    let i2 = t2.getUint16(e2);
    const n2 = t2.getUint16(e2 + 2);
    e2 += 4;
    let s2, o2;
    if (1 & i2) {
      if (2 & i2) {
        s2 = t2.getInt16(e2);
        o2 = t2.getInt16(e2 + 2);
      } else {
        s2 = t2.getUint16(e2);
        o2 = t2.getUint16(e2 + 2);
      }
      e2 += 4;
      i2 ^= 1;
    } else {
      if (2 & i2) {
        s2 = t2.getInt8(e2);
        o2 = t2.getInt8(e2 + 1);
      } else {
        s2 = t2.getUint8(e2);
        o2 = t2.getUint8(e2 + 1);
      }
      e2 += 2;
    }
    if (8 & i2) {
      r2.push(t2.getUint16(e2));
      e2 += 2;
    } else if (64 & i2) {
      r2.push(t2.getUint16(e2), t2.getUint16(e2 + 2));
      e2 += 4;
    } else if (128 & i2) {
      r2.push(t2.getUint16(e2), t2.getUint16(e2 + 2), t2.getUint16(e2 + 4), t2.getUint16(e2 + 6));
      e2 += 8;
    }
    let c2 = null;
    if (256 & i2) {
      const a3 = t2.getUint16(e2);
      e2 += 2;
      c2 = new Uint8Array(t2).slice(e2, e2 + a3);
      e2 += a3;
    }
    return [e2 - a2, new _CompositeGlyph({ flags: i2, glyphIndex: n2, argument1: s2, argument2: o2, transf: r2, instructions: c2 })];
  }
  getSize() {
    let e2 = 4 + 2 * this.transf.length;
    256 & this.flags && (e2 += 2 + this.instructions.length);
    e2 += 2;
    2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e2 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e2 += 2);
    return e2;
  }
  write(e2, t2) {
    const a2 = e2;
    2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1);
    t2.setUint16(e2, this.flags);
    t2.setUint16(e2 + 2, this.glyphIndex);
    e2 += 4;
    if (1 & this.flags) {
      if (2 & this.flags) {
        t2.setInt16(e2, this.argument1);
        t2.setInt16(e2 + 2, this.argument2);
      } else {
        t2.setUint16(e2, this.argument1);
        t2.setUint16(e2 + 2, this.argument2);
      }
      e2 += 4;
    } else {
      t2.setUint8(e2, this.argument1);
      t2.setUint8(e2 + 1, this.argument2);
      e2 += 2;
    }
    if (256 & this.flags) {
      t2.setUint16(e2, this.instructions.length);
      e2 += 2;
      if (this.instructions.length) {
        new Uint8Array(t2.buffer, 0, t2.buffer.byteLength).set(this.instructions, e2);
        e2 += this.instructions.length;
      }
    }
    return e2 - a2;
  }
  scale(e2, t2) {
  }
};
function writeInt16(e2, t2, a2) {
  e2[t2] = a2 >> 8 & 255;
  e2[t2 + 1] = 255 & a2;
}
function writeInt32(e2, t2, a2) {
  e2[t2] = a2 >> 24 & 255;
  e2[t2 + 1] = a2 >> 16 & 255;
  e2[t2 + 2] = a2 >> 8 & 255;
  e2[t2 + 3] = 255 & a2;
}
function writeData(e2, t2, a2) {
  if (a2 instanceof Uint8Array) e2.set(a2, t2);
  else if ("string" == typeof a2) for (let r2 = 0, i2 = a2.length; r2 < i2; r2++) e2[t2++] = 255 & a2.charCodeAt(r2);
  else for (const r2 of a2) e2[t2++] = 255 & r2;
}
var OpenTypeFileBuilder = class _OpenTypeFileBuilder {
  constructor(e2) {
    this.sfnt = e2;
    this.tables = /* @__PURE__ */ Object.create(null);
  }
  static getSearchParams(e2, t2) {
    let a2 = 1, r2 = 0;
    for (; (a2 ^ e2) > a2; ) {
      a2 <<= 1;
      r2++;
    }
    const i2 = a2 * t2;
    return { range: i2, entry: r2, rangeShift: t2 * e2 - i2 };
  }
  toArray() {
    let e2 = this.sfnt;
    const t2 = this.tables, a2 = Object.keys(t2);
    a2.sort();
    const r2 = a2.length;
    let i2, n2, s2, o2, c2, l2 = 12 + 16 * r2;
    const h2 = [l2];
    for (i2 = 0; i2 < r2; i2++) {
      o2 = t2[a2[i2]];
      l2 += (o2.length + 3 & -4) >>> 0;
      h2.push(l2);
    }
    const u2 = new Uint8Array(l2);
    for (i2 = 0; i2 < r2; i2++) {
      o2 = t2[a2[i2]];
      writeData(u2, h2[i2], o2);
    }
    "true" === e2 && (e2 = string32(65536));
    u2[0] = 255 & e2.charCodeAt(0);
    u2[1] = 255 & e2.charCodeAt(1);
    u2[2] = 255 & e2.charCodeAt(2);
    u2[3] = 255 & e2.charCodeAt(3);
    writeInt16(u2, 4, r2);
    const d2 = _OpenTypeFileBuilder.getSearchParams(r2, 16);
    writeInt16(u2, 6, d2.range);
    writeInt16(u2, 8, d2.entry);
    writeInt16(u2, 10, d2.rangeShift);
    l2 = 12;
    for (i2 = 0; i2 < r2; i2++) {
      c2 = a2[i2];
      u2[l2] = 255 & c2.charCodeAt(0);
      u2[l2 + 1] = 255 & c2.charCodeAt(1);
      u2[l2 + 2] = 255 & c2.charCodeAt(2);
      u2[l2 + 3] = 255 & c2.charCodeAt(3);
      let e3 = 0;
      for (n2 = h2[i2], s2 = h2[i2 + 1]; n2 < s2; n2 += 4) {
        e3 = e3 + readUint32(u2, n2) >>> 0;
      }
      writeInt32(u2, l2 + 4, e3);
      writeInt32(u2, l2 + 8, h2[i2]);
      writeInt32(u2, l2 + 12, t2[c2].length);
      l2 += 16;
    }
    return u2;
  }
  addTable(e2, t2) {
    if (e2 in this.tables) throw new Error("Table " + e2 + " already exists");
    this.tables[e2] = t2;
  }
};
var si = [4];
var oi = [5];
var ci = [6];
var li = [7];
var hi = [8];
var ui = [12, 35];
var di = [14];
var fi = [21];
var gi = [22];
var pi = [30];
var mi = [31];
var Type1CharString = class {
  constructor() {
    this.width = 0;
    this.lsb = 0;
    this.flexing = false;
    this.output = [];
    this.stack = [];
  }
  convert(e2, t2, a2) {
    const r2 = e2.length;
    let i2, n2, s2, o2 = false;
    for (let c2 = 0; c2 < r2; c2++) {
      let r3 = e2[c2];
      if (r3 < 32) {
        12 === r3 && (r3 = (r3 << 8) + e2[++c2]);
        switch (r3) {
          case 1:
          case 3:
          case 9:
          case 3072:
          case 3073:
          case 3074:
          case 3105:
            this.stack = [];
            break;
          case 4:
            if (this.flexing) {
              if (this.stack.length < 1) {
                o2 = true;
                break;
              }
              const e4 = this.stack.pop();
              this.stack.push(0, e4);
              break;
            }
            o2 = this.executeCommand(1, si);
            break;
          case 5:
            o2 = this.executeCommand(2, oi);
            break;
          case 6:
            o2 = this.executeCommand(1, ci);
            break;
          case 7:
            o2 = this.executeCommand(1, li);
            break;
          case 8:
            o2 = this.executeCommand(6, hi);
            break;
          case 10:
            if (this.stack.length < 1) {
              o2 = true;
              break;
            }
            s2 = this.stack.pop();
            if (!t2[s2]) {
              o2 = true;
              break;
            }
            o2 = this.convert(t2[s2], t2, a2);
            break;
          case 11:
            return o2;
          case 13:
            if (this.stack.length < 2) {
              o2 = true;
              break;
            }
            i2 = this.stack.pop();
            n2 = this.stack.pop();
            this.lsb = n2;
            this.width = i2;
            this.stack.push(i2, n2);
            o2 = this.executeCommand(2, gi);
            break;
          case 14:
            this.output.push(di[0]);
            break;
          case 21:
            if (this.flexing) break;
            o2 = this.executeCommand(2, fi);
            break;
          case 22:
            if (this.flexing) {
              this.stack.push(0);
              break;
            }
            o2 = this.executeCommand(1, gi);
            break;
          case 30:
            o2 = this.executeCommand(4, pi);
            break;
          case 31:
            o2 = this.executeCommand(4, mi);
            break;
          case 3078:
            if (a2) {
              const e4 = this.stack.at(-5);
              this.seac = this.stack.splice(-4, 4);
              this.seac[0] += this.lsb - e4;
              o2 = this.executeCommand(0, di);
            } else o2 = this.executeCommand(4, di);
            break;
          case 3079:
            if (this.stack.length < 4) {
              o2 = true;
              break;
            }
            this.stack.pop();
            i2 = this.stack.pop();
            const e3 = this.stack.pop();
            n2 = this.stack.pop();
            this.lsb = n2;
            this.width = i2;
            this.stack.push(i2, n2, e3);
            o2 = this.executeCommand(3, fi);
            break;
          case 3084:
            if (this.stack.length < 2) {
              o2 = true;
              break;
            }
            const c3 = this.stack.pop(), l2 = this.stack.pop();
            this.stack.push(l2 / c3);
            break;
          case 3088:
            if (this.stack.length < 2) {
              o2 = true;
              break;
            }
            s2 = this.stack.pop();
            const h2 = this.stack.pop();
            if (0 === s2 && 3 === h2) {
              const e4 = this.stack.splice(-17, 17);
              this.stack.push(e4[2] + e4[0], e4[3] + e4[1], e4[4], e4[5], e4[6], e4[7], e4[8], e4[9], e4[10], e4[11], e4[12], e4[13], e4[14]);
              o2 = this.executeCommand(13, ui, true);
              this.flexing = false;
              this.stack.push(e4[15], e4[16]);
            } else 1 === s2 && 0 === h2 && (this.flexing = true);
            break;
          case 3089:
            break;
          default:
            warn('Unknown type 1 charstring command of "' + r3 + '"');
        }
        if (o2) break;
      } else {
        r3 <= 246 ? r3 -= 139 : r3 = r3 <= 250 ? 256 * (r3 - 247) + e2[++c2] + 108 : r3 <= 254 ? -256 * (r3 - 251) - e2[++c2] - 108 : (255 & e2[++c2]) << 24 | (255 & e2[++c2]) << 16 | (255 & e2[++c2]) << 8 | 255 & e2[++c2];
        this.stack.push(r3);
      }
    }
    return o2;
  }
  executeCommand(e2, t2, a2) {
    const r2 = this.stack.length;
    if (e2 > r2) return true;
    const i2 = r2 - e2;
    for (let e3 = i2; e3 < r2; e3++) {
      let t3 = this.stack[e3];
      if (Number.isInteger(t3)) this.output.push(28, t3 >> 8 & 255, 255 & t3);
      else {
        t3 = 65536 * t3 | 0;
        this.output.push(255, t3 >> 24 & 255, t3 >> 16 & 255, t3 >> 8 & 255, 255 & t3);
      }
    }
    this.output.push(...t2);
    a2 ? this.stack.splice(i2, e2) : this.stack.length = 0;
    return false;
  }
};
function isHexDigit(e2) {
  return e2 >= 48 && e2 <= 57 || e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102;
}
function decrypt(e2, t2, a2) {
  if (a2 >= e2.length) return new Uint8Array(0);
  let r2, i2, n2 = 0 | t2;
  for (r2 = 0; r2 < a2; r2++) n2 = 52845 * (e2[r2] + n2) + 22719 & 65535;
  const s2 = e2.length - a2, o2 = new Uint8Array(s2);
  for (r2 = a2, i2 = 0; i2 < s2; r2++, i2++) {
    const t3 = e2[r2];
    o2[i2] = t3 ^ n2 >> 8;
    n2 = 52845 * (t3 + n2) + 22719 & 65535;
  }
  return o2;
}
function isSpecial(e2) {
  return 47 === e2 || 91 === e2 || 93 === e2 || 123 === e2 || 125 === e2 || 40 === e2 || 41 === e2;
}
var Type1Parser = class {
  constructor(e2, t2, a2) {
    if (t2) {
      const t3 = e2.getBytes(), a3 = !((isHexDigit(t3[0]) || isWhiteSpace(t3[0])) && isHexDigit(t3[1]) && isHexDigit(t3[2]) && isHexDigit(t3[3]) && isHexDigit(t3[4]) && isHexDigit(t3[5]) && isHexDigit(t3[6]) && isHexDigit(t3[7]));
      e2 = new Stream(a3 ? decrypt(t3, 55665, 4) : (function decryptAscii(e3, t4, a4) {
        let r2 = 0 | t4;
        const i2 = e3.length, n2 = new Uint8Array(i2 >>> 1);
        let s2, o2;
        for (s2 = 0, o2 = 0; s2 < i2; s2++) {
          const t5 = e3[s2];
          if (!isHexDigit(t5)) continue;
          s2++;
          let a5;
          for (; s2 < i2 && !isHexDigit(a5 = e3[s2]); ) s2++;
          if (s2 < i2) {
            const e4 = parseInt(String.fromCharCode(t5, a5), 16);
            n2[o2++] = e4 ^ r2 >> 8;
            r2 = 52845 * (e4 + r2) + 22719 & 65535;
          }
        }
        return n2.slice(a4, o2);
      })(t3, 55665, 4));
    }
    this.seacAnalysisEnabled = !!a2;
    this.stream = e2;
    this.nextChar();
  }
  readNumberArray() {
    this.getToken();
    const e2 = [];
    for (; ; ) {
      const t2 = this.getToken();
      if (null === t2 || "]" === t2 || "}" === t2) break;
      e2.push(parseFloat(t2 || 0));
    }
    return e2;
  }
  readNumber() {
    const e2 = this.getToken();
    return parseFloat(e2 || 0);
  }
  readInt() {
    const e2 = this.getToken();
    return 0 | parseInt(e2 || 0, 10);
  }
  readBoolean() {
    return "true" === this.getToken() ? 1 : 0;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  prevChar() {
    this.stream.skip(-2);
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let e2 = false, t2 = this.currentChar;
    for (; ; ) {
      if (-1 === t2) return null;
      if (e2) 10 !== t2 && 13 !== t2 || (e2 = false);
      else if (37 === t2) e2 = true;
      else if (!isWhiteSpace(t2)) break;
      t2 = this.nextChar();
    }
    if (isSpecial(t2)) {
      this.nextChar();
      return String.fromCharCode(t2);
    }
    let a2 = "";
    do {
      a2 += String.fromCharCode(t2);
      t2 = this.nextChar();
    } while (t2 >= 0 && !isWhiteSpace(t2) && !isSpecial(t2));
    return a2;
  }
  readCharStrings(e2, t2) {
    return -1 === t2 ? e2 : decrypt(e2, 4330, t2);
  }
  extractFontProgram(e2) {
    const t2 = this.stream, a2 = [], r2 = [], i2 = /* @__PURE__ */ Object.create(null);
    i2.lenIV = 4;
    const n2 = { subrs: [], charstrings: [], properties: { privateData: i2 } };
    let s2, o2, c2, l2;
    for (; null !== (s2 = this.getToken()); ) if ("/" === s2) {
      s2 = this.getToken();
      switch (s2) {
        case "CharStrings":
          this.getToken();
          this.getToken();
          this.getToken();
          this.getToken();
          for (; ; ) {
            s2 = this.getToken();
            if (null === s2 || "end" === s2) break;
            if ("/" !== s2) continue;
            const e4 = this.getToken();
            o2 = this.readInt();
            this.getToken();
            c2 = o2 > 0 ? t2.getBytes(o2) : new Uint8Array(0);
            l2 = n2.properties.privateData.lenIV;
            const a3 = this.readCharStrings(c2, l2);
            this.nextChar();
            s2 = this.getToken();
            "noaccess" === s2 ? this.getToken() : "/" === s2 && this.prevChar();
            r2.push({ glyph: e4, encoded: a3 });
          }
          break;
        case "Subrs":
          this.readInt();
          this.getToken();
          for (; "dup" === this.getToken(); ) {
            const e4 = this.readInt();
            o2 = this.readInt();
            this.getToken();
            c2 = o2 > 0 ? t2.getBytes(o2) : new Uint8Array(0);
            l2 = n2.properties.privateData.lenIV;
            const r3 = this.readCharStrings(c2, l2);
            this.nextChar();
            s2 = this.getToken();
            "noaccess" === s2 && this.getToken();
            a2[e4] = r3;
          }
          break;
        case "BlueValues":
        case "OtherBlues":
        case "FamilyBlues":
        case "FamilyOtherBlues":
          const e3 = this.readNumberArray();
          e3.length > 0 && e3.length, 0;
          break;
        case "StemSnapH":
        case "StemSnapV":
          n2.properties.privateData[s2] = this.readNumberArray();
          break;
        case "StdHW":
        case "StdVW":
          n2.properties.privateData[s2] = this.readNumberArray()[0];
          break;
        case "BlueShift":
        case "lenIV":
        case "BlueFuzz":
        case "BlueScale":
        case "LanguageGroup":
          n2.properties.privateData[s2] = this.readNumber();
          break;
        case "ExpansionFactor":
          n2.properties.privateData[s2] = this.readNumber() || 0.06;
          break;
        case "ForceBold":
          n2.properties.privateData[s2] = this.readBoolean();
      }
    }
    for (const { encoded: t3, glyph: i3 } of r2) {
      const r3 = new Type1CharString(), s3 = r3.convert(t3, a2, this.seacAnalysisEnabled);
      let o3 = r3.output;
      s3 && (o3 = [14]);
      const c3 = { glyphName: i3, charstring: o3, width: r3.width, lsb: r3.lsb, seac: r3.seac };
      ".notdef" === i3 ? n2.charstrings.unshift(c3) : n2.charstrings.push(c3);
      if (e2.builtInEncoding) {
        const t4 = e2.builtInEncoding.indexOf(i3);
        t4 > -1 && void 0 === e2.widths[t4] && t4 >= e2.firstChar && t4 <= e2.lastChar && (e2.widths[t4] = r3.width);
      }
    }
    return n2;
  }
  extractFontHeader(e2) {
    let t2;
    for (; null !== (t2 = this.getToken()); ) if ("/" === t2) {
      t2 = this.getToken();
      switch (t2) {
        case "FontMatrix":
          const a2 = this.readNumberArray();
          e2.fontMatrix = a2;
          break;
        case "Encoding":
          const r2 = this.getToken();
          let i2;
          if (/^\d+$/.test(r2)) {
            i2 = [];
            const e3 = 0 | parseInt(r2, 10);
            this.getToken();
            for (let a3 = 0; a3 < e3; a3++) {
              t2 = this.getToken();
              for (; "dup" !== t2 && "def" !== t2; ) {
                t2 = this.getToken();
                if (null === t2) return;
              }
              if ("def" === t2) break;
              const e4 = this.readInt();
              this.getToken();
              const a4 = this.getToken();
              i2[e4] = a4;
              this.getToken();
            }
          } else i2 = getEncoding(r2);
          e2.builtInEncoding = i2;
          break;
        case "FontBBox":
          const n2 = this.readNumberArray();
          e2.ascent = Math.max(n2[3], n2[1]);
          e2.descent = Math.min(n2[1], n2[3]);
          e2.ascentScaled = true;
      }
    }
  }
};
function findBlock(e2, t2, a2) {
  const r2 = e2.length, i2 = t2.length, n2 = r2 - i2;
  let s2 = a2, o2 = false;
  for (; s2 < n2; ) {
    let a3 = 0;
    for (; a3 < i2 && e2[s2 + a3] === t2[a3]; ) a3++;
    if (a3 >= i2) {
      s2 += a3;
      for (; s2 < r2 && isWhiteSpace(e2[s2]); ) s2++;
      o2 = true;
      break;
    }
    s2++;
  }
  return { found: o2, length: s2 };
}
var Type1Font = class {
  constructor(e2, t2, a2) {
    let r2 = a2.length1, i2 = a2.length2, n2 = t2.peekBytes(6);
    const s2 = 128 === n2[0] && 1 === n2[1];
    if (s2) {
      t2.skip(6);
      r2 = n2[5] << 24 | n2[4] << 16 | n2[3] << 8 | n2[2];
    }
    const o2 = (function getHeaderBlock(e3, t3) {
      const a3 = [101, 101, 120, 101, 99], r3 = e3.pos;
      let i3, n3, s3, o3;
      try {
        i3 = e3.getBytes(t3);
        n3 = i3.length;
      } catch {
      }
      if (n3 === t3) {
        s3 = findBlock(i3, a3, t3 - 2 * a3.length);
        if (s3.found && s3.length === t3) return { stream: new Stream(i3), length: t3 };
      }
      warn('Invalid "Length1" property in Type1 font -- trying to recover.');
      e3.pos = r3;
      for (; ; ) {
        s3 = findBlock(e3.peekBytes(2048), a3, 0);
        if (0 === s3.length) break;
        e3.pos += s3.length;
        if (s3.found) {
          o3 = e3.pos - r3;
          break;
        }
      }
      e3.pos = r3;
      if (o3) return { stream: new Stream(e3.getBytes(o3)), length: o3 };
      warn('Unable to recover "Length1" property in Type1 font -- using as is.');
      return { stream: new Stream(e3.getBytes(t3)), length: t3 };
    })(t2, r2);
    new Type1Parser(o2.stream, false, Rr).extractFontHeader(a2);
    if (s2) {
      n2 = t2.getBytes(6);
      i2 = n2[5] << 24 | n2[4] << 16 | n2[3] << 8 | n2[2];
    }
    const c2 = (function getEexecBlock(e3, t3) {
      const a3 = e3.getBytes();
      if (0 === a3.length) throw new FormatError("getEexecBlock - no font program found.");
      return { stream: new Stream(a3), length: a3.length };
    })(t2), l2 = new Type1Parser(c2.stream, true, Rr).extractFontProgram(a2);
    for (const e3 in l2.properties) a2[e3] = l2.properties[e3];
    const h2 = l2.charstrings, u2 = this.getType2Charstrings(h2), d2 = this.getType2Subrs(l2.subrs);
    this.charstrings = h2;
    this.data = this.wrap(e2, u2, this.charstrings, d2, a2);
    this.seacs = this.getSeacs(l2.charstrings);
  }
  get numGlyphs() {
    return this.charstrings.length + 1;
  }
  getCharset() {
    const e2 = [".notdef"];
    for (const { glyphName: t2 } of this.charstrings) e2.push(t2);
    return e2;
  }
  getGlyphMapping(e2) {
    const t2 = this.charstrings;
    if (e2.composite) {
      const a3 = /* @__PURE__ */ Object.create(null);
      for (let r3 = 0, i3 = t2.length; r3 < i3; r3++) {
        a3[e2.cMap.charCodeOf(r3)] = r3 + 1;
      }
      return a3;
    }
    const a2 = [".notdef"];
    let r2, i2;
    for (i2 = 0; i2 < t2.length; i2++) a2.push(t2[i2].glyphName);
    const n2 = e2.builtInEncoding;
    if (n2) {
      r2 = /* @__PURE__ */ Object.create(null);
      for (const e3 in n2) {
        i2 = a2.indexOf(n2[e3]);
        i2 >= 0 && (r2[e3] = i2);
      }
    }
    return type1FontGlyphMapping(e2, r2, a2);
  }
  hasGlyphId(e2) {
    if (e2 < 0 || e2 >= this.numGlyphs) return false;
    if (0 === e2) return true;
    return this.charstrings[e2 - 1].charstring.length > 0;
  }
  getSeacs(e2) {
    const t2 = [];
    for (let a2 = 0, r2 = e2.length; a2 < r2; a2++) {
      const r3 = e2[a2];
      r3.seac && (t2[a2 + 1] = r3.seac);
    }
    return t2;
  }
  getType2Charstrings(e2) {
    const t2 = [];
    for (const a2 of e2) t2.push(a2.charstring);
    return t2;
  }
  getType2Subrs(e2) {
    let t2 = 0;
    const a2 = e2.length;
    t2 = a2 < 1133 ? 107 : a2 < 33769 ? 1131 : 32768;
    const r2 = [];
    let i2;
    for (i2 = 0; i2 < t2; i2++) r2.push([11]);
    for (i2 = 0; i2 < a2; i2++) r2.push(e2[i2]);
    return r2;
  }
  wrap(e2, t2, a2, r2, i2) {
    const n2 = new CFF();
    n2.header = new CFFHeader(1, 0, 4, 4);
    n2.names = [e2];
    const s2 = new CFFTopDict();
    s2.setByName("version", 391);
    s2.setByName("Notice", 392);
    s2.setByName("FullName", 393);
    s2.setByName("FamilyName", 394);
    s2.setByName("Weight", 395);
    s2.setByName("Encoding", null);
    s2.setByName("FontMatrix", i2.fontMatrix);
    s2.setByName("FontBBox", i2.bbox);
    s2.setByName("charset", null);
    s2.setByName("CharStrings", null);
    s2.setByName("Private", null);
    n2.topDict = s2;
    const o2 = new CFFStrings();
    o2.add("Version 0.11");
    o2.add("See original notice");
    o2.add(e2);
    o2.add(e2);
    o2.add("Medium");
    n2.strings = o2;
    n2.globalSubrIndex = new CFFIndex();
    const c2 = t2.length, l2 = [".notdef"];
    let h2, u2;
    for (h2 = 0; h2 < c2; h2++) {
      const e3 = a2[h2].glyphName;
      -1 === Hr.indexOf(e3) && o2.add(e3);
      l2.push(e3);
    }
    n2.charset = new CFFCharset(false, 0, l2);
    const d2 = new CFFIndex();
    d2.add([139, 14]);
    for (h2 = 0; h2 < c2; h2++) d2.add(t2[h2]);
    n2.charStrings = d2;
    const f2 = new CFFPrivateDict();
    f2.setByName("Subrs", null);
    const g2 = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
    for (h2 = 0, u2 = g2.length; h2 < u2; h2++) {
      const e3 = g2[h2];
      if (!(e3 in i2.privateData)) continue;
      const t3 = i2.privateData[e3];
      if (Array.isArray(t3)) for (let e4 = t3.length - 1; e4 > 0; e4--) t3[e4] -= t3[e4 - 1];
      f2.setByName(e3, t3);
    }
    n2.topDict.privateDict = f2;
    const p2 = new CFFIndex();
    for (h2 = 0, u2 = r2.length; h2 < u2; h2++) p2.add(r2[h2]);
    f2.subrsIndex = p2;
    return new CFFCompiler(n2).compile();
  }
};
var bi = [[57344, 63743], [1048576, 1114109]];
var yi = 1e3;
var wi = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "disableFontFace", "fallbackName", "fontExtraProperties", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "systemFontInfo", "vertical"];
var xi = ["cMap", "composite", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "subtype", "toFontChar", "toUnicode", "type", "vmetrics", "widths"];
function adjustWidths(e2) {
  if (!e2.fontMatrix) return;
  if (e2.fontMatrix[0] === t[0]) return;
  const a2 = 1e-3 / e2.fontMatrix[0], r2 = e2.widths;
  for (const e3 in r2) r2[e3] *= a2;
  e2.defaultWidth *= a2;
}
function amendFallbackToUnicode(e2) {
  if (!e2.fallbackToUnicode) return;
  if (e2.toUnicode instanceof IdentityToUnicodeMap) return;
  const t2 = [];
  for (const a2 in e2.fallbackToUnicode) e2.toUnicode.has(a2) || (t2[a2] = e2.fallbackToUnicode[a2]);
  t2.length > 0 && e2.toUnicode.amend(t2);
}
var fonts_Glyph = class {
  constructor(e2, t2, a2, r2, i2, n2, s2, o2, c2) {
    this.originalCharCode = e2;
    this.fontChar = t2;
    this.unicode = a2;
    this.accent = r2;
    this.width = i2;
    this.vmetric = n2;
    this.operatorListId = s2;
    this.isSpace = o2;
    this.isInFont = c2;
  }
  get category() {
    return shadow(this, "category", (function getCharUnicodeCategory(e2) {
      const t2 = Dr.get(e2);
      if (t2) return t2;
      const a2 = e2.match(Mr), r2 = { isWhitespace: !!a2?.[1], isZeroWidthDiacritic: !!a2?.[2], isInvisibleFormatMark: !!a2?.[3] };
      Dr.set(e2, r2);
      return r2;
    })(this.unicode), true);
  }
};
function int16(e2, t2) {
  return (e2 << 8) + t2;
}
function writeSignedInt16(e2, t2, a2) {
  e2[t2 + 1] = a2;
  e2[t2] = a2 >>> 8;
}
function signedInt16(e2, t2) {
  const a2 = (e2 << 8) + t2;
  return 32768 & a2 ? a2 - 65536 : a2;
}
function string16(e2) {
  return String.fromCharCode(e2 >> 8 & 255, 255 & e2);
}
function safeString16(e2) {
  e2 > 32767 ? e2 = 32767 : e2 < -32768 && (e2 = -32768);
  return String.fromCharCode(e2 >> 8 & 255, 255 & e2);
}
function isTrueTypeCollectionFile(e2) {
  return "ttcf" === bytesToString(e2.peekBytes(4));
}
function getFontFileType(e2, { type: t2, subtype: a2, composite: r2 }) {
  let i2, n2;
  if ((function isTrueTypeFile(e3) {
    const t3 = e3.peekBytes(4);
    return 65536 === readUint32(t3, 0) || "true" === bytesToString(t3);
  })(e2) || isTrueTypeCollectionFile(e2)) i2 = r2 ? "CIDFontType2" : "TrueType";
  else if ((function isOpenTypeFile(e3) {
    return "OTTO" === bytesToString(e3.peekBytes(4));
  })(e2)) i2 = r2 ? "CIDFontType2" : "OpenType";
  else if ((function isType1File(e3) {
    const t3 = e3.peekBytes(2);
    return 37 === t3[0] && 33 === t3[1] || 128 === t3[0] && 1 === t3[1];
  })(e2)) i2 = r2 ? "CIDFontType0" : "MMType1" === t2 ? "MMType1" : "Type1";
  else if ((function isCFFFile(e3) {
    const t3 = e3.peekBytes(4);
    return t3[0] >= 1 && t3[3] >= 1 && t3[3] <= 4;
  })(e2)) if (r2) {
    i2 = "CIDFontType0";
    n2 = "CIDFontType0C";
  } else {
    i2 = "MMType1" === t2 ? "MMType1" : "Type1";
    n2 = "Type1C";
  }
  else {
    warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
    i2 = t2;
    n2 = a2;
  }
  return [i2, n2];
}
function applyStandardFontGlyphMap(e2, t2) {
  for (const a2 in t2) e2[+a2] = t2[a2];
}
function buildToFontChar(e2, t2, a2) {
  const r2 = [];
  let i2;
  for (let a3 = 0, n2 = e2.length; a3 < n2; a3++) {
    i2 = getUnicodeForGlyph(e2[a3], t2);
    -1 !== i2 && (r2[a3] = i2);
  }
  for (const e3 in a2) {
    i2 = getUnicodeForGlyph(a2[e3], t2);
    -1 !== i2 && (r2[+e3] = i2);
  }
  return r2;
}
function isMacNameRecord(e2) {
  return 1 === e2.platform && 0 === e2.encoding && 0 === e2.language;
}
function isWinNameRecord(e2) {
  return 3 === e2.platform && 1 === e2.encoding && 1033 === e2.language;
}
function convertCidString(e2, t2, a2 = false) {
  switch (t2.length) {
    case 1:
      return t2.charCodeAt(0);
    case 2:
      return t2.charCodeAt(0) << 8 | t2.charCodeAt(1);
  }
  const r2 = `Unsupported CID string (charCode ${e2}): "${t2}".`;
  if (a2) throw new FormatError(r2);
  warn(r2);
  return t2;
}
function adjustMapping(e2, t2, a2, r2) {
  const i2 = /* @__PURE__ */ Object.create(null), n2 = /* @__PURE__ */ new Map(), s2 = [], o2 = /* @__PURE__ */ new Set();
  let c2 = 0;
  let l2 = bi[c2][0], h2 = bi[c2][1];
  let u2 = null;
  for (const f2 in e2) {
    let g2 = e2[f2];
    if (!t2(g2)) continue;
    if (l2 > h2) {
      c2++;
      if (c2 >= bi.length) {
        warn("Ran out of space in font private use area.");
        break;
      }
      l2 = bi[c2][0];
      h2 = bi[c2][1];
    }
    const p2 = l2++;
    0 === g2 && (g2 = a2);
    let m2 = r2.get(f2);
    if ("string" == typeof m2) if (1 === m2.length) m2 = m2.codePointAt(0);
    else {
      if (!u2) {
        u2 = /* @__PURE__ */ new Map();
        for (let e3 = 64256; e3 <= 64335; e3++) {
          const t3 = String.fromCharCode(e3).normalize("NFKD");
          t3.length > 1 && u2.set(t3, e3);
        }
      }
      m2 = u2.get(m2) || m2.codePointAt(0);
    }
    if (m2 && !(d2 = m2, bi[0][0] <= d2 && d2 <= bi[0][1] || bi[1][0] <= d2 && d2 <= bi[1][1]) && !o2.has(g2)) {
      n2.set(m2, g2);
      o2.add(g2);
    }
    i2[p2] = g2;
    s2[f2] = p2;
  }
  var d2;
  return { toFontChar: s2, charCodeToGlyphId: i2, toUnicodeExtraMap: n2, nextAvailableFontCharCode: l2 };
}
function createCmapTable(e2, t2, a2) {
  const r2 = (function getRanges(e3, t3, a3) {
    const r3 = [];
    for (const t4 in e3) e3[t4] >= a3 || r3.push({ fontCharCode: 0 | t4, glyphId: e3[t4] });
    if (t3) for (const [e4, i4] of t3) i4 >= a3 || r3.push({ fontCharCode: e4, glyphId: i4 });
    0 === r3.length && r3.push({ fontCharCode: 0, glyphId: 0 });
    r3.sort(((e4, t4) => e4.fontCharCode - t4.fontCharCode));
    const i3 = [], n3 = r3.length;
    for (let e4 = 0; e4 < n3; ) {
      const t4 = r3[e4].fontCharCode, a4 = [r3[e4].glyphId];
      ++e4;
      let s3 = t4;
      for (; e4 < n3 && s3 + 1 === r3[e4].fontCharCode; ) {
        a4.push(r3[e4].glyphId);
        ++s3;
        ++e4;
        if (65535 === s3) break;
      }
      i3.push([t4, s3, a4]);
    }
    return i3;
  })(e2, t2, a2), i2 = r2.at(-1)[1] > 65535 ? 2 : 1;
  let n2, s2, o2, c2, l2 = "\0\0" + string16(i2) + "\0\0" + string32(4 + 8 * i2);
  for (n2 = r2.length - 1; n2 >= 0 && !(r2[n2][0] <= 65535); --n2) ;
  const h2 = n2 + 1;
  r2[n2][0] < 65535 && 65535 === r2[n2][1] && (r2[n2][1] = 65534);
  const u2 = r2[n2][1] < 65535 ? 1 : 0, d2 = h2 + u2, f2 = OpenTypeFileBuilder.getSearchParams(d2, 2);
  let g2, p2, m2, b2, y2 = "", w2 = "", x2 = "", S2 = "", k2 = "", C2 = 0;
  for (n2 = 0, s2 = h2; n2 < s2; n2++) {
    g2 = r2[n2];
    p2 = g2[0];
    m2 = g2[1];
    y2 += string16(p2);
    w2 += string16(m2);
    b2 = g2[2];
    let e3 = true;
    for (o2 = 1, c2 = b2.length; o2 < c2; ++o2) if (b2[o2] !== b2[o2 - 1] + 1) {
      e3 = false;
      break;
    }
    if (e3) {
      x2 += string16(b2[0] - p2 & 65535);
      S2 += string16(0);
    } else {
      const e4 = 2 * (d2 - n2) + 2 * C2;
      C2 += m2 - p2 + 1;
      x2 += string16(0);
      S2 += string16(e4);
      for (o2 = 0, c2 = b2.length; o2 < c2; ++o2) k2 += string16(b2[o2]);
    }
  }
  if (u2 > 0) {
    w2 += "ÿÿ";
    y2 += "ÿÿ";
    x2 += "\0";
    S2 += "\0\0";
  }
  const v2 = "\0\0" + string16(2 * d2) + string16(f2.range) + string16(f2.entry) + string16(f2.rangeShift) + w2 + "\0\0" + y2 + x2 + S2 + k2;
  let F2 = "", T2 = "";
  if (i2 > 1) {
    l2 += "\0\0\n" + string32(4 + 8 * i2 + 4 + v2.length);
    F2 = "";
    for (n2 = 0, s2 = r2.length; n2 < s2; n2++) {
      g2 = r2[n2];
      p2 = g2[0];
      b2 = g2[2];
      let e3 = b2[0];
      for (o2 = 1, c2 = b2.length; o2 < c2; ++o2) if (b2[o2] !== b2[o2 - 1] + 1) {
        m2 = g2[0] + o2 - 1;
        F2 += string32(p2) + string32(m2) + string32(e3);
        p2 = m2 + 1;
        e3 = b2[o2];
      }
      F2 += string32(p2) + string32(g2[1]) + string32(e3);
    }
    T2 = "\0\f\0\0" + string32(F2.length + 16) + "\0\0\0\0" + string32(F2.length / 12);
  }
  return l2 + "\0" + string16(v2.length + 4) + v2 + T2 + F2;
}
function createOS2Table(e2, t2, a2) {
  a2 ||= { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 };
  let r2 = 0, i2 = 0, n2 = 0, s2 = 0, o2 = null, c2 = 0, l2 = -1;
  if (t2) {
    for (let e3 in t2) {
      e3 |= 0;
      (o2 > e3 || !o2) && (o2 = e3);
      c2 < e3 && (c2 = e3);
      l2 = getUnicodeRangeFor(e3, l2);
      if (l2 < 32) r2 |= 1 << l2;
      else if (l2 < 64) i2 |= 1 << l2 - 32;
      else if (l2 < 96) n2 |= 1 << l2 - 64;
      else {
        if (!(l2 < 123)) throw new FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
        s2 |= 1 << l2 - 96;
      }
    }
    c2 > 65535 && (c2 = 65535);
  } else {
    o2 = 0;
    c2 = 255;
  }
  const h2 = e2.bbox || [0, 0, 0, 0], u2 = a2.unitsPerEm || (e2.fontMatrix ? 1 / Math.max(...e2.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), d2 = e2.ascentScaled ? 1 : u2 / yi, f2 = a2.ascent || Math.round(d2 * (e2.ascent || h2[3]));
  let g2 = a2.descent || Math.round(d2 * (e2.descent || h2[1]));
  g2 > 0 && e2.descent > 0 && h2[1] < 0 && (g2 = -g2);
  const p2 = a2.yMax || f2, m2 = -a2.yMin || -g2;
  return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(e2.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + string32(r2) + string32(i2) + string32(n2) + string32(s2) + "*21*" + string16(e2.italicAngle ? 1 : 0) + string16(o2 || e2.firstChar) + string16(c2 || e2.lastChar) + string16(f2) + string16(g2) + "\0d" + string16(p2) + string16(m2) + "\0\0\0\0\0\0\0\0" + string16(e2.xHeight) + string16(e2.capHeight) + string16(0) + string16(o2 || e2.firstChar) + "\0";
}
function createPostTable(e2) {
  return "\0\0\0" + string32(Math.floor(65536 * e2.italicAngle)) + "\0\0\0\0" + string32(e2.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function createPostscriptName(e2) {
  return e2.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function createNameTable(e2, t2) {
  t2 || (t2 = [[], []]);
  const a2 = [t2[0][0] || "Original licence", t2[0][1] || e2, t2[0][2] || "Unknown", t2[0][3] || "uniqueID", t2[0][4] || e2, t2[0][5] || "Version 0.11", t2[0][6] || createPostscriptName(e2), t2[0][7] || "Unknown", t2[0][8] || "Unknown", t2[0][9] || "Unknown"], r2 = [];
  let i2, n2, s2, o2, c2;
  for (i2 = 0, n2 = a2.length; i2 < n2; i2++) {
    c2 = t2[1][i2] || a2[i2];
    const e3 = [];
    for (s2 = 0, o2 = c2.length; s2 < o2; s2++) e3.push(string16(c2.charCodeAt(s2)));
    r2.push(e3.join(""));
  }
  const l2 = [a2, r2], h2 = ["\0", "\0"], u2 = ["\0\0", "\0"], d2 = ["\0\0", "	"], f2 = a2.length * h2.length;
  let g2 = "\0\0" + string16(f2) + string16(12 * f2 + 6), p2 = 0;
  for (i2 = 0, n2 = h2.length; i2 < n2; i2++) {
    const e3 = l2[i2];
    for (s2 = 0, o2 = e3.length; s2 < o2; s2++) {
      c2 = e3[s2];
      g2 += h2[i2] + u2[i2] + d2[i2] + string16(s2) + string16(c2.length) + string16(p2);
      p2 += c2.length;
    }
  }
  g2 += a2.join("") + r2.join("");
  return g2;
}
var Font = class {
  constructor(e2, t2, a2, r2) {
    this.name = e2;
    this.psName = null;
    this.mimetype = null;
    this.disableFontFace = r2.disableFontFace;
    this.fontExtraProperties = r2.fontExtraProperties;
    this.loadedName = a2.loadedName;
    this.isType3Font = a2.isType3Font;
    this.missingFile = false;
    this.cssFontInfo = a2.cssFontInfo;
    this._charsCache = /* @__PURE__ */ Object.create(null);
    this._glyphCache = /* @__PURE__ */ Object.create(null);
    let i2 = !!(a2.flags & Er);
    if (!i2 && !a2.isSimulatedFlags) {
      const t3 = e2.replaceAll(/[,_]/g, "-").split("-", 1)[0], a3 = Qr();
      for (const e3 of t3.split("+")) if (a3[e3]) {
        i2 = true;
        break;
      }
    }
    this.isSerifFont = i2;
    this.isSymbolicFont = !!(a2.flags & Pr);
    this.isMonospace = !!(a2.flags & Nr);
    let { type: n2, subtype: s2 } = a2;
    this.type = n2;
    this.subtype = s2;
    this.systemFontInfo = a2.systemFontInfo;
    const o2 = e2.match(/^InvalidPDFjsFont_(.*)_\d+$/);
    this.isInvalidPDFjsFont = !!o2;
    this.isInvalidPDFjsFont ? this.fallbackName = o2[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif";
    if (this.systemFontInfo?.guessFallback) {
      this.systemFontInfo.guessFallback = false;
      this.systemFontInfo.css += `,${this.fallbackName}`;
    }
    this.differences = a2.differences;
    this.widths = a2.widths;
    this.defaultWidth = a2.defaultWidth;
    this.composite = a2.composite;
    this.cMap = a2.cMap;
    this.capHeight = a2.capHeight / yi;
    this.ascent = a2.ascent / yi;
    this.descent = a2.descent / yi;
    this.lineHeight = this.ascent - this.descent;
    this.fontMatrix = a2.fontMatrix;
    this.bbox = a2.bbox;
    this.defaultEncoding = a2.defaultEncoding;
    this.toUnicode = a2.toUnicode;
    this.toFontChar = [];
    if ("Type3" === a2.type) {
      for (let e3 = 0; e3 < 256; e3++) this.toFontChar[e3] = this.differences[e3] || a2.defaultEncoding[e3];
      return;
    }
    this.cidEncoding = a2.cidEncoding || "";
    this.vertical = !!a2.vertical;
    if (this.vertical) {
      this.vmetrics = a2.vmetrics;
      this.defaultVMetrics = a2.defaultVMetrics;
    }
    if (!t2 || t2.isEmpty) {
      t2 && warn('Font file is empty in "' + e2 + '" (' + this.loadedName + ")");
      this.fallbackToSystemFont(a2);
      return;
    }
    [n2, s2] = getFontFileType(t2, a2);
    n2 === this.type && s2 === this.subtype || info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${n2}/${s2}.`);
    let c2;
    try {
      switch (n2) {
        case "MMType1":
          info("MMType1 font (" + e2 + "), falling back to Type1.");
        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          const r3 = "Type1C" === s2 || "CIDFontType0C" === s2 ? new CFFFont(t2, a2) : new Type1Font(e2, t2, a2);
          adjustWidths(a2);
          c2 = this.convert(e2, r3, a2);
          break;
        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype";
          c2 = this.checkAndRepair(e2, t2, a2);
          adjustWidths(a2);
          this.isOpenType && (n2 = "OpenType");
          break;
        default:
          throw new FormatError(`Font ${n2} is not supported`);
      }
    } catch (e3) {
      warn(e3);
      this.fallbackToSystemFont(a2);
      return;
    }
    amendFallbackToUnicode(a2);
    this.data = c2;
    this.type = n2;
    this.subtype = s2;
    this.fontMatrix = a2.fontMatrix;
    this.widths = a2.widths;
    this.defaultWidth = a2.defaultWidth;
    this.toUnicode = a2.toUnicode;
    this.seacMap = a2.seacMap;
  }
  get renderer() {
    return shadow(this, "renderer", FontRendererFactory.create(this, Rr));
  }
  exportData() {
    const e2 = this.fontExtraProperties ? [...wi, ...xi] : wi, t2 = /* @__PURE__ */ Object.create(null);
    for (const a2 of e2) {
      const e3 = this[a2];
      void 0 !== e3 && (t2[a2] = e3);
    }
    return t2;
  }
  fallbackToSystemFont(e2) {
    this.missingFile = true;
    const { name: t2, type: a2 } = this;
    let r2 = normalizeFontName(t2);
    const i2 = Jr(), n2 = Zr(), s2 = !!i2[r2], o2 = !(!n2[r2] || !i2[n2[r2]]);
    r2 = i2[r2] || n2[r2] || r2;
    const c2 = ni()[r2];
    if (c2) {
      isNaN(this.ascent) && (this.ascent = c2.ascent / yi);
      isNaN(this.descent) && (this.descent = c2.descent / yi);
      isNaN(this.capHeight) && (this.capHeight = c2.capHeight / yi);
    }
    this.bold = /bold/gi.test(r2);
    this.italic = /oblique|italic/gi.test(r2);
    this.black = /Black/g.test(t2);
    const l2 = /Narrow/g.test(t2);
    this.remeasure = (!s2 || l2) && Object.keys(this.widths).length > 0;
    if ((s2 || o2) && "CIDFontType2" === a2 && this.cidEncoding.startsWith("Identity-")) {
      const a3 = e2.cidToGidMap, r3 = [];
      applyStandardFontGlyphMap(r3, ti());
      /Arial-?Black/i.test(t2) ? applyStandardFontGlyphMap(r3, ai()) : /Calibri/i.test(t2) && applyStandardFontGlyphMap(r3, ri());
      if (a3) {
        for (const e3 in r3) {
          const t3 = r3[e3];
          void 0 !== a3[t3] && (r3[+e3] = a3[t3]);
        }
        a3.length !== this.toUnicode.length && e2.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach((function(e3, t3) {
          const i3 = r3[e3];
          void 0 === a3[i3] && (r3[+e3] = t3);
        }));
      }
      this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach((function(e3, t3) {
        r3[+e3] = t3;
      }));
      this.toFontChar = r3;
      this.toUnicode = new ToUnicodeMap(r3);
    } else if (/Symbol/i.test(r2)) this.toFontChar = buildToFontChar(Cr, Fr(), this.differences);
    else if (/Dingbats/i.test(r2)) this.toFontChar = buildToFontChar(vr, Ir(), this.differences);
    else if (s2 || o2) {
      const e3 = buildToFontChar(this.defaultEncoding, Fr(), this.differences);
      "CIDFontType2" !== a2 || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach((function(t3, a3) {
        e3[+t3] = a3;
      }));
      this.toFontChar = e3;
    } else {
      const e3 = Fr(), a3 = [];
      this.toUnicode.forEach(((t3, r3) => {
        if (!this.composite) {
          const a4 = getUnicodeForGlyph(this.differences[t3] || this.defaultEncoding[t3], e3);
          -1 !== a4 && (r3 = a4);
        }
        a3[+t3] = r3;
      }));
      this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t2) && applyStandardFontGlyphMap(a3, ti());
      this.toFontChar = a3;
    }
    amendFallbackToUnicode(e2);
    this.loadedName = r2.split("-", 1)[0];
  }
  checkAndRepair(e2, t2, a2) {
    const r2 = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
    function readTables(e3, t3) {
      const a3 = /* @__PURE__ */ Object.create(null);
      a3["OS/2"] = null;
      a3.cmap = null;
      a3.head = null;
      a3.hhea = null;
      a3.hmtx = null;
      a3.maxp = null;
      a3.name = null;
      a3.post = null;
      for (let i3 = 0; i3 < t3; i3++) {
        const t4 = readTableEntry(e3);
        r2.includes(t4.tag) && (0 !== t4.length && (a3[t4.tag] = t4));
      }
      return a3;
    }
    function readTableEntry(e3) {
      const t3 = e3.getString(4), a3 = e3.getInt32() >>> 0, r3 = e3.getInt32() >>> 0, i3 = e3.getInt32() >>> 0, n3 = e3.pos;
      e3.pos = e3.start || 0;
      e3.skip(r3);
      const s3 = e3.getBytes(i3);
      e3.pos = n3;
      if ("head" === t3) {
        s3[8] = s3[9] = s3[10] = s3[11] = 0;
        s3[17] |= 32;
      }
      return { tag: t3, checksum: a3, length: i3, offset: r3, data: s3 };
    }
    function readOpenTypeHeader(e3) {
      return { version: e3.getString(4), numTables: e3.getUint16(), searchRange: e3.getUint16(), entrySelector: e3.getUint16(), rangeShift: e3.getUint16() };
    }
    function sanitizeGlyph(e3, t3, a3, r3, i3, n3) {
      const s3 = { length: 0, sizeOfInstructions: 0 };
      if (t3 < 0 || t3 >= e3.length || a3 > e3.length || a3 - t3 <= 12) return s3;
      const o3 = e3.subarray(t3, a3), c3 = signedInt16(o3[2], o3[3]), l3 = signedInt16(o3[4], o3[5]), h3 = signedInt16(o3[6], o3[7]), u3 = signedInt16(o3[8], o3[9]);
      if (c3 > h3) {
        writeSignedInt16(o3, 2, h3);
        writeSignedInt16(o3, 6, c3);
      }
      if (l3 > u3) {
        writeSignedInt16(o3, 4, u3);
        writeSignedInt16(o3, 8, l3);
      }
      const d3 = signedInt16(o3[0], o3[1]);
      if (d3 < 0) {
        if (d3 < -1) return s3;
        r3.set(o3, i3);
        s3.length = o3.length;
        return s3;
      }
      let f3, g3 = 10, p3 = 0;
      for (f3 = 0; f3 < d3; f3++) {
        p3 = (o3[g3] << 8 | o3[g3 + 1]) + 1;
        g3 += 2;
      }
      const m3 = g3, b3 = o3[g3] << 8 | o3[g3 + 1];
      s3.sizeOfInstructions = b3;
      g3 += 2 + b3;
      const y3 = g3;
      let w3 = 0;
      for (f3 = 0; f3 < p3; f3++) {
        const e4 = o3[g3++];
        192 & e4 && (o3[g3 - 1] = 63 & e4);
        let t4 = 2;
        2 & e4 ? t4 = 1 : 16 & e4 && (t4 = 0);
        let a4 = 2;
        4 & e4 ? a4 = 1 : 32 & e4 && (a4 = 0);
        const r4 = t4 + a4;
        w3 += r4;
        if (8 & e4) {
          const e5 = o3[g3++];
          0 === e5 && (o3[g3 - 1] ^= 8);
          f3 += e5;
          w3 += e5 * r4;
        }
      }
      if (0 === w3) return s3;
      let x3 = g3 + w3;
      if (x3 > o3.length) return s3;
      if (!n3 && b3 > 0) {
        r3.set(o3.subarray(0, m3), i3);
        r3.set([0, 0], i3 + m3);
        r3.set(o3.subarray(y3, x3), i3 + m3 + 2);
        x3 -= b3;
        o3.length - x3 > 3 && (x3 = x3 + 3 & -4);
        s3.length = x3;
        return s3;
      }
      if (o3.length - x3 > 3) {
        x3 = x3 + 3 & -4;
        r3.set(o3.subarray(0, x3), i3);
        s3.length = x3;
        return s3;
      }
      r3.set(o3, i3);
      s3.length = o3.length;
      return s3;
    }
    function readNameTable(e3) {
      const a3 = (t2.start || 0) + e3.offset;
      t2.pos = a3;
      const r3 = [[], []], i3 = [], n3 = e3.length, s3 = a3 + n3;
      if (0 !== t2.getUint16() || n3 < 6) return [r3, i3];
      const o3 = t2.getUint16(), c3 = t2.getUint16();
      let l3, h3;
      for (l3 = 0; l3 < o3 && t2.pos + 12 <= s3; l3++) {
        const e4 = { platform: t2.getUint16(), encoding: t2.getUint16(), language: t2.getUint16(), name: t2.getUint16(), length: t2.getUint16(), offset: t2.getUint16() };
        (isMacNameRecord(e4) || isWinNameRecord(e4)) && i3.push(e4);
      }
      for (l3 = 0, h3 = i3.length; l3 < h3; l3++) {
        const e4 = i3[l3];
        if (e4.length <= 0) continue;
        const n4 = a3 + c3 + e4.offset;
        if (n4 + e4.length > s3) continue;
        t2.pos = n4;
        const o4 = e4.name;
        if (e4.encoding) {
          let a4 = "";
          for (let r4 = 0, i4 = e4.length; r4 < i4; r4 += 2) a4 += String.fromCharCode(t2.getUint16());
          r3[1][o4] = a4;
        } else r3[0][o4] = t2.getString(e4.length);
      }
      return [r3, i3];
    }
    const i2 = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
    function sanitizeTTProgram(e3, t3) {
      let a3, r3, n3, s3, o3, c3 = e3.data, l3 = 0, h3 = 0, u3 = 0;
      const d3 = [], f3 = [], g3 = [];
      let p3 = t3.tooComplexToFollowFunctions, m3 = false, b3 = 0, y3 = 0;
      for (let e4 = c3.length; l3 < e4; ) {
        const e5 = c3[l3++];
        if (64 === e5) {
          r3 = c3[l3++];
          if (m3 || y3) l3 += r3;
          else for (a3 = 0; a3 < r3; a3++) d3.push(c3[l3++]);
        } else if (65 === e5) {
          r3 = c3[l3++];
          if (m3 || y3) l3 += 2 * r3;
          else for (a3 = 0; a3 < r3; a3++) {
            n3 = c3[l3++];
            d3.push(n3 << 8 | c3[l3++]);
          }
        } else if (176 == (248 & e5)) {
          r3 = e5 - 176 + 1;
          if (m3 || y3) l3 += r3;
          else for (a3 = 0; a3 < r3; a3++) d3.push(c3[l3++]);
        } else if (184 == (248 & e5)) {
          r3 = e5 - 184 + 1;
          if (m3 || y3) l3 += 2 * r3;
          else for (a3 = 0; a3 < r3; a3++) {
            n3 = c3[l3++];
            d3.push(signedInt16(n3, c3[l3++]));
          }
        } else if (43 !== e5 || p3) if (44 !== e5 || p3) {
          if (45 === e5) if (m3) {
            m3 = false;
            h3 = l3;
          } else {
            o3 = f3.pop();
            if (!o3) {
              warn("TT: ENDF bad stack");
              t3.hintsValid = false;
              return;
            }
            s3 = g3.pop();
            c3 = o3.data;
            l3 = o3.i;
            t3.functionsStackDeltas[s3] = d3.length - o3.stackTop;
          }
          else if (137 === e5) {
            if (m3 || y3) {
              warn("TT: nested IDEFs not allowed");
              p3 = true;
            }
            m3 = true;
            u3 = l3;
          } else if (88 === e5) ++b3;
          else if (27 === e5) y3 = b3;
          else if (89 === e5) {
            y3 === b3 && (y3 = 0);
            --b3;
          } else if (28 === e5 && !m3 && !y3) {
            const e6 = d3.at(-1);
            e6 > 0 && (l3 += e6 - 1);
          }
        } else {
          if (m3 || y3) {
            warn("TT: nested FDEFs not allowed");
            p3 = true;
          }
          m3 = true;
          u3 = l3;
          s3 = d3.pop();
          t3.functionsDefined[s3] = { data: c3, i: l3 };
        }
        else if (!m3 && !y3) {
          s3 = d3.at(-1);
          if (isNaN(s3)) info("TT: CALL empty stack (or invalid entry).");
          else {
            t3.functionsUsed[s3] = true;
            if (s3 in t3.functionsStackDeltas) {
              const e6 = d3.length + t3.functionsStackDeltas[s3];
              if (e6 < 0) {
                warn("TT: CALL invalid functions stack delta.");
                t3.hintsValid = false;
                return;
              }
              d3.length = e6;
            } else if (s3 in t3.functionsDefined && !g3.includes(s3)) {
              f3.push({ data: c3, i: l3, stackTop: d3.length - 1 });
              g3.push(s3);
              o3 = t3.functionsDefined[s3];
              if (!o3) {
                warn("TT: CALL non-existent function");
                t3.hintsValid = false;
                return;
              }
              c3 = o3.data;
              l3 = o3.i;
            }
          }
        }
        if (!m3 && !y3) {
          let t4 = 0;
          e5 <= 142 ? t4 = i2[e5] : e5 >= 192 && e5 <= 223 ? t4 = -1 : e5 >= 224 && (t4 = -2);
          if (e5 >= 113 && e5 <= 117) {
            r3 = d3.pop();
            isNaN(r3) || (t4 = 2 * -r3);
          }
          for (; t4 < 0 && d3.length > 0; ) {
            d3.pop();
            t4++;
          }
          for (; t4 > 0; ) {
            d3.push(NaN);
            t4--;
          }
        }
      }
      t3.tooComplexToFollowFunctions = p3;
      const w3 = [c3];
      l3 > c3.length && w3.push(new Uint8Array(l3 - c3.length));
      if (u3 > h3) {
        warn("TT: complementing a missing function tail");
        w3.push(new Uint8Array([34, 45]));
      }
      !(function foldTTTable(e4, t4) {
        if (t4.length > 1) {
          let a4, r4, i3 = 0;
          for (a4 = 0, r4 = t4.length; a4 < r4; a4++) i3 += t4[a4].length;
          i3 = i3 + 3 & -4;
          const n4 = new Uint8Array(i3);
          let s4 = 0;
          for (a4 = 0, r4 = t4.length; a4 < r4; a4++) {
            n4.set(t4[a4], s4);
            s4 += t4[a4].length;
          }
          e4.data = n4;
          e4.length = i3;
        }
      })(e3, w3);
    }
    let n2, s2, o2, c2;
    if (isTrueTypeCollectionFile(t2 = new Stream(new Uint8Array(t2.getBytes())))) {
      const e3 = (function readTrueTypeCollectionData(e4, t3) {
        const { numFonts: a3, offsetTable: r3 } = (function readTrueTypeCollectionHeader(e5) {
          const t4 = e5.getString(4);
          assert("ttcf" === t4, "Must be a TrueType Collection font.");
          const a4 = e5.getUint16(), r4 = e5.getUint16(), i4 = e5.getInt32() >>> 0, n4 = [];
          for (let t5 = 0; t5 < i4; t5++) n4.push(e5.getInt32() >>> 0);
          const s3 = { ttcTag: t4, majorVersion: a4, minorVersion: r4, numFonts: i4, offsetTable: n4 };
          switch (a4) {
            case 1:
              return s3;
            case 2:
              s3.dsigTag = e5.getInt32() >>> 0;
              s3.dsigLength = e5.getInt32() >>> 0;
              s3.dsigOffset = e5.getInt32() >>> 0;
              return s3;
          }
          throw new FormatError(`Invalid TrueType Collection majorVersion: ${a4}.`);
        })(e4), i3 = t3.split("+");
        let n3;
        for (let s3 = 0; s3 < a3; s3++) {
          e4.pos = (e4.start || 0) + r3[s3];
          const a4 = readOpenTypeHeader(e4), o3 = readTables(e4, a4.numTables);
          if (!o3.name) throw new FormatError('TrueType Collection font must contain a "name" table.');
          const [c3] = readNameTable(o3.name);
          for (let e5 = 0, r4 = c3.length; e5 < r4; e5++) for (let r5 = 0, s4 = c3[e5].length; r5 < s4; r5++) {
            const s5 = c3[e5][r5]?.replaceAll(/\s/g, "");
            if (s5) {
              if (s5 === t3) return { header: a4, tables: o3 };
              if (!(i3.length < 2)) for (const e6 of i3) s5 === e6 && (n3 = { name: e6, header: a4, tables: o3 });
            }
          }
        }
        if (n3) {
          warn(`TrueType Collection does not contain "${t3}" font, falling back to "${n3.name}" font instead.`);
          return { header: n3.header, tables: n3.tables };
        }
        throw new FormatError(`TrueType Collection does not contain "${t3}" font.`);
      })(t2, this.name);
      n2 = e3.header;
      s2 = e3.tables;
    } else {
      n2 = readOpenTypeHeader(t2);
      s2 = readTables(t2, n2.numTables);
    }
    const l2 = !s2["CFF "];
    if (l2) {
      if (!s2.loca) throw new FormatError('Required "loca" table is not found');
      if (!s2.glyf) {
        warn('Required "glyf" table is not found -- trying to recover.');
        s2.glyf = { tag: "glyf", data: new Uint8Array(0) };
      }
      this.isOpenType = false;
    } else {
      const t3 = a2.composite && (a2.cidToGidMap?.length > 0 || !(a2.cMap instanceof IdentityCMap));
      if ("OTTO" === n2.version && !t3 || !s2.head || !s2.hhea || !s2.maxp || !s2.post) {
        c2 = new Stream(s2["CFF "].data);
        o2 = new CFFFont(c2, a2);
        return this.convert(e2, o2, a2);
      }
      delete s2.glyf;
      delete s2.loca;
      delete s2.fpgm;
      delete s2.prep;
      delete s2["cvt "];
      this.isOpenType = true;
    }
    if (!s2.maxp) throw new FormatError('Required "maxp" table is not found');
    t2.pos = (t2.start || 0) + s2.maxp.offset;
    let h2 = t2.getInt32();
    const u2 = t2.getUint16();
    if (65536 !== h2 && 20480 !== h2) {
      if (6 === s2.maxp.length) h2 = 20480;
      else {
        if (!(s2.maxp.length >= 32)) throw new FormatError('"maxp" table has a wrong version number');
        h2 = 65536;
      }
      !(function writeUint32(e3, t3, a3) {
        e3[t3 + 3] = 255 & a3;
        e3[t3 + 2] = a3 >>> 8;
        e3[t3 + 1] = a3 >>> 16;
        e3[t3] = a3 >>> 24;
      })(s2.maxp.data, 0, h2);
    }
    if (a2.scaleFactors?.length === u2 && l2) {
      const { scaleFactors: e3 } = a2, t3 = int16(s2.head.data[50], s2.head.data[51]), r3 = new GlyfTable({ glyfTable: s2.glyf.data, isGlyphLocationsLong: t3, locaTable: s2.loca.data, numGlyphs: u2 });
      r3.scale(e3);
      const { glyf: i3, loca: n3, isLocationLong: o3 } = r3.write();
      s2.glyf.data = i3;
      s2.loca.data = n3;
      if (o3 !== !!t3) {
        s2.head.data[50] = 0;
        s2.head.data[51] = o3 ? 1 : 0;
      }
      const c3 = s2.hmtx.data;
      for (let t4 = 0; t4 < u2; t4++) {
        const a3 = 4 * t4, r4 = Math.round(e3[t4] * int16(c3[a3], c3[a3 + 1]));
        c3[a3] = r4 >> 8 & 255;
        c3[a3 + 1] = 255 & r4;
        writeSignedInt16(c3, a3 + 2, Math.round(e3[t4] * signedInt16(c3[a3 + 2], c3[a3 + 3])));
      }
    }
    let d2 = u2 + 1, f2 = true;
    if (d2 > 65535) {
      f2 = false;
      d2 = u2;
      warn("Not enough space in glyfs to duplicate first glyph.");
    }
    let g2 = 0, p2 = 0;
    if (h2 >= 65536 && s2.maxp.length >= 32) {
      t2.pos += 8;
      if (t2.getUint16() > 2) {
        s2.maxp.data[14] = 0;
        s2.maxp.data[15] = 2;
      }
      t2.pos += 4;
      g2 = t2.getUint16();
      t2.pos += 4;
      p2 = t2.getUint16();
    }
    s2.maxp.data[4] = d2 >> 8;
    s2.maxp.data[5] = 255 & d2;
    const m2 = (function sanitizeTTPrograms(e3, t3, a3, r3) {
      const i3 = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: false, hintsValid: true };
      e3 && sanitizeTTProgram(e3, i3);
      t3 && sanitizeTTProgram(t3, i3);
      e3 && (function checkInvalidFunctions(e4, t4) {
        if (!e4.tooComplexToFollowFunctions) if (e4.functionsDefined.length > t4) {
          warn("TT: more functions defined than expected");
          e4.hintsValid = false;
        } else for (let a4 = 0, r4 = e4.functionsUsed.length; a4 < r4; a4++) {
          if (a4 > t4) {
            warn("TT: invalid function id: " + a4);
            e4.hintsValid = false;
            return;
          }
          if (e4.functionsUsed[a4] && !e4.functionsDefined[a4]) {
            warn("TT: undefined function: " + a4);
            e4.hintsValid = false;
            return;
          }
        }
      })(i3, r3);
      if (a3 && 1 & a3.length) {
        const e4 = new Uint8Array(a3.length + 1);
        e4.set(a3.data);
        a3.data = e4;
      }
      return i3.hintsValid;
    })(s2.fpgm, s2.prep, s2["cvt "], g2);
    if (!m2) {
      delete s2.fpgm;
      delete s2.prep;
      delete s2["cvt "];
    }
    !(function sanitizeMetrics(e3, t3, a3, r3, i3, n3) {
      if (!t3) {
        a3 && (a3.data = null);
        return;
      }
      e3.pos = (e3.start || 0) + t3.offset;
      e3.pos += 4;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      e3.pos += 2;
      const s3 = e3.getUint16();
      e3.pos += 8;
      e3.pos += 2;
      let o3 = e3.getUint16();
      if (0 !== s3) {
        if (!(2 & int16(r3.data[44], r3.data[45]))) {
          t3.data[22] = 0;
          t3.data[23] = 0;
        }
      }
      if (o3 > i3) {
        info(`The numOfMetrics (${o3}) should not be greater than the numGlyphs (${i3}).`);
        o3 = i3;
        t3.data[34] = (65280 & o3) >> 8;
        t3.data[35] = 255 & o3;
      }
      const c3 = i3 - o3 - (a3.length - 4 * o3 >> 1);
      if (c3 > 0) {
        const e4 = new Uint8Array(a3.length + 2 * c3);
        e4.set(a3.data);
        if (n3) {
          e4[a3.length] = a3.data[2];
          e4[a3.length + 1] = a3.data[3];
        }
        a3.data = e4;
      }
    })(t2, s2.hhea, s2.hmtx, s2.head, d2, f2);
    if (!s2.head) throw new FormatError('Required "head" table is not found');
    !(function sanitizeHead(e3, t3, a3) {
      const r3 = e3.data, i3 = (function int32(e4, t4, a4, r4) {
        return (e4 << 24) + (t4 << 16) + (a4 << 8) + r4;
      })(r3[0], r3[1], r3[2], r3[3]);
      if (i3 >> 16 != 1) {
        info("Attempting to fix invalid version in head table: " + i3);
        r3[0] = 0;
        r3[1] = 1;
        r3[2] = 0;
        r3[3] = 0;
      }
      const n3 = int16(r3[50], r3[51]);
      if (n3 < 0 || n3 > 1) {
        info("Attempting to fix invalid indexToLocFormat in head table: " + n3);
        const e4 = t3 + 1;
        if (a3 === e4 << 1) {
          r3[50] = 0;
          r3[51] = 0;
        } else {
          if (a3 !== e4 << 2) throw new FormatError("Could not fix indexToLocFormat: " + n3);
          r3[50] = 0;
          r3[51] = 1;
        }
      }
    })(s2.head, u2, l2 ? s2.loca.length : 0);
    let b2 = /* @__PURE__ */ Object.create(null);
    if (l2) {
      const e3 = int16(s2.head.data[50], s2.head.data[51]), t3 = (function sanitizeGlyphLocations(e4, t4, a3, r3, i3, n3, s3) {
        let o3, c3, l3;
        if (r3) {
          o3 = 4;
          c3 = function fontItemDecodeLong(e5, t5) {
            return e5[t5] << 24 | e5[t5 + 1] << 16 | e5[t5 + 2] << 8 | e5[t5 + 3];
          };
          l3 = function fontItemEncodeLong(e5, t5, a4) {
            e5[t5] = a4 >>> 24 & 255;
            e5[t5 + 1] = a4 >> 16 & 255;
            e5[t5 + 2] = a4 >> 8 & 255;
            e5[t5 + 3] = 255 & a4;
          };
        } else {
          o3 = 2;
          c3 = function fontItemDecode(e5, t5) {
            return e5[t5] << 9 | e5[t5 + 1] << 1;
          };
          l3 = function fontItemEncode(e5, t5, a4) {
            e5[t5] = a4 >> 9 & 255;
            e5[t5 + 1] = a4 >> 1 & 255;
          };
        }
        const h3 = n3 ? a3 + 1 : a3, u3 = o3 * (1 + h3), d3 = new Uint8Array(u3);
        d3.set(e4.data.subarray(0, u3));
        e4.data = d3;
        const f3 = t4.data, g3 = f3.length, p3 = new Uint8Array(g3);
        let m3, b3;
        const y3 = [];
        for (m3 = 0, b3 = 0; m3 < a3 + 1; m3++, b3 += o3) {
          let e5 = c3(d3, b3);
          e5 > g3 && (e5 = g3);
          y3.push({ index: m3, offset: e5, endOffset: 0 });
        }
        y3.sort(((e5, t5) => e5.offset - t5.offset));
        for (m3 = 0; m3 < a3; m3++) y3[m3].endOffset = y3[m3 + 1].offset;
        y3.sort(((e5, t5) => e5.index - t5.index));
        for (m3 = 0; m3 < a3; m3++) {
          const { offset: e5, endOffset: t5 } = y3[m3];
          if (0 !== e5 || 0 !== t5) break;
          const a4 = y3[m3 + 1].offset;
          if (0 !== a4) {
            y3[m3].endOffset = a4;
            break;
          }
        }
        const w3 = y3.at(-2);
        0 !== w3.offset && 0 === w3.endOffset && (w3.endOffset = g3);
        const x3 = /* @__PURE__ */ Object.create(null);
        let S3 = 0;
        l3(d3, 0, S3);
        for (m3 = 0, b3 = o3; m3 < a3; m3++, b3 += o3) {
          const e5 = sanitizeGlyph(f3, y3[m3].offset, y3[m3].endOffset, p3, S3, i3), t5 = e5.length;
          0 === t5 && (x3[m3] = true);
          e5.sizeOfInstructions > s3 && (s3 = e5.sizeOfInstructions);
          S3 += t5;
          l3(d3, b3, S3);
        }
        if (0 === S3) {
          const e5 = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
          for (m3 = 0, b3 = o3; m3 < h3; m3++, b3 += o3) l3(d3, b3, e5.length);
          t4.data = e5;
        } else if (n3) {
          const a4 = c3(d3, o3);
          if (p3.length > a4 + S3) t4.data = p3.subarray(0, a4 + S3);
          else {
            t4.data = new Uint8Array(a4 + S3);
            t4.data.set(p3.subarray(0, S3));
          }
          t4.data.set(p3.subarray(0, a4), S3);
          l3(e4.data, d3.length - o3, S3 + a4);
        } else t4.data = p3.subarray(0, S3);
        return { missingGlyphs: x3, maxSizeOfInstructions: s3 };
      })(s2.loca, s2.glyf, u2, e3, m2, f2, p2);
      b2 = t3.missingGlyphs;
      if (h2 >= 65536 && s2.maxp.length >= 32) {
        s2.maxp.data[26] = t3.maxSizeOfInstructions >> 8;
        s2.maxp.data[27] = 255 & t3.maxSizeOfInstructions;
      }
    }
    if (!s2.hhea) throw new FormatError('Required "hhea" table is not found');
    if (0 === s2.hhea.data[10] && 0 === s2.hhea.data[11]) {
      s2.hhea.data[10] = 255;
      s2.hhea.data[11] = 255;
    }
    const y2 = { unitsPerEm: int16(s2.head.data[18], s2.head.data[19]), yMax: signedInt16(s2.head.data[42], s2.head.data[43]), yMin: signedInt16(s2.head.data[38], s2.head.data[39]), ascent: signedInt16(s2.hhea.data[4], s2.hhea.data[5]), descent: signedInt16(s2.hhea.data[6], s2.hhea.data[7]), lineGap: signedInt16(s2.hhea.data[8], s2.hhea.data[9]) };
    this.ascent = y2.ascent / y2.unitsPerEm;
    this.descent = y2.descent / y2.unitsPerEm;
    this.lineGap = y2.lineGap / y2.unitsPerEm;
    if (this.cssFontInfo?.lineHeight) {
      this.lineHeight = this.cssFontInfo.metrics.lineHeight;
      this.lineGap = this.cssFontInfo.metrics.lineGap;
    } else this.lineHeight = this.ascent - this.descent + this.lineGap;
    s2.post && (function readPostScriptTable(e3, a3, r3) {
      const i3 = (t2.start || 0) + e3.offset;
      t2.pos = i3;
      const n3 = i3 + e3.length, s3 = t2.getInt32();
      t2.skip(28);
      let o3, c3, l3 = true;
      switch (s3) {
        case 65536:
          o3 = jr;
          break;
        case 131072:
          const e4 = t2.getUint16();
          if (e4 !== r3) {
            l3 = false;
            break;
          }
          const i4 = [];
          for (c3 = 0; c3 < e4; ++c3) {
            const e5 = t2.getUint16();
            if (e5 >= 32768) {
              l3 = false;
              break;
            }
            i4.push(e5);
          }
          if (!l3) break;
          const h3 = [], u3 = [];
          for (; t2.pos < n3; ) {
            const e5 = t2.getByte();
            u3.length = e5;
            for (c3 = 0; c3 < e5; ++c3) u3[c3] = String.fromCharCode(t2.getByte());
            h3.push(u3.join(""));
          }
          o3 = [];
          for (c3 = 0; c3 < e4; ++c3) {
            const e5 = i4[c3];
            e5 < 258 ? o3.push(jr[e5]) : o3.push(h3[e5 - 258]);
          }
          break;
        case 196608:
          break;
        default:
          warn("Unknown/unsupported post table version " + s3);
          l3 = false;
          a3.defaultEncoding && (o3 = a3.defaultEncoding);
      }
      a3.glyphNames = o3;
      return l3;
    })(s2.post, a2, u2);
    s2.post = { tag: "post", data: createPostTable(a2) };
    const w2 = /* @__PURE__ */ Object.create(null);
    function hasGlyph(e3) {
      return !b2[e3];
    }
    if (a2.composite) {
      const e3 = a2.cidToGidMap || [], t3 = 0 === e3.length;
      a2.cMap.forEach((function(a3, r3) {
        "string" == typeof r3 && (r3 = convertCidString(a3, r3, true));
        if (r3 > 65535) throw new FormatError("Max size of CID is 65,535");
        let i3 = -1;
        t3 ? i3 = r3 : void 0 !== e3[r3] && (i3 = e3[r3]);
        i3 >= 0 && i3 < u2 && hasGlyph(i3) && (w2[a3] = i3);
      }));
    } else {
      const e3 = (function readCmapTable(e4, t3, a3, r4) {
        if (!e4) {
          warn("No cmap table available.");
          return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
        }
        let i4, n4 = (t3.start || 0) + e4.offset;
        t3.pos = n4;
        t3.skip(2);
        const s3 = t3.getUint16();
        let o4, c4 = false;
        for (let e5 = 0; e5 < s3; e5++) {
          const i5 = t3.getUint16(), n5 = t3.getUint16(), l4 = t3.getInt32() >>> 0;
          let h4 = false;
          if (o4?.platformId !== i5 || o4?.encodingId !== n5) {
            if (0 !== i5 || 0 !== n5 && 1 !== n5 && 3 !== n5) if (1 === i5 && 0 === n5) h4 = true;
            else if (3 !== i5 || 1 !== n5 || !r4 && o4) {
              if (a3 && 3 === i5 && 0 === n5) {
                h4 = true;
                let a4 = true;
                if (e5 < s3 - 1) {
                  const e6 = t3.peekBytes(2);
                  int16(e6[0], e6[1]) < i5 && (a4 = false);
                }
                a4 && (c4 = true);
              }
            } else {
              h4 = true;
              a3 || (c4 = true);
            }
            else h4 = true;
            h4 && (o4 = { platformId: i5, encodingId: n5, offset: l4 });
            if (c4) break;
          }
        }
        o4 && (t3.pos = n4 + o4.offset);
        if (!o4 || -1 === t3.peekByte()) {
          warn("Could not find a preferred cmap table.");
          return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
        }
        const l3 = t3.getUint16();
        let h3 = false;
        const u3 = [];
        let d3, f3;
        if (0 === l3) {
          t3.skip(4);
          for (d3 = 0; d3 < 256; d3++) {
            const e5 = t3.getByte();
            e5 && u3.push({ charCode: d3, glyphId: e5 });
          }
          h3 = true;
        } else if (2 === l3) {
          t3.skip(4);
          const e5 = [];
          let a4 = 0;
          for (let r6 = 0; r6 < 256; r6++) {
            const r7 = t3.getUint16() >> 3;
            e5.push(r7);
            a4 = Math.max(r7, a4);
          }
          const r5 = [];
          for (let e6 = 0; e6 <= a4; e6++) r5.push({ firstCode: t3.getUint16(), entryCount: t3.getUint16(), idDelta: signedInt16(t3.getByte(), t3.getByte()), idRangePos: t3.pos + t3.getUint16() });
          for (let a5 = 0; a5 < 256; a5++) if (0 === e5[a5]) {
            t3.pos = r5[0].idRangePos + 2 * a5;
            f3 = t3.getUint16();
            u3.push({ charCode: a5, glyphId: f3 });
          } else {
            const i5 = r5[e5[a5]];
            for (d3 = 0; d3 < i5.entryCount; d3++) {
              const e6 = (a5 << 8) + d3 + i5.firstCode;
              t3.pos = i5.idRangePos + 2 * d3;
              f3 = t3.getUint16();
              0 !== f3 && (f3 = (f3 + i5.idDelta) % 65536);
              u3.push({ charCode: e6, glyphId: f3 });
            }
          }
        } else if (4 === l3) {
          t3.skip(4);
          const e5 = t3.getUint16() >> 1;
          t3.skip(6);
          const a4 = [];
          let r5;
          for (r5 = 0; r5 < e5; r5++) a4.push({ end: t3.getUint16() });
          t3.skip(2);
          for (r5 = 0; r5 < e5; r5++) a4[r5].start = t3.getUint16();
          for (r5 = 0; r5 < e5; r5++) a4[r5].delta = t3.getUint16();
          let s4, o5 = 0;
          for (r5 = 0; r5 < e5; r5++) {
            i4 = a4[r5];
            const n5 = t3.getUint16();
            if (n5) {
              s4 = (n5 >> 1) - (e5 - r5);
              i4.offsetIndex = s4;
              o5 = Math.max(o5, s4 + i4.end - i4.start + 1);
            } else i4.offsetIndex = -1;
          }
          const c5 = [];
          for (d3 = 0; d3 < o5; d3++) c5.push(t3.getUint16());
          for (r5 = 0; r5 < e5; r5++) {
            i4 = a4[r5];
            n4 = i4.start;
            const e6 = i4.end, t4 = i4.delta;
            s4 = i4.offsetIndex;
            for (d3 = n4; d3 <= e6; d3++) if (65535 !== d3) {
              f3 = s4 < 0 ? d3 : c5[s4 + d3 - n4];
              f3 = f3 + t4 & 65535;
              u3.push({ charCode: d3, glyphId: f3 });
            }
          }
        } else if (6 === l3) {
          t3.skip(4);
          const e5 = t3.getUint16(), a4 = t3.getUint16();
          for (d3 = 0; d3 < a4; d3++) {
            f3 = t3.getUint16();
            const a5 = e5 + d3;
            u3.push({ charCode: a5, glyphId: f3 });
          }
        } else {
          if (12 !== l3) {
            warn("cmap table has unsupported format: " + l3);
            return { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: false };
          }
          {
            t3.skip(10);
            const e5 = t3.getInt32() >>> 0;
            for (d3 = 0; d3 < e5; d3++) {
              const e6 = t3.getInt32() >>> 0, a4 = t3.getInt32() >>> 0;
              let r5 = t3.getInt32() >>> 0;
              for (let t4 = e6; t4 <= a4; t4++) u3.push({ charCode: t4, glyphId: r5++ });
            }
          }
        }
        u3.sort(((e5, t4) => e5.charCode - t4.charCode));
        const g3 = [], p3 = /* @__PURE__ */ new Set();
        for (const e5 of u3) {
          const { charCode: t4 } = e5;
          if (!p3.has(t4)) {
            p3.add(t4);
            g3.push(e5);
          }
        }
        return { platformId: o4.platformId, encodingId: o4.encodingId, mappings: g3, hasShortCmap: h3 };
      })(s2.cmap, t2, this.isSymbolicFont, a2.hasEncoding), r3 = e3.platformId, i3 = e3.encodingId, n3 = e3.mappings;
      let o3 = [], c3 = false;
      !a2.hasEncoding || "MacRomanEncoding" !== a2.baseEncodingName && "WinAnsiEncoding" !== a2.baseEncodingName || (o3 = getEncoding(a2.baseEncodingName));
      if (a2.hasEncoding && !this.isSymbolicFont && (3 === r3 && 1 === i3 || 1 === r3 && 0 === i3)) {
        const e4 = Fr();
        for (let t3 = 0; t3 < 256; t3++) {
          let s3;
          s3 = void 0 !== this.differences[t3] ? this.differences[t3] : o3.length && "" !== o3[t3] ? o3[t3] : Ar[t3];
          if (!s3) continue;
          const c4 = recoverGlyphName(s3, e4);
          let l3;
          3 === r3 && 1 === i3 ? l3 = e4[c4] : 1 === r3 && 0 === i3 && (l3 = Sr.indexOf(c4));
          if (void 0 === l3) {
            if (!a2.glyphNames && a2.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {
              const e5 = this.toUnicode.get(t3);
              e5 && (l3 = e5.codePointAt(0));
            }
            if (void 0 === l3) continue;
          }
          for (const e5 of n3) if (e5.charCode === l3) {
            w2[t3] = e5.glyphId;
            break;
          }
        }
      } else if (0 === r3) {
        for (const e4 of n3) w2[e4.charCode] = e4.glyphId;
        c3 = true;
      } else if (3 === r3 && 0 === i3) for (const e4 of n3) {
        let t3 = e4.charCode;
        t3 >= 61440 && t3 <= 61695 && (t3 &= 255);
        w2[t3] = e4.glyphId;
      }
      else for (const e4 of n3) w2[e4.charCode] = e4.glyphId;
      if (a2.glyphNames && (o3.length || this.differences.length)) for (let e4 = 0; e4 < 256; ++e4) {
        if (!c3 && void 0 !== w2[e4]) continue;
        const t3 = this.differences[e4] || o3[e4];
        if (!t3) continue;
        const r4 = a2.glyphNames.indexOf(t3);
        r4 > 0 && hasGlyph(r4) && (w2[e4] = r4);
      }
    }
    0 === w2.length && (w2[0] = 0);
    let x2 = d2 - 1;
    f2 || (x2 = 0);
    if (!a2.cssFontInfo) {
      const e3 = adjustMapping(w2, hasGlyph, x2, this.toUnicode);
      this.toFontChar = e3.toFontChar;
      s2.cmap = { tag: "cmap", data: createCmapTable(e3.charCodeToGlyphId, e3.toUnicodeExtraMap, d2) };
      s2["OS/2"] && (function validateOS2Table(e4, t3) {
        t3.pos = (t3.start || 0) + e4.offset;
        const a3 = t3.getUint16();
        t3.skip(60);
        const r3 = t3.getUint16();
        if (a3 < 4 && 768 & r3) return false;
        if (t3.getUint16() > t3.getUint16()) return false;
        t3.skip(6);
        if (0 === t3.getUint16()) return false;
        e4.data[8] = e4.data[9] = 0;
        return true;
      })(s2["OS/2"], t2) || (s2["OS/2"] = { tag: "OS/2", data: createOS2Table(a2, e3.charCodeToGlyphId, y2) });
    }
    if (!l2) try {
      c2 = new Stream(s2["CFF "].data);
      o2 = new CFFParser(c2, a2, Rr).parse();
      o2.duplicateFirstGlyph();
      const e3 = new CFFCompiler(o2);
      s2["CFF "].data = e3.compile();
    } catch {
      warn("Failed to compile font " + a2.loadedName);
    }
    if (s2.name) {
      const [t3, r3] = readNameTable(s2.name);
      s2.name.data = createNameTable(e2, t3);
      this.psName = t3[0][6] || null;
      a2.composite || (function adjustTrueTypeToUnicode(e3, t4, a3) {
        if (e3.isInternalFont) return;
        if (e3.hasIncludedToUnicodeMap) return;
        if (e3.hasEncoding) return;
        if (e3.toUnicode instanceof IdentityToUnicodeMap) return;
        if (!t4) return;
        if (0 === a3.length) return;
        if (e3.defaultEncoding === kr) return;
        for (const e4 of a3) if (!isWinNameRecord(e4)) return;
        const r4 = kr, i3 = [], n3 = Fr();
        for (const e4 in r4) {
          const t5 = r4[e4];
          if ("" === t5) continue;
          const a4 = n3[t5];
          void 0 !== a4 && (i3[e4] = String.fromCharCode(a4));
        }
        i3.length > 0 && e3.toUnicode.amend(i3);
      })(a2, this.isSymbolicFont, r3);
    } else s2.name = { tag: "name", data: createNameTable(this.name) };
    const S2 = new OpenTypeFileBuilder(n2.version);
    for (const e3 in s2) S2.addTable(e3, s2[e3].data);
    return S2.toArray();
  }
  convert(e2, a2, r2) {
    r2.fixedPitch = false;
    r2.builtInEncoding && (function adjustType1ToUnicode(e3, t2) {
      if (e3.isInternalFont) return;
      if (e3.hasIncludedToUnicodeMap) return;
      if (t2 === e3.defaultEncoding) return;
      if (e3.toUnicode instanceof IdentityToUnicodeMap) return;
      const a3 = [], r3 = Fr();
      for (const i3 in t2) {
        if (e3.hasEncoding && (e3.baseEncodingName || void 0 !== e3.differences[i3])) continue;
        const n3 = getUnicodeForGlyph(t2[i3], r3);
        -1 !== n3 && (a3[i3] = String.fromCharCode(n3));
      }
      a3.length > 0 && e3.toUnicode.amend(a3);
    })(r2, r2.builtInEncoding);
    let i2 = 1;
    a2 instanceof CFFFont && (i2 = a2.numGlyphs - 1);
    const n2 = a2.getGlyphMapping(r2);
    let s2 = null, o2 = n2, c2 = null;
    if (!r2.cssFontInfo) {
      s2 = adjustMapping(n2, a2.hasGlyphId.bind(a2), i2, this.toUnicode);
      this.toFontChar = s2.toFontChar;
      o2 = s2.charCodeToGlyphId;
      c2 = s2.toUnicodeExtraMap;
    }
    const l2 = a2.numGlyphs;
    function getCharCodes(e3, t2) {
      let a3 = null;
      for (const r3 in e3) t2 === e3[r3] && (a3 ||= []).push(0 | r3);
      return a3;
    }
    function createCharCode(e3, t2) {
      for (const a3 in e3) if (t2 === e3[a3]) return 0 | a3;
      s2.charCodeToGlyphId[s2.nextAvailableFontCharCode] = t2;
      return s2.nextAvailableFontCharCode++;
    }
    const h2 = a2.seacs;
    if (s2 && h2?.length) {
      const e3 = r2.fontMatrix || t, i3 = a2.getCharset(), o3 = /* @__PURE__ */ Object.create(null);
      for (let t2 in h2) {
        t2 |= 0;
        const a3 = h2[t2], r3 = Ar[a3[2]], c3 = Ar[a3[3]], l3 = i3.indexOf(r3), u3 = i3.indexOf(c3);
        if (l3 < 0 || u3 < 0) continue;
        const d3 = { x: a3[0] * e3[0] + a3[1] * e3[2] + e3[4], y: a3[0] * e3[1] + a3[1] * e3[3] + e3[5] }, f2 = getCharCodes(n2, t2);
        if (f2) for (const e4 of f2) {
          const t3 = s2.charCodeToGlyphId, a4 = createCharCode(t3, l3), r4 = createCharCode(t3, u3);
          o3[e4] = { baseFontCharCode: a4, accentFontCharCode: r4, accentOffset: d3 };
        }
      }
      r2.seacMap = o3;
    }
    const u2 = r2.fontMatrix ? 1 / Math.max(...r2.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, d2 = new OpenTypeFileBuilder("OTTO");
    d2.addTable("CFF ", a2.data);
    d2.addTable("OS/2", createOS2Table(r2, o2));
    d2.addTable("cmap", createCmapTable(o2, c2, l2));
    d2.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + safeString16(u2) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + safeString16(r2.descent) + "ÿ" + safeString16(r2.ascent) + string16(r2.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
    d2.addTable("hhea", "\0\0\0" + safeString16(r2.ascent) + safeString16(r2.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + safeString16(r2.capHeight) + safeString16(Math.tan(r2.italicAngle) * r2.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(l2));
    d2.addTable("hmtx", (function fontFieldsHmtx() {
      const e3 = a2.charstrings, t2 = a2.cff ? a2.cff.widths : null;
      let r3 = "\0\0\0\0";
      for (let a3 = 1, i3 = l2; a3 < i3; a3++) {
        let i4 = 0;
        if (e3) {
          const t3 = e3[a3 - 1];
          i4 = "width" in t3 ? t3.width : 0;
        } else t2 && (i4 = Math.ceil(t2[a3] || 0));
        r3 += string16(i4) + string16(0);
      }
      return r3;
    })());
    d2.addTable("maxp", "\0\0P\0" + string16(l2));
    d2.addTable("name", createNameTable(e2));
    d2.addTable("post", createPostTable(r2));
    return d2.toArray();
  }
  get _spaceWidth() {
    const e2 = ["space", "minus", "one", "i", "I"];
    let t2;
    for (const a2 of e2) {
      if (a2 in this.widths) {
        t2 = this.widths[a2];
        break;
      }
      const e3 = Fr()[a2];
      let r2 = 0;
      if (this.composite && this.cMap.contains(e3)) {
        r2 = this.cMap.lookup(e3);
        "string" == typeof r2 && (r2 = convertCidString(e3, r2));
      }
      !r2 && this.toUnicode && (r2 = this.toUnicode.charCodeOf(e3));
      r2 <= 0 && (r2 = e3);
      t2 = this.widths[r2];
      if (t2) break;
    }
    return shadow(this, "_spaceWidth", t2 || this.defaultWidth);
  }
  _charToGlyph(e2, t2 = false) {
    let a2, r2, i2, n2 = this._glyphCache[e2];
    if (n2?.isSpace === t2) return n2;
    let s2 = e2;
    if (this.cMap?.contains(e2)) {
      s2 = this.cMap.lookup(e2);
      "string" == typeof s2 && (s2 = convertCidString(e2, s2));
    }
    r2 = this.widths[s2];
    "number" != typeof r2 && (r2 = this.defaultWidth);
    const o2 = this.vmetrics?.[s2];
    let c2 = this.toUnicode.get(e2) || e2;
    "number" == typeof c2 && (c2 = String.fromCharCode(c2));
    let l2 = void 0 !== this.toFontChar[e2];
    a2 = this.toFontChar[e2] || e2;
    if (this.missingFile) {
      const t3 = this.differences[e2] || this.defaultEncoding[e2];
      if ((".notdef" === t3 || "" === t3) && "Type1" === this.type) {
        a2 = 32;
        if ("" === t3) {
          r2 ||= this._spaceWidth;
          c2 = String.fromCharCode(a2);
        }
      }
      a2 = (function mapSpecialUnicodeValues(e3) {
        return e3 >= 65520 && e3 <= 65535 ? 0 : e3 >= 62976 && e3 <= 63743 ? Tr()[e3] || e3 : 173 === e3 ? 45 : e3;
      })(a2);
    }
    this.isType3Font && (i2 = a2);
    let h2 = null;
    if (this.seacMap?.[e2]) {
      l2 = true;
      const t3 = this.seacMap[e2];
      a2 = t3.baseFontCharCode;
      h2 = { fontChar: String.fromCodePoint(t3.accentFontCharCode), offset: t3.accentOffset };
    }
    let u2 = "";
    "number" == typeof a2 && (a2 <= 1114111 ? u2 = String.fromCodePoint(a2) : warn(`charToGlyph - invalid fontCharCode: ${a2}`));
    if (this.missingFile && this.vertical && 1 === u2.length) {
      const e3 = _r()[u2.charCodeAt(0)];
      e3 && (u2 = c2 = String.fromCharCode(e3));
    }
    n2 = new fonts_Glyph(e2, u2, c2, h2, r2, o2, i2, t2, l2);
    return this._glyphCache[e2] = n2;
  }
  charsToGlyphs(e2) {
    let t2 = this._charsCache[e2];
    if (t2) return t2;
    t2 = [];
    if (this.cMap) {
      const a2 = /* @__PURE__ */ Object.create(null), r2 = e2.length;
      let i2 = 0;
      for (; i2 < r2; ) {
        this.cMap.readCharCode(e2, i2, a2);
        const { charcode: r3, length: n2 } = a2;
        i2 += n2;
        const s2 = this._charToGlyph(r3, 1 === n2 && 32 === e2.charCodeAt(i2 - 1));
        t2.push(s2);
      }
    } else for (let a2 = 0, r2 = e2.length; a2 < r2; ++a2) {
      const r3 = e2.charCodeAt(a2), i2 = this._charToGlyph(r3, 32 === r3);
      t2.push(i2);
    }
    return this._charsCache[e2] = t2;
  }
  getCharPositions(e2) {
    const t2 = [];
    if (this.cMap) {
      const a2 = /* @__PURE__ */ Object.create(null);
      let r2 = 0;
      for (; r2 < e2.length; ) {
        this.cMap.readCharCode(e2, r2, a2);
        const i2 = a2.length;
        t2.push([r2, r2 + i2]);
        r2 += i2;
      }
    } else for (let a2 = 0, r2 = e2.length; a2 < r2; ++a2) t2.push([a2, a2 + 1]);
    return t2;
  }
  get glyphCacheValues() {
    return Object.values(this._glyphCache);
  }
  encodeString(e2) {
    const t2 = [], a2 = [], hasCurrentBufErrors = () => t2.length % 2 == 1, r2 = this.toUnicode instanceof IdentityToUnicodeMap ? (e3) => this.toUnicode.charCodeOf(e3) : (e3) => this.toUnicode.charCodeOf(String.fromCodePoint(e3));
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) {
      const n3 = e2.codePointAt(i2);
      n3 > 55295 && (n3 < 57344 || n3 > 65533) && i2++;
      if (this.toUnicode) {
        const e3 = r2(n3);
        if (-1 !== e3) {
          if (hasCurrentBufErrors()) {
            t2.push(a2.join(""));
            a2.length = 0;
          }
          for (let t3 = (this.cMap ? this.cMap.getCharCodeLength(e3) : 1) - 1; t3 >= 0; t3--) a2.push(String.fromCharCode(e3 >> 8 * t3 & 255));
          continue;
        }
      }
      if (!hasCurrentBufErrors()) {
        t2.push(a2.join(""));
        a2.length = 0;
      }
      a2.push(String.fromCodePoint(n3));
    }
    t2.push(a2.join(""));
    return t2;
  }
};
var ErrorFont = class {
  constructor(e2) {
    this.error = e2;
    this.loadedName = "g_font_error";
    this.missingFile = true;
  }
  charsToGlyphs() {
    return [];
  }
  encodeString(e2) {
    return [e2];
  }
  exportData() {
    return { error: this.error };
  }
};
var Si = 2;
var Ai = 3;
var ki = 4;
var Ci = 5;
var vi = 6;
var Fi = 7;
var Pattern = class {
  constructor() {
    unreachable("Cannot initialize Pattern.");
  }
  static parseShading(e2, t2, a2, r2, i2, n2) {
    const s2 = e2 instanceof BaseStream ? e2.dict : e2, o2 = s2.get("ShadingType");
    try {
      switch (o2) {
        case Si:
        case Ai:
          return new RadialAxialShading(s2, t2, a2, r2, i2, n2);
        case ki:
        case Ci:
        case vi:
        case Fi:
          return new MeshShading(e2, t2, a2, r2, i2, n2);
        default:
          throw new FormatError("Unsupported ShadingType: " + o2);
      }
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn(e3);
      return new DummyShading();
    }
  }
};
var BaseShading = class {
  static SMALL_NUMBER = 1e-6;
  getIR() {
    unreachable("Abstract method `getIR` called.");
  }
};
var RadialAxialShading = class extends BaseShading {
  constructor(e2, t2, a2, r2, i2, n2) {
    super();
    this.shadingType = e2.get("ShadingType");
    let s2 = 0;
    this.shadingType === Si ? s2 = 4 : this.shadingType === Ai && (s2 = 6);
    this.coordsArr = e2.getArray("Coords");
    if (!isNumberArray(this.coordsArr, s2)) throw new FormatError("RadialAxialShading: Invalid /Coords array.");
    const o2 = ColorSpaceUtils.parse({ cs: e2.getRaw("CS") || e2.getRaw("ColorSpace"), xref: t2, resources: a2, pdfFunctionFactory: r2, globalColorSpaceCache: i2, localColorSpaceCache: n2 });
    this.bbox = lookupNormalRect(e2.getArray("BBox"), null);
    let c2 = 0, l2 = 1;
    const h2 = e2.getArray("Domain");
    isNumberArray(h2, 2) && ([c2, l2] = h2);
    let u2 = false, d2 = false;
    const f2 = e2.getArray("Extend");
    (function isBooleanArray(e3, t3) {
      return Array.isArray(e3) && (null === t3 || e3.length === t3) && e3.every(((e4) => "boolean" == typeof e4));
    })(f2, 2) && ([u2, d2] = f2);
    if (!(this.shadingType !== Ai || u2 && d2)) {
      const [e3, t3, a3, r3, i3, n3] = this.coordsArr, s3 = Math.hypot(e3 - r3, t3 - i3);
      a3 <= n3 + s3 && n3 <= a3 + s3 && warn("Unsupported radial gradient.");
    }
    this.extendStart = u2;
    this.extendEnd = d2;
    const g2 = e2.getRaw("Function"), p2 = r2.create(g2, true), m2 = (l2 - c2) / 840, b2 = this.colorStops = [];
    if (c2 >= l2 || m2 <= 0) {
      info("Bad shading domain.");
      return;
    }
    const y2 = new Float32Array(o2.numComps), w2 = new Float32Array(1);
    let x2 = 0;
    w2[0] = c2;
    p2(w2, 0, y2, 0);
    const S2 = new Uint8ClampedArray(3);
    o2.getRgb(y2, 0, S2);
    let [k2, C2, v2] = S2;
    b2.push([0, Util.makeHexColor(k2, C2, v2)]);
    let F2 = 1;
    w2[0] = c2 + m2;
    p2(w2, 0, y2, 0);
    o2.getRgb(y2, 0, S2);
    let [T2, O2, M2] = S2, D2 = T2 - k2 + 1, R2 = O2 - C2 + 1, N2 = M2 - v2 + 1, E2 = T2 - k2 - 1, L2 = O2 - C2 - 1, j2 = M2 - v2 - 1;
    for (let e3 = 2; e3 < 840; e3++) {
      w2[0] = c2 + e3 * m2;
      p2(w2, 0, y2, 0);
      o2.getRgb(y2, 0, S2);
      const [t3, a3, r3] = S2, i3 = e3 - x2;
      D2 = Math.min(D2, (t3 - k2 + 1) / i3);
      R2 = Math.min(R2, (a3 - C2 + 1) / i3);
      N2 = Math.min(N2, (r3 - v2 + 1) / i3);
      E2 = Math.max(E2, (t3 - k2 - 1) / i3);
      L2 = Math.max(L2, (a3 - C2 - 1) / i3);
      j2 = Math.max(j2, (r3 - v2 - 1) / i3);
      if (!(E2 <= D2 && L2 <= R2 && j2 <= N2)) {
        const e4 = Util.makeHexColor(T2, O2, M2);
        b2.push([F2 / 840, e4]);
        D2 = t3 - T2 + 1;
        R2 = a3 - O2 + 1;
        N2 = r3 - M2 + 1;
        E2 = t3 - T2 - 1;
        L2 = a3 - O2 - 1;
        j2 = r3 - M2 - 1;
        x2 = F2;
        k2 = T2;
        C2 = O2;
        v2 = M2;
      }
      F2 = e3;
      T2 = t3;
      O2 = a3;
      M2 = r3;
    }
    b2.push([1, Util.makeHexColor(T2, O2, M2)]);
    let _2 = "transparent";
    e2.has("Background") && (_2 = o2.getRgbHex(e2.get("Background"), 0));
    if (!u2) {
      b2.unshift([0, _2]);
      b2[1][0] += BaseShading.SMALL_NUMBER;
    }
    if (!d2) {
      b2.at(-1)[0] -= BaseShading.SMALL_NUMBER;
      b2.push([1, _2]);
    }
    this.colorStops = b2;
  }
  getIR() {
    const { coordsArr: e2, shadingType: t2 } = this;
    let a2, r2, i2, n2, s2;
    if (t2 === Si) {
      r2 = [e2[0], e2[1]];
      i2 = [e2[2], e2[3]];
      n2 = null;
      s2 = null;
      a2 = "axial";
    } else if (t2 === Ai) {
      r2 = [e2[0], e2[1]];
      i2 = [e2[3], e2[4]];
      n2 = e2[2];
      s2 = e2[5];
      a2 = "radial";
    } else unreachable(`getPattern type unknown: ${t2}`);
    return ["RadialAxial", a2, this.bbox, this.colorStops, r2, i2, n2, s2];
  }
};
var MeshStreamReader = class {
  constructor(e2, t2) {
    this.stream = e2;
    this.context = t2;
    this.buffer = 0;
    this.bufferLength = 0;
    const a2 = t2.numComps;
    this.tmpCompsBuf = new Float32Array(a2);
    const r2 = t2.colorSpace.numComps;
    this.tmpCsCompsBuf = t2.colorFn ? new Float32Array(r2) : this.tmpCompsBuf;
  }
  get hasData() {
    if (this.stream.end) return this.stream.pos < this.stream.end;
    if (this.bufferLength > 0) return true;
    const e2 = this.stream.getByte();
    if (e2 < 0) return false;
    this.buffer = e2;
    this.bufferLength = 8;
    return true;
  }
  readBits(e2) {
    const { stream: t2 } = this;
    let { buffer: a2, bufferLength: r2 } = this;
    if (32 === e2) {
      if (0 === r2) return t2.getInt32() >>> 0;
      a2 = a2 << 24 | t2.getByte() << 16 | t2.getByte() << 8 | t2.getByte();
      const e3 = t2.getByte();
      this.buffer = e3 & (1 << r2) - 1;
      return (a2 << 8 - r2 | (255 & e3) >> r2) >>> 0;
    }
    if (8 === e2 && 0 === r2) return t2.getByte();
    for (; r2 < e2; ) {
      a2 = a2 << 8 | t2.getByte();
      r2 += 8;
    }
    r2 -= e2;
    this.bufferLength = r2;
    this.buffer = a2 & (1 << r2) - 1;
    return a2 >> r2;
  }
  align() {
    this.buffer = 0;
    this.bufferLength = 0;
  }
  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }
  readCoordinate() {
    const { bitsPerCoordinate: e2, decode: t2 } = this.context, a2 = this.readBits(e2), r2 = this.readBits(e2), i2 = e2 < 32 ? 1 / ((1 << e2) - 1) : 23283064365386963e-26;
    return [a2 * i2 * (t2[1] - t2[0]) + t2[0], r2 * i2 * (t2[3] - t2[2]) + t2[2]];
  }
  readComponents() {
    const { bitsPerComponent: e2, colorFn: t2, colorSpace: a2, decode: r2, numComps: i2 } = this.context, n2 = e2 < 32 ? 1 / ((1 << e2) - 1) : 23283064365386963e-26, s2 = this.tmpCompsBuf;
    for (let t3 = 0, a3 = 4; t3 < i2; t3++, a3 += 2) {
      const i3 = this.readBits(e2);
      s2[t3] = i3 * n2 * (r2[a3 + 1] - r2[a3]) + r2[a3];
    }
    const o2 = this.tmpCsCompsBuf;
    t2?.(s2, 0, o2, 0);
    return a2.getRgb(o2, 0);
  }
};
var Ii = /* @__PURE__ */ Object.create(null);
function getB(e2) {
  return Ii[e2] ||= (function buildB(e3) {
    const t2 = [];
    for (let a2 = 0; a2 <= e3; a2++) {
      const r2 = a2 / e3, i2 = 1 - r2;
      t2.push(new Float32Array([i2 ** 3, 3 * r2 * i2 ** 2, 3 * r2 ** 2 * i2, r2 ** 3]));
    }
    return t2;
  })(e2);
}
var MeshShading = class _MeshShading extends BaseShading {
  static MIN_SPLIT_PATCH_CHUNKS_AMOUNT = 3;
  static MAX_SPLIT_PATCH_CHUNKS_AMOUNT = 20;
  static TRIANGLE_DENSITY = 20;
  constructor(e2, t2, a2, r2, i2, n2) {
    super();
    if (!(e2 instanceof BaseStream)) throw new FormatError("Mesh data is not a stream");
    const s2 = e2.dict;
    this.shadingType = s2.get("ShadingType");
    this.bbox = lookupNormalRect(s2.getArray("BBox"), null);
    const o2 = ColorSpaceUtils.parse({ cs: s2.getRaw("CS") || s2.getRaw("ColorSpace"), xref: t2, resources: a2, pdfFunctionFactory: r2, globalColorSpaceCache: i2, localColorSpaceCache: n2 });
    this.background = s2.has("Background") ? o2.getRgb(s2.get("Background"), 0) : null;
    const c2 = s2.getRaw("Function"), l2 = c2 ? r2.create(c2, true) : null;
    this.coords = [];
    this.colors = [];
    this.figures = [];
    const h2 = { bitsPerCoordinate: s2.get("BitsPerCoordinate"), bitsPerComponent: s2.get("BitsPerComponent"), bitsPerFlag: s2.get("BitsPerFlag"), decode: s2.getArray("Decode"), colorFn: l2, colorSpace: o2, numComps: l2 ? 1 : o2.numComps }, u2 = new MeshStreamReader(e2, h2);
    let d2 = false;
    switch (this.shadingType) {
      case ki:
        this._decodeType4Shading(u2);
        break;
      case Ci:
        const e3 = 0 | s2.get("VerticesPerRow");
        if (e3 < 2) throw new FormatError("Invalid VerticesPerRow");
        this._decodeType5Shading(u2, e3);
        break;
      case vi:
        this._decodeType6Shading(u2);
        d2 = true;
        break;
      case Fi:
        this._decodeType7Shading(u2);
        d2 = true;
        break;
      default:
        unreachable("Unsupported mesh type.");
    }
    if (d2) {
      this._updateBounds();
      for (let e3 = 0, t3 = this.figures.length; e3 < t3; e3++) this._buildFigureFromPatch(e3);
    }
    this._updateBounds();
    this._packData();
  }
  _decodeType4Shading(e2) {
    const t2 = this.coords, a2 = this.colors, r2 = [], i2 = [];
    let n2 = 0;
    for (; e2.hasData; ) {
      const s2 = e2.readFlag(), o2 = e2.readCoordinate(), c2 = e2.readComponents();
      if (0 === n2) {
        if (!(0 <= s2 && s2 <= 2)) throw new FormatError("Unknown type4 flag");
        switch (s2) {
          case 0:
            n2 = 3;
            break;
          case 1:
            i2.push(i2.at(-2), i2.at(-1));
            n2 = 1;
            break;
          case 2:
            i2.push(i2.at(-3), i2.at(-1));
            n2 = 1;
        }
        r2.push(s2);
      }
      i2.push(t2.length);
      t2.push(o2);
      a2.push(c2);
      n2--;
      e2.align();
    }
    this.figures.push({ type: "triangles", coords: new Int32Array(i2), colors: new Int32Array(i2) });
  }
  _decodeType5Shading(e2, t2) {
    const a2 = this.coords, r2 = this.colors, i2 = [];
    for (; e2.hasData; ) {
      const t3 = e2.readCoordinate(), n2 = e2.readComponents();
      i2.push(a2.length);
      a2.push(t3);
      r2.push(n2);
    }
    this.figures.push({ type: "lattice", coords: new Int32Array(i2), colors: new Int32Array(i2), verticesPerRow: t2 });
  }
  _decodeType6Shading(e2) {
    const t2 = this.coords, a2 = this.colors, r2 = new Int32Array(16), i2 = new Int32Array(4);
    for (; e2.hasData; ) {
      const n2 = e2.readFlag();
      if (!(0 <= n2 && n2 <= 3)) throw new FormatError("Unknown type6 flag");
      const s2 = t2.length;
      for (let a3 = 0, r3 = 0 !== n2 ? 8 : 12; a3 < r3; a3++) t2.push(e2.readCoordinate());
      const o2 = a2.length;
      for (let t3 = 0, r3 = 0 !== n2 ? 2 : 4; t3 < r3; t3++) a2.push(e2.readComponents());
      let c2, l2, h2, u2;
      switch (n2) {
        case 0:
          r2[12] = s2 + 3;
          r2[13] = s2 + 4;
          r2[14] = s2 + 5;
          r2[15] = s2 + 6;
          r2[8] = s2 + 2;
          r2[11] = s2 + 7;
          r2[4] = s2 + 1;
          r2[7] = s2 + 8;
          r2[0] = s2;
          r2[1] = s2 + 11;
          r2[2] = s2 + 10;
          r2[3] = s2 + 9;
          i2[2] = o2 + 1;
          i2[3] = o2 + 2;
          i2[0] = o2;
          i2[1] = o2 + 3;
          break;
        case 1:
          c2 = r2[12];
          l2 = r2[13];
          h2 = r2[14];
          u2 = r2[15];
          r2[12] = u2;
          r2[13] = s2 + 0;
          r2[14] = s2 + 1;
          r2[15] = s2 + 2;
          r2[8] = h2;
          r2[11] = s2 + 3;
          r2[4] = l2;
          r2[7] = s2 + 4;
          r2[0] = c2;
          r2[1] = s2 + 7;
          r2[2] = s2 + 6;
          r2[3] = s2 + 5;
          c2 = i2[2];
          l2 = i2[3];
          i2[2] = l2;
          i2[3] = o2;
          i2[0] = c2;
          i2[1] = o2 + 1;
          break;
        case 2:
          c2 = r2[15];
          l2 = r2[11];
          r2[12] = r2[3];
          r2[13] = s2 + 0;
          r2[14] = s2 + 1;
          r2[15] = s2 + 2;
          r2[8] = r2[7];
          r2[11] = s2 + 3;
          r2[4] = l2;
          r2[7] = s2 + 4;
          r2[0] = c2;
          r2[1] = s2 + 7;
          r2[2] = s2 + 6;
          r2[3] = s2 + 5;
          c2 = i2[3];
          i2[2] = i2[1];
          i2[3] = o2;
          i2[0] = c2;
          i2[1] = o2 + 1;
          break;
        case 3:
          r2[12] = r2[0];
          r2[13] = s2 + 0;
          r2[14] = s2 + 1;
          r2[15] = s2 + 2;
          r2[8] = r2[1];
          r2[11] = s2 + 3;
          r2[4] = r2[2];
          r2[7] = s2 + 4;
          r2[0] = r2[3];
          r2[1] = s2 + 7;
          r2[2] = s2 + 6;
          r2[3] = s2 + 5;
          i2[2] = i2[0];
          i2[3] = o2;
          i2[0] = i2[1];
          i2[1] = o2 + 1;
      }
      r2[5] = t2.length;
      t2.push([(-4 * t2[r2[0]][0] - t2[r2[15]][0] + 6 * (t2[r2[4]][0] + t2[r2[1]][0]) - 2 * (t2[r2[12]][0] + t2[r2[3]][0]) + 3 * (t2[r2[13]][0] + t2[r2[7]][0])) / 9, (-4 * t2[r2[0]][1] - t2[r2[15]][1] + 6 * (t2[r2[4]][1] + t2[r2[1]][1]) - 2 * (t2[r2[12]][1] + t2[r2[3]][1]) + 3 * (t2[r2[13]][1] + t2[r2[7]][1])) / 9]);
      r2[6] = t2.length;
      t2.push([(-4 * t2[r2[3]][0] - t2[r2[12]][0] + 6 * (t2[r2[2]][0] + t2[r2[7]][0]) - 2 * (t2[r2[0]][0] + t2[r2[15]][0]) + 3 * (t2[r2[4]][0] + t2[r2[14]][0])) / 9, (-4 * t2[r2[3]][1] - t2[r2[12]][1] + 6 * (t2[r2[2]][1] + t2[r2[7]][1]) - 2 * (t2[r2[0]][1] + t2[r2[15]][1]) + 3 * (t2[r2[4]][1] + t2[r2[14]][1])) / 9]);
      r2[9] = t2.length;
      t2.push([(-4 * t2[r2[12]][0] - t2[r2[3]][0] + 6 * (t2[r2[8]][0] + t2[r2[13]][0]) - 2 * (t2[r2[0]][0] + t2[r2[15]][0]) + 3 * (t2[r2[11]][0] + t2[r2[1]][0])) / 9, (-4 * t2[r2[12]][1] - t2[r2[3]][1] + 6 * (t2[r2[8]][1] + t2[r2[13]][1]) - 2 * (t2[r2[0]][1] + t2[r2[15]][1]) + 3 * (t2[r2[11]][1] + t2[r2[1]][1])) / 9]);
      r2[10] = t2.length;
      t2.push([(-4 * t2[r2[15]][0] - t2[r2[0]][0] + 6 * (t2[r2[11]][0] + t2[r2[14]][0]) - 2 * (t2[r2[12]][0] + t2[r2[3]][0]) + 3 * (t2[r2[2]][0] + t2[r2[8]][0])) / 9, (-4 * t2[r2[15]][1] - t2[r2[0]][1] + 6 * (t2[r2[11]][1] + t2[r2[14]][1]) - 2 * (t2[r2[12]][1] + t2[r2[3]][1]) + 3 * (t2[r2[2]][1] + t2[r2[8]][1])) / 9]);
      this.figures.push({ type: "patch", coords: new Int32Array(r2), colors: new Int32Array(i2) });
    }
  }
  _decodeType7Shading(e2) {
    const t2 = this.coords, a2 = this.colors, r2 = new Int32Array(16), i2 = new Int32Array(4);
    for (; e2.hasData; ) {
      const n2 = e2.readFlag();
      if (!(0 <= n2 && n2 <= 3)) throw new FormatError("Unknown type7 flag");
      const s2 = t2.length;
      for (let a3 = 0, r3 = 0 !== n2 ? 12 : 16; a3 < r3; a3++) t2.push(e2.readCoordinate());
      const o2 = a2.length;
      for (let t3 = 0, r3 = 0 !== n2 ? 2 : 4; t3 < r3; t3++) a2.push(e2.readComponents());
      let c2, l2, h2, u2;
      switch (n2) {
        case 0:
          r2[12] = s2 + 3;
          r2[13] = s2 + 4;
          r2[14] = s2 + 5;
          r2[15] = s2 + 6;
          r2[8] = s2 + 2;
          r2[9] = s2 + 13;
          r2[10] = s2 + 14;
          r2[11] = s2 + 7;
          r2[4] = s2 + 1;
          r2[5] = s2 + 12;
          r2[6] = s2 + 15;
          r2[7] = s2 + 8;
          r2[0] = s2;
          r2[1] = s2 + 11;
          r2[2] = s2 + 10;
          r2[3] = s2 + 9;
          i2[2] = o2 + 1;
          i2[3] = o2 + 2;
          i2[0] = o2;
          i2[1] = o2 + 3;
          break;
        case 1:
          c2 = r2[12];
          l2 = r2[13];
          h2 = r2[14];
          u2 = r2[15];
          r2[12] = u2;
          r2[13] = s2 + 0;
          r2[14] = s2 + 1;
          r2[15] = s2 + 2;
          r2[8] = h2;
          r2[9] = s2 + 9;
          r2[10] = s2 + 10;
          r2[11] = s2 + 3;
          r2[4] = l2;
          r2[5] = s2 + 8;
          r2[6] = s2 + 11;
          r2[7] = s2 + 4;
          r2[0] = c2;
          r2[1] = s2 + 7;
          r2[2] = s2 + 6;
          r2[3] = s2 + 5;
          c2 = i2[2];
          l2 = i2[3];
          i2[2] = l2;
          i2[3] = o2;
          i2[0] = c2;
          i2[1] = o2 + 1;
          break;
        case 2:
          c2 = r2[15];
          l2 = r2[11];
          r2[12] = r2[3];
          r2[13] = s2 + 0;
          r2[14] = s2 + 1;
          r2[15] = s2 + 2;
          r2[8] = r2[7];
          r2[9] = s2 + 9;
          r2[10] = s2 + 10;
          r2[11] = s2 + 3;
          r2[4] = l2;
          r2[5] = s2 + 8;
          r2[6] = s2 + 11;
          r2[7] = s2 + 4;
          r2[0] = c2;
          r2[1] = s2 + 7;
          r2[2] = s2 + 6;
          r2[3] = s2 + 5;
          c2 = i2[3];
          i2[2] = i2[1];
          i2[3] = o2;
          i2[0] = c2;
          i2[1] = o2 + 1;
          break;
        case 3:
          r2[12] = r2[0];
          r2[13] = s2 + 0;
          r2[14] = s2 + 1;
          r2[15] = s2 + 2;
          r2[8] = r2[1];
          r2[9] = s2 + 9;
          r2[10] = s2 + 10;
          r2[11] = s2 + 3;
          r2[4] = r2[2];
          r2[5] = s2 + 8;
          r2[6] = s2 + 11;
          r2[7] = s2 + 4;
          r2[0] = r2[3];
          r2[1] = s2 + 7;
          r2[2] = s2 + 6;
          r2[3] = s2 + 5;
          i2[2] = i2[0];
          i2[3] = o2;
          i2[0] = i2[1];
          i2[1] = o2 + 1;
      }
      this.figures.push({ type: "patch", coords: new Int32Array(r2), colors: new Int32Array(i2) });
    }
  }
  _buildFigureFromPatch(e2) {
    const t2 = this.figures[e2];
    assert("patch" === t2.type, "Unexpected patch mesh figure");
    const a2 = this.coords, r2 = this.colors, i2 = t2.coords, n2 = t2.colors, s2 = Math.min(a2[i2[0]][0], a2[i2[3]][0], a2[i2[12]][0], a2[i2[15]][0]), o2 = Math.min(a2[i2[0]][1], a2[i2[3]][1], a2[i2[12]][1], a2[i2[15]][1]), c2 = Math.max(a2[i2[0]][0], a2[i2[3]][0], a2[i2[12]][0], a2[i2[15]][0]), l2 = Math.max(a2[i2[0]][1], a2[i2[3]][1], a2[i2[12]][1], a2[i2[15]][1]);
    let h2 = Math.ceil((c2 - s2) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    h2 = MathClamp(h2, _MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, _MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
    let u2 = Math.ceil((l2 - o2) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    u2 = MathClamp(u2, _MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, _MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT);
    const d2 = h2 + 1, f2 = new Int32Array((u2 + 1) * d2), g2 = new Int32Array((u2 + 1) * d2);
    let p2 = 0;
    const m2 = new Uint8Array(3), b2 = new Uint8Array(3), y2 = r2[n2[0]], w2 = r2[n2[1]], x2 = r2[n2[2]], S2 = r2[n2[3]], k2 = getB(u2), C2 = getB(h2);
    for (let e3 = 0; e3 <= u2; e3++) {
      m2[0] = (y2[0] * (u2 - e3) + x2[0] * e3) / u2 | 0;
      m2[1] = (y2[1] * (u2 - e3) + x2[1] * e3) / u2 | 0;
      m2[2] = (y2[2] * (u2 - e3) + x2[2] * e3) / u2 | 0;
      b2[0] = (w2[0] * (u2 - e3) + S2[0] * e3) / u2 | 0;
      b2[1] = (w2[1] * (u2 - e3) + S2[1] * e3) / u2 | 0;
      b2[2] = (w2[2] * (u2 - e3) + S2[2] * e3) / u2 | 0;
      for (let t3 = 0; t3 <= h2; t3++, p2++) {
        if (!(0 !== e3 && e3 !== u2 || 0 !== t3 && t3 !== h2)) continue;
        let n3 = 0, s3 = 0, o3 = 0;
        for (let r3 = 0; r3 <= 3; r3++) for (let c4 = 0; c4 <= 3; c4++, o3++) {
          const l3 = k2[e3][r3] * C2[t3][c4];
          n3 += a2[i2[o3]][0] * l3;
          s3 += a2[i2[o3]][1] * l3;
        }
        f2[p2] = a2.length;
        a2.push([n3, s3]);
        g2[p2] = r2.length;
        const c3 = new Uint8Array(3);
        c3[0] = (m2[0] * (h2 - t3) + b2[0] * t3) / h2 | 0;
        c3[1] = (m2[1] * (h2 - t3) + b2[1] * t3) / h2 | 0;
        c3[2] = (m2[2] * (h2 - t3) + b2[2] * t3) / h2 | 0;
        r2.push(c3);
      }
    }
    f2[0] = i2[0];
    g2[0] = n2[0];
    f2[h2] = i2[3];
    g2[h2] = n2[1];
    f2[d2 * u2] = i2[12];
    g2[d2 * u2] = n2[2];
    f2[d2 * u2 + h2] = i2[15];
    g2[d2 * u2 + h2] = n2[3];
    this.figures[e2] = { type: "lattice", coords: f2, colors: g2, verticesPerRow: d2 };
  }
  _updateBounds() {
    let e2 = this.coords[0][0], t2 = this.coords[0][1], a2 = e2, r2 = t2;
    for (let i2 = 1, n2 = this.coords.length; i2 < n2; i2++) {
      const n3 = this.coords[i2][0], s2 = this.coords[i2][1];
      e2 = e2 > n3 ? n3 : e2;
      t2 = t2 > s2 ? s2 : t2;
      a2 = a2 < n3 ? n3 : a2;
      r2 = r2 < s2 ? s2 : r2;
    }
    this.bounds = [e2, t2, a2, r2];
  }
  _packData() {
    let e2, t2, a2, r2;
    const i2 = this.coords, n2 = new Float32Array(2 * i2.length);
    for (e2 = 0, a2 = 0, t2 = i2.length; e2 < t2; e2++) {
      const t3 = i2[e2];
      n2[a2++] = t3[0];
      n2[a2++] = t3[1];
    }
    this.coords = n2;
    const s2 = this.colors, o2 = new Uint8Array(3 * s2.length);
    for (e2 = 0, a2 = 0, t2 = s2.length; e2 < t2; e2++) {
      const t3 = s2[e2];
      o2[a2++] = t3[0];
      o2[a2++] = t3[1];
      o2[a2++] = t3[2];
    }
    this.colors = o2;
    const c2 = this.figures;
    for (e2 = 0, t2 = c2.length; e2 < t2; e2++) {
      const t3 = c2[e2], i3 = t3.coords, n3 = t3.colors;
      for (a2 = 0, r2 = i3.length; a2 < r2; a2++) {
        i3[a2] *= 2;
        n3[a2] *= 3;
      }
    }
  }
  getIR() {
    const { bounds: e2 } = this;
    if (e2[2] - e2[0] == 0 || e2[3] - e2[1] == 0) throw new FormatError(`Invalid MeshShading bounds: [${e2}].`);
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, e2, this.bbox, this.background];
  }
};
var DummyShading = class extends BaseShading {
  getIR() {
    return ["Dummy"];
  }
};
function getTilingPatternIR(e2, t2, a2) {
  const r2 = lookupMatrix(t2.getArray("Matrix"), Fa), i2 = lookupNormalRect(t2.getArray("BBox"), null);
  if (!i2 || i2[2] - i2[0] == 0 || i2[3] - i2[1] == 0) throw new FormatError("Invalid getTilingPatternIR /BBox array.");
  const n2 = t2.get("XStep");
  if ("number" != typeof n2) throw new FormatError("Invalid getTilingPatternIR /XStep value.");
  const s2 = t2.get("YStep");
  if ("number" != typeof s2) throw new FormatError("Invalid getTilingPatternIR /YStep value.");
  const o2 = t2.get("PaintType");
  if (!Number.isInteger(o2)) throw new FormatError("Invalid getTilingPatternIR /PaintType value.");
  const c2 = t2.get("TilingType");
  if (!Number.isInteger(c2)) throw new FormatError("Invalid getTilingPatternIR /TilingType value.");
  return ["TilingPattern", a2, e2, r2, i2, n2, s2, o2, c2];
}
var Ti = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Oi = { lineHeight: 1.2207, lineGap: 0.2207 };
var Mi = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Di = { lineHeight: 1.2207, lineGap: 0.2207 };
var Bi = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Ri = { lineHeight: 1.2207, lineGap: 0.2207 };
var Ni = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Ei = { lineHeight: 1.2207, lineGap: 0.2207 };
var Pi = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var ji = { lineHeight: 1.2, lineGap: 0.2 };
var _i = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Xi = { lineHeight: 1.35, lineGap: 0.2 };
var qi = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var Hi = { lineHeight: 1.35, lineGap: 0.2 };
var Wi = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var zi = { lineHeight: 1.2, lineGap: 0.2 };
var $i = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
var Gi = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
var Vi = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333];
var Ki = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
var Ji = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
var Yi = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
var Zi = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285];
var Qi = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
var en = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var tn = { lineHeight: 1.2, lineGap: 0.2 };
var an = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var rn = { lineHeight: 1.2, lineGap: 0.2 };
var nn = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var sn = { lineHeight: 1.2, lineGap: 0.2 };
var on = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var cn = { lineHeight: 1.2, lineGap: 0.2 };
var ln = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var hn = { lineHeight: 1.33008, lineGap: 0 };
var un = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var dn = { lineHeight: 1.33008, lineGap: 0 };
var fn = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var gn = { lineHeight: 1.33008, lineGap: 0 };
var pn = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var mn = { lineHeight: 1.33008, lineGap: 0 };
var bn = getLookupTableFactory((function(e2) {
  e2["MyriadPro-Regular"] = e2["PdfJS-Fallback-Regular"] = { name: "LiberationSans-Regular", factors: on, baseWidths: Zi, baseMapping: Qi, metrics: cn };
  e2["MyriadPro-Bold"] = e2["PdfJS-Fallback-Bold"] = { name: "LiberationSans-Bold", factors: en, baseWidths: $i, baseMapping: Gi, metrics: tn };
  e2["MyriadPro-It"] = e2["MyriadPro-Italic"] = e2["PdfJS-Fallback-Italic"] = { name: "LiberationSans-Italic", factors: nn, baseWidths: Ji, baseMapping: Yi, metrics: sn };
  e2["MyriadPro-BoldIt"] = e2["MyriadPro-BoldItalic"] = e2["PdfJS-Fallback-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: an, baseWidths: Vi, baseMapping: Ki, metrics: rn };
  e2.ArialMT = e2.Arial = e2["Arial-Regular"] = { name: "LiberationSans-Regular", baseWidths: Zi, baseMapping: Qi };
  e2["Arial-BoldMT"] = e2["Arial-Bold"] = { name: "LiberationSans-Bold", baseWidths: $i, baseMapping: Gi };
  e2["Arial-ItalicMT"] = e2["Arial-Italic"] = { name: "LiberationSans-Italic", baseWidths: Ji, baseMapping: Yi };
  e2["Arial-BoldItalicMT"] = e2["Arial-BoldItalic"] = { name: "LiberationSans-BoldItalic", baseWidths: Vi, baseMapping: Ki };
  e2["Calibri-Regular"] = { name: "LiberationSans-Regular", factors: Ni, baseWidths: Zi, baseMapping: Qi, metrics: Ei };
  e2["Calibri-Bold"] = { name: "LiberationSans-Bold", factors: Ti, baseWidths: $i, baseMapping: Gi, metrics: Oi };
  e2["Calibri-Italic"] = { name: "LiberationSans-Italic", factors: Bi, baseWidths: Ji, baseMapping: Yi, metrics: Ri };
  e2["Calibri-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: Mi, baseWidths: Vi, baseMapping: Ki, metrics: Di };
  e2["Segoeui-Regular"] = { name: "LiberationSans-Regular", factors: pn, baseWidths: Zi, baseMapping: Qi, metrics: mn };
  e2["Segoeui-Bold"] = { name: "LiberationSans-Bold", factors: ln, baseWidths: $i, baseMapping: Gi, metrics: hn };
  e2["Segoeui-Italic"] = { name: "LiberationSans-Italic", factors: fn, baseWidths: Ji, baseMapping: Yi, metrics: gn };
  e2["Segoeui-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: un, baseWidths: Vi, baseMapping: Ki, metrics: dn };
  e2["Helvetica-Regular"] = e2.Helvetica = { name: "LiberationSans-Regular", factors: Wi, baseWidths: Zi, baseMapping: Qi, metrics: zi };
  e2["Helvetica-Bold"] = { name: "LiberationSans-Bold", factors: Pi, baseWidths: $i, baseMapping: Gi, metrics: ji };
  e2["Helvetica-Italic"] = { name: "LiberationSans-Italic", factors: qi, baseWidths: Ji, baseMapping: Yi, metrics: Hi };
  e2["Helvetica-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: _i, baseWidths: Vi, baseMapping: Ki, metrics: Xi };
}));
function getXfaFontName(e2) {
  const t2 = normalizeFontName(e2);
  return bn()[t2];
}
function getXfaFontDict(e2) {
  const t2 = (function getXfaFontWidths(e3) {
    const t3 = getXfaFontName(e3);
    if (!t3) return null;
    const { baseWidths: a3, baseMapping: r3, factors: i3 } = t3, n2 = i3 ? a3.map(((e4, t4) => e4 * i3[t4])) : a3;
    let s2, o2 = -2;
    const c2 = [];
    for (const [e4, t4] of r3.map(((e5, t5) => [e5, t5])).sort((([e5], [t5]) => e5 - t5))) if (-1 !== e4) if (e4 === o2 + 1) {
      s2.push(n2[t4]);
      o2 += 1;
    } else {
      o2 = e4;
      s2 = [n2[t4]];
      c2.push(e4, s2);
    }
    return c2;
  })(e2), a2 = new Dict(null);
  a2.set("BaseFont", Name.get(e2));
  a2.set("Type", Name.get("Font"));
  a2.set("Subtype", Name.get("CIDFontType2"));
  a2.set("Encoding", Name.get("Identity-H"));
  a2.set("CIDToGIDMap", Name.get("Identity"));
  a2.set("W", t2);
  a2.set("FirstChar", t2[0]);
  a2.set("LastChar", t2.at(-2) + t2.at(-1).length - 1);
  const r2 = new Dict(null);
  a2.set("FontDescriptor", r2);
  const i2 = new Dict(null);
  i2.set("Ordering", "Identity");
  i2.set("Registry", "Adobe");
  i2.set("Supplement", 0);
  a2.set("CIDSystemInfo", i2);
  return a2;
}
var PostScriptParser = class {
  constructor(e2) {
    this.lexer = e2;
    this.operators = [];
    this.token = null;
    this.prev = null;
  }
  nextToken() {
    this.prev = this.token;
    this.token = this.lexer.getToken();
  }
  accept(e2) {
    if (this.token.type === e2) {
      this.nextToken();
      return true;
    }
    return false;
  }
  expect(e2) {
    if (this.accept(e2)) return true;
    throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${e2}.`);
  }
  parse() {
    this.nextToken();
    this.expect(yn.LBRACE);
    this.parseBlock();
    this.expect(yn.RBRACE);
    return this.operators;
  }
  parseBlock() {
    for (; ; ) if (this.accept(yn.NUMBER)) this.operators.push(this.prev.value);
    else if (this.accept(yn.OPERATOR)) this.operators.push(this.prev.value);
    else {
      if (!this.accept(yn.LBRACE)) return;
      this.parseCondition();
    }
  }
  parseCondition() {
    const e2 = this.operators.length;
    this.operators.push(null, null);
    this.parseBlock();
    this.expect(yn.RBRACE);
    if (this.accept(yn.IF)) {
      this.operators[e2] = this.operators.length;
      this.operators[e2 + 1] = "jz";
    } else {
      if (!this.accept(yn.LBRACE)) throw new FormatError("PS Function: error parsing conditional.");
      {
        const t2 = this.operators.length;
        this.operators.push(null, null);
        const a2 = this.operators.length;
        this.parseBlock();
        this.expect(yn.RBRACE);
        this.expect(yn.IFELSE);
        this.operators[t2] = this.operators.length;
        this.operators[t2 + 1] = "j";
        this.operators[e2] = a2;
        this.operators[e2 + 1] = "jz";
      }
    }
  }
};
var yn = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 };
var PostScriptToken = class _PostScriptToken {
  static get opCache() {
    return shadow(this, "opCache", /* @__PURE__ */ Object.create(null));
  }
  constructor(e2, t2) {
    this.type = e2;
    this.value = t2;
  }
  static getOperator(e2) {
    return _PostScriptToken.opCache[e2] ||= new _PostScriptToken(yn.OPERATOR, e2);
  }
  static get LBRACE() {
    return shadow(this, "LBRACE", new _PostScriptToken(yn.LBRACE, "{"));
  }
  static get RBRACE() {
    return shadow(this, "RBRACE", new _PostScriptToken(yn.RBRACE, "}"));
  }
  static get IF() {
    return shadow(this, "IF", new _PostScriptToken(yn.IF, "IF"));
  }
  static get IFELSE() {
    return shadow(this, "IFELSE", new _PostScriptToken(yn.IFELSE, "IFELSE"));
  }
};
var PostScriptLexer = class {
  constructor(e2) {
    this.stream = e2;
    this.nextChar();
    this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let e2 = false, t2 = this.currentChar;
    for (; ; ) {
      if (t2 < 0) return wa;
      if (e2) 10 !== t2 && 13 !== t2 || (e2 = false);
      else if (37 === t2) e2 = true;
      else if (!isWhiteSpace(t2)) break;
      t2 = this.nextChar();
    }
    switch (0 | t2) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return new PostScriptToken(yn.NUMBER, this.getNumber());
      case 123:
        this.nextChar();
        return PostScriptToken.LBRACE;
      case 125:
        this.nextChar();
        return PostScriptToken.RBRACE;
    }
    const a2 = this.strBuf;
    a2.length = 0;
    a2[0] = String.fromCharCode(t2);
    for (; (t2 = this.nextChar()) >= 0 && (t2 >= 65 && t2 <= 90 || t2 >= 97 && t2 <= 122); ) a2.push(String.fromCharCode(t2));
    const r2 = a2.join("");
    switch (r2.toLowerCase()) {
      case "if":
        return PostScriptToken.IF;
      case "ifelse":
        return PostScriptToken.IFELSE;
      default:
        return PostScriptToken.getOperator(r2);
    }
  }
  getNumber() {
    let e2 = this.currentChar;
    const t2 = this.strBuf;
    t2.length = 0;
    t2[0] = String.fromCharCode(e2);
    for (; (e2 = this.nextChar()) >= 0 && (e2 >= 48 && e2 <= 57 || 45 === e2 || 46 === e2); ) t2.push(String.fromCharCode(e2));
    const a2 = parseFloat(t2.join(""));
    if (isNaN(a2)) throw new FormatError(`Invalid floating point number: ${a2}`);
    return a2;
  }
};
var BaseLocalCache = class {
  constructor(e2) {
    this._onlyRefs = true === e2?.onlyRefs;
    if (!this._onlyRefs) {
      this._nameRefMap = /* @__PURE__ */ new Map();
      this._imageMap = /* @__PURE__ */ new Map();
    }
    this._imageCache = new RefSetCache();
  }
  getByName(e2) {
    this._onlyRefs && unreachable("Should not call `getByName` method.");
    const t2 = this._nameRefMap.get(e2);
    return t2 ? this.getByRef(t2) : this._imageMap.get(e2) || null;
  }
  getByRef(e2) {
    return this._imageCache.get(e2) || null;
  }
  set(e2, t2, a2) {
    unreachable("Abstract method `set` called.");
  }
};
var LocalImageCache = class extends BaseLocalCache {
  set(e2, t2 = null, a2) {
    if ("string" != typeof e2) throw new Error('LocalImageCache.set - expected "name" argument.');
    if (t2) {
      if (this._imageCache.has(t2)) return;
      this._nameRefMap.set(e2, t2);
      this._imageCache.put(t2, a2);
    } else this._imageMap.has(e2) || this._imageMap.set(e2, a2);
  }
};
var LocalColorSpaceCache = class extends BaseLocalCache {
  set(e2 = null, t2 = null, a2) {
    if ("string" != typeof e2 && !t2) throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    if (t2) {
      if (this._imageCache.has(t2)) return;
      null !== e2 && this._nameRefMap.set(e2, t2);
      this._imageCache.put(t2, a2);
    } else this._imageMap.has(e2) || this._imageMap.set(e2, a2);
  }
};
var LocalFunctionCache = class extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, a2) {
    if (!t2) throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, a2);
  }
};
var LocalGStateCache = class extends BaseLocalCache {
  set(e2, t2 = null, a2) {
    if ("string" != typeof e2) throw new Error('LocalGStateCache.set - expected "name" argument.');
    if (t2) {
      if (this._imageCache.has(t2)) return;
      this._nameRefMap.set(e2, t2);
      this._imageCache.put(t2, a2);
    } else this._imageMap.has(e2) || this._imageMap.set(e2, a2);
  }
};
var LocalTilingPatternCache = class extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, a2) {
    if (!t2) throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, a2);
  }
};
var RegionalImageCache = class extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, a2) {
    if (!t2) throw new Error('RegionalImageCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, a2);
  }
};
var GlobalColorSpaceCache = class extends BaseLocalCache {
  constructor(e2) {
    super({ onlyRefs: true });
  }
  set(e2 = null, t2, a2) {
    if (!t2) throw new Error('GlobalColorSpaceCache.set - expected "ref" argument.');
    this._imageCache.has(t2) || this._imageCache.put(t2, a2);
  }
  clear() {
    this._imageCache.clear();
  }
};
var GlobalImageCache = class _GlobalImageCache {
  static NUM_PAGES_THRESHOLD = 2;
  static MIN_IMAGES_TO_CACHE = 10;
  static MAX_BYTE_SIZE = 5e7;
  #H = new RefSet();
  constructor() {
    this._refCache = new RefSetCache();
    this._imageCache = new RefSetCache();
  }
  get #W() {
    let e2 = 0;
    for (const t2 of this._imageCache) e2 += t2.byteSize;
    return e2;
  }
  get #z() {
    return !(this._imageCache.size < _GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(this.#W < _GlobalImageCache.MAX_BYTE_SIZE);
  }
  shouldCache(e2, t2) {
    let a2 = this._refCache.get(e2);
    if (!a2) {
      a2 = /* @__PURE__ */ new Set();
      this._refCache.put(e2, a2);
    }
    a2.add(t2);
    return !(a2.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e2) && this.#z);
  }
  addDecodeFailed(e2) {
    this.#H.put(e2);
  }
  hasDecodeFailed(e2) {
    return this.#H.has(e2);
  }
  addByteSize(e2, t2) {
    const a2 = this._imageCache.get(e2);
    a2 && (a2.byteSize || (a2.byteSize = t2));
  }
  getData(e2, t2) {
    const a2 = this._refCache.get(e2);
    if (!a2) return null;
    if (a2.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) return null;
    const r2 = this._imageCache.get(e2);
    if (!r2) return null;
    a2.add(t2);
    return r2;
  }
  setData(e2, t2) {
    if (!this._refCache.has(e2)) throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
    this._imageCache.has(e2) || (this.#z ? warn("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e2, t2));
  }
  clear(e2 = false) {
    if (!e2) {
      this.#H.clear();
      this._refCache.clear();
    }
    this._imageCache.clear();
  }
};
var PDFFunctionFactory = class {
  constructor({ xref: e2, isEvalSupported: t2 = true }) {
    this.xref = e2;
    this.isEvalSupported = false !== t2;
  }
  create(e2, t2 = false) {
    let a2, r2;
    e2 instanceof Ref ? a2 = e2 : e2 instanceof Dict ? a2 = e2.objId : e2 instanceof BaseStream && (a2 = e2.dict?.objId);
    if (a2) {
      const e3 = this._localFunctionCache.getByRef(a2);
      if (e3) return e3;
    }
    const i2 = this.xref.fetchIfRef(e2);
    if (Array.isArray(i2)) {
      if (!t2) throw new Error('PDFFunctionFactory.create - expected "parseArray" argument.');
      r2 = PDFFunction.parseArray(this, i2);
    } else r2 = PDFFunction.parse(this, i2);
    a2 && this._localFunctionCache.set(null, a2, r2);
    return r2;
  }
  get _localFunctionCache() {
    return shadow(this, "_localFunctionCache", new LocalFunctionCache());
  }
};
function toNumberArray(e2) {
  return Array.isArray(e2) ? isNumberArray(e2, null) ? e2 : e2.map(((e3) => +e3)) : null;
}
var PDFFunction = class {
  static getSampleArray(e2, t2, a2, r2) {
    let i2, n2, s2 = 1;
    for (i2 = 0, n2 = e2.length; i2 < n2; i2++) s2 *= e2[i2];
    s2 *= t2;
    const o2 = new Array(s2);
    let c2 = 0, l2 = 0;
    const h2 = 1 / (2 ** a2 - 1), u2 = r2.getBytes((s2 * a2 + 7) / 8);
    let d2 = 0;
    for (i2 = 0; i2 < s2; i2++) {
      for (; c2 < a2; ) {
        l2 <<= 8;
        l2 |= u2[d2++];
        c2 += 8;
      }
      c2 -= a2;
      o2[i2] = (l2 >> c2) * h2;
      l2 &= (1 << c2) - 1;
    }
    return o2;
  }
  static parse(e2, t2) {
    const a2 = t2.dict || t2;
    switch (a2.get("FunctionType")) {
      case 0:
        return this.constructSampled(e2, t2, a2);
      case 1:
        break;
      case 2:
        return this.constructInterpolated(e2, a2);
      case 3:
        return this.constructStiched(e2, a2);
      case 4:
        return this.constructPostScript(e2, t2, a2);
    }
    throw new FormatError("Unknown type of function");
  }
  static parseArray(e2, t2) {
    const { xref: a2 } = e2, r2 = [];
    for (const i2 of t2) r2.push(this.parse(e2, a2.fetchIfRef(i2)));
    return function(e3, t3, a3, i2) {
      for (let n2 = 0, s2 = r2.length; n2 < s2; n2++) r2[n2](e3, t3, a3, i2 + n2);
    };
  }
  static constructSampled(e2, t2, a2) {
    function toMultiArray(e3) {
      const t3 = e3.length, a3 = [];
      let r3 = 0;
      for (let i3 = 0; i3 < t3; i3 += 2) a3[r3++] = [e3[i3], e3[i3 + 1]];
      return a3;
    }
    function interpolate(e3, t3, a3, r3, i3) {
      return r3 + (i3 - r3) / (a3 - t3) * (e3 - t3);
    }
    let r2 = toNumberArray(a2.getArray("Domain")), i2 = toNumberArray(a2.getArray("Range"));
    if (!r2 || !i2) throw new FormatError("No domain or range");
    const n2 = r2.length / 2, s2 = i2.length / 2;
    r2 = toMultiArray(r2);
    i2 = toMultiArray(i2);
    const o2 = toNumberArray(a2.getArray("Size")), c2 = a2.get("BitsPerSample"), l2 = a2.get("Order") || 1;
    1 !== l2 && info("No support for cubic spline interpolation: " + l2);
    let h2 = toNumberArray(a2.getArray("Encode"));
    if (h2) h2 = toMultiArray(h2);
    else {
      h2 = [];
      for (let e3 = 0; e3 < n2; ++e3) h2.push([0, o2[e3] - 1]);
    }
    let u2 = toNumberArray(a2.getArray("Decode"));
    u2 = u2 ? toMultiArray(u2) : i2;
    const d2 = this.getSampleArray(o2, s2, c2, t2);
    return function constructSampledFn(e3, t3, a3, c3) {
      const l3 = 1 << n2, f2 = new Float64Array(l3).fill(1), g2 = new Uint32Array(l3);
      let p2, m2, b2 = s2, y2 = 1;
      for (p2 = 0; p2 < n2; ++p2) {
        const a4 = r2[p2][0], i3 = r2[p2][1];
        let n3 = interpolate(MathClamp(e3[t3 + p2], a4, i3), a4, i3, h2[p2][0], h2[p2][1]);
        const s3 = o2[p2];
        n3 = MathClamp(n3, 0, s3 - 1);
        const c4 = n3 < s3 - 1 ? Math.floor(n3) : n3 - 1, u3 = c4 + 1 - n3, d3 = n3 - c4, w2 = c4 * b2, x2 = w2 + b2;
        for (m2 = 0; m2 < l3; m2++) if (m2 & y2) {
          f2[m2] *= d3;
          g2[m2] += x2;
        } else {
          f2[m2] *= u3;
          g2[m2] += w2;
        }
        b2 *= s3;
        y2 <<= 1;
      }
      for (m2 = 0; m2 < s2; ++m2) {
        let e4 = 0;
        for (p2 = 0; p2 < l3; p2++) e4 += d2[g2[p2] + m2] * f2[p2];
        e4 = interpolate(e4, 0, 1, u2[m2][0], u2[m2][1]);
        a3[c3 + m2] = MathClamp(e4, i2[m2][0], i2[m2][1]);
      }
    };
  }
  static constructInterpolated(e2, t2) {
    const a2 = toNumberArray(t2.getArray("C0")) || [0], r2 = toNumberArray(t2.getArray("C1")) || [1], i2 = t2.get("N"), n2 = [];
    for (let e3 = 0, t3 = a2.length; e3 < t3; ++e3) n2.push(r2[e3] - a2[e3]);
    const s2 = n2.length;
    return function constructInterpolatedFn(e3, t3, r3, o2) {
      const c2 = 1 === i2 ? e3[t3] : e3[t3] ** i2;
      for (let e4 = 0; e4 < s2; ++e4) r3[o2 + e4] = a2[e4] + c2 * n2[e4];
    };
  }
  static constructStiched(e2, t2) {
    const a2 = toNumberArray(t2.getArray("Domain"));
    if (!a2) throw new FormatError("No domain");
    if (1 !== a2.length / 2) throw new FormatError("Bad domain for stiched function");
    const { xref: r2 } = e2, i2 = [];
    for (const a3 of t2.get("Functions")) i2.push(this.parse(e2, r2.fetchIfRef(a3)));
    const n2 = toNumberArray(t2.getArray("Bounds")), s2 = toNumberArray(t2.getArray("Encode")), o2 = new Float32Array(1);
    return function constructStichedFn(e3, t3, r3, c2) {
      const l2 = MathClamp(e3[t3], a2[0], a2[1]), h2 = n2.length;
      let u2;
      for (u2 = 0; u2 < h2 && !(l2 < n2[u2]); ++u2) ;
      let d2 = a2[0];
      u2 > 0 && (d2 = n2[u2 - 1]);
      let f2 = a2[1];
      u2 < n2.length && (f2 = n2[u2]);
      const g2 = s2[2 * u2], p2 = s2[2 * u2 + 1];
      o2[0] = d2 === f2 ? g2 : g2 + (l2 - d2) * (p2 - g2) / (f2 - d2);
      i2[u2](o2, 0, r3, c2);
    };
  }
  static constructPostScript(e2, t2, a2) {
    const r2 = toNumberArray(a2.getArray("Domain")), i2 = toNumberArray(a2.getArray("Range"));
    if (!r2) throw new FormatError("No domain.");
    if (!i2) throw new FormatError("No range.");
    const n2 = new PostScriptLexer(t2), s2 = new PostScriptParser(n2).parse();
    if (e2.isEvalSupported && FeatureTest.isEvalSupported) {
      const e3 = new PostScriptCompiler().compile(s2, r2, i2);
      if (e3) return new Function("src", "srcOffset", "dest", "destOffset", e3);
    }
    info("Unable to compile PS function");
    const o2 = i2.length >> 1, c2 = r2.length >> 1, l2 = new PostScriptEvaluator(s2), h2 = /* @__PURE__ */ Object.create(null);
    let u2 = 8192;
    const d2 = new Float32Array(c2);
    return function constructPostScriptFn(e3, t3, a3, r3) {
      let n3, s3, f2 = "";
      const g2 = d2;
      for (n3 = 0; n3 < c2; n3++) {
        s3 = e3[t3 + n3];
        g2[n3] = s3;
        f2 += s3 + "_";
      }
      const p2 = h2[f2];
      if (void 0 !== p2) {
        a3.set(p2, r3);
        return;
      }
      const m2 = new Float32Array(o2), b2 = l2.execute(g2), y2 = b2.length - o2;
      for (n3 = 0; n3 < o2; n3++) {
        s3 = b2[y2 + n3];
        let e4 = i2[2 * n3];
        if (s3 < e4) s3 = e4;
        else {
          e4 = i2[2 * n3 + 1];
          s3 > e4 && (s3 = e4);
        }
        m2[n3] = s3;
      }
      if (u2 > 0) {
        u2--;
        h2[f2] = m2;
      }
      a3.set(m2, r3);
    };
  }
};
function isPDFFunction(e2) {
  let t2;
  if (e2 instanceof Dict) t2 = e2;
  else {
    if (!(e2 instanceof BaseStream)) return false;
    t2 = e2.dict;
  }
  return t2.has("FunctionType");
}
var PostScriptStack = class _PostScriptStack {
  static MAX_STACK_SIZE = 100;
  constructor(e2) {
    this.stack = e2 ? Array.from(e2) : [];
  }
  push(e2) {
    if (this.stack.length >= _PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
    this.stack.push(e2);
  }
  pop() {
    if (this.stack.length <= 0) throw new Error("PostScript function stack underflow.");
    return this.stack.pop();
  }
  copy(e2) {
    if (this.stack.length + e2 >= _PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
    const t2 = this.stack;
    for (let a2 = t2.length - e2, r2 = e2 - 1; r2 >= 0; r2--, a2++) t2.push(t2[a2]);
  }
  index(e2) {
    this.push(this.stack[this.stack.length - e2 - 1]);
  }
  roll(e2, t2) {
    const a2 = this.stack, r2 = a2.length - e2, i2 = a2.length - 1, n2 = r2 + (t2 - Math.floor(t2 / e2) * e2);
    for (let e3 = r2, t3 = i2; e3 < t3; e3++, t3--) {
      const r3 = a2[e3];
      a2[e3] = a2[t3];
      a2[t3] = r3;
    }
    for (let e3 = r2, t3 = n2 - 1; e3 < t3; e3++, t3--) {
      const r3 = a2[e3];
      a2[e3] = a2[t3];
      a2[t3] = r3;
    }
    for (let e3 = n2, t3 = i2; e3 < t3; e3++, t3--) {
      const r3 = a2[e3];
      a2[e3] = a2[t3];
      a2[t3] = r3;
    }
  }
};
var PostScriptEvaluator = class {
  constructor(e2) {
    this.operators = e2;
  }
  execute(e2) {
    const t2 = new PostScriptStack(e2);
    let a2 = 0;
    const r2 = this.operators, i2 = r2.length;
    let n2, s2, o2;
    for (; a2 < i2; ) {
      n2 = r2[a2++];
      if ("number" != typeof n2) switch (n2) {
        case "jz":
          o2 = t2.pop();
          s2 = t2.pop();
          s2 || (a2 = o2);
          break;
        case "j":
          s2 = t2.pop();
          a2 = s2;
          break;
        case "abs":
          s2 = t2.pop();
          t2.push(Math.abs(s2));
          break;
        case "add":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 + o2);
          break;
        case "and":
          o2 = t2.pop();
          s2 = t2.pop();
          "boolean" == typeof s2 && "boolean" == typeof o2 ? t2.push(s2 && o2) : t2.push(s2 & o2);
          break;
        case "atan":
          o2 = t2.pop();
          s2 = t2.pop();
          s2 = Math.atan2(s2, o2) / Math.PI * 180;
          s2 < 0 && (s2 += 360);
          t2.push(s2);
          break;
        case "bitshift":
          o2 = t2.pop();
          s2 = t2.pop();
          s2 > 0 ? t2.push(s2 << o2) : t2.push(s2 >> o2);
          break;
        case "ceiling":
          s2 = t2.pop();
          t2.push(Math.ceil(s2));
          break;
        case "copy":
          s2 = t2.pop();
          t2.copy(s2);
          break;
        case "cos":
          s2 = t2.pop();
          t2.push(Math.cos(s2 % 360 / 180 * Math.PI));
          break;
        case "cvi":
          s2 = 0 | t2.pop();
          t2.push(s2);
          break;
        case "cvr":
          break;
        case "div":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 / o2);
          break;
        case "dup":
          t2.copy(1);
          break;
        case "eq":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 === o2);
          break;
        case "exch":
          t2.roll(2, 1);
          break;
        case "exp":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 ** o2);
          break;
        case "false":
          t2.push(false);
          break;
        case "floor":
          s2 = t2.pop();
          t2.push(Math.floor(s2));
          break;
        case "ge":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 >= o2);
          break;
        case "gt":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 > o2);
          break;
        case "idiv":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 / o2 | 0);
          break;
        case "index":
          s2 = t2.pop();
          t2.index(s2);
          break;
        case "le":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 <= o2);
          break;
        case "ln":
          s2 = t2.pop();
          t2.push(Math.log(s2));
          break;
        case "log":
          s2 = t2.pop();
          t2.push(Math.log10(s2));
          break;
        case "lt":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 < o2);
          break;
        case "mod":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 % o2);
          break;
        case "mul":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 * o2);
          break;
        case "ne":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 !== o2);
          break;
        case "neg":
          s2 = t2.pop();
          t2.push(-s2);
          break;
        case "not":
          s2 = t2.pop();
          "boolean" == typeof s2 ? t2.push(!s2) : t2.push(~s2);
          break;
        case "or":
          o2 = t2.pop();
          s2 = t2.pop();
          "boolean" == typeof s2 && "boolean" == typeof o2 ? t2.push(s2 || o2) : t2.push(s2 | o2);
          break;
        case "pop":
          t2.pop();
          break;
        case "roll":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.roll(s2, o2);
          break;
        case "round":
          s2 = t2.pop();
          t2.push(Math.round(s2));
          break;
        case "sin":
          s2 = t2.pop();
          t2.push(Math.sin(s2 % 360 / 180 * Math.PI));
          break;
        case "sqrt":
          s2 = t2.pop();
          t2.push(Math.sqrt(s2));
          break;
        case "sub":
          o2 = t2.pop();
          s2 = t2.pop();
          t2.push(s2 - o2);
          break;
        case "true":
          t2.push(true);
          break;
        case "truncate":
          s2 = t2.pop();
          s2 = s2 < 0 ? Math.ceil(s2) : Math.floor(s2);
          t2.push(s2);
          break;
        case "xor":
          o2 = t2.pop();
          s2 = t2.pop();
          "boolean" == typeof s2 && "boolean" == typeof o2 ? t2.push(s2 !== o2) : t2.push(s2 ^ o2);
          break;
        default:
          throw new FormatError(`Unknown operator ${n2}`);
      }
      else t2.push(n2);
    }
    return t2.stack;
  }
};
var AstNode = class {
  constructor(e2) {
    this.type = e2;
  }
  visit(e2) {
    unreachable("abstract method");
  }
};
var AstArgument = class extends AstNode {
  constructor(e2, t2, a2) {
    super("args");
    this.index = e2;
    this.min = t2;
    this.max = a2;
  }
  visit(e2) {
    e2.visitArgument(this);
  }
};
var AstLiteral = class extends AstNode {
  constructor(e2) {
    super("literal");
    this.number = e2;
    this.min = e2;
    this.max = e2;
  }
  visit(e2) {
    e2.visitLiteral(this);
  }
};
var AstBinaryOperation = class extends AstNode {
  constructor(e2, t2, a2, r2, i2) {
    super("binary");
    this.op = e2;
    this.arg1 = t2;
    this.arg2 = a2;
    this.min = r2;
    this.max = i2;
  }
  visit(e2) {
    e2.visitBinaryOperation(this);
  }
};
var AstMin = class extends AstNode {
  constructor(e2, t2) {
    super("max");
    this.arg = e2;
    this.min = e2.min;
    this.max = t2;
  }
  visit(e2) {
    e2.visitMin(this);
  }
};
var AstVariable = class extends AstNode {
  constructor(e2, t2, a2) {
    super("var");
    this.index = e2;
    this.min = t2;
    this.max = a2;
  }
  visit(e2) {
    e2.visitVariable(this);
  }
};
var AstVariableDefinition = class extends AstNode {
  constructor(e2, t2) {
    super("definition");
    this.variable = e2;
    this.arg = t2;
  }
  visit(e2) {
    e2.visitVariableDefinition(this);
  }
};
var ExpressionBuilderVisitor = class {
  constructor() {
    this.parts = [];
  }
  visitArgument(e2) {
    this.parts.push("Math.max(", e2.min, ", Math.min(", e2.max, ", src[srcOffset + ", e2.index, "]))");
  }
  visitVariable(e2) {
    this.parts.push("v", e2.index);
  }
  visitLiteral(e2) {
    this.parts.push(e2.number);
  }
  visitBinaryOperation(e2) {
    this.parts.push("(");
    e2.arg1.visit(this);
    this.parts.push(" ", e2.op, " ");
    e2.arg2.visit(this);
    this.parts.push(")");
  }
  visitVariableDefinition(e2) {
    this.parts.push("var ");
    e2.variable.visit(this);
    this.parts.push(" = ");
    e2.arg.visit(this);
    this.parts.push(";");
  }
  visitMin(e2) {
    this.parts.push("Math.min(");
    e2.arg.visit(this);
    this.parts.push(", ", e2.max, ")");
  }
  toString() {
    return this.parts.join("");
  }
};
function buildAddOperation(e2, t2) {
  return "literal" === t2.type && 0 === t2.number ? e2 : "literal" === e2.type && 0 === e2.number ? t2 : "literal" === t2.type && "literal" === e2.type ? new AstLiteral(e2.number + t2.number) : new AstBinaryOperation("+", e2, t2, e2.min + t2.min, e2.max + t2.max);
}
function buildMulOperation(e2, t2) {
  if ("literal" === t2.type) {
    if (0 === t2.number) return new AstLiteral(0);
    if (1 === t2.number) return e2;
    if ("literal" === e2.type) return new AstLiteral(e2.number * t2.number);
  }
  if ("literal" === e2.type) {
    if (0 === e2.number) return new AstLiteral(0);
    if (1 === e2.number) return t2;
  }
  const a2 = Math.min(e2.min * t2.min, e2.min * t2.max, e2.max * t2.min, e2.max * t2.max), r2 = Math.max(e2.min * t2.min, e2.min * t2.max, e2.max * t2.min, e2.max * t2.max);
  return new AstBinaryOperation("*", e2, t2, a2, r2);
}
function buildSubOperation(e2, t2) {
  if ("literal" === t2.type) {
    if (0 === t2.number) return e2;
    if ("literal" === e2.type) return new AstLiteral(e2.number - t2.number);
  }
  return "binary" === t2.type && "-" === t2.op && "literal" === e2.type && 1 === e2.number && "literal" === t2.arg1.type && 1 === t2.arg1.number ? t2.arg2 : new AstBinaryOperation("-", e2, t2, e2.min - t2.max, e2.max - t2.min);
}
function buildMinOperation(e2, t2) {
  return e2.min >= t2 ? new AstLiteral(t2) : e2.max <= t2 ? e2 : new AstMin(e2, t2);
}
var PostScriptCompiler = class {
  compile(e2, t2, a2) {
    const r2 = [], i2 = [], n2 = t2.length >> 1, s2 = a2.length >> 1;
    let o2, c2, l2, h2, u2, d2, f2, g2, p2 = 0;
    for (let e3 = 0; e3 < n2; e3++) r2.push(new AstArgument(e3, t2[2 * e3], t2[2 * e3 + 1]));
    for (let t3 = 0, a3 = e2.length; t3 < a3; t3++) {
      g2 = e2[t3];
      if ("number" != typeof g2) switch (g2) {
        case "add":
          if (r2.length < 2) return null;
          h2 = r2.pop();
          l2 = r2.pop();
          r2.push(buildAddOperation(l2, h2));
          break;
        case "cvr":
          if (r2.length < 1) return null;
          break;
        case "mul":
          if (r2.length < 2) return null;
          h2 = r2.pop();
          l2 = r2.pop();
          r2.push(buildMulOperation(l2, h2));
          break;
        case "sub":
          if (r2.length < 2) return null;
          h2 = r2.pop();
          l2 = r2.pop();
          r2.push(buildSubOperation(l2, h2));
          break;
        case "exch":
          if (r2.length < 2) return null;
          u2 = r2.pop();
          d2 = r2.pop();
          r2.push(u2, d2);
          break;
        case "pop":
          if (r2.length < 1) return null;
          r2.pop();
          break;
        case "index":
          if (r2.length < 1) return null;
          l2 = r2.pop();
          if ("literal" !== l2.type) return null;
          o2 = l2.number;
          if (o2 < 0 || !Number.isInteger(o2) || r2.length < o2) return null;
          u2 = r2[r2.length - o2 - 1];
          if ("literal" === u2.type || "var" === u2.type) {
            r2.push(u2);
            break;
          }
          f2 = new AstVariable(p2++, u2.min, u2.max);
          r2[r2.length - o2 - 1] = f2;
          r2.push(f2);
          i2.push(new AstVariableDefinition(f2, u2));
          break;
        case "dup":
          if (r2.length < 1) return null;
          if ("number" == typeof e2[t3 + 1] && "gt" === e2[t3 + 2] && e2[t3 + 3] === t3 + 7 && "jz" === e2[t3 + 4] && "pop" === e2[t3 + 5] && e2[t3 + 6] === e2[t3 + 1]) {
            l2 = r2.pop();
            r2.push(buildMinOperation(l2, e2[t3 + 1]));
            t3 += 6;
            break;
          }
          u2 = r2.at(-1);
          if ("literal" === u2.type || "var" === u2.type) {
            r2.push(u2);
            break;
          }
          f2 = new AstVariable(p2++, u2.min, u2.max);
          r2[r2.length - 1] = f2;
          r2.push(f2);
          i2.push(new AstVariableDefinition(f2, u2));
          break;
        case "roll":
          if (r2.length < 2) return null;
          h2 = r2.pop();
          l2 = r2.pop();
          if ("literal" !== h2.type || "literal" !== l2.type) return null;
          c2 = h2.number;
          o2 = l2.number;
          if (o2 <= 0 || !Number.isInteger(o2) || !Number.isInteger(c2) || r2.length < o2) return null;
          c2 = (c2 % o2 + o2) % o2;
          if (0 === c2) break;
          r2.push(...r2.splice(r2.length - o2, o2 - c2));
          break;
        default:
          return null;
      }
      else r2.push(new AstLiteral(g2));
    }
    if (r2.length !== s2) return null;
    const m2 = [];
    for (const e3 of i2) {
      const t3 = new ExpressionBuilderVisitor();
      e3.visit(t3);
      m2.push(t3.toString());
    }
    for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) {
      const t4 = r2[e3], i3 = new ExpressionBuilderVisitor();
      t4.visit(i3);
      const n3 = a2[2 * e3], s3 = a2[2 * e3 + 1], o3 = [i3.toString()];
      if (n3 > t4.min) {
        o3.unshift("Math.max(", n3, ", ");
        o3.push(")");
      }
      if (s3 < t4.max) {
        o3.unshift("Math.min(", s3, ", ");
        o3.push(")");
      }
      o3.unshift("dest[destOffset + ", e3, "] = ");
      o3.push(";");
      m2.push(o3.join(""));
    }
    return m2.join("\n");
  }
};
var wn = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"];
var xn = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
function isOdd(e2) {
  return !!(1 & e2);
}
function isEven(e2) {
  return !(1 & e2);
}
function findUnequal(e2, t2, a2) {
  let r2, i2;
  for (r2 = t2, i2 = e2.length; r2 < i2; ++r2) if (e2[r2] !== a2) return r2;
  return r2;
}
function reverseValues(e2, t2, a2) {
  for (let r2 = t2, i2 = a2 - 1; r2 < i2; ++r2, --i2) {
    const t3 = e2[r2];
    e2[r2] = e2[i2];
    e2[i2] = t3;
  }
}
function createBidiText(e2, t2, a2 = false) {
  let r2 = "ltr";
  a2 ? r2 = "ttb" : t2 || (r2 = "rtl");
  return { str: e2, dir: r2 };
}
var Sn = [];
var An = [];
function bidi(e2, t2 = -1, a2 = false) {
  let r2 = true;
  const i2 = e2.length;
  if (0 === i2 || a2) return createBidiText(e2, r2, a2);
  Sn.length = i2;
  An.length = i2;
  let n2, s2, o2 = 0;
  for (n2 = 0; n2 < i2; ++n2) {
    Sn[n2] = e2.charAt(n2);
    const t3 = e2.charCodeAt(n2);
    let a3 = "L";
    if (t3 <= 255) a3 = wn[t3];
    else if (1424 <= t3 && t3 <= 1524) a3 = "R";
    else if (1536 <= t3 && t3 <= 1791) {
      a3 = xn[255 & t3];
      a3 || warn("Bidi: invalid Unicode character " + t3.toString(16));
    } else (1792 <= t3 && t3 <= 2220 || 64336 <= t3 && t3 <= 65023 || 65136 <= t3 && t3 <= 65279) && (a3 = "AL");
    "R" !== a3 && "AL" !== a3 && "AN" !== a3 || o2++;
    An[n2] = a3;
  }
  if (0 === o2) {
    r2 = true;
    return createBidiText(e2, r2);
  }
  if (-1 === t2) if (o2 / i2 < 0.3 && i2 > 4) {
    r2 = true;
    t2 = 0;
  } else {
    r2 = false;
    t2 = 1;
  }
  const c2 = [];
  for (n2 = 0; n2 < i2; ++n2) c2[n2] = t2;
  const l2 = isOdd(t2) ? "R" : "L", h2 = l2, u2 = h2;
  let d2, f2 = h2;
  for (n2 = 0; n2 < i2; ++n2) "NSM" === An[n2] ? An[n2] = f2 : f2 = An[n2];
  f2 = h2;
  for (n2 = 0; n2 < i2; ++n2) {
    d2 = An[n2];
    "EN" === d2 ? An[n2] = "AL" === f2 ? "AN" : "EN" : "R" !== d2 && "L" !== d2 && "AL" !== d2 || (f2 = d2);
  }
  for (n2 = 0; n2 < i2; ++n2) {
    d2 = An[n2];
    "AL" === d2 && (An[n2] = "R");
  }
  for (n2 = 1; n2 < i2 - 1; ++n2) {
    "ES" === An[n2] && "EN" === An[n2 - 1] && "EN" === An[n2 + 1] && (An[n2] = "EN");
    "CS" !== An[n2] || "EN" !== An[n2 - 1] && "AN" !== An[n2 - 1] || An[n2 + 1] !== An[n2 - 1] || (An[n2] = An[n2 - 1]);
  }
  for (n2 = 0; n2 < i2; ++n2) if ("EN" === An[n2]) {
    for (let e3 = n2 - 1; e3 >= 0 && "ET" === An[e3]; --e3) An[e3] = "EN";
    for (let e3 = n2 + 1; e3 < i2 && "ET" === An[e3]; ++e3) An[e3] = "EN";
  }
  for (n2 = 0; n2 < i2; ++n2) {
    d2 = An[n2];
    "WS" !== d2 && "ES" !== d2 && "ET" !== d2 && "CS" !== d2 || (An[n2] = "ON");
  }
  f2 = h2;
  for (n2 = 0; n2 < i2; ++n2) {
    d2 = An[n2];
    "EN" === d2 ? An[n2] = "L" === f2 ? "L" : "EN" : "R" !== d2 && "L" !== d2 || (f2 = d2);
  }
  for (n2 = 0; n2 < i2; ++n2) if ("ON" === An[n2]) {
    const e3 = findUnequal(An, n2 + 1, "ON");
    let t3 = h2;
    n2 > 0 && (t3 = An[n2 - 1]);
    let a3 = u2;
    e3 + 1 < i2 && (a3 = An[e3 + 1]);
    "L" !== t3 && (t3 = "R");
    "L" !== a3 && (a3 = "R");
    t3 === a3 && An.fill(t3, n2, e3);
    n2 = e3 - 1;
  }
  for (n2 = 0; n2 < i2; ++n2) "ON" === An[n2] && (An[n2] = l2);
  for (n2 = 0; n2 < i2; ++n2) {
    d2 = An[n2];
    isEven(c2[n2]) ? "R" === d2 ? c2[n2] += 1 : "AN" !== d2 && "EN" !== d2 || (c2[n2] += 2) : "L" !== d2 && "AN" !== d2 && "EN" !== d2 || (c2[n2] += 1);
  }
  let g2, p2 = -1, m2 = 99;
  for (n2 = 0, s2 = c2.length; n2 < s2; ++n2) {
    g2 = c2[n2];
    p2 < g2 && (p2 = g2);
    m2 > g2 && isOdd(g2) && (m2 = g2);
  }
  for (g2 = p2; g2 >= m2; --g2) {
    let e3 = -1;
    for (n2 = 0, s2 = c2.length; n2 < s2; ++n2) if (c2[n2] < g2) {
      if (e3 >= 0) {
        reverseValues(Sn, e3, n2);
        e3 = -1;
      }
    } else e3 < 0 && (e3 = n2);
    e3 >= 0 && reverseValues(Sn, e3, c2.length);
  }
  for (n2 = 0, s2 = Sn.length; n2 < s2; ++n2) {
    const e3 = Sn[n2];
    "<" !== e3 && ">" !== e3 || (Sn[n2] = "");
  }
  return createBidiText(Sn.join(""), r2);
}
var kn = { style: "normal", weight: "normal" };
var Cn = { style: "normal", weight: "bold" };
var vn = { style: "italic", weight: "normal" };
var Fn = { style: "italic", weight: "bold" };
var In = /* @__PURE__ */ new Map([["Times-Roman", { local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "Linux Libertine O", "Libertinus Serif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"], style: kn, ultimate: "serif" }], ["Times-Bold", { alias: "Times-Roman", style: Cn, ultimate: "serif" }], ["Times-Italic", { alias: "Times-Roman", style: vn, ultimate: "serif" }], ["Times-BoldItalic", { alias: "Times-Roman", style: Fn, ultimate: "serif" }], ["Helvetica", { local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"], path: "LiberationSans-Regular.ttf", style: kn, ultimate: "sans-serif" }], ["Helvetica-Bold", { alias: "Helvetica", path: "LiberationSans-Bold.ttf", style: Cn, ultimate: "sans-serif" }], ["Helvetica-Oblique", { alias: "Helvetica", path: "LiberationSans-Italic.ttf", style: vn, ultimate: "sans-serif" }], ["Helvetica-BoldOblique", { alias: "Helvetica", path: "LiberationSans-BoldItalic.ttf", style: Fn, ultimate: "sans-serif" }], ["Courier", { local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono", "Linux Libertine Mono O", "Libertinus Mono"], style: kn, ultimate: "monospace" }], ["Courier-Bold", { alias: "Courier", style: Cn, ultimate: "monospace" }], ["Courier-Oblique", { alias: "Courier", style: vn, ultimate: "monospace" }], ["Courier-BoldOblique", { alias: "Courier", style: Fn, ultimate: "monospace" }], ["ArialBlack", { local: ["Arial Black"], style: { style: "normal", weight: "900" }, fallback: "Helvetica-Bold" }], ["ArialBlack-Bold", { alias: "ArialBlack" }], ["ArialBlack-Italic", { alias: "ArialBlack", style: { style: "italic", weight: "900" }, fallback: "Helvetica-BoldOblique" }], ["ArialBlack-BoldItalic", { alias: "ArialBlack-Italic" }], ["ArialNarrow", { local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"], style: kn, fallback: "Helvetica" }], ["ArialNarrow-Bold", { alias: "ArialNarrow", style: Cn, fallback: "Helvetica-Bold" }], ["ArialNarrow-Italic", { alias: "ArialNarrow", style: vn, fallback: "Helvetica-Oblique" }], ["ArialNarrow-BoldItalic", { alias: "ArialNarrow", style: Fn, fallback: "Helvetica-BoldOblique" }], ["Calibri", { local: ["Calibri", "Carlito"], style: kn, fallback: "Helvetica" }], ["Calibri-Bold", { alias: "Calibri", style: Cn, fallback: "Helvetica-Bold" }], ["Calibri-Italic", { alias: "Calibri", style: vn, fallback: "Helvetica-Oblique" }], ["Calibri-BoldItalic", { alias: "Calibri", style: Fn, fallback: "Helvetica-BoldOblique" }], ["Wingdings", { local: ["Wingdings", "URW Dingbats"], style: kn }], ["Wingdings-Regular", { alias: "Wingdings" }], ["Wingdings-Bold", { alias: "Wingdings" }]]);
var Tn = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
function getFamilyName(e2) {
  const t2 = /* @__PURE__ */ new Set(["thin", "extralight", "ultralight", "demilight", "semilight", "light", "book", "regular", "normal", "medium", "demibold", "semibold", "bold", "extrabold", "ultrabold", "black", "heavy", "extrablack", "ultrablack", "roman", "italic", "oblique", "ultracondensed", "extracondensed", "condensed", "semicondensed", "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded", "bolditalic"]);
  return e2.split(/[- ,+]+/g).filter(((e3) => !t2.has(e3.toLowerCase()))).join(" ");
}
function generateFont({ alias: e2, local: t2, path: a2, fallback: r2, style: i2, ultimate: n2 }, s2, o2, c2 = true, l2 = true, h2 = "") {
  const u2 = { style: null, ultimate: null };
  if (t2) {
    const e3 = h2 ? ` ${h2}` : "";
    for (const a3 of t2) s2.push(`local(${a3}${e3})`);
  }
  if (e2) {
    const t3 = In.get(e2), n3 = h2 || (function getStyleToAppend(e3) {
      switch (e3) {
        case Cn:
          return "Bold";
        case vn:
          return "Italic";
        case Fn:
          return "Bold Italic";
        default:
          if ("bold" === e3?.weight) return "Bold";
          if ("italic" === e3?.style) return "Italic";
      }
      return "";
    })(i2);
    Object.assign(u2, generateFont(t3, s2, o2, c2 && !r2, l2 && !a2, n3));
  }
  i2 && (u2.style = i2);
  n2 && (u2.ultimate = n2);
  if (c2 && r2) {
    const e3 = In.get(r2), { ultimate: t3 } = generateFont(e3, s2, o2, c2, l2 && !a2, h2);
    u2.ultimate ||= t3;
  }
  l2 && a2 && o2 && s2.push(`url(${o2}${a2})`);
  return u2;
}
function getFontSubstitution(e2, t2, a2, r2, i2, n2) {
  if (r2.startsWith("InvalidPDFjsFont_")) return null;
  "TrueType" !== n2 && "Type1" !== n2 || !/^[A-Z]{6}\+/.test(r2) || (r2 = r2.slice(7));
  const s2 = r2 = normalizeFontName(r2);
  let o2 = e2.get(s2);
  if (o2) return o2;
  let c2 = In.get(r2);
  if (!c2) {
    for (const [e3, t3] of Tn) if (r2.startsWith(e3)) {
      r2 = `${t3}${r2.substring(e3.length)}`;
      c2 = In.get(r2);
      break;
    }
  }
  let l2 = false;
  if (!c2) {
    c2 = In.get(i2);
    l2 = true;
  }
  const h2 = `${t2.getDocId()}_s${t2.createFontId()}`;
  if (!c2) {
    if (!validateFontName(r2)) {
      warn(`Cannot substitute the font because of its name: ${r2}`);
      e2.set(s2, null);
      return null;
    }
    const t3 = /bold/gi.test(r2), a3 = /oblique|italic/gi.test(r2), i3 = t3 && a3 && Fn || t3 && Cn || a3 && vn || kn;
    o2 = { css: `"${getFamilyName(r2)}",${h2}`, guessFallback: true, loadedName: h2, baseFontName: r2, src: `local(${r2})`, style: i3 };
    e2.set(s2, o2);
    return o2;
  }
  const u2 = [];
  l2 && validateFontName(r2) && u2.push(`local(${r2})`);
  const { style: d2, ultimate: f2 } = generateFont(c2, u2, a2), g2 = null === f2, p2 = g2 ? "" : `,${f2}`;
  o2 = { css: `"${getFamilyName(r2)}",${h2}${p2}`, guessFallback: g2, loadedName: h2, baseFontName: r2, src: u2.join(","), style: d2 };
  e2.set(s2, o2);
  return o2;
}
var On = 3285377520;
var Mn = 4294901760;
var Dn = 65535;
var MurmurHash3_64 = class {
  constructor(e2) {
    this.h1 = e2 ? 4294967295 & e2 : On;
    this.h2 = e2 ? 4294967295 & e2 : On;
  }
  update(e2) {
    let t2, a2;
    if ("string" == typeof e2) {
      t2 = new Uint8Array(2 * e2.length);
      a2 = 0;
      for (let r3 = 0, i3 = e2.length; r3 < i3; r3++) {
        const i4 = e2.charCodeAt(r3);
        if (i4 <= 255) t2[a2++] = i4;
        else {
          t2[a2++] = i4 >>> 8;
          t2[a2++] = 255 & i4;
        }
      }
    } else {
      if (!ArrayBuffer.isView(e2)) throw new Error("Invalid data format, must be a string or TypedArray.");
      t2 = e2.slice();
      a2 = t2.byteLength;
    }
    const r2 = a2 >> 2, i2 = a2 - 4 * r2, n2 = new Uint32Array(t2.buffer, 0, r2);
    let s2 = 0, o2 = 0, c2 = this.h1, l2 = this.h2;
    const h2 = 3432918353, u2 = 461845907, d2 = 11601, f2 = 13715;
    for (let e3 = 0; e3 < r2; e3++) if (1 & e3) {
      s2 = n2[e3];
      s2 = s2 * h2 & Mn | s2 * d2 & Dn;
      s2 = s2 << 15 | s2 >>> 17;
      s2 = s2 * u2 & Mn | s2 * f2 & Dn;
      c2 ^= s2;
      c2 = c2 << 13 | c2 >>> 19;
      c2 = 5 * c2 + 3864292196;
    } else {
      o2 = n2[e3];
      o2 = o2 * h2 & Mn | o2 * d2 & Dn;
      o2 = o2 << 15 | o2 >>> 17;
      o2 = o2 * u2 & Mn | o2 * f2 & Dn;
      l2 ^= o2;
      l2 = l2 << 13 | l2 >>> 19;
      l2 = 5 * l2 + 3864292196;
    }
    s2 = 0;
    switch (i2) {
      case 3:
        s2 ^= t2[4 * r2 + 2] << 16;
      case 2:
        s2 ^= t2[4 * r2 + 1] << 8;
      case 1:
        s2 ^= t2[4 * r2];
        s2 = s2 * h2 & Mn | s2 * d2 & Dn;
        s2 = s2 << 15 | s2 >>> 17;
        s2 = s2 * u2 & Mn | s2 * f2 & Dn;
        1 & r2 ? c2 ^= s2 : l2 ^= s2;
    }
    this.h1 = c2;
    this.h2 = l2;
  }
  hexdigest() {
    let e2 = this.h1, t2 = this.h2;
    e2 ^= t2 >>> 1;
    e2 = 3981806797 * e2 & Mn | 36045 * e2 & Dn;
    t2 = 4283543511 * t2 & Mn | (2950163797 * (t2 << 16 | e2 >>> 16) & Mn) >>> 16;
    e2 ^= t2 >>> 1;
    e2 = 444984403 * e2 & Mn | 60499 * e2 & Dn;
    t2 = 3301882366 * t2 & Mn | (3120437893 * (t2 << 16 | e2 >>> 16) & Mn) >>> 16;
    e2 ^= t2 >>> 1;
    return (e2 >>> 0).toString(16).padStart(8, "0") + (t2 >>> 0).toString(16).padStart(8, "0");
  }
};
function resizeImageMask(e2, t2, a2, r2, i2, n2) {
  const s2 = i2 * n2;
  let o2;
  o2 = t2 <= 8 ? new Uint8Array(s2) : t2 <= 16 ? new Uint16Array(s2) : new Uint32Array(s2);
  const c2 = a2 / i2, l2 = r2 / n2;
  let h2, u2, d2, f2, g2 = 0;
  const p2 = new Uint16Array(i2), m2 = a2;
  for (h2 = 0; h2 < i2; h2++) p2[h2] = Math.floor(h2 * c2);
  for (h2 = 0; h2 < n2; h2++) {
    d2 = Math.floor(h2 * l2) * m2;
    for (u2 = 0; u2 < i2; u2++) {
      f2 = d2 + p2[u2];
      o2[g2++] = e2[f2];
    }
  }
  return o2;
}
var PDFImage = class _PDFImage {
  constructor({ xref: e2, res: t2, image: a2, isInline: r2 = false, smask: i2 = null, mask: n2 = null, isMask: s2 = false, pdfFunctionFactory: o2, globalColorSpaceCache: c2, localColorSpaceCache: l2 }) {
    this.image = a2;
    const h2 = a2.dict, u2 = h2.get("F", "Filter");
    let d2;
    if (u2 instanceof Name) d2 = u2.name;
    else if (Array.isArray(u2)) {
      const t3 = e2.fetchIfRef(u2[0]);
      t3 instanceof Name && (d2 = t3.name);
    }
    switch (d2) {
      case "JPXDecode":
        ({ width: a2.width, height: a2.height, componentsCount: a2.numComps, bitsPerComponent: a2.bitsPerComponent } = JpxImage.parseImageProperties(a2.stream));
        a2.stream.reset();
        const e3 = ImageResizer.getReducePowerForJPX(a2.width, a2.height, a2.numComps);
        this.jpxDecoderOptions = { numComponents: 0, isIndexedColormap: false, smaskInData: h2.has("SMaskInData"), reducePower: e3 };
        if (e3) {
          const t3 = 2 ** e3;
          a2.width = Math.ceil(a2.width / t3);
          a2.height = Math.ceil(a2.height / t3);
        }
        break;
      case "JBIG2Decode":
        a2.bitsPerComponent = 1;
        a2.numComps = 1;
    }
    let f2 = h2.get("W", "Width"), g2 = h2.get("H", "Height");
    if (Number.isInteger(a2.width) && a2.width > 0 && Number.isInteger(a2.height) && a2.height > 0 && (a2.width !== f2 || a2.height !== g2)) {
      warn("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
      f2 = a2.width;
      g2 = a2.height;
    } else {
      const e3 = "number" == typeof f2 && f2 > 0, t3 = "number" == typeof g2 && g2 > 0;
      if (!e3 || !t3) {
        if (!a2.fallbackDims) throw new FormatError(`Invalid image width: ${f2} or height: ${g2}`);
        warn("PDFImage - using the Width/Height of the parent image, for SMask/Mask data.");
        e3 || (f2 = a2.fallbackDims.width);
        t3 || (g2 = a2.fallbackDims.height);
      }
    }
    this.width = f2;
    this.height = g2;
    this.interpolate = h2.get("I", "Interpolate");
    this.imageMask = h2.get("IM", "ImageMask") || false;
    this.matte = h2.get("Matte") || false;
    let p2 = a2.bitsPerComponent;
    if (!p2) {
      p2 = h2.get("BPC", "BitsPerComponent");
      if (!p2) {
        if (!this.imageMask) throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);
        p2 = 1;
      }
    }
    this.bpc = p2;
    if (!this.imageMask) {
      let i3 = h2.getRaw("CS") || h2.getRaw("ColorSpace");
      const n3 = !!i3;
      if (n3) this.jpxDecoderOptions?.smaskInData && (i3 = Name.get("DeviceRGBA"));
      else if (this.jpxDecoderOptions) i3 = Name.get("DeviceRGBA");
      else switch (a2.numComps) {
        case 1:
          i3 = Name.get("DeviceGray");
          break;
        case 3:
          i3 = Name.get("DeviceRGB");
          break;
        case 4:
          i3 = Name.get("DeviceCMYK");
          break;
        default:
          throw new Error(`Images with ${a2.numComps} color components not supported.`);
      }
      this.colorSpace = ColorSpaceUtils.parse({ cs: i3, xref: e2, resources: r2 ? t2 : null, pdfFunctionFactory: o2, globalColorSpaceCache: c2, localColorSpaceCache: l2 });
      this.numComps = this.colorSpace.numComps;
      if (this.jpxDecoderOptions) {
        this.jpxDecoderOptions.numComponents = n3 ? this.numComps : 0;
        this.jpxDecoderOptions.isIndexedColormap = "Indexed" === this.colorSpace.name;
      }
    }
    this.decode = h2.getArray("D", "Decode");
    this.needsDecode = false;
    if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, p2) || s2 && !ColorSpace.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = true;
      const e3 = (1 << p2) - 1;
      this.decodeCoefficients = [];
      this.decodeAddends = [];
      const t3 = "Indexed" === this.colorSpace?.name;
      for (let a3 = 0, r3 = 0; a3 < this.decode.length; a3 += 2, ++r3) {
        const i3 = this.decode[a3], n3 = this.decode[a3 + 1];
        this.decodeCoefficients[r3] = t3 ? (n3 - i3) / e3 : n3 - i3;
        this.decodeAddends[r3] = t3 ? i3 : e3 * i3;
      }
    }
    if (i2) {
      i2.fallbackDims ??= { width: f2, height: g2 };
      this.smask = new _PDFImage({ xref: e2, res: t2, image: i2, isInline: r2, pdfFunctionFactory: o2, globalColorSpaceCache: c2, localColorSpaceCache: l2 });
    } else if (n2) if (n2 instanceof BaseStream) {
      if (n2.dict.get("IM", "ImageMask")) {
        n2.fallbackDims ??= { width: f2, height: g2 };
        this.mask = new _PDFImage({ xref: e2, res: t2, image: n2, isInline: r2, isMask: true, pdfFunctionFactory: o2, globalColorSpaceCache: c2, localColorSpaceCache: l2 });
      } else warn("Ignoring /Mask in image without /ImageMask.");
    } else this.mask = n2;
  }
  static async buildImage({ xref: e2, res: t2, image: a2, isInline: r2 = false, pdfFunctionFactory: i2, globalColorSpaceCache: n2, localColorSpaceCache: s2 }) {
    const o2 = a2;
    let c2 = null, l2 = null;
    const h2 = a2.dict.get("SMask"), u2 = a2.dict.get("Mask");
    h2 ? h2 instanceof BaseStream ? c2 = h2 : warn("Unsupported /SMask format.") : u2 && (u2 instanceof BaseStream || Array.isArray(u2) ? l2 = u2 : warn("Unsupported /Mask format."));
    return new _PDFImage({ xref: e2, res: t2, image: o2, isInline: r2, smask: c2, mask: l2, pdfFunctionFactory: i2, globalColorSpaceCache: n2, localColorSpaceCache: s2 });
  }
  static async createMask({ image: e2, isOffscreenCanvasSupported: t2 = false }) {
    const { dict: a2 } = e2, r2 = a2.get("W", "Width"), i2 = a2.get("H", "Height"), n2 = a2.get("I", "Interpolate"), s2 = a2.getArray("D", "Decode"), o2 = s2?.[0] > 0, c2 = (r2 + 7 >> 3) * i2, l2 = e2.getBytes(c2), h2 = 1 === r2 && 1 === i2 && o2 === (0 === l2.length || !!(128 & l2[0]));
    if (h2) return { isSingleOpaquePixel: h2 };
    if (t2) {
      if (ImageResizer.needsToBeResized(r2, i2)) {
        const e4 = new Uint8ClampedArray(r2 * i2 * 4);
        convertBlackAndWhiteToRGBA({ src: l2, dest: e4, width: r2, height: i2, nonBlackColor: 0, inverseDecode: o2 });
        return ImageResizer.createImage({ kind: v, data: e4, width: r2, height: i2, interpolate: n2 });
      }
      const e3 = new OffscreenCanvas(r2, i2), t3 = e3.getContext("2d"), a3 = t3.createImageData(r2, i2);
      convertBlackAndWhiteToRGBA({ src: l2, dest: a3.data, width: r2, height: i2, nonBlackColor: 0, inverseDecode: o2 });
      t3.putImageData(a3, 0, 0);
      return { data: null, width: r2, height: i2, interpolate: n2, bitmap: e3.transferToImageBitmap() };
    }
    const u2 = l2.byteLength;
    let d2;
    if (e2 instanceof DecodeStream && (!o2 || c2 === u2)) d2 = l2;
    else if (o2) {
      d2 = new Uint8Array(c2);
      d2.set(l2);
      d2.fill(255, u2);
    } else d2 = new Uint8Array(l2);
    if (o2) for (let e3 = 0; e3 < u2; e3++) d2[e3] ^= 255;
    return { data: d2, width: r2, height: i2, interpolate: n2 };
  }
  get drawWidth() {
    return Math.max(this.width, this.smask?.width || 0, this.mask?.width || 0);
  }
  get drawHeight() {
    return Math.max(this.height, this.smask?.height || 0, this.mask?.height || 0);
  }
  decodeBuffer(e2) {
    const t2 = this.bpc, a2 = this.numComps, r2 = this.decodeAddends, i2 = this.decodeCoefficients, n2 = (1 << t2) - 1;
    let s2, o2;
    if (1 === t2) {
      for (s2 = 0, o2 = e2.length; s2 < o2; s2++) e2[s2] = +!e2[s2];
      return;
    }
    let c2 = 0;
    for (s2 = 0, o2 = this.width * this.height; s2 < o2; s2++) for (let t3 = 0; t3 < a2; t3++) {
      e2[c2] = MathClamp(r2[t3] + e2[c2] * i2[t3], 0, n2);
      c2++;
    }
  }
  getComponents(e2) {
    const t2 = this.bpc;
    if (8 === t2) return e2;
    const a2 = this.width, r2 = this.height, i2 = this.numComps, n2 = a2 * r2 * i2;
    let s2, o2 = 0;
    s2 = t2 <= 8 ? new Uint8Array(n2) : t2 <= 16 ? new Uint16Array(n2) : new Uint32Array(n2);
    const c2 = a2 * i2, l2 = (1 << t2) - 1;
    let h2, u2, d2 = 0;
    if (1 === t2) {
      let t3, a3, i3;
      for (let n3 = 0; n3 < r2; n3++) {
        a3 = d2 + (-8 & c2);
        i3 = d2 + c2;
        for (; d2 < a3; ) {
          u2 = e2[o2++];
          s2[d2] = u2 >> 7 & 1;
          s2[d2 + 1] = u2 >> 6 & 1;
          s2[d2 + 2] = u2 >> 5 & 1;
          s2[d2 + 3] = u2 >> 4 & 1;
          s2[d2 + 4] = u2 >> 3 & 1;
          s2[d2 + 5] = u2 >> 2 & 1;
          s2[d2 + 6] = u2 >> 1 & 1;
          s2[d2 + 7] = 1 & u2;
          d2 += 8;
        }
        if (d2 < i3) {
          u2 = e2[o2++];
          t3 = 128;
          for (; d2 < i3; ) {
            s2[d2++] = +!!(u2 & t3);
            t3 >>= 1;
          }
        }
      }
    } else {
      let a3 = 0;
      u2 = 0;
      for (d2 = 0, h2 = n2; d2 < h2; ++d2) {
        if (d2 % c2 == 0) {
          u2 = 0;
          a3 = 0;
        }
        for (; a3 < t2; ) {
          u2 = u2 << 8 | e2[o2++];
          a3 += 8;
        }
        const r3 = a3 - t2;
        let i3 = u2 >> r3;
        i3 < 0 ? i3 = 0 : i3 > l2 && (i3 = l2);
        s2[d2] = i3;
        u2 &= (1 << r3) - 1;
        a3 = r3;
      }
    }
    return s2;
  }
  async fillOpacity(e2, t2, a2, r2, i2) {
    const n2 = this.smask, s2 = this.mask;
    let o2, c2, l2, h2, u2, d2;
    if (n2) {
      c2 = n2.width;
      l2 = n2.height;
      o2 = new Uint8ClampedArray(c2 * l2);
      await n2.fillGrayBuffer(o2);
      c2 === t2 && l2 === a2 || (o2 = resizeImageMask(o2, n2.bpc, c2, l2, t2, a2));
    } else if (s2) if (s2 instanceof _PDFImage) {
      c2 = s2.width;
      l2 = s2.height;
      o2 = new Uint8ClampedArray(c2 * l2);
      s2.numComps = 1;
      await s2.fillGrayBuffer(o2);
      for (h2 = 0, u2 = c2 * l2; h2 < u2; ++h2) o2[h2] = 255 - o2[h2];
      c2 === t2 && l2 === a2 || (o2 = resizeImageMask(o2, s2.bpc, c2, l2, t2, a2));
    } else {
      if (!Array.isArray(s2)) throw new FormatError("Unknown mask format.");
      {
        o2 = new Uint8ClampedArray(t2 * a2);
        const e3 = this.numComps;
        for (h2 = 0, u2 = t2 * a2; h2 < u2; ++h2) {
          let t3 = 0;
          const a3 = h2 * e3;
          for (d2 = 0; d2 < e3; ++d2) {
            const e4 = i2[a3 + d2], r3 = 2 * d2;
            if (e4 < s2[r3] || e4 > s2[r3 + 1]) {
              t3 = 255;
              break;
            }
          }
          o2[h2] = t3;
        }
      }
    }
    if (o2) for (h2 = 0, d2 = 3, u2 = t2 * r2; h2 < u2; ++h2, d2 += 4) e2[d2] = o2[h2];
    else for (h2 = 0, d2 = 3, u2 = t2 * r2; h2 < u2; ++h2, d2 += 4) e2[d2] = 255;
  }
  undoPreblend(e2, t2, a2) {
    const r2 = this.smask?.matte;
    if (!r2) return;
    const i2 = this.colorSpace.getRgb(r2, 0), n2 = i2[0], s2 = i2[1], o2 = i2[2], c2 = t2 * a2 * 4;
    for (let t3 = 0; t3 < c2; t3 += 4) {
      const a3 = e2[t3 + 3];
      if (0 === a3) {
        e2[t3] = 255;
        e2[t3 + 1] = 255;
        e2[t3 + 2] = 255;
        continue;
      }
      const r3 = 255 / a3;
      e2[t3] = (e2[t3] - n2) * r3 + n2;
      e2[t3 + 1] = (e2[t3 + 1] - s2) * r3 + s2;
      e2[t3 + 2] = (e2[t3 + 2] - o2) * r3 + o2;
    }
  }
  async createImageData(e2 = false, t2 = false) {
    const a2 = this.drawWidth, r2 = this.drawHeight, i2 = { width: a2, height: r2, interpolate: this.interpolate, kind: 0, data: null }, n2 = this.numComps, s2 = this.width, o2 = this.height, c2 = this.bpc, l2 = s2 * n2 * c2 + 7 >> 3, h2 = t2 && ImageResizer.needsToBeResized(a2, r2);
    if (!this.smask && !this.mask && "DeviceRGBA" === this.colorSpace.name) {
      i2.kind = v;
      const e3 = i2.data = await this.getImageBytes(o2 * s2 * 4, {});
      return t2 ? h2 ? ImageResizer.createImage(i2, false) : this.createBitmap(v, a2, r2, e3) : i2;
    }
    if (!e2) {
      let e3;
      "DeviceGray" === this.colorSpace.name && 1 === c2 ? e3 = k : "DeviceRGB" !== this.colorSpace.name || 8 !== c2 || this.needsDecode || (e3 = C);
      if (e3 && !this.smask && !this.mask && a2 === s2 && r2 === o2) {
        const n3 = await this.#$(s2, o2);
        if (n3) return n3;
        const c3 = await this.getImageBytes(o2 * l2, {});
        if (t2) return h2 ? ImageResizer.createImage({ data: c3, kind: e3, width: a2, height: r2, interpolate: this.interpolate }, this.needsDecode) : this.createBitmap(e3, s2, o2, c3);
        i2.kind = e3;
        i2.data = c3;
        if (this.needsDecode) {
          assert(e3 === k, "PDFImage.createImageData: The image must be grayscale.");
          const t3 = i2.data;
          for (let e4 = 0, a3 = t3.length; e4 < a3; e4++) t3[e4] ^= 255;
        }
        return i2;
      }
      if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {
        let e4 = o2 * l2;
        if (t2 && !h2) {
          let t3 = false;
          switch (this.colorSpace.name) {
            case "DeviceGray":
              e4 *= 4;
              t3 = true;
              break;
            case "DeviceRGB":
              e4 = e4 / 3 * 4;
              t3 = true;
              break;
            case "DeviceCMYK":
              t3 = true;
          }
          if (t3) {
            const t4 = await this.#$(a2, r2);
            if (t4) return t4;
            const i3 = await this.getImageBytes(e4, { drawWidth: a2, drawHeight: r2, forceRGBA: true });
            return this.createBitmap(v, a2, r2, i3);
          }
        } else switch (this.colorSpace.name) {
          case "DeviceGray":
            e4 *= 3;
          case "DeviceRGB":
          case "DeviceCMYK":
            i2.kind = C;
            i2.data = await this.getImageBytes(e4, { drawWidth: a2, drawHeight: r2, forceRGB: true });
            return h2 ? ImageResizer.createImage(i2) : i2;
        }
      }
    }
    const u2 = await this.getImageBytes(o2 * l2, { internal: true }), d2 = 0 | u2.length / l2 * r2 / o2, f2 = this.getComponents(u2);
    let g2, p2, m2, b2, y2, w2;
    if (t2 && !h2) {
      m2 = new OffscreenCanvas(a2, r2);
      b2 = m2.getContext("2d");
      y2 = b2.createImageData(a2, r2);
      w2 = y2.data;
    }
    i2.kind = v;
    if (e2 || this.smask || this.mask) {
      t2 && !h2 || (w2 = new Uint8ClampedArray(a2 * r2 * 4));
      g2 = 1;
      p2 = true;
      await this.fillOpacity(w2, a2, r2, d2, f2);
    } else {
      if (!t2 || h2) {
        i2.kind = C;
        w2 = new Uint8ClampedArray(a2 * r2 * 3);
        g2 = 0;
      } else {
        new Uint32Array(w2.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255);
        g2 = 1;
      }
      p2 = false;
    }
    this.needsDecode && this.decodeBuffer(f2);
    this.colorSpace.fillRgb(w2, s2, o2, a2, r2, d2, c2, f2, g2);
    p2 && this.undoPreblend(w2, a2, d2);
    if (t2 && !h2) {
      b2.putImageData(y2, 0, 0);
      return { data: null, width: a2, height: r2, bitmap: m2.transferToImageBitmap(), interpolate: this.interpolate };
    }
    i2.data = w2;
    return h2 ? ImageResizer.createImage(i2) : i2;
  }
  async fillGrayBuffer(e2) {
    const t2 = this.numComps;
    if (1 !== t2) throw new FormatError(`Reading gray scale from a color image: ${t2}`);
    const a2 = this.width, r2 = this.height, i2 = this.bpc, n2 = a2 * t2 * i2 + 7 >> 3, s2 = await this.getImageBytes(r2 * n2, { internal: true }), o2 = this.getComponents(s2);
    let c2, l2;
    if (1 === i2) {
      l2 = a2 * r2;
      if (this.needsDecode) for (c2 = 0; c2 < l2; ++c2) e2[c2] = o2[c2] - 1 & 255;
      else for (c2 = 0; c2 < l2; ++c2) e2[c2] = 255 & -o2[c2];
      return;
    }
    this.needsDecode && this.decodeBuffer(o2);
    l2 = a2 * r2;
    const h2 = 255 / ((1 << i2) - 1);
    for (c2 = 0; c2 < l2; ++c2) e2[c2] = h2 * o2[c2];
  }
  createBitmap(e2, t2, a2, r2) {
    const i2 = new OffscreenCanvas(t2, a2), n2 = i2.getContext("2d");
    let s2;
    if (e2 === v) s2 = new ImageData(r2, t2, a2);
    else {
      s2 = n2.createImageData(t2, a2);
      convertToRGBA({ kind: e2, src: r2, dest: new Uint32Array(s2.data.buffer), width: t2, height: a2, inverseDecode: this.needsDecode });
    }
    n2.putImageData(s2, 0, 0);
    return { data: null, width: t2, height: a2, bitmap: i2.transferToImageBitmap(), interpolate: this.interpolate };
  }
  async #$(e2, t2) {
    const a2 = await this.image.getTransferableImage();
    return a2 ? { data: null, width: e2, height: t2, bitmap: a2, interpolate: this.interpolate } : null;
  }
  async getImageBytes(e2, { drawWidth: t2, drawHeight: a2, forceRGBA: r2 = false, forceRGB: i2 = false, internal: n2 = false }) {
    this.image.reset();
    this.image.drawWidth = t2 || this.width;
    this.image.drawHeight = a2 || this.height;
    this.image.forceRGBA = !!r2;
    this.image.forceRGB = !!i2;
    const s2 = await this.image.getImageData(e2, this.jpxDecoderOptions);
    if (n2 || this.image instanceof DecodeStream) return s2;
    assert(s2 instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
    return new Uint8Array(s2);
  }
};
var Bn = Object.freeze({ maxImageSize: -1, disableFontFace: false, ignoreErrors: false, isEvalSupported: true, isOffscreenCanvasSupported: false, isImageDecoderSupported: false, canvasMaxAreaInBytes: -1, fontExtraProperties: false, useSystemFonts: true, useWasm: true, useWorkerFetch: true, cMapUrl: null, iccUrl: null, standardFontDataUrl: null, wasmUrl: null });
var Rn = 1;
var Nn = 2;
var En = Promise.resolve();
function normalizeBlendMode(e2, t2 = false) {
  if (Array.isArray(e2)) {
    for (const t3 of e2) {
      const e3 = normalizeBlendMode(t3, true);
      if (e3) return e3;
    }
    warn(`Unsupported blend mode Array: ${e2}`);
    return "source-over";
  }
  if (!(e2 instanceof Name)) return t2 ? null : "source-over";
  switch (e2.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  if (t2) return null;
  warn(`Unsupported blend mode: ${e2.name}`);
  return "source-over";
}
function addCachedImageOps(e2, { objId: t2, fn: a2, args: r2, optionalContent: i2, hasMask: n2 }) {
  t2 && e2.addDependency(t2);
  e2.addImageOps(a2, r2, i2, n2);
  a2 === Vt && r2[0]?.count > 0 && r2[0].count++;
}
var TimeSlotManager = class _TimeSlotManager {
  static TIME_SLOT_DURATION_MS = 20;
  static CHECK_TIME_EVERY = 100;
  constructor() {
    this.reset();
  }
  check() {
    if (++this.checked < _TimeSlotManager.CHECK_TIME_EVERY) return false;
    this.checked = 0;
    return this.endTime <= Date.now();
  }
  reset() {
    this.endTime = Date.now() + _TimeSlotManager.TIME_SLOT_DURATION_MS;
    this.checked = 0;
  }
};
var PartialEvaluator = class _PartialEvaluator {
  constructor({ xref: e2, handler: t2, pageIndex: a2, idFactory: r2, fontCache: i2, builtInCMapCache: n2, standardFontDataCache: s2, globalColorSpaceCache: o2, globalImageCache: c2, systemFontCache: l2, options: h2 = null }) {
    this.xref = e2;
    this.handler = t2;
    this.pageIndex = a2;
    this.idFactory = r2;
    this.fontCache = i2;
    this.builtInCMapCache = n2;
    this.standardFontDataCache = s2;
    this.globalColorSpaceCache = o2;
    this.globalImageCache = c2;
    this.systemFontCache = l2;
    this.options = h2 || Bn;
    this.type3FontRefs = null;
    this._regionalImageCache = new RegionalImageCache();
    this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
  }
  get _pdfFunctionFactory() {
    return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.options.isEvalSupported }));
  }
  get parsingType3Font() {
    return !!this.type3FontRefs;
  }
  clone(e2 = null) {
    const t2 = Object.create(this);
    t2.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, e2);
    return t2;
  }
  hasBlendModes(e2, t2) {
    if (!(e2 instanceof Dict)) return false;
    if (e2.objId && t2.has(e2.objId)) return false;
    const a2 = new RefSet(t2);
    e2.objId && a2.put(e2.objId);
    const r2 = [e2], i2 = this.xref;
    for (; r2.length; ) {
      const e3 = r2.shift(), t3 = e3.get("ExtGState");
      if (t3 instanceof Dict) for (let e4 of t3.getRawValues()) {
        if (e4 instanceof Ref) {
          if (a2.has(e4)) continue;
          try {
            e4 = i2.fetch(e4);
          } catch (t5) {
            a2.put(e4);
            info(`hasBlendModes - ignoring ExtGState: "${t5}".`);
            continue;
          }
        }
        if (!(e4 instanceof Dict)) continue;
        e4.objId && a2.put(e4.objId);
        const t4 = e4.get("BM");
        if (t4 instanceof Name) {
          if ("Normal" !== t4.name) return true;
        } else if (void 0 !== t4 && Array.isArray(t4)) {
          for (const e5 of t4) if (e5 instanceof Name && "Normal" !== e5.name) return true;
        }
      }
      const n2 = e3.get("XObject");
      if (n2 instanceof Dict) for (let e4 of n2.getRawValues()) {
        if (e4 instanceof Ref) {
          if (a2.has(e4)) continue;
          try {
            e4 = i2.fetch(e4);
          } catch (t5) {
            a2.put(e4);
            info(`hasBlendModes - ignoring XObject: "${t5}".`);
            continue;
          }
        }
        if (!(e4 instanceof BaseStream)) continue;
        e4.dict.objId && a2.put(e4.dict.objId);
        const t4 = e4.dict.get("Resources");
        if (t4 instanceof Dict && (!t4.objId || !a2.has(t4.objId))) {
          r2.push(t4);
          t4.objId && a2.put(t4.objId);
        }
      }
    }
    for (const e3 of a2) t2.put(e3);
    return false;
  }
  async fetchBuiltInCMap(e2) {
    const t2 = this.builtInCMapCache.get(e2);
    if (t2) return t2;
    let a2;
    a2 = this.options.useWorkerFetch ? { cMapData: await fetchBinaryData(`${this.options.cMapUrl}${e2}.bcmap`), isCompressed: true } : await this.handler.sendWithPromise("FetchBinaryData", { type: "cMapReaderFactory", name: e2 });
    this.builtInCMapCache.set(e2, a2);
    return a2;
  }
  async fetchStandardFontData(e2) {
    const t2 = this.standardFontDataCache.get(e2);
    if (t2) return new Stream(t2);
    if (this.options.useSystemFonts && "Symbol" !== e2 && "ZapfDingbats" !== e2) return null;
    const a2 = Yr()[e2];
    let r2;
    try {
      r2 = this.options.useWorkerFetch ? await fetchBinaryData(`${this.options.standardFontDataUrl}${a2}`) : await this.handler.sendWithPromise("FetchBinaryData", { type: "standardFontDataFactory", filename: a2 });
    } catch (e3) {
      warn(e3);
      return null;
    }
    this.standardFontDataCache.set(e2, r2);
    return new Stream(r2);
  }
  async buildFormXObject(e2, t2, a2, r2, i2, n2, s2, o2) {
    const { dict: c2 } = t2, l2 = lookupMatrix(c2.getArray("Matrix"), null), h2 = lookupNormalRect(c2.getArray("BBox"), null);
    let u2, d2;
    c2.has("OC") && (u2 = await this.parseMarkedContentProps(c2.get("OC"), e2));
    void 0 !== u2 && r2.addOp(jt, ["OC", u2]);
    const f2 = c2.get("Group");
    if (f2) {
      d2 = { matrix: l2, bbox: h2, smask: a2, isolated: false, knockout: false };
      let t3 = null;
      if (isName(f2.get("S"), "Transparency")) {
        d2.isolated = f2.get("I") || false;
        d2.knockout = f2.get("K") || false;
        if (f2.has("CS")) {
          const a3 = this._getColorSpace(f2.getRaw("CS"), e2, s2);
          t3 = a3 instanceof ColorSpace ? a3 : await this._handleColorSpace(a3);
        }
      }
      if (a2?.backdrop) {
        t3 ||= ColorSpaceUtils.rgb;
        a2.backdrop = t3.getRgbHex(a2.backdrop, 0);
      }
      r2.addOp(Wt, [d2]);
    }
    const g2 = [l2 && new Float32Array(l2), !f2 && h2 && new Float32Array(h2) || null];
    r2.addOp(qt, g2);
    const p2 = c2.get("Resources");
    await this.getOperatorList({ stream: t2, task: i2, resources: p2 instanceof Dict ? p2 : e2, operatorList: r2, initialState: n2, prevRefs: o2 });
    r2.addOp(Ht, []);
    f2 && r2.addOp(zt, [d2]);
    void 0 !== u2 && r2.addOp(_t, []);
  }
  _sendImgData(e2, t2, a2 = false) {
    const r2 = t2 ? [t2.bitmap || t2.data.buffer] : null;
    return this.parsingType3Font || a2 ? this.handler.send("commonobj", [e2, "Image", t2], r2) : this.handler.send("obj", [e2, this.pageIndex, "Image", t2], r2);
  }
  async buildPaintImageXObject({ resources: e2, image: t2, isInline: a2 = false, operatorList: r2, cacheKey: i2, localImageCache: n2, localColorSpaceCache: s2 }) {
    const { maxImageSize: o2, ignoreErrors: c2, isOffscreenCanvasSupported: l2 } = this.options, { dict: h2 } = t2, u2 = h2.objId, d2 = h2.get("W", "Width"), f2 = h2.get("H", "Height");
    if (!d2 || "number" != typeof d2 || !f2 || "number" != typeof f2) {
      warn("Image dimensions are missing, or not numbers.");
      return;
    }
    if (-1 !== o2 && d2 * f2 > o2) {
      const e3 = "Image exceeded maximum allowed size and was removed.";
      if (!c2) throw new Error(e3);
      warn(e3);
      return;
    }
    let g2;
    h2.has("OC") && (g2 = await this.parseMarkedContentProps(h2.get("OC"), e2));
    let p2, m2, b2;
    if (h2.get("IM", "ImageMask") || false) {
      p2 = await PDFImage.createMask({ image: t2, isOffscreenCanvasSupported: l2 && !this.parsingType3Font });
      if (p2.isSingleOpaquePixel) {
        m2 = ta;
        b2 = [];
        r2.addImageOps(m2, b2, g2);
        if (i2) {
          const e4 = { fn: m2, args: b2, optionalContent: g2 };
          n2.set(i2, u2, e4);
          u2 && this._regionalImageCache.set(null, u2, e4);
        }
        return;
      }
      if (this.parsingType3Font) {
        b2 = (function compileType3Glyph({ data: e4, width: t3, height: a3 }) {
          if (t3 > 1e3 || a3 > 1e3) return null;
          const r3 = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), i3 = t3 + 1, n3 = new Uint8Array(i3 * (a3 + 1));
          let s3, o3, c3;
          const l3 = t3 + 7 & -8, h3 = new Uint8Array(l3 * a3);
          let u3 = 0;
          for (const t4 of e4) {
            let e5 = 128;
            for (; e5 > 0; ) {
              h3[u3++] = t4 & e5 ? 0 : 255;
              e5 >>= 1;
            }
          }
          let d3 = 0;
          u3 = 0;
          if (0 !== h3[u3]) {
            n3[0] = 1;
            ++d3;
          }
          for (o3 = 1; o3 < t3; o3++) {
            if (h3[u3] !== h3[u3 + 1]) {
              n3[o3] = h3[u3] ? 2 : 1;
              ++d3;
            }
            u3++;
          }
          if (0 !== h3[u3]) {
            n3[o3] = 2;
            ++d3;
          }
          for (s3 = 1; s3 < a3; s3++) {
            u3 = s3 * l3;
            c3 = s3 * i3;
            if (h3[u3 - l3] !== h3[u3]) {
              n3[c3] = h3[u3] ? 1 : 8;
              ++d3;
            }
            let e5 = (h3[u3] ? 4 : 0) + (h3[u3 - l3] ? 8 : 0);
            for (o3 = 1; o3 < t3; o3++) {
              e5 = (e5 >> 2) + (h3[u3 + 1] ? 4 : 0) + (h3[u3 - l3 + 1] ? 8 : 0);
              if (r3[e5]) {
                n3[c3 + o3] = r3[e5];
                ++d3;
              }
              u3++;
            }
            if (h3[u3 - l3] !== h3[u3]) {
              n3[c3 + o3] = h3[u3] ? 2 : 4;
              ++d3;
            }
            if (d3 > 1e3) return null;
          }
          u3 = l3 * (a3 - 1);
          c3 = s3 * i3;
          if (0 !== h3[u3]) {
            n3[c3] = 8;
            ++d3;
          }
          for (o3 = 1; o3 < t3; o3++) {
            if (h3[u3] !== h3[u3 + 1]) {
              n3[c3 + o3] = h3[u3] ? 4 : 8;
              ++d3;
            }
            u3++;
          }
          if (0 !== h3[u3]) {
            n3[c3 + o3] = 4;
            ++d3;
          }
          if (d3 > 1e3) return null;
          const f3 = new Int32Array([0, i3, -1, 0, -i3, 0, 0, 0, 1]), g3 = [], { a: p3, b: m3, c: b3, d: y3, e: w3, f: x3 } = new DOMMatrix().scaleSelf(1 / t3, -1 / a3).translateSelf(0, -a3);
          for (s3 = 0; d3 && s3 <= a3; s3++) {
            let e5 = s3 * i3;
            const a4 = e5 + t3;
            for (; e5 < a4 && !n3[e5]; ) e5++;
            if (e5 === a4) continue;
            let r4 = e5 % i3, o4 = s3;
            g3.push(sa, p3 * r4 + b3 * o4 + w3, m3 * r4 + y3 * o4 + x3);
            const c4 = e5;
            let l4 = n3[e5];
            do {
              const t4 = f3[l4];
              do {
                e5 += t4;
              } while (!n3[e5]);
              const a5 = n3[e5];
              if (5 !== a5 && 10 !== a5) {
                l4 = a5;
                n3[e5] = 0;
              } else {
                l4 = a5 & 51 * l4 >> 4;
                n3[e5] &= l4 >> 2 | l4 << 2;
              }
              r4 = e5 % i3;
              o4 = e5 / i3 | 0;
              g3.push(oa, p3 * r4 + b3 * o4 + w3, m3 * r4 + y3 * o4 + x3);
              n3[e5] || --d3;
            } while (c4 !== e5);
            --s3;
          }
          return [na, [new Float32Array(g3)], new Float32Array([0, 0, t3, a3])];
        })(p2);
        if (b2) {
          r2.addImageOps(aa, b2, g2);
          return;
        }
        warn("Cannot compile Type3 glyph.");
        r2.addImageOps(Vt, [p2], g2);
        return;
      }
      const e3 = `mask_${this.idFactory.createObjId()}`;
      r2.addDependency(e3);
      p2.dataLen = p2.bitmap ? p2.width * p2.height * 4 : p2.data.length;
      this._sendImgData(e3, p2);
      m2 = Vt;
      b2 = [{ data: e3, width: p2.width, height: p2.height, interpolate: p2.interpolate, count: 1 }];
      r2.addImageOps(m2, b2, g2);
      if (i2) {
        const t3 = { objId: e3, fn: m2, args: b2, optionalContent: g2 };
        n2.set(i2, u2, t3);
        u2 && this._regionalImageCache.set(null, u2, t3);
      }
      return;
    }
    const y2 = h2.has("SMask") || h2.has("Mask");
    if (a2 && d2 + f2 < 200 && !y2) {
      try {
        const i3 = new PDFImage({ xref: this.xref, res: e2, image: t2, isInline: a2, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: s2 });
        p2 = await i3.createImageData(true, false);
        r2.addImageOps(Yt, [p2], g2);
      } catch (e3) {
        const t3 = `Unable to decode inline image: "${e3}".`;
        if (!c2) throw new Error(t3);
        warn(t3);
      }
      return;
    }
    let w2 = `img_${this.idFactory.createObjId()}`, x2 = false, S2 = null;
    if (this.parsingType3Font) w2 = `${this.idFactory.getDocId()}_type3_${w2}`;
    else if (i2 && u2) {
      x2 = this.globalImageCache.shouldCache(u2, this.pageIndex);
      if (x2) {
        assert(!a2, "Cannot cache an inline image globally.");
        w2 = `${this.idFactory.getDocId()}_${w2}`;
      }
    }
    r2.addDependency(w2);
    m2 = Jt;
    b2 = [w2, d2, f2];
    r2.addImageOps(m2, b2, g2, y2);
    if (x2) {
      S2 = { objId: w2, fn: m2, args: b2, optionalContent: g2, hasMask: y2, byteSize: 0 };
      if (this.globalImageCache.hasDecodeFailed(u2)) {
        this.globalImageCache.setData(u2, S2);
        this._sendImgData(w2, null, x2);
        return;
      }
      if (d2 * f2 > 25e4 || y2) {
        const e3 = await this.handler.sendWithPromise("commonobj", [w2, "CopyLocalImage", { imageRef: u2 }]);
        if (e3) {
          this.globalImageCache.setData(u2, S2);
          this.globalImageCache.addByteSize(u2, e3);
          return;
        }
      }
    }
    PDFImage.buildImage({ xref: this.xref, res: e2, image: t2, isInline: a2, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: s2 }).then((async (e3) => {
      p2 = await e3.createImageData(false, l2);
      p2.dataLen = p2.bitmap ? p2.width * p2.height * 4 : p2.data.length;
      p2.ref = u2;
      x2 && this.globalImageCache.addByteSize(u2, p2.dataLen);
      return this._sendImgData(w2, p2, x2);
    })).catch(((e3) => {
      warn(`Unable to decode image "${w2}": "${e3}".`);
      u2 && this.globalImageCache.addDecodeFailed(u2);
      return this._sendImgData(w2, null, x2);
    }));
    if (i2) {
      const e3 = { objId: w2, fn: m2, args: b2, optionalContent: g2, hasMask: y2 };
      n2.set(i2, u2, e3);
      if (u2) {
        this._regionalImageCache.set(null, u2, e3);
        if (x2) {
          assert(S2, "The global cache-data must be available.");
          this.globalImageCache.setData(u2, S2);
        }
      }
    }
  }
  handleSMask(e2, t2, a2, r2, i2, n2, s2) {
    const o2 = e2.get("G"), c2 = { subtype: e2.get("S").name, backdrop: e2.get("BC") }, l2 = e2.get("TR");
    if (isPDFFunction(l2)) {
      const e3 = this._pdfFunctionFactory.create(l2), t3 = new Uint8Array(256), a3 = new Float32Array(1);
      for (let r3 = 0; r3 < 256; r3++) {
        a3[0] = r3 / 255;
        e3(a3, 0, a3, 0);
        t3[r3] = 255 * a3[0] | 0;
      }
      c2.transferMap = t3;
    }
    return this.buildFormXObject(t2, o2, c2, a2, r2, i2.state.clone({ newPath: true }), n2, s2);
  }
  handleTransferFunction(e2) {
    let t2;
    if (Array.isArray(e2)) t2 = e2;
    else {
      if (!isPDFFunction(e2)) return null;
      t2 = [e2];
    }
    const a2 = [];
    let r2 = 0, i2 = 0;
    for (const e3 of t2) {
      const t3 = this.xref.fetchIfRef(e3);
      r2++;
      if (isName(t3, "Identity")) {
        a2.push(null);
        continue;
      }
      if (!isPDFFunction(t3)) return null;
      const n2 = this._pdfFunctionFactory.create(t3), s2 = new Uint8Array(256), o2 = new Float32Array(1);
      for (let e4 = 0; e4 < 256; e4++) {
        o2[0] = e4 / 255;
        n2(o2, 0, o2, 0);
        s2[e4] = 255 * o2[0] | 0;
      }
      a2.push(s2);
      i2++;
    }
    return 1 !== r2 && 4 !== r2 || 0 === i2 ? null : a2;
  }
  handleTilingType(e2, t2, a2, r2, i2, n2, s2, o2) {
    const c2 = new OperatorList(), l2 = Dict.merge({ xref: this.xref, dictArray: [i2.get("Resources"), a2] });
    return this.getOperatorList({ stream: r2, task: s2, resources: l2, operatorList: c2 }).then((function() {
      const a3 = c2.getIR(), r3 = getTilingPatternIR(a3, i2, t2);
      n2.addDependencies(c2.dependencies);
      n2.addOp(e2, r3);
      i2.objId && o2.set(null, i2.objId, { operatorListIR: a3, dict: i2 });
    })).catch(((e3) => {
      if (!(e3 instanceof AbortException)) {
        if (!this.options.ignoreErrors) throw e3;
        warn(`handleTilingType - ignoring pattern: "${e3}".`);
      }
    }));
  }
  async handleSetFont(e2, t2, a2, r2, i2, n2, s2 = null, o2 = null) {
    const c2 = t2?.[0] instanceof Name ? t2[0].name : null, l2 = await this.loadFont(c2, a2, e2, i2, s2, o2);
    l2.font.isType3Font && r2.addDependencies(l2.type3Dependencies);
    n2.font = l2.font;
    l2.send(this.handler);
    return l2.loadedName;
  }
  handleText(e2, t2) {
    const a2 = t2.font, r2 = a2.charsToGlyphs(e2);
    if (a2.data) {
      (!!(t2.textRenderingMode & S) || "Pattern" === t2.fillColorSpace.name || a2.disableFontFace) && _PartialEvaluator.buildFontPaths(a2, r2, this.handler, this.options);
    }
    return r2;
  }
  ensureStateFont(e2) {
    if (e2.font) return;
    const t2 = new FormatError("Missing setFont (Tf) operator before text rendering operator.");
    if (!this.options.ignoreErrors) throw t2;
    warn(`ensureStateFont: "${t2}".`);
  }
  async setGState({ resources: e2, gState: t2, operatorList: a2, cacheKey: r2, task: i2, stateManager: n2, localGStateCache: s2, localColorSpaceCache: o2, seenRefs: c2 }) {
    const l2 = t2.objId;
    let h2 = true;
    const u2 = [];
    let d2 = Promise.resolve();
    for (const [r3, s3] of t2) switch (r3) {
      case "Type":
        break;
      case "LW":
        if ("number" != typeof s3) {
          warn(`Invalid LW (line width): ${s3}`);
          break;
        }
        u2.push([r3, Math.abs(s3)]);
        break;
      case "LC":
      case "LJ":
      case "ML":
      case "D":
      case "RI":
      case "FL":
      case "CA":
      case "ca":
        u2.push([r3, s3]);
        break;
      case "Font":
        h2 = false;
        d2 = d2.then((() => this.handleSetFont(e2, null, s3[0], a2, i2, n2.state).then((function(e3) {
          a2.addDependency(e3);
          u2.push([r3, [e3, s3[1]]]);
        }))));
        break;
      case "BM":
        u2.push([r3, normalizeBlendMode(s3)]);
        break;
      case "SMask":
        if (isName(s3, "None")) {
          u2.push([r3, false]);
          break;
        }
        if (s3 instanceof Dict) {
          h2 = false;
          d2 = d2.then((() => this.handleSMask(s3, e2, a2, i2, n2, o2, c2)));
          u2.push([r3, true]);
        } else warn("Unsupported SMask type");
        break;
      case "TR":
        const t3 = this.handleTransferFunction(s3);
        u2.push([r3, t3]);
        break;
      case "OP":
      case "op":
      case "OPM":
      case "BG":
      case "BG2":
      case "UCR":
      case "UCR2":
      case "TR2":
      case "HT":
      case "SM":
      case "SA":
      case "AIS":
      case "TK":
        info("graphic state operator " + r3);
        break;
      default:
        info("Unknown graphic state operator " + r3);
    }
    await d2;
    u2.length > 0 && a2.addOp(De, [u2]);
    h2 && s2.set(r2, l2, u2);
  }
  loadFont(e2, t2, a2, r2, i2 = null, n2 = null) {
    const errorFont = async () => new TranslatedFont({ loadedName: "g_font_error", font: new ErrorFont(`Font "${e2}" is not available.`), dict: t2 });
    let s2;
    if (t2) t2 instanceof Ref && (s2 = t2);
    else {
      const t3 = a2.get("Font");
      t3 && (s2 = t3.getRaw(e2));
    }
    if (s2) {
      if (this.type3FontRefs?.has(s2)) return errorFont();
      if (this.fontCache.has(s2)) return this.fontCache.get(s2);
      try {
        t2 = this.xref.fetchIfRef(s2);
      } catch (e3) {
        warn(`loadFont - lookup failed: "${e3}".`);
      }
    }
    if (!(t2 instanceof Dict)) {
      if (!this.options.ignoreErrors && !this.parsingType3Font) {
        warn(`Font "${e2}" is not available.`);
        return errorFont();
      }
      warn(`Font "${e2}" is not available -- attempting to fallback to a default font.`);
      t2 = i2 || _PartialEvaluator.fallbackFontDict;
    }
    if (t2.cacheKey && this.fontCache.has(t2.cacheKey)) return this.fontCache.get(t2.cacheKey);
    const { promise: o2, resolve: c2 } = Promise.withResolvers();
    let l2;
    try {
      l2 = this.preEvaluateFont(t2);
      l2.cssFontInfo = n2;
    } catch (e3) {
      warn(`loadFont - preEvaluateFont failed: "${e3}".`);
      return errorFont();
    }
    const { descriptor: h2, hash: u2 } = l2, d2 = s2 instanceof Ref;
    let f2;
    if (u2 && h2 instanceof Dict) {
      const e3 = h2.fontAliases ||= /* @__PURE__ */ Object.create(null);
      if (e3[u2]) {
        const t3 = e3[u2].aliasRef;
        if (d2 && t3 && this.fontCache.has(t3)) {
          this.fontCache.putAlias(s2, t3);
          return this.fontCache.get(s2);
        }
      } else e3[u2] = { fontID: this.idFactory.createFontId() };
      d2 && (e3[u2].aliasRef = s2);
      f2 = e3[u2].fontID;
    } else f2 = this.idFactory.createFontId();
    assert(f2?.startsWith("f"), 'The "fontID" must be (correctly) defined.');
    if (d2) this.fontCache.put(s2, o2);
    else {
      t2.cacheKey = `cacheKey_${f2}`;
      this.fontCache.put(t2.cacheKey, o2);
    }
    t2.loadedName = `${this.idFactory.getDocId()}_${f2}`;
    this.translateFont(l2).then((async (e3) => {
      const i3 = new TranslatedFont({ loadedName: t2.loadedName, font: e3, dict: t2 });
      if (e3.isType3Font) try {
        await i3.loadType3Data(this, a2, r2);
      } catch (e4) {
        throw new Error(`Type3 font load error: ${e4}`);
      }
      c2(i3);
    })).catch(((e3) => {
      warn(`loadFont - translateFont failed: "${e3}".`);
      c2(new TranslatedFont({ loadedName: t2.loadedName, font: new ErrorFont(e3?.message), dict: t2 }));
    }));
    return o2;
  }
  buildPath(e2, t2, a2) {
    const { pathMinMax: r2, pathBuffer: i2 } = a2;
    switch (0 | e2) {
      case Xe: {
        const e3 = a2.currentPointX = t2[0], n2 = a2.currentPointY = t2[1], s2 = t2[2], o2 = t2[3], c2 = e3 + s2, l2 = n2 + o2;
        0 === s2 || 0 === o2 ? i2.push(sa, e3, n2, oa, c2, l2, la) : i2.push(sa, e3, n2, oa, c2, n2, oa, c2, l2, oa, e3, l2, la);
        Util.rectBoundingBox(e3, n2, c2, l2, r2);
        break;
      }
      case Ee: {
        const e3 = a2.currentPointX = t2[0], n2 = a2.currentPointY = t2[1];
        i2.push(sa, e3, n2);
        Util.pointBoundingBox(e3, n2, r2);
        break;
      }
      case Pe: {
        const e3 = a2.currentPointX = t2[0], n2 = a2.currentPointY = t2[1];
        i2.push(oa, e3, n2);
        Util.pointBoundingBox(e3, n2, r2);
        break;
      }
      case Le: {
        const e3 = a2.currentPointX, n2 = a2.currentPointY, [s2, o2, c2, l2, h2, u2] = t2;
        a2.currentPointX = h2;
        a2.currentPointY = u2;
        i2.push(ca, s2, o2, c2, l2, h2, u2);
        Util.bezierBoundingBox(e3, n2, s2, o2, c2, l2, h2, u2, r2);
        break;
      }
      case je: {
        const e3 = a2.currentPointX, n2 = a2.currentPointY, [s2, o2, c2, l2] = t2;
        a2.currentPointX = c2;
        a2.currentPointY = l2;
        i2.push(ca, e3, n2, s2, o2, c2, l2);
        Util.bezierBoundingBox(e3, n2, e3, n2, s2, o2, c2, l2, r2);
        break;
      }
      case _e: {
        const e3 = a2.currentPointX, n2 = a2.currentPointY, [s2, o2, c2, l2] = t2;
        a2.currentPointX = c2;
        a2.currentPointY = l2;
        i2.push(ca, s2, o2, c2, l2, c2, l2);
        Util.bezierBoundingBox(e3, n2, s2, o2, c2, l2, c2, l2, r2);
        break;
      }
      case Ue:
        i2.push(la);
    }
  }
  _getColorSpace(e2, t2, a2) {
    return ColorSpaceUtils.parse({ cs: e2, xref: this.xref, resources: t2, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: a2, asyncIfNotCached: true });
  }
  async _handleColorSpace(e2) {
    try {
      return await e2;
    } catch (e3) {
      if (e3 instanceof AbortException) return null;
      if (this.options.ignoreErrors) {
        warn(`_handleColorSpace - ignoring ColorSpace: "${e3}".`);
        return null;
      }
      throw e3;
    }
  }
  parseShading({ shading: e2, resources: t2, localColorSpaceCache: a2, localShadingPatternCache: r2 }) {
    let i2, n2 = r2.get(e2);
    if (n2) return n2;
    try {
      i2 = Pattern.parseShading(e2, this.xref, t2, this._pdfFunctionFactory, this.globalColorSpaceCache, a2).getIR();
    } catch (t3) {
      if (t3 instanceof AbortException) return null;
      if (this.options.ignoreErrors) {
        warn(`parseShading - ignoring shading: "${t3}".`);
        r2.set(e2, null);
        return null;
      }
      throw t3;
    }
    n2 = `pattern_${this.idFactory.createObjId()}`;
    this.parsingType3Font && (n2 = `${this.idFactory.getDocId()}_type3_${n2}`);
    r2.set(e2, n2);
    this.parsingType3Font ? this.handler.send("commonobj", [n2, "Pattern", i2]) : this.handler.send("obj", [n2, this.pageIndex, "Pattern", i2]);
    return n2;
  }
  handleColorN(e2, t2, a2, r2, i2, n2, s2, o2, c2, l2) {
    const h2 = a2.pop();
    if (h2 instanceof Name) {
      const u2 = i2.getRaw(h2.name), d2 = u2 instanceof Ref && c2.getByRef(u2);
      if (d2) try {
        const i3 = r2.base ? r2.base.getRgbHex(a2, 0) : null, n3 = getTilingPatternIR(d2.operatorListIR, d2.dict, i3);
        e2.addOp(t2, n3);
        return;
      } catch {
      }
      const f2 = this.xref.fetchIfRef(u2);
      if (f2) {
        const i3 = f2 instanceof BaseStream ? f2.dict : f2, h3 = i3.get("PatternType");
        if (h3 === Rn) {
          const o3 = r2.base ? r2.base.getRgbHex(a2, 0) : null;
          return this.handleTilingType(t2, o3, n2, f2, i3, e2, s2, c2);
        }
        if (h3 === Nn) {
          const a3 = i3.get("Shading"), r3 = this.parseShading({ shading: a3, resources: n2, localColorSpaceCache: o2, localShadingPatternCache: l2 });
          if (r3) {
            const a4 = lookupMatrix(i3.getArray("Matrix"), null);
            e2.addOp(t2, ["Shading", r3, a4]);
          }
          return;
        }
        throw new FormatError(`Unknown PatternType: ${h3}`);
      }
    }
    throw new FormatError(`Unknown PatternName: ${h2}`);
  }
  _parseVisibilityExpression(e2, t2, a2) {
    if (++t2 > 10) {
      warn("Visibility expression is too deeply nested");
      return;
    }
    const r2 = e2.length, i2 = this.xref.fetchIfRef(e2[0]);
    if (!(r2 < 2) && i2 instanceof Name) {
      switch (i2.name) {
        case "And":
        case "Or":
        case "Not":
          a2.push(i2.name);
          break;
        default:
          warn(`Invalid operator ${i2.name} in visibility expression`);
          return;
      }
      for (let i3 = 1; i3 < r2; i3++) {
        const r3 = e2[i3], n2 = this.xref.fetchIfRef(r3);
        if (Array.isArray(n2)) {
          const e3 = [];
          a2.push(e3);
          this._parseVisibilityExpression(n2, t2, e3);
        } else r3 instanceof Ref && a2.push(r3.toString());
      }
    } else warn("Invalid visibility expression");
  }
  async parseMarkedContentProps(e2, t2) {
    let a2;
    if (e2 instanceof Name) {
      a2 = t2.get("Properties").get(e2.name);
    } else {
      if (!(e2 instanceof Dict)) throw new FormatError("Optional content properties malformed.");
      a2 = e2;
    }
    const r2 = a2.get("Type")?.name;
    if ("OCG" === r2) return { type: r2, id: a2.objId };
    if ("OCMD" === r2) {
      const e3 = a2.get("VE");
      if (Array.isArray(e3)) {
        const t4 = [];
        this._parseVisibilityExpression(e3, 0, t4);
        if (t4.length > 0) return { type: "OCMD", expression: t4 };
      }
      const t3 = a2.get("OCGs");
      if (Array.isArray(t3) || t3 instanceof Dict) {
        const e4 = [];
        if (Array.isArray(t3)) for (const a3 of t3) e4.push(a3.toString());
        else e4.push(t3.objId);
        return { type: r2, ids: e4, policy: a2.get("P") instanceof Name ? a2.get("P").name : null, expression: null };
      }
      if (t3 instanceof Ref) return { type: r2, id: t3.toString() };
    }
    return null;
  }
  getOperatorList({ stream: e2, task: t2, resources: a2, operatorList: r2, initialState: i2 = null, fallbackFontDict: n2 = null, prevRefs: s2 = null }) {
    const o2 = e2.dict?.objId, c2 = new RefSet(s2);
    if (o2) {
      if (s2?.has(o2)) throw new Error(`getOperatorList - ignoring circular reference: ${o2}`);
      c2.put(o2);
    }
    a2 ||= Dict.empty;
    i2 ||= new EvalState();
    if (!r2) throw new Error('getOperatorList: missing "operatorList" parameter');
    const l2 = this, h2 = this.xref, u2 = new LocalImageCache(), d2 = new LocalColorSpaceCache(), f2 = new LocalGStateCache(), g2 = new LocalTilingPatternCache(), p2 = /* @__PURE__ */ new Map(), m2 = a2.get("XObject") || Dict.empty, b2 = a2.get("Pattern") || Dict.empty, y2 = new StateManager(i2), w2 = new EvaluatorPreprocessor(e2, h2, y2), x2 = new TimeSlotManager();
    function closePendingRestoreOPS(e3) {
      for (let e4 = 0, t3 = w2.savedStatesDepth; e4 < t3; e4++) r2.addOp(Re, []);
    }
    return new Promise((function promiseBody(e3, i3) {
      const next = function(t3) {
        Promise.all([t3, r2.ready]).then((function() {
          try {
            promiseBody(e3, i3);
          } catch (e4) {
            i3(e4);
          }
        }), i3);
      };
      t2.ensureNotTerminated();
      x2.reset();
      const s3 = {};
      let o3, S2, k2, C2, v2, F2;
      for (; !(o3 = x2.check()); ) {
        s3.args = null;
        if (!w2.read(s3)) break;
        let e4 = s3.args, i4 = s3.fn;
        switch (0 | i4) {
          case Nt:
            F2 = e4[0] instanceof Name;
            v2 = e4[0].name;
            if (F2) {
              const t3 = u2.getByName(v2);
              if (t3) {
                addCachedImageOps(r2, t3);
                e4 = null;
                continue;
              }
            }
            next(new Promise((function(e5, i5) {
              if (!F2) throw new FormatError("XObject must be referred to by name.");
              let n3 = m2.getRaw(v2);
              if (n3 instanceof Ref) {
                const t3 = u2.getByRef(n3) || l2._regionalImageCache.getByRef(n3) || l2.globalImageCache.getData(n3, l2.pageIndex);
                if (t3) {
                  addCachedImageOps(r2, t3);
                  e5();
                  return;
                }
                n3 = h2.fetch(n3);
              }
              if (!(n3 instanceof BaseStream)) throw new FormatError("XObject should be a stream");
              const s5 = n3.dict.get("Subtype");
              if (!(s5 instanceof Name)) throw new FormatError("XObject should have a Name subtype");
              if ("Form" !== s5.name) if ("Image" !== s5.name) {
                if ("PS" !== s5.name) throw new FormatError(`Unhandled XObject subtype ${s5.name}`);
                info("Ignored XObject subtype PS");
                e5();
              } else l2.buildPaintImageXObject({ resources: a2, image: n3, operatorList: r2, cacheKey: v2, localImageCache: u2, localColorSpaceCache: d2 }).then(e5, i5);
              else {
                y2.save();
                l2.buildFormXObject(a2, n3, null, r2, t2, y2.state.clone({ newPath: true }), d2, c2).then((function() {
                  y2.restore();
                  e5();
                }), i5);
              }
            })).catch((function(e5) {
              if (!(e5 instanceof AbortException)) {
                if (!l2.options.ignoreErrors) throw e5;
                warn(`getOperatorList - ignoring XObject: "${e5}".`);
              }
            })));
            return;
          case nt:
            const s4 = e4[1];
            next(l2.handleSetFont(a2, e4, null, r2, t2, y2.state, n2).then((function(e5) {
              r2.addDependency(e5);
              r2.addOp(nt, [e5, s4]);
            })));
            return;
          case Rt:
            const o4 = e4[0].cacheKey;
            if (o4) {
              const t3 = u2.getByName(o4);
              if (t3) {
                addCachedImageOps(r2, t3);
                e4 = null;
                continue;
              }
            }
            next(l2.buildPaintImageXObject({ resources: a2, image: e4[0], isInline: true, operatorList: r2, cacheKey: o4, localImageCache: u2, localColorSpaceCache: d2 }));
            return;
          case dt:
            if (!y2.state.font) {
              l2.ensureStateFont(y2.state);
              continue;
            }
            e4[0] = l2.handleText(e4[0], y2.state);
            break;
          case ft:
            if (!y2.state.font) {
              l2.ensureStateFont(y2.state);
              continue;
            }
            const w3 = [], x3 = y2.state;
            for (const t3 of e4[0]) "string" == typeof t3 ? w3.push(...l2.handleText(t3, x3)) : "number" == typeof t3 && w3.push(t3);
            e4[0] = w3;
            i4 = dt;
            break;
          case gt:
            if (!y2.state.font) {
              l2.ensureStateFont(y2.state);
              continue;
            }
            r2.addOp(ut);
            e4[0] = l2.handleText(e4[0], y2.state);
            i4 = dt;
            break;
          case pt:
            if (!y2.state.font) {
              l2.ensureStateFont(y2.state);
              continue;
            }
            r2.addOp(ut);
            r2.addOp(at, [e4.shift()]);
            r2.addOp(tt, [e4.shift()]);
            e4[0] = l2.handleText(e4[0], y2.state);
            i4 = dt;
            break;
          case st:
            y2.state.textRenderingMode = e4[0];
            break;
          case wt: {
            const t3 = l2._getColorSpace(e4[0], a2, d2);
            if (t3 instanceof ColorSpace) {
              y2.state.fillColorSpace = t3;
              continue;
            }
            next(l2._handleColorSpace(t3).then(((e5) => {
              y2.state.fillColorSpace = e5 || ColorSpaceUtils.gray;
            })));
            return;
          }
          case yt: {
            const t3 = l2._getColorSpace(e4[0], a2, d2);
            if (t3 instanceof ColorSpace) {
              y2.state.strokeColorSpace = t3;
              continue;
            }
            next(l2._handleColorSpace(t3).then(((e5) => {
              y2.state.strokeColorSpace = e5 || ColorSpaceUtils.gray;
            })));
            return;
          }
          case At:
            C2 = y2.state.fillColorSpace;
            e4 = [C2.getRgbHex(e4, 0)];
            i4 = It;
            break;
          case xt:
            C2 = y2.state.strokeColorSpace;
            e4 = [C2.getRgbHex(e4, 0)];
            i4 = Ft;
            break;
          case vt:
            y2.state.fillColorSpace = ColorSpaceUtils.gray;
            e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)];
            i4 = It;
            break;
          case Ct:
            y2.state.strokeColorSpace = ColorSpaceUtils.gray;
            e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)];
            i4 = Ft;
            break;
          case Ot:
            y2.state.fillColorSpace = ColorSpaceUtils.cmyk;
            e4 = [ColorSpaceUtils.cmyk.getRgbHex(e4, 0)];
            i4 = It;
            break;
          case Tt:
            y2.state.strokeColorSpace = ColorSpaceUtils.cmyk;
            e4 = [ColorSpaceUtils.cmyk.getRgbHex(e4, 0)];
            i4 = Ft;
            break;
          case It:
            y2.state.fillColorSpace = ColorSpaceUtils.rgb;
            e4 = [ColorSpaceUtils.rgb.getRgbHex(e4, 0)];
            break;
          case Ft:
            y2.state.strokeColorSpace = ColorSpaceUtils.rgb;
            e4 = [ColorSpaceUtils.rgb.getRgbHex(e4, 0)];
            break;
          case kt:
            C2 = y2.state.patternFillColorSpace;
            if (!C2) {
              if (isNumberArray(e4, null)) {
                e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)];
                i4 = It;
                break;
              }
              e4 = [];
              i4 = ia;
              break;
            }
            if ("Pattern" === C2.name) {
              next(l2.handleColorN(r2, kt, e4, C2, b2, a2, t2, d2, g2, p2));
              return;
            }
            e4 = [C2.getRgbHex(e4, 0)];
            i4 = It;
            break;
          case St:
            C2 = y2.state.patternStrokeColorSpace;
            if (!C2) {
              if (isNumberArray(e4, null)) {
                e4 = [ColorSpaceUtils.gray.getRgbHex(e4, 0)];
                i4 = Ft;
                break;
              }
              e4 = [];
              i4 = ra;
              break;
            }
            if ("Pattern" === C2.name) {
              next(l2.handleColorN(r2, St, e4, C2, b2, a2, t2, d2, g2, p2));
              return;
            }
            e4 = [C2.getRgbHex(e4, 0)];
            i4 = Ft;
            break;
          case Mt:
            let T2;
            try {
              const t3 = a2.get("Shading");
              if (!t3) throw new FormatError("No shading resource found");
              T2 = t3.get(e4[0].name);
              if (!T2) throw new FormatError("No shading object found");
            } catch (e5) {
              if (e5 instanceof AbortException) continue;
              if (l2.options.ignoreErrors) {
                warn(`getOperatorList - ignoring Shading: "${e5}".`);
                continue;
              }
              throw e5;
            }
            const O2 = l2.parseShading({ shading: T2, resources: a2, localColorSpaceCache: d2, localShadingPatternCache: p2 });
            if (!O2) continue;
            e4 = [O2];
            i4 = Mt;
            break;
          case De:
            F2 = e4[0] instanceof Name;
            v2 = e4[0].name;
            if (F2) {
              const t3 = f2.getByName(v2);
              if (t3) {
                t3.length > 0 && r2.addOp(De, [t3]);
                e4 = null;
                continue;
              }
            }
            next(new Promise((function(e5, i5) {
              if (!F2) throw new FormatError("GState must be referred to by name.");
              const n3 = a2.get("ExtGState");
              if (!(n3 instanceof Dict)) throw new FormatError("ExtGState should be a dictionary.");
              const s5 = n3.get(v2);
              if (!(s5 instanceof Dict)) throw new FormatError("GState should be a dictionary.");
              l2.setGState({ resources: a2, gState: s5, operatorList: r2, cacheKey: v2, task: t2, stateManager: y2, localGStateCache: f2, localColorSpaceCache: d2, seenRefs: c2 }).then(e5, i5);
            })).catch((function(e5) {
              if (!(e5 instanceof AbortException)) {
                if (!l2.options.ignoreErrors) throw e5;
                warn(`getOperatorList - ignoring ExtGState: "${e5}".`);
              }
            })));
            return;
          case Ce: {
            const [t3] = e4;
            if ("number" != typeof t3) {
              warn(`Invalid setLineWidth: ${t3}`);
              continue;
            }
            e4[0] = Math.abs(t3);
            break;
          }
          case Ee:
          case Pe:
          case Le:
          case je:
          case _e:
          case Ue:
          case Xe:
            l2.buildPath(i4, e4, y2.state);
            continue;
          case qe:
          case He:
          case We:
          case ze:
          case $e:
          case Ge:
          case Ve:
          case Ke:
          case Je: {
            const { state: { pathBuffer: e5, pathMinMax: t3 } } = y2;
            i4 !== He && i4 !== Ve && i4 !== Ke || e5.push(la);
            if (0 === e5.length) r2.addOp(aa, [i4, [null], null]);
            else {
              r2.addOp(aa, [i4, [new Float32Array(e5)], t3.slice()]);
              e5.length = 0;
              t3.set([1 / 0, 1 / 0, -1 / 0, -1 / 0], 0);
            }
            continue;
          }
          case ht:
            r2.addOp(i4, [new Float32Array(e4)]);
            continue;
          case Et:
          case Pt:
          case Ut:
          case Xt:
            continue;
          case jt:
            if (!(e4[0] instanceof Name)) {
              warn(`Expected name for beginMarkedContentProps arg0=${e4[0]}`);
              r2.addOp(jt, ["OC", null]);
              continue;
            }
            if ("OC" === e4[0].name) {
              next(l2.parseMarkedContentProps(e4[1], a2).then(((e5) => {
                r2.addOp(jt, ["OC", e5]);
              })).catch(((e5) => {
                if (!(e5 instanceof AbortException)) {
                  if (!l2.options.ignoreErrors) throw e5;
                  warn(`getOperatorList - ignoring beginMarkedContentProps: "${e5}".`);
                  r2.addOp(jt, ["OC", null]);
                }
              })));
              return;
            }
            e4 = [e4[0].name, e4[1] instanceof Dict ? e4[1].get("MCID") : null];
            break;
          default:
            if (null !== e4) {
              for (S2 = 0, k2 = e4.length; S2 < k2 && !(e4[S2] instanceof Dict); S2++) ;
              if (S2 < k2) {
                warn("getOperatorList - ignoring operator: " + i4);
                continue;
              }
            }
        }
        r2.addOp(i4, e4);
      }
      if (o3) next(En);
      else {
        closePendingRestoreOPS();
        e3();
      }
    })).catch(((e3) => {
      if (!(e3 instanceof AbortException)) {
        if (!this.options.ignoreErrors) throw e3;
        warn(`getOperatorList - ignoring errors during "${t2.name}" task: "${e3}".`);
        closePendingRestoreOPS();
      }
    }));
  }
  getTextContent({ stream: e2, task: a2, resources: r2, stateManager: i2 = null, includeMarkedContent: n2 = false, sink: s2, seenStyles: o2 = /* @__PURE__ */ new Set(), viewBox: c2, lang: l2 = null, markedContentData: h2 = null, disableNormalization: u2 = false, keepWhiteSpace: d2 = false, prevRefs: f2 = null, intersector: g2 = null }) {
    const p2 = e2.dict?.objId, m2 = new RefSet(f2);
    if (p2) {
      if (f2?.has(p2)) throw new Error(`getTextContent - ignoring circular reference: ${p2}`);
      m2.put(p2);
    }
    r2 ||= Dict.empty;
    i2 ||= new StateManager(new TextState());
    n2 && (h2 ||= { level: 0 });
    const b2 = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: l2 }, y2 = { initialized: false, str: [], totalWidth: 0, totalHeight: 0, width: 0, height: 0, vertical: false, prevTransform: null, textAdvanceScale: 0, spaceInFlowMin: 0, spaceInFlowMax: 0, trackingSpaceMin: 1 / 0, negativeSpaceMax: -1 / 0, notASpace: -1 / 0, transform: null, fontName: null, hasEOL: false }, w2 = [" ", " "];
    let x2 = 0;
    function saveLastChar(e3) {
      const t2 = (x2 + 1) % 2, a3 = " " !== w2[x2] && " " === w2[t2];
      w2[x2] = e3;
      x2 = t2;
      return !d2 && a3;
    }
    function shouldAddWhitepsace() {
      return !d2 && " " !== w2[x2] && " " === w2[(x2 + 1) % 2];
    }
    function resetLastChars() {
      w2[0] = w2[1] = " ";
      x2 = 0;
    }
    const S2 = this, k2 = this.xref, C2 = [];
    let v2 = null;
    const F2 = new LocalImageCache(), T2 = new LocalGStateCache(), O2 = new EvaluatorPreprocessor(e2, k2, i2);
    let M2;
    function pushWhitespace({ width: e3 = 0, height: t2 = 0, transform: a3 = y2.prevTransform, fontName: r3 = y2.fontName }) {
      g2?.addExtraChar(" ");
      b2.items.push({ str: " ", dir: "ltr", width: e3, height: t2, transform: a3, fontName: r3, hasEOL: false });
    }
    function getCurrentTextTransform() {
      const e3 = M2.font, a3 = [M2.fontSize * M2.textHScale, 0, 0, M2.fontSize, 0, M2.textRise];
      if (e3.isType3Font && (M2.fontSize <= 1 || e3.isCharBBox) && !isArrayEqual(M2.fontMatrix, t)) {
        const t2 = e3.bbox[3] - e3.bbox[1];
        t2 > 0 && (a3[3] *= t2 * M2.fontMatrix[3]);
      }
      return Util.transform(M2.ctm, Util.transform(M2.textMatrix, a3));
    }
    function ensureTextContentItem() {
      if (y2.initialized) return y2;
      const { font: e3, loadedName: t2 } = M2;
      if (!o2.has(t2)) {
        o2.add(t2);
        b2.styles[t2] = { fontFamily: e3.fallbackName, ascent: e3.ascent, descent: e3.descent, vertical: e3.vertical };
        if (S2.options.fontExtraProperties && e3.systemFontInfo) {
          const a4 = b2.styles[t2];
          a4.fontSubstitution = e3.systemFontInfo.css;
          a4.fontSubstitutionLoadedName = e3.systemFontInfo.loadedName;
        }
      }
      y2.fontName = t2;
      const a3 = y2.transform = getCurrentTextTransform();
      if (e3.vertical) {
        y2.width = y2.totalWidth = Math.hypot(a3[0], a3[1]);
        y2.height = y2.totalHeight = 0;
        y2.vertical = true;
      } else {
        y2.width = y2.totalWidth = 0;
        y2.height = y2.totalHeight = Math.hypot(a3[2], a3[3]);
        y2.vertical = false;
      }
      const r3 = Math.hypot(M2.textLineMatrix[0], M2.textLineMatrix[1]), i3 = Math.hypot(M2.ctm[0], M2.ctm[1]);
      y2.textAdvanceScale = i3 * r3;
      const { fontSize: n3 } = M2;
      y2.trackingSpaceMin = 0.102 * n3;
      y2.notASpace = 0.03 * n3;
      y2.negativeSpaceMax = -0.2 * n3;
      y2.spaceInFlowMin = 0.102 * n3;
      y2.spaceInFlowMax = 0.6 * n3;
      y2.hasEOL = false;
      y2.initialized = true;
      return y2;
    }
    function updateAdvanceScale() {
      if (!y2.initialized) return;
      const e3 = Math.hypot(M2.textLineMatrix[0], M2.textLineMatrix[1]), t2 = Math.hypot(M2.ctm[0], M2.ctm[1]) * e3;
      if (t2 !== y2.textAdvanceScale) {
        if (y2.vertical) {
          y2.totalHeight += y2.height * y2.textAdvanceScale;
          y2.height = 0;
        } else {
          y2.totalWidth += y2.width * y2.textAdvanceScale;
          y2.width = 0;
        }
        y2.textAdvanceScale = t2;
      }
    }
    function runBidiTransform(e3) {
      let t2 = e3.str.join("");
      u2 || (t2 = (function normalizeUnicode(e4) {
        if (!ma) {
          ma = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
          ba = /* @__PURE__ */ new Map([["ﬅ", "ſt"]]);
        }
        return e4.replaceAll(ma, ((e5, t3, a4) => t3 ? t3.normalize("NFKC") : ba.get(a4)));
      })(t2));
      const a3 = bidi(t2, -1, e3.vertical);
      return { str: a3.str, dir: a3.dir, width: Math.abs(e3.totalWidth), height: Math.abs(e3.totalHeight), transform: e3.transform, fontName: e3.fontName, hasEOL: e3.hasEOL };
    }
    async function handleSetFont(e3, i3) {
      const n3 = await S2.loadFont(e3, i3, r2, a2);
      M2.loadedName = n3.loadedName;
      M2.font = n3.font;
      M2.fontMatrix = n3.font.fontMatrix || t;
    }
    function applyInverseRotation(e3, t2, a3) {
      const r3 = Math.hypot(a3[0], a3[1]);
      return [(a3[0] * e3 + a3[1] * t2) / r3, (a3[2] * e3 + a3[3] * t2) / r3];
    }
    function compareWithLastPosition(e3) {
      const t2 = getCurrentTextTransform();
      let a3 = t2[4], r3 = t2[5];
      if (M2.font?.vertical) {
        if (a3 < c2[0] || a3 > c2[2] || r3 + e3 < c2[1] || r3 > c2[3]) return false;
      } else if (a3 + e3 < c2[0] || a3 > c2[2] || r3 < c2[1] || r3 > c2[3]) return false;
      if (!M2.font || !y2.prevTransform) return true;
      let i3 = y2.prevTransform[4], n3 = y2.prevTransform[5];
      if (i3 === a3 && n3 === r3) return true;
      let s3 = -1;
      t2[0] && 0 === t2[1] && 0 === t2[2] ? s3 = t2[0] > 0 ? 0 : 180 : t2[1] && 0 === t2[0] && 0 === t2[3] && (s3 = t2[1] > 0 ? 90 : 270);
      switch (s3) {
        case 0:
          break;
        case 90:
          [a3, r3] = [r3, a3];
          [i3, n3] = [n3, i3];
          break;
        case 180:
          [a3, r3, i3, n3] = [-a3, -r3, -i3, -n3];
          break;
        case 270:
          [a3, r3] = [-r3, -a3];
          [i3, n3] = [-n3, -i3];
          break;
        default:
          [a3, r3] = applyInverseRotation(a3, r3, t2);
          [i3, n3] = applyInverseRotation(i3, n3, y2.prevTransform);
      }
      if (M2.font.vertical) {
        const e4 = (n3 - r3) / y2.textAdvanceScale, t3 = a3 - i3, s4 = Math.sign(y2.height);
        if (e4 < s4 * y2.negativeSpaceMax) {
          if (Math.abs(t3) > 0.5 * y2.width) {
            appendEOL();
            return true;
          }
          resetLastChars();
          flushTextContentItem();
          return true;
        }
        if (Math.abs(t3) > y2.width) {
          appendEOL();
          return true;
        }
        e4 <= s4 * y2.notASpace && resetLastChars();
        if (e4 <= s4 * y2.trackingSpaceMin) if (shouldAddWhitepsace()) {
          resetLastChars();
          flushTextContentItem();
          pushWhitespace({ height: Math.abs(e4) });
        } else y2.height += e4;
        else if (!addFakeSpaces(e4, y2.prevTransform, s4)) if (0 === y2.str.length) {
          resetLastChars();
          pushWhitespace({ height: Math.abs(e4) });
        } else y2.height += e4;
        Math.abs(t3) > 0.25 * y2.width && flushTextContentItem();
        return true;
      }
      const o3 = (a3 - i3) / y2.textAdvanceScale, l3 = r3 - n3, h3 = Math.sign(y2.width);
      if (o3 < h3 * y2.negativeSpaceMax) {
        if (Math.abs(l3) > 0.5 * y2.height) {
          appendEOL();
          return true;
        }
        resetLastChars();
        flushTextContentItem();
        return true;
      }
      if (Math.abs(l3) > y2.height) {
        appendEOL();
        return true;
      }
      o3 <= h3 * y2.notASpace && resetLastChars();
      if (o3 <= h3 * y2.trackingSpaceMin) if (shouldAddWhitepsace()) {
        resetLastChars();
        flushTextContentItem();
        pushWhitespace({ width: Math.abs(o3) });
      } else y2.width += o3;
      else if (!addFakeSpaces(o3, y2.prevTransform, h3)) if (0 === y2.str.length) {
        resetLastChars();
        pushWhitespace({ width: Math.abs(o3) });
      } else y2.width += o3;
      Math.abs(l3) > 0.25 * y2.height && flushTextContentItem();
      return true;
    }
    function buildTextContentItem({ chars: e3, extraSpacing: t2 }) {
      const a3 = M2.font;
      if (!e3) {
        const e4 = M2.charSpacing + t2;
        e4 && (a3.vertical ? M2.translateTextMatrix(0, -e4) : M2.translateTextMatrix(e4 * M2.textHScale, 0));
        d2 && compareWithLastPosition(0);
        return;
      }
      const r3 = a3.charsToGlyphs(e3), i3 = M2.fontMatrix[0] * M2.fontSize;
      for (let e4 = 0, n3 = r3.length; e4 < n3; e4++) {
        const s3 = r3[e4], { category: o3 } = s3;
        if (o3.isInvisibleFormatMark) continue;
        let c3 = M2.charSpacing + (e4 + 1 === n3 ? t2 : 0), l3 = s3.width;
        a3.vertical && (l3 = s3.vmetric ? s3.vmetric[0] : -l3);
        let h3 = l3 * i3;
        if (!d2 && o3.isWhitespace) {
          if (a3.vertical) {
            c3 += -h3 + M2.wordSpacing;
            M2.translateTextMatrix(0, -c3);
          } else {
            c3 += h3 + M2.wordSpacing;
            M2.translateTextMatrix(c3 * M2.textHScale, 0);
          }
          saveLastChar(" ");
          continue;
        }
        if (!o3.isZeroWidthDiacritic && !compareWithLastPosition(h3)) {
          a3.vertical ? M2.translateTextMatrix(0, h3) : M2.translateTextMatrix(h3 * M2.textHScale, 0);
          continue;
        }
        const u3 = ensureTextContentItem();
        o3.isZeroWidthDiacritic && (h3 = 0);
        if (a3.vertical) {
          g2?.addGlyph(getCurrentTextTransform(), 0, h3, s3.unicode);
          M2.translateTextMatrix(0, h3);
          h3 = Math.abs(h3);
          u3.height += h3;
        } else {
          h3 *= M2.textHScale;
          g2?.addGlyph(getCurrentTextTransform(), h3, 0, s3.unicode);
          M2.translateTextMatrix(h3, 0);
          u3.width += h3;
        }
        h3 && (u3.prevTransform = getCurrentTextTransform());
        const f3 = s3.unicode;
        if (saveLastChar(f3)) {
          u3.str.push(" ");
          g2?.addExtraChar(" ");
        }
        g2 || u3.str.push(f3);
        c3 && (a3.vertical ? M2.translateTextMatrix(0, -c3) : M2.translateTextMatrix(c3 * M2.textHScale, 0));
      }
    }
    function appendEOL() {
      g2?.addExtraChar("\n");
      resetLastChars();
      if (y2.initialized) {
        y2.hasEOL = true;
        flushTextContentItem();
      } else b2.items.push({ str: "", dir: "ltr", width: 0, height: 0, transform: getCurrentTextTransform(), fontName: M2.loadedName, hasEOL: true });
    }
    function addFakeSpaces(e3, t2, a3) {
      if (a3 * y2.spaceInFlowMin <= e3 && e3 <= a3 * y2.spaceInFlowMax) {
        if (y2.initialized) {
          resetLastChars();
          y2.str.push(" ");
          g2?.addExtraChar(" ");
        }
        return false;
      }
      const r3 = y2.fontName;
      let i3 = 0;
      if (y2.vertical) {
        i3 = e3;
        e3 = 0;
      }
      flushTextContentItem();
      resetLastChars();
      pushWhitespace({ width: Math.abs(e3), height: Math.abs(i3), transform: t2 || getCurrentTextTransform(), fontName: r3 });
      return true;
    }
    function flushTextContentItem() {
      if (y2.initialized && y2.str) {
        y2.vertical ? y2.totalHeight += y2.height * y2.textAdvanceScale : y2.totalWidth += y2.width * y2.textAdvanceScale;
        b2.items.push(runBidiTransform(y2));
        y2.initialized = false;
        y2.str.length = 0;
      }
    }
    function enqueueChunk(e3 = false) {
      const t2 = b2.items.length;
      if (0 !== t2 && !(e3 && t2 < 10)) {
        s2?.enqueue(b2, t2);
        b2.items = [];
        b2.styles = /* @__PURE__ */ Object.create(null);
      }
    }
    const D2 = new TimeSlotManager();
    return new Promise((function promiseBody(e3, t2) {
      const next = function(a3) {
        enqueueChunk(true);
        Promise.all([a3, s2?.ready]).then((function() {
          try {
            promiseBody(e3, t2);
          } catch (e4) {
            t2(e4);
          }
        }), t2);
      };
      a2.ensureNotTerminated();
      D2.reset();
      const f3 = {};
      let g3, p3, y3, w3 = [];
      for (; !(g3 = D2.check()); ) {
        w3.length = 0;
        f3.args = w3;
        if (!O2.read(f3)) break;
        const e4 = M2;
        M2 = i2.state;
        const t3 = f3.fn;
        w3 = f3.args;
        switch (0 | t3) {
          case nt:
            const t4 = w3[0].name, f4 = w3[1];
            if (M2.font && t4 === M2.fontName && f4 === M2.fontSize) break;
            flushTextContentItem();
            M2.fontName = t4;
            M2.fontSize = f4;
            next(handleSetFont(t4, null));
            return;
          case ot:
            M2.textRise = w3[0];
            break;
          case rt:
            M2.textHScale = w3[0] / 100;
            break;
          case it:
            M2.leading = w3[0];
            break;
          case ct:
            M2.translateTextLineMatrix(w3[0], w3[1]);
            M2.textMatrix = M2.textLineMatrix.slice();
            break;
          case lt:
            M2.leading = -w3[1];
            M2.translateTextLineMatrix(w3[0], w3[1]);
            M2.textMatrix = M2.textLineMatrix.slice();
            break;
          case ut:
            M2.carriageReturn();
            break;
          case ht:
            M2.setTextMatrix(w3[0], w3[1], w3[2], w3[3], w3[4], w3[5]);
            M2.setTextLineMatrix(w3[0], w3[1], w3[2], w3[3], w3[4], w3[5]);
            updateAdvanceScale();
            break;
          case tt:
            M2.charSpacing = w3[0];
            break;
          case at:
            M2.wordSpacing = w3[0];
            break;
          case Qe:
            M2.textMatrix = Fa.slice();
            M2.textLineMatrix = Fa.slice();
            break;
          case ft:
            if (!i2.state.font) {
              S2.ensureStateFont(i2.state);
              continue;
            }
            const g4 = (M2.font.vertical ? 1 : -1) * M2.fontSize / 1e3, x3 = w3[0];
            for (let e5 = 0, t5 = x3.length; e5 < t5; e5++) {
              const t6 = x3[e5];
              if ("string" == typeof t6) C2.push(t6);
              else if ("number" == typeof t6 && 0 !== t6) {
                const e6 = C2.join("");
                C2.length = 0;
                buildTextContentItem({ chars: e6, extraSpacing: t6 * g4 });
              }
            }
            if (C2.length > 0) {
              const e5 = C2.join("");
              C2.length = 0;
              buildTextContentItem({ chars: e5, extraSpacing: 0 });
            }
            break;
          case dt:
            if (!i2.state.font) {
              S2.ensureStateFont(i2.state);
              continue;
            }
            buildTextContentItem({ chars: w3[0], extraSpacing: 0 });
            break;
          case gt:
            if (!i2.state.font) {
              S2.ensureStateFont(i2.state);
              continue;
            }
            M2.carriageReturn();
            buildTextContentItem({ chars: w3[0], extraSpacing: 0 });
            break;
          case pt:
            if (!i2.state.font) {
              S2.ensureStateFont(i2.state);
              continue;
            }
            M2.wordSpacing = w3[0];
            M2.charSpacing = w3[1];
            M2.carriageReturn();
            buildTextContentItem({ chars: w3[2], extraSpacing: 0 });
            break;
          case Nt:
            flushTextContentItem();
            v2 ??= r2.get("XObject") || Dict.empty;
            y3 = w3[0] instanceof Name;
            p3 = w3[0].name;
            if (y3 && F2.getByName(p3)) break;
            next(new Promise((function(e5, t5) {
              if (!y3) throw new FormatError("XObject must be referred to by name.");
              let f5 = v2.getRaw(p3);
              if (f5 instanceof Ref) {
                if (F2.getByRef(f5)) {
                  e5();
                  return;
                }
                if (S2.globalImageCache.getData(f5, S2.pageIndex)) {
                  e5();
                  return;
                }
                f5 = k2.fetch(f5);
              }
              if (!(f5 instanceof BaseStream)) throw new FormatError("XObject should be a stream");
              const { dict: g5 } = f5, b3 = g5.get("Subtype");
              if (!(b3 instanceof Name)) throw new FormatError("XObject should have a Name subtype");
              if ("Form" !== b3.name) {
                F2.set(p3, g5.objId, true);
                e5();
                return;
              }
              const w4 = i2.state.clone(), x4 = new StateManager(w4), C3 = lookupMatrix(g5.getArray("Matrix"), null);
              C3 && x4.transform(C3);
              const T3 = g5.get("Resources");
              enqueueChunk();
              const O3 = { enqueueInvoked: false, enqueue(e6, t6) {
                this.enqueueInvoked = true;
                s2.enqueue(e6, t6);
              }, get desiredSize() {
                return s2.desiredSize ?? 0;
              }, get ready() {
                return s2.ready;
              } };
              S2.getTextContent({ stream: f5, task: a2, resources: T3 instanceof Dict ? T3 : r2, stateManager: x4, includeMarkedContent: n2, sink: s2 && O3, seenStyles: o2, viewBox: c2, lang: l2, markedContentData: h2, disableNormalization: u2, keepWhiteSpace: d2, prevRefs: m2 }).then((function() {
                O3.enqueueInvoked || F2.set(p3, g5.objId, true);
                e5();
              }), t5);
            })).catch((function(e5) {
              if (!(e5 instanceof AbortException)) {
                if (!S2.options.ignoreErrors) throw e5;
                warn(`getTextContent - ignoring XObject: "${e5}".`);
              }
            })));
            return;
          case De:
            y3 = w3[0] instanceof Name;
            p3 = w3[0].name;
            if (y3 && T2.getByName(p3)) break;
            next(new Promise((function(e5, t5) {
              if (!y3) throw new FormatError("GState must be referred to by name.");
              const a3 = r2.get("ExtGState");
              if (!(a3 instanceof Dict)) throw new FormatError("ExtGState should be a dictionary.");
              const i3 = a3.get(p3);
              if (!(i3 instanceof Dict)) throw new FormatError("GState should be a dictionary.");
              const n3 = i3.get("Font");
              if (n3) {
                flushTextContentItem();
                M2.fontName = null;
                M2.fontSize = n3[1];
                handleSetFont(null, n3[0]).then(e5, t5);
              } else {
                T2.set(p3, i3.objId, true);
                e5();
              }
            })).catch((function(e5) {
              if (!(e5 instanceof AbortException)) {
                if (!S2.options.ignoreErrors) throw e5;
                warn(`getTextContent - ignoring ExtGState: "${e5}".`);
              }
            })));
            return;
          case Lt:
            flushTextContentItem();
            if (n2) {
              h2.level++;
              b2.items.push({ type: "beginMarkedContent", tag: w3[0] instanceof Name ? w3[0].name : null });
            }
            break;
          case jt:
            flushTextContentItem();
            if (n2) {
              h2.level++;
              let e5 = null;
              w3[1] instanceof Dict && (e5 = w3[1].get("MCID"));
              b2.items.push({ type: "beginMarkedContentProps", id: Number.isInteger(e5) ? `${S2.idFactory.getPageObjId()}_mc${e5}` : null, tag: w3[0] instanceof Name ? w3[0].name : null });
            }
            break;
          case _t:
            flushTextContentItem();
            if (n2) {
              if (0 === h2.level) break;
              h2.level--;
              b2.items.push({ type: "endMarkedContent" });
            }
            break;
          case Re:
            !e4 || e4.font === M2.font && e4.fontSize === M2.fontSize && e4.fontName === M2.fontName || flushTextContentItem();
        }
        if (b2.items.length >= (s2?.desiredSize ?? 1)) {
          g3 = true;
          break;
        }
      }
      if (g3) next(En);
      else {
        flushTextContentItem();
        enqueueChunk();
        e3();
      }
    })).catch(((e3) => {
      if (!(e3 instanceof AbortException)) {
        if (!this.options.ignoreErrors) throw e3;
        warn(`getTextContent - ignoring errors during "${a2.name}" task: "${e3}".`);
        flushTextContentItem();
        enqueueChunk();
      }
    }));
  }
  async extractDataStructures(e2, t2) {
    const a2 = this.xref;
    let r2;
    const i2 = this.readToUnicode(t2.toUnicode);
    if (t2.composite) {
      const a3 = e2.get("CIDSystemInfo");
      a3 instanceof Dict && (t2.cidSystemInfo = { registry: stringToPDFString(a3.get("Registry")), ordering: stringToPDFString(a3.get("Ordering")), supplement: a3.get("Supplement") });
      try {
        const t3 = e2.get("CIDToGIDMap");
        t3 instanceof BaseStream && (r2 = t3.getBytes());
      } catch (e3) {
        if (!this.options.ignoreErrors) throw e3;
        warn(`extractDataStructures - ignoring CIDToGIDMap data: "${e3}".`);
      }
    }
    const n2 = [];
    let s2, o2 = null;
    if (e2.has("Encoding")) {
      s2 = e2.get("Encoding");
      if (s2 instanceof Dict) {
        o2 = s2.get("BaseEncoding");
        o2 = o2 instanceof Name ? o2.name : null;
        if (s2.has("Differences")) {
          const e3 = s2.get("Differences");
          let t3 = 0;
          for (const r3 of e3) {
            const e4 = a2.fetchIfRef(r3);
            if ("number" == typeof e4) t3 = e4;
            else {
              if (!(e4 instanceof Name)) throw new FormatError(`Invalid entry in 'Differences' array: ${e4}`);
              n2[t3++] = e4.name;
            }
          }
        }
      } else if (s2 instanceof Name) o2 = s2.name;
      else {
        const e3 = "Encoding is not a Name nor a Dict";
        if (!this.options.ignoreErrors) throw new FormatError(e3);
        warn(e3);
      }
      "MacRomanEncoding" !== o2 && "MacExpertEncoding" !== o2 && "WinAnsiEncoding" !== o2 && (o2 = null);
    }
    const c2 = !t2.file || t2.isInternalFont, l2 = ei()[t2.name];
    o2 && c2 && l2 && (o2 = null);
    if (o2) t2.defaultEncoding = getEncoding(o2);
    else {
      const e3 = !!(t2.flags & Pr), a3 = !!(t2.flags & Lr);
      s2 = Ar;
      "TrueType" !== t2.type || a3 || (s2 = kr);
      if (e3 || l2) {
        s2 = Sr;
        c2 && (/Symbol/i.test(t2.name) ? s2 = Cr : /Dingbats/i.test(t2.name) ? s2 = vr : /Wingdings/i.test(t2.name) && (s2 = kr));
      }
      t2.defaultEncoding = s2;
    }
    t2.differences = n2;
    t2.baseEncodingName = o2;
    t2.hasEncoding = !!o2 || n2.length > 0;
    t2.dict = e2;
    t2.toUnicode = await i2;
    const h2 = await this.buildToUnicode(t2);
    t2.toUnicode = h2;
    r2 && (t2.cidToGidMap = this.readCidToGidMap(r2, h2));
    return t2;
  }
  _simpleFontToUnicode(e2, t2 = false) {
    assert(!e2.composite, "Must be a simple font.");
    const a2 = [], r2 = e2.defaultEncoding.slice(), i2 = e2.baseEncodingName, n2 = e2.differences;
    for (const e3 in n2) {
      const t3 = n2[e3];
      ".notdef" !== t3 && (r2[e3] = t3);
    }
    const s2 = Fr();
    for (const n3 in r2) {
      let o2 = r2[n3];
      if ("" === o2) continue;
      let c2 = s2[o2];
      if (void 0 !== c2) {
        a2[n3] = String.fromCharCode(c2);
        continue;
      }
      let l2 = 0;
      switch (o2[0]) {
        case "G":
          3 === o2.length && (l2 = parseInt(o2.substring(1), 16));
          break;
        case "g":
          5 === o2.length && (l2 = parseInt(o2.substring(1), 16));
          break;
        case "C":
        case "c":
          if (o2.length >= 3 && o2.length <= 4) {
            const a3 = o2.substring(1);
            if (t2) {
              l2 = parseInt(a3, 16);
              break;
            }
            l2 = +a3;
            if (Number.isNaN(l2) && Number.isInteger(parseInt(a3, 16))) return this._simpleFontToUnicode(e2, true);
          }
          break;
        case "u":
          c2 = getUnicodeForGlyph(o2, s2);
          -1 !== c2 && (l2 = c2);
          break;
        default:
          switch (o2) {
            case "f_h":
            case "f_t":
            case "T_h":
              a2[n3] = o2.replaceAll("_", "");
              continue;
          }
      }
      if (l2 > 0 && l2 <= 1114111 && Number.isInteger(l2)) {
        if (i2 && l2 === +n3) {
          const e3 = getEncoding(i2);
          if (e3 && (o2 = e3[n3])) {
            a2[n3] = String.fromCharCode(s2[o2]);
            continue;
          }
        }
        a2[n3] = String.fromCodePoint(l2);
      }
    }
    return a2;
  }
  async buildToUnicode(e2) {
    e2.hasIncludedToUnicodeMap = e2.toUnicode?.length > 0;
    if (e2.hasIncludedToUnicodeMap) {
      !e2.composite && e2.hasEncoding && (e2.fallbackToUnicode = this._simpleFontToUnicode(e2));
      return e2.toUnicode;
    }
    if (!e2.composite) return new ToUnicodeMap(this._simpleFontToUnicode(e2));
    if (e2.composite && (e2.cMap.builtInCMap && !(e2.cMap instanceof IdentityCMap) || "Adobe" === e2.cidSystemInfo?.registry && ("GB1" === e2.cidSystemInfo.ordering || "CNS1" === e2.cidSystemInfo.ordering || "Japan1" === e2.cidSystemInfo.ordering || "Korea1" === e2.cidSystemInfo.ordering))) {
      const { registry: t2, ordering: a2 } = e2.cidSystemInfo, r2 = Name.get(`${t2}-${a2}-UCS2`), i2 = await CMapFactory.create({ encoding: r2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }), n2 = [], s2 = [];
      e2.cMap.forEach((function(e3, t3) {
        if (t3 > 65535) throw new FormatError("Max size of CID is 65,535");
        const a3 = i2.lookup(t3);
        if (a3) {
          s2.length = 0;
          for (let e4 = 0, t4 = a3.length; e4 < t4; e4 += 2) s2.push((a3.charCodeAt(e4) << 8) + a3.charCodeAt(e4 + 1));
          n2[e3] = String.fromCharCode(...s2);
        }
      }));
      return new ToUnicodeMap(n2);
    }
    return new IdentityToUnicodeMap(e2.firstChar, e2.lastChar);
  }
  async readToUnicode(e2) {
    if (!e2) return null;
    if (e2 instanceof Name) {
      const t2 = await CMapFactory.create({ encoding: e2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      return t2 instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t2.getMap());
    }
    if (e2 instanceof BaseStream) try {
      const t2 = await CMapFactory.create({ encoding: e2, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      if (t2 instanceof IdentityCMap) return new IdentityToUnicodeMap(0, 65535);
      const a2 = new Array(t2.length);
      t2.forEach((function(e3, t3) {
        if ("number" == typeof t3) {
          a2[e3] = String.fromCodePoint(t3);
          return;
        }
        t3.length % 2 != 0 && (t3 = "\0" + t3);
        const r2 = [];
        for (let e4 = 0; e4 < t3.length; e4 += 2) {
          const a3 = t3.charCodeAt(e4) << 8 | t3.charCodeAt(e4 + 1);
          if (55296 != (63488 & a3)) {
            r2.push(a3);
            continue;
          }
          e4 += 2;
          const i2 = t3.charCodeAt(e4) << 8 | t3.charCodeAt(e4 + 1);
          r2.push(((1023 & a3) << 10) + (1023 & i2) + 65536);
        }
        a2[e3] = String.fromCodePoint(...r2);
      }));
      return new ToUnicodeMap(a2);
    } catch (e3) {
      if (e3 instanceof AbortException) return null;
      if (this.options.ignoreErrors) {
        warn(`readToUnicode - ignoring ToUnicode data: "${e3}".`);
        return null;
      }
      throw e3;
    }
    return null;
  }
  readCidToGidMap(e2, t2) {
    const a2 = [];
    for (let r2 = 0, i2 = e2.length; r2 < i2; r2++) {
      const i3 = e2[r2++] << 8 | e2[r2], n2 = r2 >> 1;
      (0 !== i3 || t2.has(n2)) && (a2[n2] = i3);
    }
    return a2;
  }
  extractWidths(e2, t2, a2) {
    const r2 = this.xref;
    let i2 = [], n2 = 0;
    const s2 = [];
    let o2;
    if (a2.composite) {
      const t3 = e2.get("DW");
      n2 = "number" == typeof t3 ? Math.ceil(t3) : 1e3;
      const c3 = e2.get("W");
      if (Array.isArray(c3)) for (let e3 = 0, t4 = c3.length; e3 < t4; e3++) {
        let t5 = r2.fetchIfRef(c3[e3++]);
        if (!Number.isInteger(t5)) break;
        const a3 = r2.fetchIfRef(c3[e3]);
        if (Array.isArray(a3)) for (const e4 of a3) {
          const a4 = r2.fetchIfRef(e4);
          "number" == typeof a4 && (i2[t5] = a4);
          t5++;
        }
        else {
          if (!Number.isInteger(a3)) break;
          {
            const n3 = r2.fetchIfRef(c3[++e3]);
            if ("number" != typeof n3) continue;
            for (let e4 = t5; e4 <= a3; e4++) i2[e4] = n3;
          }
        }
      }
      if (a2.vertical) {
        const t4 = e2.getArray("DW2");
        let a3 = isNumberArray(t4, 2) ? t4 : [880, -1e3];
        o2 = [a3[1], 0.5 * n2, a3[0]];
        a3 = e2.get("W2");
        if (Array.isArray(a3)) for (let e3 = 0, t5 = a3.length; e3 < t5; e3++) {
          let t6 = r2.fetchIfRef(a3[e3++]);
          if (!Number.isInteger(t6)) break;
          const i3 = r2.fetchIfRef(a3[e3]);
          if (Array.isArray(i3)) for (let e4 = 0, a4 = i3.length; e4 < a4; e4++) {
            const a5 = [r2.fetchIfRef(i3[e4++]), r2.fetchIfRef(i3[e4++]), r2.fetchIfRef(i3[e4])];
            isNumberArray(a5, null) && (s2[t6] = a5);
            t6++;
          }
          else {
            if (!Number.isInteger(i3)) break;
            {
              const n3 = [r2.fetchIfRef(a3[++e3]), r2.fetchIfRef(a3[++e3]), r2.fetchIfRef(a3[++e3])];
              if (!isNumberArray(n3, null)) continue;
              for (let e4 = t6; e4 <= i3; e4++) s2[e4] = n3;
            }
          }
        }
      }
    } else {
      const s3 = e2.get("Widths");
      if (Array.isArray(s3)) {
        let e3 = a2.firstChar;
        for (const t3 of s3) {
          const a3 = r2.fetchIfRef(t3);
          "number" == typeof a3 && (i2[e3] = a3);
          e3++;
        }
        const o3 = t2.get("MissingWidth");
        n2 = "number" == typeof o3 ? o3 : 0;
      } else {
        const t3 = e2.get("BaseFont");
        if (t3 instanceof Name) {
          const e3 = this.getBaseFontMetrics(t3.name);
          i2 = this.buildCharCodeToWidth(e3.widths, a2);
          n2 = e3.defaultWidth;
        }
      }
    }
    let c2 = true, l2 = n2;
    for (const e3 in i2) {
      const t3 = i2[e3];
      if (t3) if (l2) {
        if (l2 !== t3) {
          c2 = false;
          break;
        }
      } else l2 = t3;
    }
    c2 ? a2.flags |= Nr : a2.flags &= ~Nr;
    a2.defaultWidth = n2;
    a2.widths = i2;
    a2.defaultVMetrics = o2;
    a2.vmetrics = s2;
  }
  isSerifFont(e2) {
    const t2 = e2.split("-", 1)[0];
    return t2 in Qr() || /serif/gi.test(t2);
  }
  getBaseFontMetrics(e2) {
    let t2 = 0, a2 = /* @__PURE__ */ Object.create(null), r2 = false;
    let i2 = Jr()[e2] || e2;
    const n2 = ii();
    i2 in n2 || (i2 = this.isSerifFont(e2) ? "Times-Roman" : "Helvetica");
    const s2 = n2[i2];
    if ("number" == typeof s2) {
      t2 = s2;
      r2 = true;
    } else a2 = s2();
    return { defaultWidth: t2, monospace: r2, widths: a2 };
  }
  buildCharCodeToWidth(e2, t2) {
    const a2 = /* @__PURE__ */ Object.create(null), r2 = t2.differences, i2 = t2.defaultEncoding;
    for (let t3 = 0; t3 < 256; t3++) t3 in r2 && e2[r2[t3]] ? a2[t3] = e2[r2[t3]] : t3 in i2 && e2[i2[t3]] && (a2[t3] = e2[i2[t3]]);
    return a2;
  }
  preEvaluateFont(e2) {
    const t2 = e2;
    let a2 = e2.get("Subtype");
    if (!(a2 instanceof Name)) throw new FormatError("invalid font Subtype");
    let r2, i2 = false;
    if ("Type0" === a2.name) {
      const t3 = e2.get("DescendantFonts");
      if (!t3) throw new FormatError("Descendant fonts are not specified");
      if (!((e2 = Array.isArray(t3) ? this.xref.fetchIfRef(t3[0]) : t3) instanceof Dict)) throw new FormatError("Descendant font is not a dictionary.");
      a2 = e2.get("Subtype");
      if (!(a2 instanceof Name)) throw new FormatError("invalid font Subtype");
      i2 = true;
    }
    let n2 = e2.get("FirstChar");
    Number.isInteger(n2) || (n2 = 0);
    let s2 = e2.get("LastChar");
    Number.isInteger(s2) || (s2 = i2 ? 65535 : 255);
    const o2 = e2.get("FontDescriptor"), c2 = e2.get("ToUnicode") || t2.get("ToUnicode");
    if (o2) {
      r2 = new MurmurHash3_64();
      const a3 = t2.getRaw("Encoding");
      if (a3 instanceof Name) r2.update(a3.name);
      else if (a3 instanceof Ref) r2.update(a3.toString());
      else if (a3 instanceof Dict) {
        for (const e3 of a3.getRawValues()) if (e3 instanceof Name) r2.update(e3.name);
        else if (e3 instanceof Ref) r2.update(e3.toString());
        else if (Array.isArray(e3)) {
          const t3 = e3.length, a4 = new Array(t3);
          for (let r3 = 0; r3 < t3; r3++) {
            const t4 = e3[r3];
            t4 instanceof Name ? a4[r3] = t4.name : ("number" == typeof t4 || t4 instanceof Ref) && (a4[r3] = t4.toString());
          }
          r2.update(a4.join());
        }
      }
      r2.update(`${n2}-${s2}`);
      if (c2 instanceof BaseStream) {
        const e3 = c2.str || c2, t3 = e3.buffer ? new Uint8Array(e3.buffer.buffer, 0, e3.bufferLength) : new Uint8Array(e3.bytes.buffer, e3.start, e3.end - e3.start);
        r2.update(t3);
      } else c2 instanceof Name && r2.update(c2.name);
      const o3 = e2.get("Widths") || t2.get("Widths");
      if (Array.isArray(o3)) {
        const e3 = [];
        for (const t3 of o3) ("number" == typeof t3 || t3 instanceof Ref) && e3.push(t3.toString());
        r2.update(e3.join());
      }
      if (i2) {
        r2.update("compositeFont");
        const a4 = e2.get("W") || t2.get("W");
        if (Array.isArray(a4)) {
          const e3 = [];
          for (const t3 of a4) if ("number" == typeof t3 || t3 instanceof Ref) e3.push(t3.toString());
          else if (Array.isArray(t3)) {
            const a5 = [];
            for (const e4 of t3) ("number" == typeof e4 || e4 instanceof Ref) && a5.push(e4.toString());
            e3.push(`[${a5.join()}]`);
          }
          r2.update(e3.join());
        }
        const i3 = e2.getRaw("CIDToGIDMap") || t2.getRaw("CIDToGIDMap");
        i3 instanceof Name ? r2.update(i3.name) : i3 instanceof Ref ? r2.update(i3.toString()) : i3 instanceof BaseStream && r2.update(i3.peekBytes());
      }
    }
    return { descriptor: o2, dict: e2, baseDict: t2, composite: i2, type: a2.name, firstChar: n2, lastChar: s2, toUnicode: c2, hash: r2 ? r2.hexdigest() : "" };
  }
  async translateFont({ descriptor: e2, dict: a2, baseDict: r2, composite: i2, type: n2, firstChar: s2, lastChar: o2, toUnicode: c2, cssFontInfo: l2 }) {
    const h2 = "Type3" === n2;
    if (!e2) {
      if (!h2) {
        let e3 = a2.get("BaseFont");
        if (!(e3 instanceof Name)) throw new FormatError("Base font is not specified");
        e3 = e3.name.replaceAll(/[,_]/g, "-");
        const t2 = this.getBaseFontMetrics(e3), i3 = e3.split("-", 1)[0], l3 = (this.isSerifFont(i3) ? Er : 0) | (t2.monospace ? Nr : 0) | (ei()[i3] ? Pr : Lr), u3 = { type: n2, name: e3, loadedName: r2.loadedName, systemFontInfo: null, widths: t2.widths, defaultWidth: t2.defaultWidth, isSimulatedFlags: true, flags: l3, firstChar: s2, lastChar: o2, toUnicode: c2, xHeight: 0, capHeight: 0, italicAngle: 0, isType3Font: h2 }, d3 = a2.get("Widths"), f3 = getStandardFontName(e3);
        let g3 = null;
        if (f3) {
          g3 = await this.fetchStandardFontData(f3);
          u3.isInternalFont = !!g3;
        }
        !u3.isInternalFont && this.options.useSystemFonts && (u3.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e3, f3, n2));
        const p3 = await this.extractDataStructures(a2, u3);
        if (Array.isArray(d3)) {
          const e4 = [];
          let t3 = s2;
          for (const a3 of d3) {
            const r3 = this.xref.fetchIfRef(a3);
            "number" == typeof r3 && (e4[t3] = r3);
            t3++;
          }
          p3.widths = e4;
        } else p3.widths = this.buildCharCodeToWidth(t2.widths, p3);
        return new Font(e3, g3, p3, this.options);
      }
      e2 = Dict.empty;
    }
    let u2 = e2.get("FontName"), d2 = a2.get("BaseFont");
    "string" == typeof u2 && (u2 = Name.get(u2));
    "string" == typeof d2 && (d2 = Name.get(d2));
    const f2 = u2?.name, g2 = d2?.name;
    if (h2) f2 || (u2 = Name.get(n2));
    else if (f2 !== g2) {
      info(`The FontDescriptor's FontName is "${f2}" but should be the same as the Font's BaseFont "${g2}".`);
      f2 && g2 && (g2.startsWith(f2) || !isKnownFontName(f2) && isKnownFontName(g2)) && (u2 = null);
      u2 ||= d2;
    }
    if (!(u2 instanceof Name)) throw new FormatError("invalid font name");
    let p2, m2, b2, y2, w2;
    try {
      p2 = e2.get("FontFile", "FontFile2", "FontFile3");
      if (p2) {
        if (!(p2 instanceof BaseStream)) throw new FormatError("FontFile should be a stream");
        if (p2.isEmpty) throw new FormatError("FontFile is empty");
      }
    } catch (e3) {
      if (!this.options.ignoreErrors) throw e3;
      warn(`translateFont - fetching "${u2.name}" font file: "${e3}".`);
      p2 = null;
    }
    let x2 = false, S2 = null, k2 = null;
    if (p2) {
      if (p2.dict) {
        const e3 = p2.dict.get("Subtype");
        e3 instanceof Name && (m2 = e3.name);
        b2 = p2.dict.get("Length1");
        y2 = p2.dict.get("Length2");
        w2 = p2.dict.get("Length3");
      }
    } else if (l2) {
      const e3 = getXfaFontName(u2.name);
      if (e3) {
        l2.fontFamily = `${l2.fontFamily}-PdfJS-XFA`;
        l2.metrics = e3.metrics || null;
        S2 = e3.factors || null;
        p2 = await this.fetchStandardFontData(e3.name);
        x2 = !!p2;
        r2 = a2 = getXfaFontDict(u2.name);
        i2 = true;
      }
    } else if (!h2) {
      const e3 = getStandardFontName(u2.name);
      if (e3) {
        p2 = await this.fetchStandardFontData(e3);
        x2 = !!p2;
      }
      !x2 && this.options.useSystemFonts && (k2 = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, u2.name, e3, n2));
    }
    const C2 = lookupMatrix(a2.getArray("FontMatrix"), t), v2 = lookupNormalRect(e2.getArray("FontBBox") || a2.getArray("FontBBox"), h2 ? [0, 0, 0, 0] : void 0);
    let F2 = e2.get("Ascent");
    "number" != typeof F2 && (F2 = void 0);
    let T2 = e2.get("Descent");
    "number" != typeof T2 && (T2 = void 0);
    let O2 = e2.get("XHeight");
    "number" != typeof O2 && (O2 = 0);
    let M2 = e2.get("CapHeight");
    "number" != typeof M2 && (M2 = 0);
    let D2 = e2.get("Flags");
    Number.isInteger(D2) || (D2 = 0);
    let R2 = e2.get("ItalicAngle");
    "number" != typeof R2 && (R2 = 0);
    const N2 = { type: n2, name: u2.name, subtype: m2, file: p2, length1: b2, length2: y2, length3: w2, isInternalFont: x2, loadedName: r2.loadedName, composite: i2, fixedPitch: false, fontMatrix: C2, firstChar: s2, lastChar: o2, toUnicode: c2, bbox: v2, ascent: F2, descent: T2, xHeight: O2, capHeight: M2, flags: D2, italicAngle: R2, isType3Font: h2, cssFontInfo: l2, scaleFactors: S2, systemFontInfo: k2 };
    if (i2) {
      const e3 = r2.get("Encoding");
      e3 instanceof Name && (N2.cidEncoding = e3.name);
      const t2 = await CMapFactory.create({ encoding: e3, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      N2.cMap = t2;
      N2.vertical = N2.cMap.vertical;
    }
    const E2 = await this.extractDataStructures(a2, N2);
    this.extractWidths(a2, e2, E2);
    return new Font(u2.name, p2, E2, this.options);
  }
  static buildFontPaths(e2, t2, a2, r2) {
    function buildPath(t3) {
      const i2 = `${e2.loadedName}_path_${t3}`;
      try {
        if (e2.renderer.hasBuiltPath(t3)) return;
        a2.send("commonobj", [i2, "FontPath", e2.renderer.getPathJs(t3)]);
      } catch (e3) {
        if (r2.ignoreErrors) {
          warn(`buildFontPaths - ignoring ${i2} glyph: "${e3}".`);
          return;
        }
        throw e3;
      }
    }
    for (const e3 of t2) {
      buildPath(e3.fontChar);
      const t3 = e3.accent;
      t3?.fontChar && buildPath(t3.fontChar);
    }
  }
  static get fallbackFontDict() {
    const e2 = new Dict();
    e2.set("BaseFont", Name.get("Helvetica"));
    e2.set("Type", Name.get("FallbackType"));
    e2.set("Subtype", Name.get("FallbackType"));
    e2.set("Encoding", Name.get("WinAnsiEncoding"));
    return shadow(this, "fallbackFontDict", e2);
  }
};
var TranslatedFont = class {
  #G = false;
  #V = null;
  constructor({ loadedName: e2, font: t2, dict: a2 }) {
    this.loadedName = e2;
    this.font = t2;
    this.dict = a2;
    this.type3Dependencies = t2.isType3Font ? /* @__PURE__ */ new Set() : null;
  }
  send(e2) {
    if (!this.#G) {
      this.#G = true;
      e2.send("commonobj", [this.loadedName, "Font", this.font.exportData()]);
    }
  }
  fallback(e2, t2) {
    if (this.font.data) {
      this.font.disableFontFace = true;
      PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e2, t2);
    }
  }
  loadType3Data(e2, t2, a2) {
    if (this.#V) return this.#V;
    const { font: r2, type3Dependencies: i2 } = this;
    assert(r2.isType3Font, "Must be a Type3 font.");
    const n2 = e2.clone({ ignoreErrors: false }), s2 = new RefSet(e2.type3FontRefs);
    this.dict.objId && !s2.has(this.dict.objId) && s2.put(this.dict.objId);
    n2.type3FontRefs = s2;
    let o2 = Promise.resolve();
    const c2 = this.dict.get("CharProcs"), l2 = this.dict.get("Resources") || t2, h2 = /* @__PURE__ */ Object.create(null), [u2, d2, f2, g2] = r2.bbox, p2 = f2 - u2, m2 = g2 - d2, b2 = Math.hypot(p2, m2);
    for (const e3 of c2.getKeys()) o2 = o2.then((() => {
      const t3 = c2.get(e3), r3 = new OperatorList();
      return n2.getOperatorList({ stream: t3, task: a2, resources: l2, operatorList: r3 }).then((() => {
        switch (r3.fnArray[0]) {
          case bt:
            this.#K(r3, b2);
            break;
          case mt:
            b2 || this.#J(r3);
        }
        h2[e3] = r3.getIR();
        for (const e4 of r3.dependencies) i2.add(e4);
      })).catch((function(t4) {
        warn(`Type3 font resource "${e3}" is not available.`);
        const a3 = new OperatorList();
        h2[e3] = a3.getIR();
      }));
    }));
    this.#V = o2.then((() => {
      r2.charProcOperatorList = h2;
      if (this._bbox) {
        r2.isCharBBox = true;
        r2.bbox = this._bbox;
      }
    }));
    return this.#V;
  }
  #K(e2, t2 = NaN) {
    const a2 = Util.normalizeRect(e2.argsArray[0].slice(2)), r2 = a2[2] - a2[0], i2 = a2[3] - a2[1], n2 = Math.hypot(r2, i2);
    if (0 === r2 || 0 === i2) {
      e2.fnArray.splice(0, 1);
      e2.argsArray.splice(0, 1);
    } else if (0 === t2 || Math.round(n2 / t2) >= 10) {
      this._bbox ??= [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      Util.rectBoundingBox(...a2, this._bbox);
    }
    let s2 = 0, o2 = e2.length;
    for (; s2 < o2; ) {
      switch (e2.fnArray[s2]) {
        case bt:
          break;
        case yt:
        case wt:
        case xt:
        case St:
        case At:
        case kt:
        case Ct:
        case vt:
        case Ft:
        case It:
        case Tt:
        case Ot:
        case Mt:
        case Oe:
          e2.fnArray.splice(s2, 1);
          e2.argsArray.splice(s2, 1);
          o2--;
          continue;
        case De:
          const [t3] = e2.argsArray[s2];
          let a3 = 0, r3 = t3.length;
          for (; a3 < r3; ) {
            const [e3] = t3[a3];
            switch (e3) {
              case "TR":
              case "TR2":
              case "HT":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
                t3.splice(a3, 1);
                r3--;
                continue;
            }
            a3++;
          }
      }
      s2++;
    }
  }
  #J(e2) {
    let t2 = 1;
    const a2 = e2.length;
    for (; t2 < a2; ) {
      if (e2.fnArray[t2] === aa) {
        const a3 = e2.argsArray[t2][2];
        this._bbox ??= [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        Util.rectBoundingBox(...a3, this._bbox);
      }
      t2++;
    }
  }
};
var StateManager = class {
  constructor(e2 = new EvalState()) {
    this.state = e2;
    this.stateStack = [];
  }
  save() {
    const e2 = this.state;
    this.stateStack.push(this.state);
    this.state = e2.clone();
  }
  restore() {
    const e2 = this.stateStack.pop();
    e2 && (this.state = e2);
  }
  transform(e2) {
    this.state.ctm = Util.transform(this.state.ctm, e2);
  }
};
var TextState = class {
  constructor() {
    this.ctm = new Float32Array(Fa);
    this.fontName = null;
    this.fontSize = 0;
    this.loadedName = null;
    this.font = null;
    this.fontMatrix = t;
    this.textMatrix = Fa.slice();
    this.textLineMatrix = Fa.slice();
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.leading = 0;
    this.textHScale = 1;
    this.textRise = 0;
  }
  setTextMatrix(e2, t2, a2, r2, i2, n2) {
    const s2 = this.textMatrix;
    s2[0] = e2;
    s2[1] = t2;
    s2[2] = a2;
    s2[3] = r2;
    s2[4] = i2;
    s2[5] = n2;
  }
  setTextLineMatrix(e2, t2, a2, r2, i2, n2) {
    const s2 = this.textLineMatrix;
    s2[0] = e2;
    s2[1] = t2;
    s2[2] = a2;
    s2[3] = r2;
    s2[4] = i2;
    s2[5] = n2;
  }
  translateTextMatrix(e2, t2) {
    const a2 = this.textMatrix;
    a2[4] = a2[0] * e2 + a2[2] * t2 + a2[4];
    a2[5] = a2[1] * e2 + a2[3] * t2 + a2[5];
  }
  translateTextLineMatrix(e2, t2) {
    const a2 = this.textLineMatrix;
    a2[4] = a2[0] * e2 + a2[2] * t2 + a2[4];
    a2[5] = a2[1] * e2 + a2[3] * t2 + a2[5];
  }
  carriageReturn() {
    this.translateTextLineMatrix(0, -this.leading);
    this.textMatrix = this.textLineMatrix.slice();
  }
  clone() {
    const e2 = Object.create(this);
    e2.textMatrix = this.textMatrix.slice();
    e2.textLineMatrix = this.textLineMatrix.slice();
    e2.fontMatrix = this.fontMatrix.slice();
    return e2;
  }
};
var EvalState = class {
  constructor() {
    this.ctm = new Float32Array(Fa);
    this.font = null;
    this.textRenderingMode = x;
    this._fillColorSpace = this._strokeColorSpace = ColorSpaceUtils.gray;
    this.patternFillColorSpace = null;
    this.patternStrokeColorSpace = null;
    this.currentPointX = this.currentPointY = 0;
    this.pathMinMax = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
    this.pathBuffer = [];
  }
  get fillColorSpace() {
    return this._fillColorSpace;
  }
  set fillColorSpace(e2) {
    this._fillColorSpace = this.patternFillColorSpace = e2;
  }
  get strokeColorSpace() {
    return this._strokeColorSpace;
  }
  set strokeColorSpace(e2) {
    this._strokeColorSpace = this.patternStrokeColorSpace = e2;
  }
  clone({ newPath: e2 = false } = {}) {
    const t2 = Object.create(this);
    if (e2) {
      t2.pathBuffer = [];
      t2.pathMinMax = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
    }
    return t2;
  }
};
var EvaluatorPreprocessor = class _EvaluatorPreprocessor {
  static get opMap() {
    return shadow(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), { w: { id: Ce, numArgs: 1, variableArgs: false }, J: { id: ve, numArgs: 1, variableArgs: false }, j: { id: Fe, numArgs: 1, variableArgs: false }, M: { id: Ie, numArgs: 1, variableArgs: false }, d: { id: Te, numArgs: 2, variableArgs: false }, ri: { id: Oe, numArgs: 1, variableArgs: false }, i: { id: Me, numArgs: 1, variableArgs: false }, gs: { id: De, numArgs: 1, variableArgs: false }, q: { id: Be, numArgs: 0, variableArgs: false }, Q: { id: Re, numArgs: 0, variableArgs: false }, cm: { id: Ne, numArgs: 6, variableArgs: false }, m: { id: Ee, numArgs: 2, variableArgs: false }, l: { id: Pe, numArgs: 2, variableArgs: false }, c: { id: Le, numArgs: 6, variableArgs: false }, v: { id: je, numArgs: 4, variableArgs: false }, y: { id: _e, numArgs: 4, variableArgs: false }, h: { id: Ue, numArgs: 0, variableArgs: false }, re: { id: Xe, numArgs: 4, variableArgs: false }, S: { id: qe, numArgs: 0, variableArgs: false }, s: { id: He, numArgs: 0, variableArgs: false }, f: { id: We, numArgs: 0, variableArgs: false }, F: { id: We, numArgs: 0, variableArgs: false }, "f*": { id: ze, numArgs: 0, variableArgs: false }, B: { id: $e, numArgs: 0, variableArgs: false }, "B*": { id: Ge, numArgs: 0, variableArgs: false }, b: { id: Ve, numArgs: 0, variableArgs: false }, "b*": { id: Ke, numArgs: 0, variableArgs: false }, n: { id: Je, numArgs: 0, variableArgs: false }, W: { id: Ye, numArgs: 0, variableArgs: false }, "W*": { id: Ze, numArgs: 0, variableArgs: false }, BT: { id: Qe, numArgs: 0, variableArgs: false }, ET: { id: et, numArgs: 0, variableArgs: false }, Tc: { id: tt, numArgs: 1, variableArgs: false }, Tw: { id: at, numArgs: 1, variableArgs: false }, Tz: { id: rt, numArgs: 1, variableArgs: false }, TL: { id: it, numArgs: 1, variableArgs: false }, Tf: { id: nt, numArgs: 2, variableArgs: false }, Tr: { id: st, numArgs: 1, variableArgs: false }, Ts: { id: ot, numArgs: 1, variableArgs: false }, Td: { id: ct, numArgs: 2, variableArgs: false }, TD: { id: lt, numArgs: 2, variableArgs: false }, Tm: { id: ht, numArgs: 6, variableArgs: false }, "T*": { id: ut, numArgs: 0, variableArgs: false }, Tj: { id: dt, numArgs: 1, variableArgs: false }, TJ: { id: ft, numArgs: 1, variableArgs: false }, "'": { id: gt, numArgs: 1, variableArgs: false }, '"': { id: pt, numArgs: 3, variableArgs: false }, d0: { id: mt, numArgs: 2, variableArgs: false }, d1: { id: bt, numArgs: 6, variableArgs: false }, CS: { id: yt, numArgs: 1, variableArgs: false }, cs: { id: wt, numArgs: 1, variableArgs: false }, SC: { id: xt, numArgs: 4, variableArgs: true }, SCN: { id: St, numArgs: 33, variableArgs: true }, sc: { id: At, numArgs: 4, variableArgs: true }, scn: { id: kt, numArgs: 33, variableArgs: true }, G: { id: Ct, numArgs: 1, variableArgs: false }, g: { id: vt, numArgs: 1, variableArgs: false }, RG: { id: Ft, numArgs: 3, variableArgs: false }, rg: { id: It, numArgs: 3, variableArgs: false }, K: { id: Tt, numArgs: 4, variableArgs: false }, k: { id: Ot, numArgs: 4, variableArgs: false }, sh: { id: Mt, numArgs: 1, variableArgs: false }, BI: { id: Dt, numArgs: 0, variableArgs: false }, ID: { id: Bt, numArgs: 0, variableArgs: false }, EI: { id: Rt, numArgs: 1, variableArgs: false }, Do: { id: Nt, numArgs: 1, variableArgs: false }, MP: { id: Et, numArgs: 1, variableArgs: false }, DP: { id: Pt, numArgs: 2, variableArgs: false }, BMC: { id: Lt, numArgs: 1, variableArgs: false }, BDC: { id: jt, numArgs: 2, variableArgs: false }, EMC: { id: _t, numArgs: 0, variableArgs: false }, BX: { id: Ut, numArgs: 0, variableArgs: false }, EX: { id: Xt, numArgs: 0, variableArgs: false }, BM: null, BD: null, true: null, fa: null, fal: null, fals: null, false: null, nu: null, nul: null, null: null }));
  }
  static MAX_INVALID_PATH_OPS = 10;
  constructor(e2, t2, a2 = new StateManager()) {
    this.parser = new Parser({ lexer: new Lexer(e2, _EvaluatorPreprocessor.opMap), xref: t2 });
    this.stateManager = a2;
    this.nonProcessedArgs = [];
    this._isPathOp = false;
    this._numInvalidPathOPS = 0;
  }
  get savedStatesDepth() {
    return this.stateManager.stateStack.length;
  }
  read(e2) {
    let t2 = e2.args;
    for (; ; ) {
      const a2 = this.parser.getObj();
      if (a2 instanceof Cmd) {
        const r2 = a2.cmd, i2 = _EvaluatorPreprocessor.opMap[r2];
        if (!i2) {
          warn(`Unknown command "${r2}".`);
          continue;
        }
        const n2 = i2.id, s2 = i2.numArgs;
        let o2 = null !== t2 ? t2.length : 0;
        this._isPathOp || (this._numInvalidPathOPS = 0);
        this._isPathOp = n2 >= Ee && n2 <= Je;
        if (i2.variableArgs) o2 > s2 && info(`Command ${r2}: expected [0, ${s2}] args, but received ${o2} args.`);
        else {
          if (o2 !== s2) {
            const e3 = this.nonProcessedArgs;
            for (; o2 > s2; ) {
              e3.push(t2.shift());
              o2--;
            }
            for (; o2 < s2 && 0 !== e3.length; ) {
              null === t2 && (t2 = []);
              t2.unshift(e3.pop());
              o2++;
            }
          }
          if (o2 < s2) {
            const e3 = `command ${r2}: expected ${s2} args, but received ${o2} args.`;
            if (this._isPathOp && ++this._numInvalidPathOPS > _EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) throw new FormatError(`Invalid ${e3}`);
            warn(`Skipping ${e3}`);
            null !== t2 && (t2.length = 0);
            continue;
          }
        }
        this.preprocessCommand(n2, t2);
        e2.fn = n2;
        e2.args = t2;
        return true;
      }
      if (a2 === wa) return false;
      if (null !== a2) {
        null === t2 && (t2 = []);
        t2.push(a2);
        if (t2.length > 33) throw new FormatError("Too many arguments");
      }
    }
  }
  preprocessCommand(e2, t2) {
    switch (0 | e2) {
      case Be:
        this.stateManager.save();
        break;
      case Re:
        this.stateManager.restore();
        break;
      case Ne:
        this.stateManager.transform(t2);
    }
  }
};
var DefaultAppearanceEvaluator = class extends EvaluatorPreprocessor {
  constructor(e2) {
    super(new StringStream(e2));
  }
  parse() {
    const e2 = { fn: 0, args: [] }, t2 = { fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3) };
    try {
      for (; ; ) {
        e2.args.length = 0;
        if (!this.read(e2)) break;
        if (0 !== this.savedStatesDepth) continue;
        const { fn: a2, args: r2 } = e2;
        switch (0 | a2) {
          case nt:
            const [e3, a3] = r2;
            e3 instanceof Name && (t2.fontName = e3.name);
            "number" == typeof a3 && a3 > 0 && (t2.fontSize = a3);
            break;
          case It:
            ColorSpaceUtils.rgb.getRgbItem(r2, 0, t2.fontColor, 0);
            break;
          case vt:
            ColorSpaceUtils.gray.getRgbItem(r2, 0, t2.fontColor, 0);
            break;
          case Ot:
            ColorSpaceUtils.cmyk.getRgbItem(r2, 0, t2.fontColor, 0);
        }
      }
    } catch (e3) {
      warn(`parseDefaultAppearance - ignoring errors: "${e3}".`);
    }
    return t2;
  }
};
function parseDefaultAppearance(e2) {
  return new DefaultAppearanceEvaluator(e2).parse();
}
var AppearanceStreamEvaluator = class extends EvaluatorPreprocessor {
  constructor(e2, t2, a2, r2) {
    super(e2);
    this.stream = e2;
    this.evaluatorOptions = t2;
    this.xref = a2;
    this.globalColorSpaceCache = r2;
    this.resources = e2.dict?.get("Resources");
  }
  parse() {
    const e2 = { fn: 0, args: [] };
    let t2 = { scaleFactor: 1, fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3), fillColorSpace: ColorSpaceUtils.gray }, a2 = false;
    const r2 = [];
    try {
      for (; ; ) {
        e2.args.length = 0;
        if (a2 || !this.read(e2)) break;
        const { fn: i2, args: n2 } = e2;
        switch (0 | i2) {
          case Be:
            r2.push({ scaleFactor: t2.scaleFactor, fontSize: t2.fontSize, fontName: t2.fontName, fontColor: t2.fontColor.slice(), fillColorSpace: t2.fillColorSpace });
            break;
          case Re:
            t2 = r2.pop() || t2;
            break;
          case ht:
            t2.scaleFactor *= Math.hypot(n2[0], n2[1]);
            break;
          case nt:
            const [e3, i3] = n2;
            e3 instanceof Name && (t2.fontName = e3.name);
            "number" == typeof i3 && i3 > 0 && (t2.fontSize = i3 * t2.scaleFactor);
            break;
          case wt:
            t2.fillColorSpace = ColorSpaceUtils.parse({ cs: n2[0], xref: this.xref, resources: this.resources, pdfFunctionFactory: this._pdfFunctionFactory, globalColorSpaceCache: this.globalColorSpaceCache, localColorSpaceCache: this._localColorSpaceCache });
            break;
          case At:
            t2.fillColorSpace.getRgbItem(n2, 0, t2.fontColor, 0);
            break;
          case It:
            ColorSpaceUtils.rgb.getRgbItem(n2, 0, t2.fontColor, 0);
            break;
          case vt:
            ColorSpaceUtils.gray.getRgbItem(n2, 0, t2.fontColor, 0);
            break;
          case Ot:
            ColorSpaceUtils.cmyk.getRgbItem(n2, 0, t2.fontColor, 0);
            break;
          case dt:
          case ft:
          case gt:
          case pt:
            a2 = true;
        }
      }
    } catch (e3) {
      warn(`parseAppearanceStream - ignoring errors: "${e3}".`);
    }
    this.stream.reset();
    delete t2.scaleFactor;
    delete t2.fillColorSpace;
    return t2;
  }
  get _localColorSpaceCache() {
    return shadow(this, "_localColorSpaceCache", new LocalColorSpaceCache());
  }
  get _pdfFunctionFactory() {
    return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({ xref: this.xref, isEvalSupported: this.evaluatorOptions.isEvalSupported }));
  }
};
function getPdfColor(e2, t2) {
  if (e2[0] === e2[1] && e2[1] === e2[2]) {
    return `${numberToString(e2[0] / 255)} ${t2 ? "g" : "G"}`;
  }
  return Array.from(e2, ((e3) => numberToString(e3 / 255))).join(" ") + " " + (t2 ? "rg" : "RG");
}
var FakeUnicodeFont = class _FakeUnicodeFont {
  constructor(e2, t2) {
    this.xref = e2;
    this.widths = null;
    this.firstChar = 1 / 0;
    this.lastChar = -1 / 0;
    this.fontFamily = t2;
    const a2 = new OffscreenCanvas(1, 1);
    this.ctxMeasure = a2.getContext("2d", { willReadFrequently: true });
    _FakeUnicodeFont._fontNameId || (_FakeUnicodeFont._fontNameId = 1);
    this.fontName = Name.get(`InvalidPDFjsFont_${t2}_${_FakeUnicodeFont._fontNameId++}`);
  }
  get fontDescriptorRef() {
    if (!_FakeUnicodeFont._fontDescriptorRef) {
      const e2 = new Dict(this.xref);
      e2.setIfName("Type", "FontDescriptor");
      e2.set("FontName", this.fontName);
      e2.set("FontFamily", "MyriadPro Regular");
      e2.set("FontBBox", [0, 0, 0, 0]);
      e2.setIfName("FontStretch", "Normal");
      e2.set("FontWeight", 400);
      e2.set("ItalicAngle", 0);
      _FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e2);
    }
    return _FakeUnicodeFont._fontDescriptorRef;
  }
  get descendantFontRef() {
    const e2 = new Dict(this.xref);
    e2.set("BaseFont", this.fontName);
    e2.setIfName("Type", "Font");
    e2.setIfName("Subtype", "CIDFontType0");
    e2.setIfName("CIDToGIDMap", "Identity");
    e2.set("FirstChar", this.firstChar);
    e2.set("LastChar", this.lastChar);
    e2.set("FontDescriptor", this.fontDescriptorRef);
    e2.set("DW", 1e3);
    const t2 = [], a2 = [...this.widths.entries()].sort();
    let r2 = null, i2 = null;
    for (const [e3, n3] of a2) if (r2) if (e3 === r2 + i2.length) i2.push(n3);
    else {
      t2.push(r2, i2);
      r2 = e3;
      i2 = [n3];
    }
    else {
      r2 = e3;
      i2 = [n3];
    }
    r2 && t2.push(r2, i2);
    e2.set("W", t2);
    const n2 = new Dict(this.xref);
    n2.set("Ordering", "Identity");
    n2.set("Registry", "Adobe");
    n2.set("Supplement", 0);
    e2.set("CIDSystemInfo", n2);
    return this.xref.getNewPersistentRef(e2);
  }
  get baseFontRef() {
    const e2 = new Dict(this.xref);
    e2.set("BaseFont", this.fontName);
    e2.setIfName("Type", "Font");
    e2.setIfName("Subtype", "Type0");
    e2.setIfName("Encoding", "Identity-H");
    e2.set("DescendantFonts", [this.descendantFontRef]);
    e2.setIfName("ToUnicode", "Identity-H");
    return this.xref.getNewPersistentRef(e2);
  }
  get resources() {
    const e2 = new Dict(this.xref), t2 = new Dict(this.xref);
    t2.set(this.fontName.name, this.baseFontRef);
    e2.set("Font", t2);
    return e2;
  }
  _createContext() {
    this.widths = /* @__PURE__ */ new Map();
    this.ctxMeasure.font = `1000px ${this.fontFamily}`;
    return this.ctxMeasure;
  }
  createFontResources(e2) {
    const t2 = this._createContext();
    for (const a2 of e2.split(/\r\n?|\n/)) for (const e3 of a2.split("")) {
      const a3 = e3.charCodeAt(0);
      if (this.widths.has(a3)) continue;
      const r2 = t2.measureText(e3), i2 = Math.ceil(r2.width);
      this.widths.set(a3, i2);
      this.firstChar = Math.min(a3, this.firstChar);
      this.lastChar = Math.max(a3, this.lastChar);
    }
    return this.resources;
  }
  static getFirstPositionInfo(e2, t2, i2) {
    const [n2, s2, o2, c2] = e2;
    let l2 = o2 - n2, h2 = c2 - s2;
    t2 % 180 != 0 && ([l2, h2] = [h2, l2]);
    const u2 = a * i2;
    return { coords: [0, h2 + r * i2 - u2], bbox: [0, 0, l2, h2], matrix: 0 !== t2 ? getRotationMatrix(t2, h2, u2) : void 0 };
  }
  createAppearance(e2, t2, i2, n2, s2, o2) {
    const c2 = this._createContext(), l2 = [];
    let h2 = -1 / 0;
    for (const t3 of e2.split(/\r\n?|\n/)) {
      l2.push(t3);
      const e3 = c2.measureText(t3).width;
      h2 = Math.max(h2, e3);
      for (const e4 of codePointIter(t3)) {
        const t4 = String.fromCodePoint(e4);
        let a2 = this.widths.get(e4);
        if (void 0 === a2) {
          const r2 = c2.measureText(t4);
          a2 = Math.ceil(r2.width);
          this.widths.set(e4, a2);
          this.firstChar = Math.min(e4, this.firstChar);
          this.lastChar = Math.max(e4, this.lastChar);
        }
      }
    }
    h2 *= n2 / 1e3;
    const [u2, d2, f2, g2] = t2;
    let p2 = f2 - u2, m2 = g2 - d2;
    i2 % 180 != 0 && ([p2, m2] = [m2, p2]);
    let b2 = 1;
    h2 > p2 && (b2 = p2 / h2);
    let y2 = 1;
    const w2 = a * n2, x2 = r * n2, S2 = w2 * l2.length;
    S2 > m2 && (y2 = m2 / S2);
    const k2 = n2 * Math.min(b2, y2), C2 = ["q", `0 0 ${numberToString(p2)} ${numberToString(m2)} re W n`, "BT", `1 0 0 1 0 ${numberToString(m2 + x2)} Tm 0 Tc ${getPdfColor(s2, true)}`, `/${this.fontName.name} ${numberToString(k2)} Tf`], { resources: v2 } = this;
    if (1 !== (o2 = "number" == typeof o2 && o2 >= 0 && o2 <= 1 ? o2 : 1)) {
      C2.push("/R0 gs");
      const e3 = new Dict(this.xref), t3 = new Dict(this.xref);
      t3.set("ca", o2);
      t3.set("CA", o2);
      t3.setIfName("Type", "ExtGState");
      e3.set("R0", t3);
      v2.set("ExtGState", e3);
    }
    const F2 = numberToString(w2);
    for (const e3 of l2) C2.push(`0 -${F2} Td <${stringToUTF16HexString(e3)}> Tj`);
    C2.push("ET", "Q");
    const T2 = C2.join("\n"), O2 = new Dict(this.xref);
    O2.setIfName("Subtype", "Form");
    O2.setIfName("Type", "XObject");
    O2.set("BBox", [0, 0, p2, m2]);
    O2.set("Length", T2.length);
    O2.set("Resources", v2);
    if (i2) {
      const e3 = getRotationMatrix(i2, p2, m2);
      O2.set("Matrix", e3);
    }
    const M2 = new StringStream(T2);
    M2.dict = O2;
    return M2;
  }
};
var Pn = ["m/d", "m/d/yy", "mm/dd/yy", "mm/yy", "d-mmm", "d-mmm-yy", "dd-mmm-yy", "yy-mm-dd", "mmm-yy", "mmmm-yy", "mmm d, yyyy", "mmmm d, yyyy", "m/d/yy h:MM tt", "m/d/yy HH:MM"];
var Ln = ["HH:MM", "h:MM tt", "HH:MM:ss", "h:MM:ss tt"];
var NameOrNumberTree = class {
  constructor(e2, t2, a2) {
    this.root = e2;
    this.xref = t2;
    this._type = a2;
  }
  getAll() {
    const e2 = /* @__PURE__ */ new Map();
    if (!this.root) return e2;
    const t2 = this.xref, a2 = new RefSet();
    a2.put(this.root);
    const r2 = [this.root];
    for (; r2.length > 0; ) {
      const i2 = t2.fetchIfRef(r2.shift());
      if (!(i2 instanceof Dict)) continue;
      if (i2.has("Kids")) {
        const e3 = i2.get("Kids");
        if (!Array.isArray(e3)) continue;
        for (const t3 of e3) {
          if (a2.has(t3)) throw new FormatError(`Duplicate entry in "${this._type}" tree.`);
          r2.push(t3);
          a2.put(t3);
        }
        continue;
      }
      const n2 = i2.get(this._type);
      if (Array.isArray(n2)) for (let a3 = 0, r3 = n2.length; a3 < r3; a3 += 2) e2.set(t2.fetchIfRef(n2[a3]), t2.fetchIfRef(n2[a3 + 1]));
    }
    return e2;
  }
  getRaw(e2) {
    if (!this.root) return null;
    const t2 = this.xref;
    let a2 = t2.fetchIfRef(this.root), r2 = 0;
    for (; a2.has("Kids"); ) {
      if (++r2 > 10) {
        warn(`Search depth limit reached for "${this._type}" tree.`);
        return null;
      }
      const i3 = a2.get("Kids");
      if (!Array.isArray(i3)) return null;
      let n2 = 0, s2 = i3.length - 1;
      for (; n2 <= s2; ) {
        const r3 = n2 + s2 >> 1, o2 = t2.fetchIfRef(i3[r3]), c2 = o2.get("Limits");
        if (e2 < t2.fetchIfRef(c2[0])) s2 = r3 - 1;
        else {
          if (!(e2 > t2.fetchIfRef(c2[1]))) {
            a2 = o2;
            break;
          }
          n2 = r3 + 1;
        }
      }
      if (n2 > s2) return null;
    }
    const i2 = a2.get(this._type);
    if (Array.isArray(i2)) {
      let a3 = 0, r3 = i2.length - 2;
      for (; a3 <= r3; ) {
        const n2 = a3 + r3 >> 1, s2 = n2 + (1 & n2), o2 = t2.fetchIfRef(i2[s2]);
        if (e2 < o2) r3 = s2 - 2;
        else {
          if (!(e2 > o2)) return i2[s2 + 1];
          a3 = s2 + 2;
        }
      }
    }
    return null;
  }
  get(e2) {
    return this.xref.fetchIfRef(this.getRaw(e2));
  }
};
var NameTree = class extends NameOrNumberTree {
  constructor(e2, t2) {
    super(e2, t2, "Names");
  }
};
var NumberTree = class extends NameOrNumberTree {
  constructor(e2, t2) {
    super(e2, t2, "Nums");
  }
};
function clearGlobalCaches() {
  !(function clearPatternCaches() {
    Ii = /* @__PURE__ */ Object.create(null);
  })();
  !(function clearPrimitiveCaches() {
    xa = /* @__PURE__ */ Object.create(null);
    Sa = /* @__PURE__ */ Object.create(null);
    Aa = /* @__PURE__ */ Object.create(null);
  })();
  !(function clearUnicodeCaches() {
    Dr.clear();
  })();
  JpxImage.cleanup();
}
function pickPlatformItem(e2) {
  return e2 instanceof Dict ? e2.has("UF") ? e2.get("UF") : e2.has("F") ? e2.get("F") : e2.has("Unix") ? e2.get("Unix") : e2.has("Mac") ? e2.get("Mac") : e2.has("DOS") ? e2.get("DOS") : null : null;
}
var FileSpec = class {
  #Y = false;
  constructor(e2, t2, a2 = false) {
    if (e2 instanceof Dict) {
      this.xref = t2;
      this.root = e2;
      e2.has("FS") && (this.fs = e2.get("FS"));
      e2.has("RF") && warn("Related file specifications are not supported");
      a2 || (e2.has("EF") ? this.#Y = true : warn("Non-embedded file specifications are not supported"));
    }
  }
  get filename() {
    let e2 = "";
    const t2 = pickPlatformItem(this.root);
    t2 && "string" == typeof t2 && (e2 = stringToPDFString(t2, true).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/"));
    return shadow(this, "filename", e2 || "unnamed");
  }
  get content() {
    if (!this.#Y) return null;
    this._contentRef ||= pickPlatformItem(this.root?.get("EF"));
    let e2 = null;
    if (this._contentRef) {
      const t2 = this.xref.fetchIfRef(this._contentRef);
      t2 instanceof BaseStream ? e2 = t2.getBytes() : warn("Embedded file specification points to non-existing/invalid content");
    } else warn("Embedded file specification does not have any content");
    return e2;
  }
  get description() {
    let e2 = "";
    const t2 = this.root?.get("Desc");
    t2 && "string" == typeof t2 && (e2 = stringToPDFString(t2));
    return shadow(this, "description", e2);
  }
  get serializable() {
    return { rawFilename: this.filename, filename: (e2 = this.filename, e2.substring(e2.lastIndexOf("/") + 1)), content: this.content, description: this.description };
    var e2;
  }
};
var jn = 0;
var _n = -2;
var Un = -3;
var Xn = -4;
var qn = -5;
var Hn = -6;
var Wn = -9;
function isWhitespace(e2, t2) {
  const a2 = e2[t2];
  return " " === a2 || "\n" === a2 || "\r" === a2 || "	" === a2;
}
var XMLParserBase = class {
  _resolveEntities(e2) {
    return e2.replaceAll(/&([^;]+);/g, ((e3, t2) => {
      if ("#x" === t2.substring(0, 2)) return String.fromCodePoint(parseInt(t2.substring(2), 16));
      if ("#" === t2.substring(0, 1)) return String.fromCodePoint(parseInt(t2.substring(1), 10));
      switch (t2) {
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "amp":
          return "&";
        case "quot":
          return '"';
        case "apos":
          return "'";
      }
      return this.onResolveEntity(t2);
    }));
  }
  _parseContent(e2, t2) {
    const a2 = [];
    let r2 = t2;
    function skipWs() {
      for (; r2 < e2.length && isWhitespace(e2, r2); ) ++r2;
    }
    for (; r2 < e2.length && !isWhitespace(e2, r2) && ">" !== e2[r2] && "/" !== e2[r2]; ) ++r2;
    const i2 = e2.substring(t2, r2);
    skipWs();
    for (; r2 < e2.length && ">" !== e2[r2] && "/" !== e2[r2] && "?" !== e2[r2]; ) {
      skipWs();
      let t3 = "", i3 = "";
      for (; r2 < e2.length && !isWhitespace(e2, r2) && "=" !== e2[r2]; ) {
        t3 += e2[r2];
        ++r2;
      }
      skipWs();
      if ("=" !== e2[r2]) return null;
      ++r2;
      skipWs();
      const n2 = e2[r2];
      if ('"' !== n2 && "'" !== n2) return null;
      const s2 = e2.indexOf(n2, ++r2);
      if (s2 < 0) return null;
      i3 = e2.substring(r2, s2);
      a2.push({ name: t3, value: this._resolveEntities(i3) });
      r2 = s2 + 1;
      skipWs();
    }
    return { name: i2, attributes: a2, parsed: r2 - t2 };
  }
  _parseProcessingInstruction(e2, t2) {
    let a2 = t2;
    for (; a2 < e2.length && !isWhitespace(e2, a2) && ">" !== e2[a2] && "?" !== e2[a2] && "/" !== e2[a2]; ) ++a2;
    const r2 = e2.substring(t2, a2);
    !(function skipWs() {
      for (; a2 < e2.length && isWhitespace(e2, a2); ) ++a2;
    })();
    const i2 = a2;
    for (; a2 < e2.length && ("?" !== e2[a2] || ">" !== e2[a2 + 1]); ) ++a2;
    return { name: r2, value: e2.substring(i2, a2), parsed: a2 - t2 };
  }
  parseXml(e2) {
    let t2 = 0;
    for (; t2 < e2.length; ) {
      let a2 = t2;
      if ("<" === e2[t2]) {
        ++a2;
        let t3;
        switch (e2[a2]) {
          case "/":
            ++a2;
            t3 = e2.indexOf(">", a2);
            if (t3 < 0) {
              this.onError(Wn);
              return;
            }
            this.onEndElement(e2.substring(a2, t3));
            a2 = t3 + 1;
            break;
          case "?":
            ++a2;
            const r2 = this._parseProcessingInstruction(e2, a2);
            if ("?>" !== e2.substring(a2 + r2.parsed, a2 + r2.parsed + 2)) {
              this.onError(Un);
              return;
            }
            this.onPi(r2.name, r2.value);
            a2 += r2.parsed + 2;
            break;
          case "!":
            if ("--" === e2.substring(a2 + 1, a2 + 3)) {
              t3 = e2.indexOf("-->", a2 + 3);
              if (t3 < 0) {
                this.onError(qn);
                return;
              }
              this.onComment(e2.substring(a2 + 3, t3));
              a2 = t3 + 3;
            } else if ("[CDATA[" === e2.substring(a2 + 1, a2 + 8)) {
              t3 = e2.indexOf("]]>", a2 + 8);
              if (t3 < 0) {
                this.onError(_n);
                return;
              }
              this.onCdata(e2.substring(a2 + 8, t3));
              a2 = t3 + 3;
            } else {
              if ("DOCTYPE" !== e2.substring(a2 + 1, a2 + 8)) {
                this.onError(Hn);
                return;
              }
              {
                const r3 = e2.indexOf("[", a2 + 8);
                let i3 = false;
                t3 = e2.indexOf(">", a2 + 8);
                if (t3 < 0) {
                  this.onError(Xn);
                  return;
                }
                if (r3 > 0 && t3 > r3) {
                  t3 = e2.indexOf("]>", a2 + 8);
                  if (t3 < 0) {
                    this.onError(Xn);
                    return;
                  }
                  i3 = true;
                }
                const n3 = e2.substring(a2 + 8, t3 + (i3 ? 1 : 0));
                this.onDoctype(n3);
                a2 = t3 + (i3 ? 2 : 1);
              }
            }
            break;
          default:
            const i2 = this._parseContent(e2, a2);
            if (null === i2) {
              this.onError(Hn);
              return;
            }
            let n2 = false;
            if ("/>" === e2.substring(a2 + i2.parsed, a2 + i2.parsed + 2)) n2 = true;
            else if (">" !== e2.substring(a2 + i2.parsed, a2 + i2.parsed + 1)) {
              this.onError(Wn);
              return;
            }
            this.onBeginElement(i2.name, i2.attributes, n2);
            a2 += i2.parsed + (n2 ? 2 : 1);
        }
      } else {
        for (; a2 < e2.length && "<" !== e2[a2]; ) a2++;
        const r2 = e2.substring(t2, a2);
        this.onText(this._resolveEntities(r2));
      }
      t2 = a2;
    }
  }
  onResolveEntity(e2) {
    return `&${e2};`;
  }
  onPi(e2, t2) {
  }
  onComment(e2) {
  }
  onCdata(e2) {
  }
  onDoctype(e2) {
  }
  onText(e2) {
  }
  onBeginElement(e2, t2, a2) {
  }
  onEndElement(e2) {
  }
  onError(e2) {
  }
};
var SimpleDOMNode = class {
  constructor(e2, t2) {
    this.nodeName = e2;
    this.nodeValue = t2;
    Object.defineProperty(this, "parentNode", { value: null, writable: true });
  }
  get firstChild() {
    return this.childNodes?.[0];
  }
  get nextSibling() {
    const e2 = this.parentNode.childNodes;
    if (!e2) return;
    const t2 = e2.indexOf(this);
    return -1 !== t2 ? e2[t2 + 1] : void 0;
  }
  get textContent() {
    return this.childNodes ? this.childNodes.map(((e2) => e2.textContent)).join("") : this.nodeValue || "";
  }
  get children() {
    return this.childNodes || [];
  }
  hasChildNodes() {
    return this.childNodes?.length > 0;
  }
  searchNode(e2, t2) {
    if (t2 >= e2.length) return this;
    const a2 = e2[t2];
    if (a2.name.startsWith("#") && t2 < e2.length - 1) return this.searchNode(e2, t2 + 1);
    const r2 = [];
    let i2 = this;
    for (; ; ) {
      if (a2.name === i2.nodeName) {
        if (0 !== a2.pos) {
          if (0 === r2.length) return null;
          {
            const [n2] = r2.pop();
            let s2 = 0;
            for (const r3 of n2.childNodes) if (a2.name === r3.nodeName) {
              if (s2 === a2.pos) return r3.searchNode(e2, t2 + 1);
              s2++;
            }
            return i2.searchNode(e2, t2 + 1);
          }
        }
        {
          const a3 = i2.searchNode(e2, t2 + 1);
          if (null !== a3) return a3;
        }
      }
      if (i2.childNodes?.length > 0) {
        r2.push([i2, 0]);
        i2 = i2.childNodes[0];
      } else {
        if (0 === r2.length) return null;
        for (; 0 !== r2.length; ) {
          const [e3, t3] = r2.pop(), a3 = t3 + 1;
          if (a3 < e3.childNodes.length) {
            r2.push([e3, a3]);
            i2 = e3.childNodes[a3];
            break;
          }
        }
        if (0 === r2.length) return null;
      }
    }
  }
  dump(e2) {
    if ("#text" !== this.nodeName) {
      e2.push(`<${this.nodeName}`);
      if (this.attributes) for (const t2 of this.attributes) e2.push(` ${t2.name}="${encodeToXmlString(t2.value)}"`);
      if (this.hasChildNodes()) {
        e2.push(">");
        for (const t2 of this.childNodes) t2.dump(e2);
        e2.push(`</${this.nodeName}>`);
      } else this.nodeValue ? e2.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e2.push("/>");
    } else e2.push(encodeToXmlString(this.nodeValue));
  }
};
var SimpleXMLParser = class extends XMLParserBase {
  constructor({ hasAttributes: e2 = false, lowerCaseName: t2 = false }) {
    super();
    this._currentFragment = null;
    this._stack = null;
    this._errorCode = jn;
    this._hasAttributes = e2;
    this._lowerCaseName = t2;
  }
  parseFromString(e2) {
    this._currentFragment = [];
    this._stack = [];
    this._errorCode = jn;
    this.parseXml(e2);
    if (this._errorCode !== jn) return;
    const [t2] = this._currentFragment;
    return t2 ? { documentElement: t2 } : void 0;
  }
  onText(e2) {
    if ((function isWhitespaceString(e3) {
      for (let t3 = 0, a2 = e3.length; t3 < a2; t3++) if (!isWhitespace(e3, t3)) return false;
      return true;
    })(e2)) return;
    const t2 = new SimpleDOMNode("#text", e2);
    this._currentFragment.push(t2);
  }
  onCdata(e2) {
    const t2 = new SimpleDOMNode("#text", e2);
    this._currentFragment.push(t2);
  }
  onBeginElement(e2, t2, a2) {
    this._lowerCaseName && (e2 = e2.toLowerCase());
    const r2 = new SimpleDOMNode(e2);
    r2.childNodes = [];
    this._hasAttributes && (r2.attributes = t2);
    this._currentFragment.push(r2);
    if (!a2) {
      this._stack.push(this._currentFragment);
      this._currentFragment = r2.childNodes;
    }
  }
  onEndElement(e2) {
    this._currentFragment = this._stack.pop() || [];
    const t2 = this._currentFragment.at(-1);
    if (!t2) return null;
    for (const e3 of t2.childNodes) e3.parentNode = t2;
    return t2;
  }
  onError(e2) {
    this._errorCode = e2;
  }
};
var MetadataParser = class {
  constructor(e2) {
    e2 = this._repair(e2);
    const t2 = new SimpleXMLParser({ lowerCaseName: true }).parseFromString(e2);
    this._metadataMap = /* @__PURE__ */ new Map();
    this._data = e2;
    t2 && this._parse(t2);
  }
  _repair(e2) {
    return e2.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, (function(e3, t2) {
      const a2 = t2.replaceAll(/\\([0-3])([0-7])([0-7])/g, (function(e4, t3, a3, r3) {
        return String.fromCharCode(64 * t3 + 8 * a3 + 1 * r3);
      })).replaceAll(/&(amp|apos|gt|lt|quot);/g, (function(e4, t3) {
        switch (t3) {
          case "amp":
            return "&";
          case "apos":
            return "'";
          case "gt":
            return ">";
          case "lt":
            return "<";
          case "quot":
            return '"';
        }
        throw new Error(`_repair: ${t3} isn't defined.`);
      })), r2 = [">"];
      for (let e4 = 0, t3 = a2.length; e4 < t3; e4 += 2) {
        const t4 = 256 * a2.charCodeAt(e4) + a2.charCodeAt(e4 + 1);
        t4 >= 32 && t4 < 127 && 60 !== t4 && 62 !== t4 && 38 !== t4 ? r2.push(String.fromCharCode(t4)) : r2.push("&#x" + (65536 + t4).toString(16).substring(1) + ";");
      }
      return r2.join("");
    }));
  }
  _getSequence(e2) {
    const t2 = e2.nodeName;
    return "rdf:bag" !== t2 && "rdf:seq" !== t2 && "rdf:alt" !== t2 ? null : e2.childNodes.filter(((e3) => "rdf:li" === e3.nodeName));
  }
  _parseArray(e2) {
    if (!e2.hasChildNodes()) return;
    const [t2] = e2.childNodes, a2 = this._getSequence(t2) || [];
    this._metadataMap.set(e2.nodeName, a2.map(((e3) => e3.textContent.trim())));
  }
  _parse(e2) {
    let t2 = e2.documentElement;
    if ("rdf:rdf" !== t2.nodeName) {
      t2 = t2.firstChild;
      for (; t2 && "rdf:rdf" !== t2.nodeName; ) t2 = t2.nextSibling;
    }
    if (t2 && "rdf:rdf" === t2.nodeName && t2.hasChildNodes()) {
      for (const e3 of t2.childNodes) if ("rdf:description" === e3.nodeName) for (const t3 of e3.childNodes) {
        const e4 = t3.nodeName;
        switch (e4) {
          case "#text":
            continue;
          case "dc:creator":
          case "dc:subject":
            this._parseArray(t3);
            continue;
        }
        this._metadataMap.set(e4, t3.textContent.trim());
      }
    }
  }
  get serializable() {
    return { parsedData: this._metadataMap, rawData: this._data };
  }
};
var zn = 1;
var $n = 2;
var Gn = 3;
var Vn = 4;
var Kn = 5;
var StructTreeRoot = class _StructTreeRoot {
  constructor(e2, t2, a2) {
    this.xref = e2;
    this.dict = t2;
    this.ref = a2 instanceof Ref ? a2 : null;
    this.roleMap = /* @__PURE__ */ new Map();
    this.structParentIds = null;
  }
  init() {
    this.readRoleMap();
  }
  #Z(e2, t2, a2) {
    if (!(e2 instanceof Ref) || t2 < 0) return;
    this.structParentIds ||= new RefSetCache();
    let r2 = this.structParentIds.get(e2);
    if (!r2) {
      r2 = [];
      this.structParentIds.put(e2, r2);
    }
    r2.push([t2, a2]);
  }
  addAnnotationIdToPage(e2, t2) {
    this.#Z(e2, t2, Vn);
  }
  readRoleMap() {
    const e2 = this.dict.get("RoleMap");
    if (e2 instanceof Dict) for (const [t2, a2] of e2) a2 instanceof Name && this.roleMap.set(t2, a2.name);
  }
  static async canCreateStructureTree({ catalogRef: e2, pdfManager: t2, newAnnotationsByPage: a2 }) {
    if (!(e2 instanceof Ref)) {
      warn("Cannot save the struct tree: no catalog reference.");
      return false;
    }
    let r2 = 0, i2 = true;
    for (const [e3, n2] of a2) {
      const { ref: a3 } = await t2.getPage(e3);
      if (!(a3 instanceof Ref)) {
        warn(`Cannot save the struct tree: page ${e3} has no ref.`);
        i2 = true;
        break;
      }
      for (const e4 of n2) if (e4.accessibilityData?.type) {
        e4.parentTreeId = r2++;
        i2 = false;
      }
    }
    if (i2) {
      for (const e3 of a2.values()) for (const t3 of e3) delete t3.parentTreeId;
      return false;
    }
    return true;
  }
  static async createStructureTree({ newAnnotationsByPage: e2, xref: t2, catalogRef: a2, pdfManager: r2, changes: i2 }) {
    const n2 = await r2.ensureCatalog("cloneDict"), s2 = new RefSetCache();
    s2.put(a2, n2);
    const o2 = t2.getNewTemporaryRef();
    n2.set("StructTreeRoot", o2);
    const c2 = new Dict(t2);
    c2.set("Type", Name.get("StructTreeRoot"));
    const l2 = t2.getNewTemporaryRef();
    c2.set("ParentTree", l2);
    const h2 = [];
    c2.set("K", h2);
    s2.put(o2, c2);
    const u2 = new Dict(t2), d2 = [];
    u2.set("Nums", d2);
    const f2 = await this.#Q({ newAnnotationsByPage: e2, structTreeRootRef: o2, structTreeRoot: null, kids: h2, nums: d2, xref: t2, pdfManager: r2, changes: i2, cache: s2 });
    c2.set("ParentTreeNextKey", f2);
    s2.put(l2, u2);
    for (const [e3, t3] of s2.items()) i2.put(e3, { data: t3 });
  }
  async canUpdateStructTree({ pdfManager: e2, newAnnotationsByPage: t2 }) {
    if (!this.ref) {
      warn("Cannot update the struct tree: no root reference.");
      return false;
    }
    let a2 = this.dict.get("ParentTreeNextKey");
    if (!Number.isInteger(a2) || a2 < 0) {
      warn("Cannot update the struct tree: invalid next key.");
      return false;
    }
    const r2 = this.dict.get("ParentTree");
    if (!(r2 instanceof Dict)) {
      warn("Cannot update the struct tree: ParentTree isn't a dict.");
      return false;
    }
    const i2 = r2.get("Nums");
    if (!Array.isArray(i2)) {
      warn("Cannot update the struct tree: nums isn't an array.");
      return false;
    }
    const n2 = new NumberTree(r2, this.xref);
    for (const a3 of t2.keys()) {
      const { pageDict: t3 } = await e2.getPage(a3);
      if (!t3.has("StructParents")) continue;
      const r3 = t3.get("StructParents");
      if (!Number.isInteger(r3) || !Array.isArray(n2.get(r3))) {
        warn(`Cannot save the struct tree: page ${a3} has a wrong id.`);
        return false;
      }
    }
    let s2 = true;
    for (const [r3, i3] of t2) {
      const { pageDict: t3 } = await e2.getPage(r3);
      _StructTreeRoot.#ee({ elements: i3, xref: this.xref, pageDict: t3, numberTree: n2 });
      for (const e3 of i3) if (e3.accessibilityData?.type) {
        e3.accessibilityData.structParent >= 0 || (e3.parentTreeId = a2++);
        s2 = false;
      }
    }
    if (s2) {
      for (const e3 of t2.values()) for (const t3 of e3) {
        delete t3.parentTreeId;
        delete t3.structTreeParent;
      }
      return false;
    }
    return true;
  }
  async updateStructureTree({ newAnnotationsByPage: e2, pdfManager: t2, changes: a2 }) {
    const { ref: r2, xref: i2 } = this, n2 = this.dict.clone(), s2 = new RefSetCache();
    s2.put(r2, n2);
    let o2, c2 = n2.getRaw("ParentTree");
    if (c2 instanceof Ref) o2 = i2.fetch(c2);
    else {
      o2 = c2;
      c2 = i2.getNewTemporaryRef();
      n2.set("ParentTree", c2);
    }
    o2 = o2.clone();
    s2.put(c2, o2);
    let l2 = o2.getRaw("Nums"), h2 = null;
    if (l2 instanceof Ref) {
      h2 = l2;
      l2 = i2.fetch(h2);
    }
    l2 = l2.slice();
    h2 || o2.set("Nums", l2);
    const u2 = await _StructTreeRoot.#Q({ newAnnotationsByPage: e2, structTreeRootRef: r2, structTreeRoot: this, kids: null, nums: l2, xref: i2, pdfManager: t2, changes: a2, cache: s2 });
    if (-1 !== u2) {
      n2.set("ParentTreeNextKey", u2);
      h2 && s2.put(h2, l2);
      for (const [e3, t3] of s2.items()) a2.put(e3, { data: t3 });
    }
  }
  static async #Q({ newAnnotationsByPage: e2, structTreeRootRef: t2, structTreeRoot: a2, kids: r2, nums: i2, xref: n2, pdfManager: s2, changes: o2, cache: c2 }) {
    const l2 = Name.get("OBJR");
    let h2, u2 = -1;
    for (const [d2, f2] of e2) {
      const e3 = await s2.getPage(d2), { ref: g2 } = e3, p2 = g2 instanceof Ref;
      for (const { accessibilityData: s3, ref: m2, parentTreeId: b2, structTreeParent: y2 } of f2) {
        if (!s3?.type) continue;
        const { structParent: f3 } = s3;
        if (a2 && Number.isInteger(f3) && f3 >= 0) {
          let t3 = (h2 ||= /* @__PURE__ */ new Map()).get(d2);
          if (void 0 === t3) {
            t3 = new StructTreePage(a2, e3.pageDict).collectObjects(g2);
            h2.set(d2, t3);
          }
          const r3 = t3?.get(f3);
          if (r3) {
            const e4 = n2.fetch(r3).clone();
            _StructTreeRoot.#te(e4, s3);
            o2.put(r3, { data: e4 });
            continue;
          }
        }
        u2 = Math.max(u2, b2);
        const w2 = n2.getNewTemporaryRef(), x2 = new Dict(n2);
        _StructTreeRoot.#te(x2, s3);
        await this.#ae({ structTreeParent: y2, tagDict: x2, newTagRef: w2, structTreeRootRef: t2, fallbackKids: r2, xref: n2, cache: c2 });
        const S2 = new Dict(n2);
        x2.set("K", S2);
        S2.set("Type", l2);
        p2 && S2.set("Pg", g2);
        S2.set("Obj", m2);
        c2.put(w2, x2);
        i2.push(b2, w2);
      }
    }
    return u2 + 1;
  }
  static #te(e2, { type: t2, title: a2, lang: r2, alt: i2, expanded: n2, actualText: s2 }) {
    e2.set("S", Name.get(t2));
    a2 && e2.set("T", stringToAsciiOrUTF16BE(a2));
    r2 && e2.set("Lang", stringToAsciiOrUTF16BE(r2));
    i2 && e2.set("Alt", stringToAsciiOrUTF16BE(i2));
    n2 && e2.set("E", stringToAsciiOrUTF16BE(n2));
    s2 && e2.set("ActualText", stringToAsciiOrUTF16BE(s2));
  }
  static #ee({ elements: e2, xref: t2, pageDict: a2, numberTree: r2 }) {
    const i2 = /* @__PURE__ */ new Map();
    for (const t3 of e2) if (t3.structTreeParentId) {
      const e3 = parseInt(t3.structTreeParentId.split("_mc")[1], 10);
      let a3 = i2.get(e3);
      if (!a3) {
        a3 = [];
        i2.set(e3, a3);
      }
      a3.push(t3);
    }
    const n2 = a2.get("StructParents");
    if (!Number.isInteger(n2)) return;
    const s2 = r2.get(n2), updateElement = (e3, a3, r3) => {
      const n3 = i2.get(e3);
      if (n3) {
        const e4 = a3.getRaw("P"), i3 = t2.fetchIfRef(e4);
        if (e4 instanceof Ref && i3 instanceof Dict) {
          const e5 = { ref: r3, dict: a3 };
          for (const t3 of n3) t3.structTreeParent = e5;
        }
        return true;
      }
      return false;
    };
    for (const e3 of s2) {
      if (!(e3 instanceof Ref)) continue;
      const a3 = t2.fetch(e3), r3 = a3.get("K");
      if (Number.isInteger(r3)) updateElement(r3, a3, e3);
      else if (Array.isArray(r3)) for (let i3 of r3) {
        i3 = t2.fetchIfRef(i3);
        if (Number.isInteger(i3) && updateElement(i3, a3, e3)) break;
        if (!(i3 instanceof Dict)) continue;
        if (!isName(i3.get("Type"), "MCR")) break;
        const r4 = i3.get("MCID");
        if (Number.isInteger(r4) && updateElement(r4, a3, e3)) break;
      }
    }
  }
  static async #ae({ structTreeParent: e2, tagDict: t2, newTagRef: a2, structTreeRootRef: r2, fallbackKids: i2, xref: n2, cache: s2 }) {
    let o2, c2 = null;
    if (e2) {
      ({ ref: c2 } = e2);
      o2 = e2.dict.getRaw("P") || r2;
    } else o2 = r2;
    t2.set("P", o2);
    const l2 = n2.fetchIfRef(o2);
    if (!l2) {
      i2.push(a2);
      return;
    }
    let h2 = s2.get(o2);
    if (!h2) {
      h2 = l2.clone();
      s2.put(o2, h2);
    }
    const u2 = h2.getRaw("K");
    let d2 = u2 instanceof Ref ? s2.get(u2) : null;
    if (!d2) {
      d2 = n2.fetchIfRef(u2);
      d2 = Array.isArray(d2) ? d2.slice() : [u2];
      const e3 = n2.getNewTemporaryRef();
      h2.set("K", e3);
      s2.put(e3, d2);
    }
    const f2 = d2.indexOf(c2);
    d2.splice(f2 >= 0 ? f2 + 1 : d2.length, 0, a2);
  }
};
var StructElementNode = class {
  constructor(e2, t2) {
    this.tree = e2;
    this.xref = e2.xref;
    this.dict = t2;
    this.kids = [];
    this.parseKids();
  }
  get role() {
    const e2 = this.dict.get("S"), t2 = e2 instanceof Name ? e2.name : "", { root: a2 } = this.tree;
    return a2.roleMap.get(t2) ?? t2;
  }
  parseKids() {
    let e2 = null;
    const t2 = this.dict.getRaw("Pg");
    t2 instanceof Ref && (e2 = t2.toString());
    const a2 = this.dict.get("K");
    if (Array.isArray(a2)) for (const t3 of a2) {
      const a3 = this.parseKid(e2, this.xref.fetchIfRef(t3));
      a3 && this.kids.push(a3);
    }
    else {
      const t3 = this.parseKid(e2, a2);
      t3 && this.kids.push(t3);
    }
  }
  parseKid(e2, t2) {
    if (Number.isInteger(t2)) return this.tree.pageDict.objId !== e2 ? null : new StructElement({ type: zn, mcid: t2, pageObjId: e2 });
    if (!(t2 instanceof Dict)) return null;
    const a2 = t2.getRaw("Pg");
    a2 instanceof Ref && (e2 = a2.toString());
    const r2 = t2.get("Type") instanceof Name ? t2.get("Type").name : null;
    if ("MCR" === r2) {
      if (this.tree.pageDict.objId !== e2) return null;
      const a3 = t2.getRaw("Stm");
      return new StructElement({ type: $n, refObjId: a3 instanceof Ref ? a3.toString() : null, pageObjId: e2, mcid: t2.get("MCID") });
    }
    if ("OBJR" === r2) {
      if (this.tree.pageDict.objId !== e2) return null;
      const a3 = t2.getRaw("Obj");
      return new StructElement({ type: Gn, refObjId: a3 instanceof Ref ? a3.toString() : null, pageObjId: e2 });
    }
    return new StructElement({ type: Kn, dict: t2 });
  }
};
var StructElement = class {
  constructor({ type: e2, dict: t2 = null, mcid: a2 = null, pageObjId: r2 = null, refObjId: i2 = null }) {
    this.type = e2;
    this.dict = t2;
    this.mcid = a2;
    this.pageObjId = r2;
    this.refObjId = i2;
    this.parentNode = null;
  }
};
var StructTreePage = class {
  constructor(e2, t2) {
    this.root = e2;
    this.xref = e2?.xref ?? null;
    this.rootDict = e2?.dict ?? null;
    this.pageDict = t2;
    this.nodes = [];
  }
  collectObjects(e2) {
    if (!(this.root && this.rootDict && e2 instanceof Ref)) return null;
    const t2 = this.rootDict.get("ParentTree");
    if (!t2) return null;
    const a2 = this.root.structParentIds?.get(e2);
    if (!a2) return null;
    const r2 = /* @__PURE__ */ new Map(), i2 = new NumberTree(t2, this.xref);
    for (const [e3] of a2) {
      const t3 = i2.getRaw(e3);
      t3 instanceof Ref && r2.set(e3, t3);
    }
    return r2;
  }
  parse(e2) {
    if (!(this.root && this.rootDict && e2 instanceof Ref)) return;
    const t2 = this.rootDict.get("ParentTree");
    if (!t2) return;
    const a2 = this.pageDict.get("StructParents"), r2 = this.root.structParentIds?.get(e2);
    if (!Number.isInteger(a2) && !r2) return;
    const i2 = /* @__PURE__ */ new Map(), n2 = new NumberTree(t2, this.xref);
    if (Number.isInteger(a2)) {
      const e3 = n2.get(a2);
      if (Array.isArray(e3)) for (const t3 of e3) t3 instanceof Ref && this.addNode(this.xref.fetch(t3), i2);
    }
    if (r2) for (const [e3, t3] of r2) {
      const a3 = n2.get(e3);
      if (a3) {
        const e4 = this.addNode(this.xref.fetchIfRef(a3), i2);
        1 === e4?.kids?.length && e4.kids[0].type === Gn && (e4.kids[0].type = t3);
      }
    }
  }
  addNode(e2, t2, a2 = 0) {
    if (a2 > 40) {
      warn("StructTree MAX_DEPTH reached.");
      return null;
    }
    if (!(e2 instanceof Dict)) return null;
    if (t2.has(e2)) return t2.get(e2);
    const r2 = new StructElementNode(this, e2);
    t2.set(e2, r2);
    const i2 = e2.get("P");
    if (!(i2 instanceof Dict) || isName(i2.get("Type"), "StructTreeRoot")) {
      this.addTopLevelNode(e2, r2) || t2.delete(e2);
      return r2;
    }
    const n2 = this.addNode(i2, t2, a2 + 1);
    if (!n2) return r2;
    let s2 = false;
    for (const t3 of n2.kids) if (t3.type === Kn && t3.dict === e2) {
      t3.parentNode = r2;
      s2 = true;
    }
    s2 || t2.delete(e2);
    return r2;
  }
  addTopLevelNode(e2, t2) {
    const a2 = this.rootDict.get("K");
    if (!a2) return false;
    if (a2 instanceof Dict) {
      if (a2.objId !== e2.objId) return false;
      this.nodes[0] = t2;
      return true;
    }
    if (!Array.isArray(a2)) return true;
    let r2 = false;
    for (let i2 = 0; i2 < a2.length; i2++) {
      const n2 = a2[i2];
      if (n2?.toString() === e2.objId) {
        this.nodes[i2] = t2;
        r2 = true;
      }
    }
    return r2;
  }
  get serializable() {
    function nodeToSerializable(e3, t2, a2 = 0) {
      if (a2 > 40) {
        warn("StructTree too deep to be fully serialized.");
        return;
      }
      const r2 = /* @__PURE__ */ Object.create(null);
      r2.role = e3.role;
      r2.children = [];
      t2.children.push(r2);
      let i2 = e3.dict.get("Alt");
      "string" != typeof i2 && (i2 = e3.dict.get("ActualText"));
      "string" == typeof i2 && (r2.alt = stringToPDFString(i2));
      const n2 = e3.dict.get("A");
      if (n2 instanceof Dict) {
        const e4 = lookupNormalRect(n2.getArray("BBox"), null);
        if (e4) r2.bbox = e4;
        else {
          const e5 = n2.get("Width"), t3 = n2.get("Height");
          "number" == typeof e5 && e5 > 0 && "number" == typeof t3 && t3 > 0 && (r2.bbox = [0, 0, e5, t3]);
        }
      }
      const s2 = e3.dict.get("Lang");
      "string" == typeof s2 && (r2.lang = stringToPDFString(s2));
      for (const t3 of e3.kids) {
        const e4 = t3.type === Kn ? t3.parentNode : null;
        e4 ? nodeToSerializable(e4, r2, a2 + 1) : t3.type === zn || t3.type === $n ? r2.children.push({ type: "content", id: `p${t3.pageObjId}_mc${t3.mcid}` }) : t3.type === Gn ? r2.children.push({ type: "object", id: t3.refObjId }) : t3.type === Vn && r2.children.push({ type: "annotation", id: `pdfjs_internal_id_${t3.refObjId}` });
      }
    }
    const e2 = /* @__PURE__ */ Object.create(null);
    e2.children = [];
    e2.role = "Root";
    for (const t2 of this.nodes) t2 && nodeToSerializable(t2, e2);
    return e2;
  }
};
var Jn = (function _isValidExplicitDest(e2, t2, a2) {
  if (!Array.isArray(a2) || a2.length < 2) return false;
  const [r2, i2, ...n2] = a2;
  if (!e2(r2) && !Number.isInteger(r2)) return false;
  if (!t2(i2)) return false;
  const s2 = n2.length;
  let o2 = true;
  switch (i2.name) {
    case "XYZ":
      if (s2 < 2 || s2 > 3) return false;
      break;
    case "Fit":
    case "FitB":
      return 0 === s2;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (s2 > 1) return false;
      break;
    case "FitR":
      if (4 !== s2) return false;
      o2 = false;
      break;
    default:
      return false;
  }
  for (const e3 of n2) if (!("number" == typeof e3 || o2 && null === e3)) return false;
  return true;
}).bind(null, ((e2) => e2 instanceof Ref), isName);
function fetchDest(e2) {
  e2 instanceof Dict && (e2 = e2.get("D"));
  return Jn(e2) ? e2 : null;
}
function fetchRemoteDest(e2) {
  let t2 = e2.get("D");
  if (t2) {
    t2 instanceof Name && (t2 = t2.name);
    if ("string" == typeof t2) return stringToPDFString(t2, true);
    if (Jn(t2)) return JSON.stringify(t2);
  }
  return null;
}
var Catalog = class _Catalog {
  #re = null;
  #ie = null;
  builtInCMapCache = /* @__PURE__ */ new Map();
  fontCache = new RefSetCache();
  globalColorSpaceCache = new GlobalColorSpaceCache();
  globalImageCache = new GlobalImageCache();
  nonBlendModesSet = new RefSet();
  pageDictCache = new RefSetCache();
  pageIndexCache = new RefSetCache();
  pageKidsCountCache = new RefSetCache();
  standardFontDataCache = /* @__PURE__ */ new Map();
  systemFontCache = /* @__PURE__ */ new Map();
  constructor(e2, t2) {
    this.pdfManager = e2;
    this.xref = t2;
    this.#ie = t2.getCatalogObj();
    if (!(this.#ie instanceof Dict)) throw new FormatError("Catalog object is not a dictionary.");
    this.toplevelPagesDict;
  }
  cloneDict() {
    return this.#ie.clone();
  }
  get version() {
    const e2 = this.#ie.get("Version");
    if (e2 instanceof Name) {
      if (Ca.test(e2.name)) return shadow(this, "version", e2.name);
      warn(`Invalid PDF catalog version: ${e2.name}`);
    }
    return shadow(this, "version", null);
  }
  get lang() {
    const e2 = this.#ie.get("Lang");
    return shadow(this, "lang", e2 && "string" == typeof e2 ? stringToPDFString(e2) : null);
  }
  get needsRendering() {
    const e2 = this.#ie.get("NeedsRendering");
    return shadow(this, "needsRendering", "boolean" == typeof e2 && e2);
  }
  get collection() {
    let e2 = null;
    try {
      const t2 = this.#ie.get("Collection");
      t2 instanceof Dict && t2.size > 0 && (e2 = t2);
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      info("Cannot fetch Collection entry; assuming no collection is present.");
    }
    return shadow(this, "collection", e2);
  }
  get acroForm() {
    let e2 = null;
    try {
      const t2 = this.#ie.get("AcroForm");
      t2 instanceof Dict && t2.size > 0 && (e2 = t2);
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      info("Cannot fetch AcroForm entry; assuming no forms are present.");
    }
    return shadow(this, "acroForm", e2);
  }
  get acroFormRef() {
    const e2 = this.#ie.getRaw("AcroForm");
    return shadow(this, "acroFormRef", e2 instanceof Ref ? e2 : null);
  }
  get metadata() {
    const e2 = this.#ie.getRaw("Metadata");
    if (!(e2 instanceof Ref)) return shadow(this, "metadata", null);
    let t2 = null;
    try {
      const a2 = this.xref.fetch(e2, !this.xref.encrypt?.encryptMetadata);
      if (a2 instanceof BaseStream && a2.dict instanceof Dict) {
        const e3 = a2.dict.get("Type"), r2 = a2.dict.get("Subtype");
        if (isName(e3, "Metadata") && isName(r2, "XML")) {
          const e4 = stringToUTF8String(a2.getString());
          e4 && (t2 = new MetadataParser(e4).serializable);
        }
      }
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      info(`Skipping invalid Metadata: "${e3}".`);
    }
    return shadow(this, "metadata", t2);
  }
  get markInfo() {
    let e2 = null;
    try {
      e2 = this.#ne();
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn("Unable to read mark info.");
    }
    return shadow(this, "markInfo", e2);
  }
  #ne() {
    const e2 = this.#ie.get("MarkInfo");
    if (!(e2 instanceof Dict)) return null;
    const t2 = { Marked: false, UserProperties: false, Suspects: false };
    for (const a2 in t2) {
      const r2 = e2.get(a2);
      "boolean" == typeof r2 && (t2[a2] = r2);
    }
    return t2;
  }
  get structTreeRoot() {
    let e2 = null;
    try {
      e2 = this.#se();
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn("Unable read to structTreeRoot info.");
    }
    return shadow(this, "structTreeRoot", e2);
  }
  #se() {
    const e2 = this.#ie.getRaw("StructTreeRoot"), t2 = this.xref.fetchIfRef(e2);
    if (!(t2 instanceof Dict)) return null;
    const a2 = new StructTreeRoot(this.xref, t2, e2);
    a2.init();
    return a2;
  }
  get toplevelPagesDict() {
    const e2 = this.#ie.get("Pages");
    if (!(e2 instanceof Dict)) throw new FormatError("Invalid top-level pages dictionary.");
    return shadow(this, "toplevelPagesDict", e2);
  }
  get documentOutline() {
    let e2 = null;
    try {
      e2 = this.#oe();
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn("Unable to read document outline.");
    }
    return shadow(this, "documentOutline", e2);
  }
  #oe() {
    let e2 = this.#ie.get("Outlines");
    if (!(e2 instanceof Dict)) return null;
    e2 = e2.getRaw("First");
    if (!(e2 instanceof Ref)) return null;
    const t2 = { items: [] }, a2 = [{ obj: e2, parent: t2 }], r2 = new RefSet();
    r2.put(e2);
    const i2 = this.xref, n2 = new Uint8ClampedArray(3);
    for (; a2.length > 0; ) {
      const t3 = a2.shift(), s2 = i2.fetchIfRef(t3.obj);
      if (null === s2) continue;
      s2.has("Title") || warn("Invalid outline item encountered.");
      const o2 = { url: null, dest: null, action: null };
      _Catalog.parseDestDictionary({ destDict: s2, resultObj: o2, docBaseUrl: this.baseUrl, docAttachments: this.attachments });
      const c2 = s2.get("Title"), l2 = s2.get("F") || 0, h2 = s2.getArray("C"), u2 = s2.get("Count");
      let d2 = n2;
      !isNumberArray(h2, 3) || 0 === h2[0] && 0 === h2[1] && 0 === h2[2] || (d2 = ColorSpaceUtils.rgb.getRgb(h2, 0));
      const f2 = { action: o2.action, attachment: o2.attachment, dest: o2.dest, url: o2.url, unsafeUrl: o2.unsafeUrl, newWindow: o2.newWindow, setOCGState: o2.setOCGState, title: "string" == typeof c2 ? stringToPDFString(c2) : "", color: d2, count: Number.isInteger(u2) ? u2 : void 0, bold: !!(2 & l2), italic: !!(1 & l2), items: [] };
      t3.parent.items.push(f2);
      e2 = s2.getRaw("First");
      if (e2 instanceof Ref && !r2.has(e2)) {
        a2.push({ obj: e2, parent: f2 });
        r2.put(e2);
      }
      e2 = s2.getRaw("Next");
      if (e2 instanceof Ref && !r2.has(e2)) {
        a2.push({ obj: e2, parent: t3.parent });
        r2.put(e2);
      }
    }
    return t2.items.length > 0 ? t2.items : null;
  }
  get permissions() {
    let e2 = null;
    try {
      e2 = this.#ce();
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn("Unable to read permissions.");
    }
    return shadow(this, "permissions", e2);
  }
  #ce() {
    const e2 = this.xref.trailer.get("Encrypt");
    if (!(e2 instanceof Dict)) return null;
    let t2 = e2.get("P");
    if ("number" != typeof t2) return null;
    t2 += 2 ** 32;
    const a2 = [];
    for (const e3 in w) {
      const r2 = w[e3];
      t2 & r2 && a2.push(r2);
    }
    return a2;
  }
  get optionalContentConfig() {
    let e2 = null;
    try {
      const t2 = this.#ie.get("OCProperties");
      if (!t2) return shadow(this, "optionalContentConfig", null);
      const a2 = t2.get("D");
      if (!a2) return shadow(this, "optionalContentConfig", null);
      const r2 = t2.get("OCGs");
      if (!Array.isArray(r2)) return shadow(this, "optionalContentConfig", null);
      const i2 = new RefSetCache();
      for (const e3 of r2) e3 instanceof Ref && !i2.has(e3) && i2.put(e3, this.#le(e3));
      e2 = this.#he(a2, i2);
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn(`Unable to read optional content config: ${e3}`);
    }
    return shadow(this, "optionalContentConfig", e2);
  }
  #le(e2) {
    const t2 = this.xref.fetch(e2), a2 = { id: e2.toString(), name: null, intent: null, usage: { print: null, view: null }, rbGroups: [] }, r2 = t2.get("Name");
    "string" == typeof r2 && (a2.name = stringToPDFString(r2));
    let i2 = t2.getArray("Intent");
    Array.isArray(i2) || (i2 = [i2]);
    i2.every(((e3) => e3 instanceof Name)) && (a2.intent = i2.map(((e3) => e3.name)));
    const n2 = t2.get("Usage");
    if (!(n2 instanceof Dict)) return a2;
    const s2 = a2.usage, o2 = n2.get("Print");
    if (o2 instanceof Dict) {
      const e3 = o2.get("PrintState");
      if (e3 instanceof Name) switch (e3.name) {
        case "ON":
        case "OFF":
          s2.print = { printState: e3.name };
      }
    }
    const c2 = n2.get("View");
    if (c2 instanceof Dict) {
      const e3 = c2.get("ViewState");
      if (e3 instanceof Name) switch (e3.name) {
        case "ON":
        case "OFF":
          s2.view = { viewState: e3.name };
      }
    }
    return a2;
  }
  #he(e2, t2) {
    function parseOnOff(e3) {
      const a3 = [];
      if (Array.isArray(e3)) for (const r3 of e3) r3 instanceof Ref && t2.has(r3) && a3.push(r3.toString());
      return a3;
    }
    function parseOrder(e3, a3 = 0) {
      if (!Array.isArray(e3)) return null;
      const i3 = [];
      for (const n3 of e3) {
        if (n3 instanceof Ref && t2.has(n3)) {
          r2.put(n3);
          i3.push(n3.toString());
          continue;
        }
        const e4 = parseNestedOrder(n3, a3);
        e4 && i3.push(e4);
      }
      if (a3 > 0) return i3;
      const n2 = [];
      for (const [e4] of t2.items()) r2.has(e4) || n2.push(e4.toString());
      n2.length && i3.push({ name: null, order: n2 });
      return i3;
    }
    function parseNestedOrder(e3, t3) {
      if (++t3 > i2) {
        warn("parseNestedOrder - reached MAX_NESTED_LEVELS.");
        return null;
      }
      const r3 = a2.fetchIfRef(e3);
      if (!Array.isArray(r3)) return null;
      const n2 = a2.fetchIfRef(r3[0]);
      if ("string" != typeof n2) return null;
      const s2 = parseOrder(r3.slice(1), t3);
      return s2?.length ? { name: stringToPDFString(n2), order: s2 } : null;
    }
    const a2 = this.xref, r2 = new RefSet(), i2 = 10;
    !(function parseRBGroups(e3) {
      if (Array.isArray(e3)) for (const r3 of e3) {
        const e4 = a2.fetchIfRef(r3);
        if (!Array.isArray(e4) || !e4.length) continue;
        const i3 = /* @__PURE__ */ new Set();
        for (const a3 of e4) if (a3 instanceof Ref && t2.has(a3) && !i3.has(a3.toString())) {
          i3.add(a3.toString());
          t2.get(a3).rbGroups.push(i3);
        }
      }
    })(e2.get("RBGroups"));
    return { name: "string" == typeof e2.get("Name") ? stringToPDFString(e2.get("Name")) : null, creator: "string" == typeof e2.get("Creator") ? stringToPDFString(e2.get("Creator")) : null, baseState: e2.get("BaseState") instanceof Name ? e2.get("BaseState").name : null, on: parseOnOff(e2.get("ON")), off: parseOnOff(e2.get("OFF")), order: parseOrder(e2.get("Order")), groups: [...t2] };
  }
  setActualNumPages(e2 = null) {
    this.#re = e2;
  }
  get hasActualNumPages() {
    return null !== this.#re;
  }
  get _pagesCount() {
    const e2 = this.toplevelPagesDict.get("Count");
    if (!Number.isInteger(e2)) throw new FormatError("Page count in top-level pages dictionary is not an integer.");
    return shadow(this, "_pagesCount", e2);
  }
  get numPages() {
    return this.#re ?? this._pagesCount;
  }
  get destinations() {
    const e2 = this.#ue(), t2 = /* @__PURE__ */ Object.create(null);
    for (const a2 of e2) if (a2 instanceof NameTree) for (const [e3, r2] of a2.getAll()) {
      const a3 = fetchDest(r2);
      a3 && (t2[stringToPDFString(e3, true)] = a3);
    }
    else if (a2 instanceof Dict) for (const [e3, r2] of a2) {
      const a3 = fetchDest(r2);
      a3 && (t2[stringToPDFString(e3, true)] ||= a3);
    }
    return shadow(this, "destinations", t2);
  }
  getDestination(e2) {
    if (this.hasOwnProperty("destinations")) return this.destinations[e2] ?? null;
    const t2 = this.#ue();
    for (const a2 of t2) if (a2 instanceof NameTree || a2 instanceof Dict) {
      const t3 = fetchDest(a2.get(e2));
      if (t3) return t3;
    }
    if (t2.length) {
      const t3 = this.destinations[e2];
      if (t3) return t3;
    }
    return null;
  }
  #ue() {
    const e2 = this.#ie.get("Names"), t2 = [];
    e2?.has("Dests") && t2.push(new NameTree(e2.getRaw("Dests"), this.xref));
    this.#ie.has("Dests") && t2.push(this.#ie.get("Dests"));
    return t2;
  }
  get pageLabels() {
    let e2 = null;
    try {
      e2 = this.#de();
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn("Unable to read page labels.");
    }
    return shadow(this, "pageLabels", e2);
  }
  #de() {
    const e2 = this.#ie.getRaw("PageLabels");
    if (!e2) return null;
    const t2 = new Array(this.numPages);
    let a2 = null, r2 = "";
    const i2 = new NumberTree(e2, this.xref).getAll();
    let n2 = "", s2 = 1;
    for (let e3 = 0, o2 = this.numPages; e3 < o2; e3++) {
      const o3 = i2.get(e3);
      if (void 0 !== o3) {
        if (!(o3 instanceof Dict)) throw new FormatError("PageLabel is not a dictionary.");
        if (o3.has("Type") && !isName(o3.get("Type"), "PageLabel")) throw new FormatError("Invalid type in PageLabel dictionary.");
        if (o3.has("S")) {
          const e4 = o3.get("S");
          if (!(e4 instanceof Name)) throw new FormatError("Invalid style in PageLabel dictionary.");
          a2 = e4.name;
        } else a2 = null;
        if (o3.has("P")) {
          const e4 = o3.get("P");
          if ("string" != typeof e4) throw new FormatError("Invalid prefix in PageLabel dictionary.");
          r2 = stringToPDFString(e4);
        } else r2 = "";
        if (o3.has("St")) {
          const e4 = o3.get("St");
          if (!(Number.isInteger(e4) && e4 >= 1)) throw new FormatError("Invalid start in PageLabel dictionary.");
          s2 = e4;
        } else s2 = 1;
      }
      switch (a2) {
        case "D":
          n2 = s2;
          break;
        case "R":
        case "r":
          n2 = toRomanNumerals(s2, "r" === a2);
          break;
        case "A":
        case "a":
          const e4 = 26, t3 = "a" === a2 ? 97 : 65, r3 = s2 - 1;
          n2 = String.fromCharCode(t3 + r3 % e4).repeat(Math.floor(r3 / e4) + 1);
          break;
        default:
          if (a2) throw new FormatError(`Invalid style "${a2}" in PageLabel dictionary.`);
          n2 = "";
      }
      t2[e3] = r2 + n2;
      s2++;
    }
    return t2;
  }
  get pageLayout() {
    const e2 = this.#ie.get("PageLayout");
    let t2 = "";
    if (e2 instanceof Name) switch (e2.name) {
      case "SinglePage":
      case "OneColumn":
      case "TwoColumnLeft":
      case "TwoColumnRight":
      case "TwoPageLeft":
      case "TwoPageRight":
        t2 = e2.name;
    }
    return shadow(this, "pageLayout", t2);
  }
  get pageMode() {
    const e2 = this.#ie.get("PageMode");
    let t2 = "UseNone";
    if (e2 instanceof Name) switch (e2.name) {
      case "UseNone":
      case "UseOutlines":
      case "UseThumbs":
      case "FullScreen":
      case "UseOC":
      case "UseAttachments":
        t2 = e2.name;
    }
    return shadow(this, "pageMode", t2);
  }
  get viewerPreferences() {
    const e2 = this.#ie.get("ViewerPreferences");
    if (!(e2 instanceof Dict)) return shadow(this, "viewerPreferences", null);
    let t2 = null;
    for (const [a2, r2] of e2) {
      let e3;
      switch (a2) {
        case "HideToolbar":
        case "HideMenubar":
        case "HideWindowUI":
        case "FitWindow":
        case "CenterWindow":
        case "DisplayDocTitle":
        case "PickTrayByPDFSize":
          "boolean" == typeof r2 && (e3 = r2);
          break;
        case "NonFullScreenPageMode":
          if (r2 instanceof Name) switch (r2.name) {
            case "UseNone":
            case "UseOutlines":
            case "UseThumbs":
            case "UseOC":
              e3 = r2.name;
              break;
            default:
              e3 = "UseNone";
          }
          break;
        case "Direction":
          if (r2 instanceof Name) switch (r2.name) {
            case "L2R":
            case "R2L":
              e3 = r2.name;
              break;
            default:
              e3 = "L2R";
          }
          break;
        case "ViewArea":
        case "ViewClip":
        case "PrintArea":
        case "PrintClip":
          if (r2 instanceof Name) switch (r2.name) {
            case "MediaBox":
            case "CropBox":
            case "BleedBox":
            case "TrimBox":
            case "ArtBox":
              e3 = r2.name;
              break;
            default:
              e3 = "CropBox";
          }
          break;
        case "PrintScaling":
          if (r2 instanceof Name) switch (r2.name) {
            case "None":
            case "AppDefault":
              e3 = r2.name;
              break;
            default:
              e3 = "AppDefault";
          }
          break;
        case "Duplex":
          if (r2 instanceof Name) switch (r2.name) {
            case "Simplex":
            case "DuplexFlipShortEdge":
            case "DuplexFlipLongEdge":
              e3 = r2.name;
              break;
            default:
              e3 = "None";
          }
          break;
        case "PrintPageRange":
          if (Array.isArray(r2) && r2.length % 2 == 0) {
            r2.every(((e4, t3, a3) => Number.isInteger(e4) && e4 > 0 && (0 === t3 || e4 >= a3[t3 - 1]) && e4 <= this.numPages)) && (e3 = r2);
          }
          break;
        case "NumCopies":
          Number.isInteger(r2) && r2 > 0 && (e3 = r2);
          break;
        default:
          warn(`Ignoring non-standard key in ViewerPreferences: ${a2}.`);
          continue;
      }
      if (void 0 !== e3) {
        t2 ??= /* @__PURE__ */ Object.create(null);
        t2[a2] = e3;
      } else warn(`Bad value, for key "${a2}", in ViewerPreferences: ${r2}.`);
    }
    return shadow(this, "viewerPreferences", t2);
  }
  get openAction() {
    const e2 = this.#ie.get("OpenAction"), t2 = /* @__PURE__ */ Object.create(null);
    if (e2 instanceof Dict) {
      const a2 = new Dict(this.xref);
      a2.set("A", e2);
      const r2 = { url: null, dest: null, action: null };
      _Catalog.parseDestDictionary({ destDict: a2, resultObj: r2 });
      Array.isArray(r2.dest) ? t2.dest = r2.dest : r2.action && (t2.action = r2.action);
    } else Jn(e2) && (t2.dest = e2);
    return shadow(this, "openAction", objectSize(t2) > 0 ? t2 : null);
  }
  get attachments() {
    const e2 = this.#ie.get("Names");
    let t2 = null;
    if (e2 instanceof Dict && e2.has("EmbeddedFiles")) {
      const a2 = new NameTree(e2.getRaw("EmbeddedFiles"), this.xref);
      for (const [e3, r2] of a2.getAll()) {
        const a3 = new FileSpec(r2, this.xref);
        t2 ??= /* @__PURE__ */ Object.create(null);
        t2[stringToPDFString(e3, true)] = a3.serializable;
      }
    }
    return shadow(this, "attachments", t2);
  }
  get xfaImages() {
    const e2 = this.#ie.get("Names");
    let t2 = null;
    if (e2 instanceof Dict && e2.has("XFAImages")) {
      const a2 = new NameTree(e2.getRaw("XFAImages"), this.xref);
      for (const [e3, r2] of a2.getAll()) if (r2 instanceof BaseStream) {
        t2 ??= /* @__PURE__ */ new Map();
        t2.set(stringToPDFString(e3, true), r2.getBytes());
      }
    }
    return shadow(this, "xfaImages", t2);
  }
  #fe() {
    const e2 = this.#ie.get("Names");
    let t2 = null;
    function appendIfJavaScriptDict(e3, a3) {
      if (!(a3 instanceof Dict)) return;
      if (!isName(a3.get("S"), "JavaScript")) return;
      let r2 = a3.get("JS");
      if (r2 instanceof BaseStream) r2 = r2.getString();
      else if ("string" != typeof r2) return;
      r2 = stringToPDFString(r2, true).replaceAll("\0", "");
      r2 && (t2 ||= /* @__PURE__ */ new Map()).set(e3, r2);
    }
    if (e2 instanceof Dict && e2.has("JavaScript")) {
      const t3 = new NameTree(e2.getRaw("JavaScript"), this.xref);
      for (const [e3, a3] of t3.getAll()) appendIfJavaScriptDict(stringToPDFString(e3, true), a3);
    }
    const a2 = this.#ie.get("OpenAction");
    a2 && appendIfJavaScriptDict("OpenAction", a2);
    return t2;
  }
  get jsActions() {
    const e2 = this.#fe();
    let t2 = collectActions(this.xref, this.#ie, we);
    if (e2) {
      t2 ||= /* @__PURE__ */ Object.create(null);
      for (const [a2, r2] of e2) a2 in t2 ? t2[a2].push(r2) : t2[a2] = [r2];
    }
    return shadow(this, "jsActions", t2);
  }
  async cleanup(e2 = false) {
    clearGlobalCaches();
    this.globalColorSpaceCache.clear();
    this.globalImageCache.clear(e2);
    this.pageKidsCountCache.clear();
    this.pageIndexCache.clear();
    this.pageDictCache.clear();
    this.nonBlendModesSet.clear();
    for (const { dict: e3 } of await Promise.all(this.fontCache)) delete e3.cacheKey;
    this.fontCache.clear();
    this.builtInCMapCache.clear();
    this.standardFontDataCache.clear();
    this.systemFontCache.clear();
  }
  async getPageDict(e2) {
    const t2 = [this.toplevelPagesDict], a2 = new RefSet(), r2 = this.#ie.getRaw("Pages");
    r2 instanceof Ref && a2.put(r2);
    const i2 = this.xref, n2 = this.pageKidsCountCache, s2 = this.pageIndexCache, o2 = this.pageDictCache;
    let c2 = 0;
    for (; t2.length; ) {
      const r3 = t2.pop();
      if (r3 instanceof Ref) {
        const l3 = n2.get(r3);
        if (l3 >= 0 && c2 + l3 <= e2) {
          c2 += l3;
          continue;
        }
        if (a2.has(r3)) throw new FormatError("Pages tree contains circular reference.");
        a2.put(r3);
        const h3 = await (o2.get(r3) || i2.fetchAsync(r3));
        if (h3 instanceof Dict) {
          let t3 = h3.getRaw("Type");
          t3 instanceof Ref && (t3 = await i2.fetchAsync(t3));
          if (isName(t3, "Page") || !h3.has("Kids")) {
            n2.has(r3) || n2.put(r3, 1);
            s2.has(r3) || s2.put(r3, c2);
            if (c2 === e2) return [h3, r3];
            c2++;
            continue;
          }
        }
        t2.push(h3);
        continue;
      }
      if (!(r3 instanceof Dict)) throw new FormatError("Page dictionary kid reference points to wrong type of object.");
      const { objId: l2 } = r3;
      let h2 = r3.getRaw("Count");
      h2 instanceof Ref && (h2 = await i2.fetchAsync(h2));
      if (Number.isInteger(h2) && h2 >= 0) {
        l2 && !n2.has(l2) && n2.put(l2, h2);
        if (c2 + h2 <= e2) {
          c2 += h2;
          continue;
        }
      }
      let u2 = r3.getRaw("Kids");
      u2 instanceof Ref && (u2 = await i2.fetchAsync(u2));
      if (!Array.isArray(u2)) {
        let t3 = r3.getRaw("Type");
        t3 instanceof Ref && (t3 = await i2.fetchAsync(t3));
        if (isName(t3, "Page") || !r3.has("Kids")) {
          if (c2 === e2) return [r3, null];
          c2++;
          continue;
        }
        throw new FormatError("Page dictionary kids object is not an array.");
      }
      for (let e3 = u2.length - 1; e3 >= 0; e3--) {
        const a3 = u2[e3];
        t2.push(a3);
        r3 === this.toplevelPagesDict && a3 instanceof Ref && !o2.has(a3) && o2.put(a3, i2.fetchAsync(a3));
      }
    }
    throw new Error(`Page index ${e2} not found.`);
  }
  async getAllPageDicts(e2 = false) {
    const { ignoreErrors: t2 } = this.pdfManager.evaluatorOptions, a2 = [{ currentNode: this.toplevelPagesDict, posInKids: 0 }], r2 = new RefSet(), i2 = this.#ie.getRaw("Pages");
    i2 instanceof Ref && r2.put(i2);
    const n2 = /* @__PURE__ */ new Map(), s2 = this.xref, o2 = this.pageIndexCache;
    let c2 = 0;
    function addPageDict(e3, t3) {
      t3 && !o2.has(t3) && o2.put(t3, c2);
      n2.set(c2++, [e3, t3]);
    }
    function addPageError(a3) {
      if (a3 instanceof XRefEntryException && !e2) throw a3;
      if (e2 && t2 && 0 === c2) {
        warn(`getAllPageDicts - Skipping invalid first page: "${a3}".`);
        a3 = Dict.empty;
      }
      n2.set(c2++, [a3, null]);
    }
    for (; a2.length > 0; ) {
      const e3 = a2.at(-1), { currentNode: t3, posInKids: i3 } = e3;
      let n3 = t3.getRaw("Kids");
      if (n3 instanceof Ref) try {
        n3 = await s2.fetchAsync(n3);
      } catch (e4) {
        addPageError(e4);
        break;
      }
      if (!Array.isArray(n3)) {
        addPageError(new FormatError("Page dictionary kids object is not an array."));
        break;
      }
      if (i3 >= n3.length) {
        a2.pop();
        continue;
      }
      const o3 = n3[i3];
      let c3;
      if (o3 instanceof Ref) {
        if (r2.has(o3)) {
          addPageError(new FormatError("Pages tree contains circular reference."));
          break;
        }
        r2.put(o3);
        try {
          c3 = await s2.fetchAsync(o3);
        } catch (e4) {
          addPageError(e4);
          break;
        }
      } else c3 = o3;
      if (!(c3 instanceof Dict)) {
        addPageError(new FormatError("Page dictionary kid reference points to wrong type of object."));
        break;
      }
      let l2 = c3.getRaw("Type");
      if (l2 instanceof Ref) try {
        l2 = await s2.fetchAsync(l2);
      } catch (e4) {
        addPageError(e4);
        break;
      }
      isName(l2, "Page") || !c3.has("Kids") ? addPageDict(c3, o3 instanceof Ref ? o3 : null) : a2.push({ currentNode: c3, posInKids: 0 });
      e3.posInKids++;
    }
    return n2;
  }
  getPageIndex(e2) {
    const t2 = this.pageIndexCache.get(e2);
    if (void 0 !== t2) return Promise.resolve(t2);
    const a2 = this.xref;
    let r2 = 0;
    const next = (t3) => (function pagesBeforeRef(t4) {
      let r3, i2 = 0;
      return a2.fetchAsync(t4).then((function(a3) {
        if (isRefsEqual(t4, e2) && !isDict(a3, "Page") && !(a3 instanceof Dict && !a3.has("Type") && a3.has("Contents"))) throw new FormatError("The reference does not point to a /Page dictionary.");
        if (!a3) return null;
        if (!(a3 instanceof Dict)) throw new FormatError("Node must be a dictionary.");
        r3 = a3.getRaw("Parent");
        return a3.getAsync("Parent");
      })).then((function(e3) {
        if (!e3) return null;
        if (!(e3 instanceof Dict)) throw new FormatError("Parent must be a dictionary.");
        return e3.getAsync("Kids");
      })).then((function(e3) {
        if (!e3) return null;
        const n2 = [];
        let s2 = false;
        for (const r4 of e3) {
          if (!(r4 instanceof Ref)) throw new FormatError("Kid must be a reference.");
          if (isRefsEqual(r4, t4)) {
            s2 = true;
            break;
          }
          n2.push(a2.fetchAsync(r4).then((function(e4) {
            if (!(e4 instanceof Dict)) throw new FormatError("Kid node must be a dictionary.");
            e4.has("Count") ? i2 += e4.get("Count") : i2++;
          })));
        }
        if (!s2) throw new FormatError("Kid reference not found in parent's kids.");
        return Promise.all(n2).then((() => [i2, r3]));
      }));
    })(t3).then(((t4) => {
      if (!t4) {
        this.pageIndexCache.put(e2, r2);
        return r2;
      }
      const [a3, i2] = t4;
      r2 += a3;
      return next(i2);
    }));
    return next(e2);
  }
  get baseUrl() {
    const e2 = this.#ie.get("URI");
    if (e2 instanceof Dict) {
      const t2 = e2.get("Base");
      if ("string" == typeof t2) {
        const e3 = createValidAbsoluteUrl(t2, null, { tryConvertEncoding: true });
        if (e3) return shadow(this, "baseUrl", e3.href);
      }
    }
    return shadow(this, "baseUrl", this.pdfManager.docBaseUrl);
  }
  static parseDestDictionary({ destDict: e2, resultObj: t2, docBaseUrl: a2 = null, docAttachments: r2 = null }) {
    if (!(e2 instanceof Dict)) {
      warn("parseDestDictionary: `destDict` must be a dictionary.");
      return;
    }
    let i2, n2, s2 = e2.get("A");
    if (!(s2 instanceof Dict)) if (e2.has("Dest")) s2 = e2.get("Dest");
    else {
      s2 = e2.get("AA");
      s2 instanceof Dict && (s2.has("D") ? s2 = s2.get("D") : s2.has("U") && (s2 = s2.get("U")));
    }
    if (s2 instanceof Dict) {
      const e3 = s2.get("S");
      if (!(e3 instanceof Name)) {
        warn("parseDestDictionary: Invalid type in Action dictionary.");
        return;
      }
      const a3 = e3.name;
      switch (a3) {
        case "ResetForm":
          const e4 = s2.get("Flags"), o2 = !(1 & ("number" == typeof e4 ? e4 : 0)), c2 = [], l2 = [];
          for (const e5 of s2.get("Fields") || []) e5 instanceof Ref ? l2.push(e5.toString()) : "string" == typeof e5 && c2.push(stringToPDFString(e5));
          t2.resetForm = { fields: c2, refs: l2, include: o2 };
          break;
        case "URI":
          i2 = s2.get("URI");
          i2 instanceof Name && (i2 = "/" + i2.name);
          break;
        case "GoTo":
          n2 = s2.get("D");
          break;
        case "Launch":
        case "GoToR":
          const h2 = s2.get("F");
          if (h2 instanceof Dict) {
            const e5 = new FileSpec(h2, null, true), { rawFilename: t3 } = e5.serializable;
            i2 = t3;
          } else "string" == typeof h2 && (i2 = h2);
          const u2 = fetchRemoteDest(s2);
          u2 && "string" == typeof i2 && (i2 = i2.split("#", 1)[0] + "#" + u2);
          const d2 = s2.get("NewWindow");
          "boolean" == typeof d2 && (t2.newWindow = d2);
          break;
        case "GoToE":
          const f2 = s2.get("T");
          let g2;
          if (r2 && f2 instanceof Dict) {
            const e5 = f2.get("R"), t3 = f2.get("N");
            isName(e5, "C") && "string" == typeof t3 && (g2 = r2[stringToPDFString(t3, true)]);
          }
          if (g2) {
            t2.attachment = g2;
            const e5 = fetchRemoteDest(s2);
            e5 && (t2.attachmentDest = e5);
          } else warn('parseDestDictionary - unimplemented "GoToE" action.');
          break;
        case "Named":
          const p2 = s2.get("N");
          p2 instanceof Name && (t2.action = p2.name);
          break;
        case "SetOCGState":
          const m2 = s2.get("State"), b2 = s2.get("PreserveRB");
          if (!Array.isArray(m2) || 0 === m2.length) break;
          const y2 = [];
          for (const e5 of m2) if (e5 instanceof Name) switch (e5.name) {
            case "ON":
            case "OFF":
            case "Toggle":
              y2.push(e5.name);
          }
          else e5 instanceof Ref && y2.push(e5.toString());
          if (y2.length !== m2.length) break;
          t2.setOCGState = { state: y2, preserveRB: "boolean" != typeof b2 || b2 };
          break;
        case "JavaScript":
          const w2 = s2.get("JS");
          let x2;
          w2 instanceof BaseStream ? x2 = w2.getString() : "string" == typeof w2 && (x2 = w2);
          const S2 = x2 && recoverJsURL(stringToPDFString(x2, true));
          if (S2) {
            i2 = S2.url;
            t2.newWindow = S2.newWindow;
            break;
          }
        default:
          if ("JavaScript" === a3 || "SubmitForm" === a3) break;
          warn(`parseDestDictionary - unsupported action: "${a3}".`);
      }
    } else e2.has("Dest") && (n2 = e2.get("Dest"));
    if ("string" == typeof i2) {
      const e3 = createValidAbsoluteUrl(i2, a2, { addDefaultProtocol: true, tryConvertEncoding: true });
      e3 && (t2.url = e3.href);
      t2.unsafeUrl = i2;
    }
    if (n2) {
      n2 instanceof Name && (n2 = n2.name);
      "string" == typeof n2 ? t2.dest = stringToPDFString(n2, true) : Jn(n2) && (t2.dest = n2);
    }
  }
};
function addChildren(e2, t2) {
  if (e2 instanceof Dict) e2 = e2.getRawValues();
  else if (e2 instanceof BaseStream) e2 = e2.dict.getRawValues();
  else if (!Array.isArray(e2)) return;
  for (const r2 of e2) ((a2 = r2) instanceof Ref || a2 instanceof Dict || a2 instanceof BaseStream || Array.isArray(a2)) && t2.push(r2);
  var a2;
}
var ObjectLoader = class _ObjectLoader {
  refSet = new RefSet();
  constructor(e2, t2, a2) {
    this.dict = e2;
    this.keys = t2;
    this.xref = a2;
  }
  async load() {
    const { keys: e2, dict: t2 } = this, a2 = [];
    for (const r2 of e2) {
      const e3 = t2.getRaw(r2);
      void 0 !== e3 && a2.push(e3);
    }
    await this.#ge(a2);
    this.refSet = null;
  }
  async #ge(e2) {
    const t2 = [], a2 = [];
    for (; e2.length; ) {
      let r2 = e2.pop();
      if (r2 instanceof Ref) {
        if (this.refSet.has(r2)) continue;
        try {
          this.refSet.put(r2);
          r2 = this.xref.fetch(r2);
        } catch (e3) {
          if (!(e3 instanceof MissingDataException)) {
            warn(`ObjectLoader.#walk - requesting all data: "${e3}".`);
            await this.xref.stream.manager.requestAllChunks();
            return;
          }
          t2.push(r2);
          a2.push({ begin: e3.begin, end: e3.end });
        }
      }
      if (r2 instanceof BaseStream) {
        const e3 = r2.getBaseStreams();
        if (e3) {
          let i2 = false;
          for (const t3 of e3) if (!t3.isDataLoaded) {
            i2 = true;
            a2.push({ begin: t3.start, end: t3.end });
          }
          i2 && t2.push(r2);
        }
      }
      addChildren(r2, e2);
    }
    if (a2.length) {
      await this.xref.stream.manager.requestRanges(a2);
      for (const e3 of t2) e3 instanceof Ref && this.refSet.remove(e3);
      await this.#ge(t2);
    }
  }
  static async load(e2, t2, a2) {
    if (a2.stream.isDataLoaded) return;
    const r2 = new _ObjectLoader(e2, t2, a2);
    await r2.load();
  }
};
var Yn = Symbol();
var Zn = Symbol();
var Qn = Symbol();
var es = Symbol();
var ts = Symbol();
var as = Symbol();
var rs = Symbol();
var is = Symbol();
var ns = Symbol();
var ss = Symbol("content");
var os = Symbol("data");
var cs = Symbol();
var ls = Symbol("extra");
var hs = Symbol();
var us = Symbol();
var ds = Symbol();
var fs = Symbol();
var gs = Symbol();
var ps = Symbol();
var ms = Symbol();
var bs = Symbol();
var ys = Symbol();
var ws = Symbol();
var xs = Symbol();
var Ss = Symbol();
var As = Symbol();
var ks = Symbol();
var Cs = Symbol();
var vs = Symbol();
var Fs = Symbol();
var Is = Symbol();
var Ts = Symbol();
var Os = Symbol();
var Ms = Symbol();
var Ds = Symbol();
var Bs = Symbol();
var Rs = Symbol();
var Ns = Symbol();
var Es = Symbol();
var Ls = Symbol();
var js = Symbol();
var _s = Symbol();
var Us = Symbol();
var Xs = Symbol();
var qs = Symbol();
var Hs = Symbol("namespaceId");
var Ws = Symbol("nodeName");
var zs = Symbol();
var $s = Symbol();
var Gs = Symbol();
var Vs = Symbol();
var Ks = Symbol();
var Js = Symbol();
var Ys = Symbol();
var Zs = Symbol();
var Qs = Symbol("root");
var eo = Symbol();
var to = Symbol();
var ao = Symbol();
var ro = Symbol();
var io = Symbol();
var no = Symbol();
var so = Symbol();
var oo = Symbol();
var co = Symbol();
var lo = Symbol();
var ho = Symbol();
var uo = Symbol("uid");
var fo = Symbol();
var go = { config: { id: 0, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xci/") }, connectionSet: { id: 1, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-connection-set/") }, datasets: { id: 2, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-data/") }, form: { id: 3, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-form/") }, localeSet: { id: 4, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-locale-set/") }, pdf: { id: 5, check: (e2) => "http://ns.adobe.com/xdp/pdf/" === e2 }, signature: { id: 6, check: (e2) => "http://www.w3.org/2000/09/xmldsig#" === e2 }, sourceSet: { id: 7, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-source-set/") }, stylesheet: { id: 8, check: (e2) => "http://www.w3.org/1999/XSL/Transform" === e2 }, template: { id: 9, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-template/") }, xdc: { id: 10, check: (e2) => e2.startsWith("http://www.xfa.org/schema/xdc/") }, xdp: { id: 11, check: (e2) => "http://ns.adobe.com/xdp/" === e2 }, xfdf: { id: 12, check: (e2) => "http://ns.adobe.com/xfdf/" === e2 }, xhtml: { id: 13, check: (e2) => "http://www.w3.org/1999/xhtml" === e2 }, xmpmeta: { id: 14, check: (e2) => "http://ns.adobe.com/xmpmeta/" === e2 } };
var po = { pt: (e2) => e2, cm: (e2) => e2 / 2.54 * 72, mm: (e2) => e2 / 25.4 * 72, in: (e2) => 72 * e2, px: (e2) => e2 };
var mo = /([+-]?\d+\.?\d*)(.*)/;
function stripQuotes(e2) {
  return e2.startsWith("'") || e2.startsWith('"') ? e2.slice(1, -1) : e2;
}
function getInteger({ data: e2, defaultValue: t2, validate: a2 }) {
  if (!e2) return t2;
  e2 = e2.trim();
  const r2 = parseInt(e2, 10);
  return !isNaN(r2) && a2(r2) ? r2 : t2;
}
function getFloat({ data: e2, defaultValue: t2, validate: a2 }) {
  if (!e2) return t2;
  e2 = e2.trim();
  const r2 = parseFloat(e2);
  return !isNaN(r2) && a2(r2) ? r2 : t2;
}
function getKeyword({ data: e2, defaultValue: t2, validate: a2 }) {
  return e2 && a2(e2 = e2.trim()) ? e2 : t2;
}
function getStringOption(e2, t2) {
  return getKeyword({ data: e2, defaultValue: t2[0], validate: (e3) => t2.includes(e3) });
}
function getMeasurement(e2, t2 = "0") {
  t2 ||= "0";
  if (!e2) return getMeasurement(t2);
  const a2 = e2.trim().match(mo);
  if (!a2) return getMeasurement(t2);
  const [, r2, i2] = a2, n2 = parseFloat(r2);
  if (isNaN(n2)) return getMeasurement(t2);
  if (0 === n2) return 0;
  const s2 = po[i2];
  return s2 ? s2(n2) : n2;
}
function getRatio(e2) {
  if (!e2) return { num: 1, den: 1 };
  const t2 = e2.split(":", 2).map(((e3) => parseFloat(e3.trim()))).filter(((e3) => !isNaN(e3)));
  1 === t2.length && t2.push(1);
  if (0 === t2.length) return { num: 1, den: 1 };
  const [a2, r2] = t2;
  return { num: a2, den: r2 };
}
function getRelevant(e2) {
  return e2 ? e2.trim().split(/\s+/).map(((e3) => ({ excluded: "-" === e3[0], viewname: e3.substring(1) }))) : [];
}
var HTMLResult = class _HTMLResult {
  static get FAILURE() {
    return shadow(this, "FAILURE", new _HTMLResult(false, null, null, null));
  }
  static get EMPTY() {
    return shadow(this, "EMPTY", new _HTMLResult(true, null, null, null));
  }
  constructor(e2, t2, a2, r2) {
    this.success = e2;
    this.html = t2;
    this.bbox = a2;
    this.breakNode = r2;
  }
  isBreak() {
    return !!this.breakNode;
  }
  static breakNode(e2) {
    return new _HTMLResult(false, null, null, e2);
  }
  static success(e2, t2 = null) {
    return new _HTMLResult(true, e2, t2, null);
  }
};
var FontFinder = class {
  constructor(e2) {
    this.fonts = /* @__PURE__ */ new Map();
    this.cache = /* @__PURE__ */ new Map();
    this.warned = /* @__PURE__ */ new Set();
    this.defaultFont = null;
    this.add(e2);
  }
  add(e2, t2 = null) {
    for (const t3 of e2) this.addPdfFont(t3);
    for (const e3 of this.fonts.values()) e3.regular || (e3.regular = e3.italic || e3.bold || e3.bolditalic);
    if (!t2 || 0 === t2.size) return;
    const a2 = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
    for (const e3 of t2) this.fonts.set(e3, a2);
  }
  addPdfFont(e2) {
    const t2 = e2.cssFontInfo, a2 = t2.fontFamily;
    let r2 = this.fonts.get(a2);
    if (!r2) {
      r2 = /* @__PURE__ */ Object.create(null);
      this.fonts.set(a2, r2);
      this.defaultFont || (this.defaultFont = r2);
    }
    let i2 = "";
    const n2 = parseFloat(t2.fontWeight);
    0 !== parseFloat(t2.italicAngle) ? i2 = n2 >= 700 ? "bolditalic" : "italic" : n2 >= 700 && (i2 = "bold");
    if (!i2) {
      (e2.name.includes("Bold") || e2.psName?.includes("Bold")) && (i2 = "bold");
      (e2.name.includes("Italic") || e2.name.endsWith("It") || e2.psName?.includes("Italic") || e2.psName?.endsWith("It")) && (i2 += "italic");
    }
    i2 || (i2 = "regular");
    r2[i2] = e2;
  }
  getDefault() {
    return this.defaultFont;
  }
  find(e2, t2 = true) {
    let a2 = this.fonts.get(e2) || this.cache.get(e2);
    if (a2) return a2;
    const r2 = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
    let i2 = e2.replaceAll(r2, "");
    a2 = this.fonts.get(i2);
    if (a2) {
      this.cache.set(e2, a2);
      return a2;
    }
    i2 = i2.toLowerCase();
    const n2 = [];
    for (const [e3, t3] of this.fonts.entries()) e3.replaceAll(r2, "").toLowerCase().startsWith(i2) && n2.push(t3);
    if (0 === n2.length) for (const [, e3] of this.fonts.entries()) e3.regular.name?.replaceAll(r2, "").toLowerCase().startsWith(i2) && n2.push(e3);
    if (0 === n2.length) {
      i2 = i2.replaceAll(/psmt|mt/gi, "");
      for (const [e3, t3] of this.fonts.entries()) e3.replaceAll(r2, "").toLowerCase().startsWith(i2) && n2.push(t3);
    }
    if (0 === n2.length) for (const e3 of this.fonts.values()) e3.regular.name?.replaceAll(r2, "").toLowerCase().startsWith(i2) && n2.push(e3);
    if (n2.length >= 1) {
      1 !== n2.length && t2 && warn(`XFA - Too many choices to guess the correct font: ${e2}`);
      this.cache.set(e2, n2[0]);
      return n2[0];
    }
    if (t2 && !this.warned.has(e2)) {
      this.warned.add(e2);
      warn(`XFA - Cannot find the font: ${e2}`);
    }
    return null;
  }
};
function selectFont(e2, t2) {
  return "italic" === e2.posture ? "bold" === e2.weight ? t2.bolditalic : t2.italic : "bold" === e2.weight ? t2.bold : t2.regular;
}
var FontInfo = class {
  constructor(e2, t2, a2, r2) {
    this.lineHeight = a2;
    this.paraMargin = t2 || { top: 0, bottom: 0, left: 0, right: 0 };
    if (!e2) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(r2);
      return;
    }
    this.xfaFont = { typeface: e2.typeface, posture: e2.posture, weight: e2.weight, size: e2.size, letterSpacing: e2.letterSpacing };
    const i2 = r2.find(e2.typeface);
    if (i2) {
      this.pdfFont = selectFont(e2, i2);
      this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(r2));
    } else [this.pdfFont, this.xfaFont] = this.defaultFont(r2);
  }
  defaultFont(e2) {
    const t2 = e2.find("Helvetica", false) || e2.find("Myriad Pro", false) || e2.find("Arial", false) || e2.getDefault();
    if (t2?.regular) {
      const e3 = t2.regular;
      return [e3, { typeface: e3.cssFontInfo.fontFamily, posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
    }
    return [null, { typeface: "Courier", posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
  }
};
var FontSelector = class {
  constructor(e2, t2, a2, r2) {
    this.fontFinder = r2;
    this.stack = [new FontInfo(e2, t2, a2, r2)];
  }
  pushData(e2, t2, a2) {
    const r2 = this.stack.at(-1);
    for (const t3 of ["typeface", "posture", "weight", "size", "letterSpacing"]) e2[t3] || (e2[t3] = r2.xfaFont[t3]);
    for (const e3 of ["top", "bottom", "left", "right"]) isNaN(t2[e3]) && (t2[e3] = r2.paraMargin[e3]);
    const i2 = new FontInfo(e2, t2, a2 || r2.lineHeight, this.fontFinder);
    i2.pdfFont || (i2.pdfFont = r2.pdfFont);
    this.stack.push(i2);
  }
  popFont() {
    this.stack.pop();
  }
  topFont() {
    return this.stack.at(-1);
  }
};
var TextMeasure = class {
  constructor(e2, t2, a2, r2) {
    this.glyphs = [];
    this.fontSelector = new FontSelector(e2, t2, a2, r2);
    this.extraHeight = 0;
  }
  pushData(e2, t2, a2) {
    this.fontSelector.pushData(e2, t2, a2);
  }
  popFont(e2) {
    return this.fontSelector.popFont();
  }
  addPara() {
    const e2 = this.fontSelector.topFont();
    this.extraHeight += e2.paraMargin.top + e2.paraMargin.bottom;
  }
  addString(e2) {
    if (!e2) return;
    const t2 = this.fontSelector.topFont(), a2 = t2.xfaFont.size;
    if (t2.pdfFont) {
      const r2 = t2.xfaFont.letterSpacing, i2 = t2.pdfFont, n2 = i2.lineHeight || 1.2, s2 = t2.lineHeight || Math.max(1.2, n2) * a2, o2 = n2 - (void 0 === i2.lineGap ? 0.2 : i2.lineGap), c2 = Math.max(1, o2) * a2, l2 = a2 / 1e3, h2 = i2.defaultWidth || i2.charsToGlyphs(" ")[0].width;
      for (const t3 of e2.split(/[\u2029\n]/)) {
        const e3 = i2.encodeString(t3).join(""), a3 = i2.charsToGlyphs(e3);
        for (const e4 of a3) {
          const t4 = e4.width || h2;
          this.glyphs.push([t4 * l2 + r2, s2, c2, e4.unicode, false]);
        }
        this.glyphs.push([0, 0, 0, "\n", true]);
      }
      this.glyphs.pop();
    } else {
      for (const t3 of e2.split(/[\u2029\n]/)) {
        for (const e3 of t3.split("")) this.glyphs.push([a2, 1.2 * a2, a2, e3, false]);
        this.glyphs.push([0, 0, 0, "\n", true]);
      }
      this.glyphs.pop();
    }
  }
  compute(e2) {
    let t2 = -1, a2 = 0, r2 = 0, i2 = 0, n2 = 0, s2 = 0, o2 = false, c2 = true;
    for (let l2 = 0, h2 = this.glyphs.length; l2 < h2; l2++) {
      const [h3, u2, d2, f2, g2] = this.glyphs[l2], p2 = " " === f2, m2 = c2 ? d2 : u2;
      if (g2) {
        r2 = Math.max(r2, n2);
        n2 = 0;
        i2 += s2;
        s2 = m2;
        t2 = -1;
        a2 = 0;
        c2 = false;
      } else if (p2) if (n2 + h3 > e2) {
        r2 = Math.max(r2, n2);
        n2 = 0;
        i2 += s2;
        s2 = m2;
        t2 = -1;
        a2 = 0;
        o2 = true;
        c2 = false;
      } else {
        s2 = Math.max(m2, s2);
        a2 = n2;
        n2 += h3;
        t2 = l2;
      }
      else if (n2 + h3 > e2) {
        i2 += s2;
        s2 = m2;
        if (-1 !== t2) {
          l2 = t2;
          r2 = Math.max(r2, a2);
          n2 = 0;
          t2 = -1;
          a2 = 0;
        } else {
          r2 = Math.max(r2, n2);
          n2 = h3;
        }
        o2 = true;
        c2 = false;
      } else {
        n2 += h3;
        s2 = Math.max(m2, s2);
      }
    }
    r2 = Math.max(r2, n2);
    i2 += s2 + this.extraHeight;
    return { width: 1.02 * r2, height: i2, isBroken: o2 };
  }
};
var bo = /^[^.[]+/;
var yo = /^[^\]]+/;
var wo = 0;
var xo = 1;
var So = 2;
var Ao = 3;
var ko = 4;
var Co = /* @__PURE__ */ new Map([["$data", (e2, t2) => e2.datasets ? e2.datasets.data : e2], ["$record", (e2, t2) => (e2.datasets ? e2.datasets.data : e2)[Ss]()[0]], ["$template", (e2, t2) => e2.template], ["$connectionSet", (e2, t2) => e2.connectionSet], ["$form", (e2, t2) => e2.form], ["$layout", (e2, t2) => e2.layout], ["$host", (e2, t2) => e2.host], ["$dataWindow", (e2, t2) => e2.dataWindow], ["$event", (e2, t2) => e2.event], ["!", (e2, t2) => e2.datasets], ["$xfa", (e2, t2) => e2], ["xfa", (e2, t2) => e2], ["$", (e2, t2) => t2]]);
var vo = /* @__PURE__ */ new WeakMap();
function parseExpression(e2, t2, a2 = true) {
  let r2 = e2.match(bo);
  if (!r2) return null;
  let [i2] = r2;
  const n2 = [{ name: i2, cacheName: "." + i2, index: 0, js: null, formCalc: null, operator: wo }];
  let s2 = i2.length;
  for (; s2 < e2.length; ) {
    const c2 = s2;
    if ("[" === e2.charAt(s2++)) {
      r2 = e2.slice(s2).match(yo);
      if (!r2) {
        warn("XFA - Invalid index in SOM expression");
        return null;
      }
      n2.at(-1).index = "*" === (o2 = (o2 = r2[0]).trim()) ? 1 / 0 : parseInt(o2, 10) || 0;
      s2 += r2[0].length + 1;
      continue;
    }
    let l2;
    switch (e2.charAt(s2)) {
      case ".":
        if (!t2) return null;
        s2++;
        l2 = xo;
        break;
      case "#":
        s2++;
        l2 = So;
        break;
      case "[":
        if (a2) {
          warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
          return null;
        }
        l2 = Ao;
        break;
      case "(":
        if (a2) {
          warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
          return null;
        }
        l2 = ko;
        break;
      default:
        l2 = wo;
    }
    r2 = e2.slice(s2).match(bo);
    if (!r2) break;
    [i2] = r2;
    s2 += i2.length;
    n2.push({ name: i2, cacheName: e2.slice(c2, s2), operator: l2, index: 0, js: null, formCalc: null });
  }
  var o2;
  return n2;
}
function searchNode(e2, t2, a2, r2 = true, i2 = true) {
  const n2 = parseExpression(a2, r2);
  if (!n2) return null;
  const s2 = Co.get(n2[0].name);
  let o2, c2 = 0;
  if (s2) {
    o2 = true;
    e2 = [s2(e2, t2)];
    c2 = 1;
  } else {
    o2 = null === t2;
    e2 = [t2 || e2];
  }
  for (let a3 = n2.length; c2 < a3; c2++) {
    const { name: a4, cacheName: r3, operator: s3, index: l2 } = n2[c2], h2 = [];
    for (const t3 of e2) {
      if (!t3.isXFAObject) continue;
      let e3, n3;
      if (i2) {
        n3 = vo.get(t3);
        if (!n3) {
          n3 = /* @__PURE__ */ new Map();
          vo.set(t3, n3);
        }
        e3 = n3.get(r3);
      }
      if (!e3) {
        switch (s3) {
          case wo:
            e3 = t3[ms](a4, false);
            break;
          case xo:
            e3 = t3[ms](a4, true);
            break;
          case So:
            e3 = t3[ps](a4);
            e3 = e3.isXFAObjectArray ? e3.children : [e3];
        }
        i2 && n3.set(r3, e3);
      }
      e3.length > 0 && h2.push(e3);
    }
    if (0 !== h2.length || o2 || 0 !== c2) e2 = isFinite(l2) ? h2.filter(((e3) => l2 < e3.length)).map(((e3) => e3[l2])) : h2.flat();
    else {
      const a5 = t2[vs]();
      if (!(t2 = a5)) return null;
      c2 = -1;
      e2 = [t2];
    }
  }
  return 0 === e2.length ? null : e2;
}
function createDataNode(e2, t2, a2) {
  const r2 = parseExpression(a2);
  if (!r2) return null;
  if (r2.some(((e3) => e3.operator === xo))) return null;
  const i2 = Co.get(r2[0].name);
  let n2 = 0;
  if (i2) {
    e2 = i2(e2, t2);
    n2 = 1;
  } else e2 = t2 || e2;
  for (let t3 = r2.length; n2 < t3; n2++) {
    const { name: t4, operator: a3, index: i3 } = r2[n2];
    if (!isFinite(i3)) {
      r2[n2].index = 0;
      return e2.createNodes(r2.slice(n2));
    }
    let s2;
    switch (a3) {
      case wo:
        s2 = e2[ms](t4, false);
        break;
      case xo:
        s2 = e2[ms](t4, true);
        break;
      case So:
        s2 = e2[ps](t4);
        s2 = s2.isXFAObjectArray ? s2.children : [s2];
    }
    if (0 === s2.length) return e2.createNodes(r2.slice(n2));
    if (!(i3 < s2.length)) {
      r2[n2].index = i3 - s2.length;
      return e2.createNodes(r2.slice(n2));
    }
    {
      const t5 = s2[i3];
      if (!t5.isXFAObject) {
        warn("XFA - Cannot create a node.");
        return null;
      }
      e2 = t5;
    }
  }
  return null;
}
var Fo = Symbol();
var Io = Symbol();
var Oo = Symbol();
var Mo = Symbol("_children");
var Do = Symbol();
var Bo = Symbol();
var Ro = Symbol();
var No = Symbol();
var Eo = Symbol();
var Po = Symbol();
var Lo = Symbol();
var jo = Symbol();
var _o = Symbol();
var Uo = Symbol("parent");
var Xo = Symbol();
var qo = Symbol();
var Ho = Symbol();
var Wo = 0;
var zo = go.datasets.id;
var XFAObject = class _XFAObject {
  constructor(e2, t2, a2 = false) {
    this[Hs] = e2;
    this[Ws] = t2;
    this[Lo] = a2;
    this[Uo] = null;
    this[Mo] = [];
    this[uo] = `${t2}${Wo++}`;
    this[Is] = null;
  }
  get isXFAObject() {
    return true;
  }
  get isXFAObjectArray() {
    return false;
  }
  createNodes(e2) {
    let t2 = this, a2 = null;
    for (const { name: r2, index: i2 } of e2) {
      for (let e3 = 0, n2 = isFinite(i2) ? i2 : 0; e3 <= n2; e3++) {
        const e4 = t2[Hs] === zo ? -1 : t2[Hs];
        a2 = new XmlObject(e4, r2);
        t2[Qn](a2);
      }
      t2 = a2;
    }
    return a2;
  }
  [$s](e2) {
    if (!this[Lo] || !this[Gs](e2)) return false;
    const t2 = e2[Ws], a2 = this[t2];
    if (!(a2 instanceof XFAObjectArray)) {
      null !== a2 && this[Zs](a2);
      this[t2] = e2;
      this[Qn](e2);
      return true;
    }
    if (a2.push(e2)) {
      this[Qn](e2);
      return true;
    }
    let r2 = "";
    this.id ? r2 = ` (id: ${this.id})` : this.name && (r2 = ` (name: ${this.name} ${this.h.value})`);
    warn(`XFA - node "${this[Ws]}"${r2} has already enough "${t2}"!`);
    return false;
  }
  [Gs](e2) {
    return this.hasOwnProperty(e2[Ws]) && e2[Hs] === this[Hs];
  }
  [Ls]() {
    return false;
  }
  [Yn]() {
    return false;
  }
  [Bs]() {
    return false;
  }
  [Rs]() {
    return false;
  }
  [Js]() {
    this.para && this[Fs]()[ls].paraStack.pop();
  }
  [Ys]() {
    this[Fs]()[ls].paraStack.push(this.para);
  }
  [ao](e2) {
    this.id && this[Hs] === go.template.id && e2.set(this.id, this);
  }
  [Fs]() {
    return this[Is].template;
  }
  [js]() {
    return false;
  }
  [_s]() {
    return false;
  }
  [Qn](e2) {
    e2[Uo] = this;
    this[Mo].push(e2);
    !e2[Is] && this[Is] && (e2[Is] = this[Is]);
  }
  [Zs](e2) {
    const t2 = this[Mo].indexOf(e2);
    this[Mo].splice(t2, 1);
  }
  [Ts]() {
    return this.hasOwnProperty("value");
  }
  [io](e2) {
  }
  [Vs](e2) {
  }
  [hs]() {
  }
  [ts](e2) {
    delete this[Lo];
    if (this[rs]) {
      e2.clean(this[rs]);
      delete this[rs];
    }
  }
  [Ms](e2) {
    return this[Mo].indexOf(e2);
  }
  [Ds](e2, t2) {
    t2[Uo] = this;
    this[Mo].splice(e2, 0, t2);
    !t2[Is] && this[Is] && (t2[Is] = this[Is]);
  }
  [Us]() {
    return !this.name;
  }
  [qs]() {
    return "";
  }
  [so]() {
    return 0 === this[Mo].length ? this[ss] : this[Mo].map(((e2) => e2[so]())).join("");
  }
  get [Oo]() {
    const e2 = Object.getPrototypeOf(this);
    if (!e2._attributes) {
      const t2 = e2._attributes = /* @__PURE__ */ new Set();
      for (const e3 of Object.getOwnPropertyNames(this)) {
        if (null === this[e3] || this[e3] instanceof _XFAObject || this[e3] instanceof XFAObjectArray) break;
        t2.add(e3);
      }
    }
    return shadow(this, Oo, e2._attributes);
  }
  [Es](e2) {
    let t2 = this;
    for (; t2; ) {
      if (t2 === e2) return true;
      t2 = t2[vs]();
    }
    return false;
  }
  [vs]() {
    return this[Uo];
  }
  [Cs]() {
    return this[vs]();
  }
  [Ss](e2 = null) {
    return e2 ? this[e2] : this[Mo];
  }
  [cs]() {
    const e2 = /* @__PURE__ */ Object.create(null);
    this[ss] && (e2.$content = this[ss]);
    for (const t2 of Object.getOwnPropertyNames(this)) {
      const a2 = this[t2];
      null !== a2 && (a2 instanceof _XFAObject ? e2[t2] = a2[cs]() : a2 instanceof XFAObjectArray ? a2.isEmpty() || (e2[t2] = a2.dump()) : e2[t2] = a2);
    }
    return e2;
  }
  [ho]() {
    return null;
  }
  [co]() {
    return HTMLResult.EMPTY;
  }
  *[As]() {
    for (const e2 of this[Ss]()) yield e2;
  }
  *[No](e2, t2) {
    for (const a2 of this[As]()) if (!e2 || t2 === e2.has(a2[Ws])) {
      const e3 = this[gs](), t3 = a2[co](e3);
      t3.success || (this[ls].failingNode = a2);
      yield t3;
    }
  }
  [us]() {
    return null;
  }
  [Zn](e2, t2) {
    this[ls].children.push(e2);
  }
  [gs]() {
  }
  [es]({ filter: e2 = null, include: t2 = true }) {
    if (this[ls].generator) {
      const e3 = this[gs](), t3 = this[ls].failingNode[co](e3);
      if (!t3.success) return t3;
      t3.html && this[Zn](t3.html, t3.bbox);
      delete this[ls].failingNode;
    } else this[ls].generator = this[No](e2, t2);
    for (; ; ) {
      const e3 = this[ls].generator.next();
      if (e3.done) break;
      const t3 = e3.value;
      if (!t3.success) return t3;
      t3.html && this[Zn](t3.html, t3.bbox);
    }
    this[ls].generator = null;
    return HTMLResult.EMPTY;
  }
  [ro](e2) {
    this[qo] = new Set(Object.keys(e2));
  }
  [Po](e2) {
    const t2 = this[Oo], a2 = this[qo];
    return [...e2].filter(((e3) => t2.has(e3) && !a2.has(e3)));
  }
  [eo](e2, t2 = /* @__PURE__ */ new Set()) {
    for (const a2 of this[Mo]) a2[Xo](e2, t2);
  }
  [Xo](e2, t2) {
    const a2 = this[Eo](e2, t2);
    a2 ? this[Fo](a2, e2, t2) : this[eo](e2, t2);
  }
  [Eo](e2, t2) {
    const { use: a2, usehref: r2 } = this;
    if (!a2 && !r2) return null;
    let i2 = null, n2 = null, s2 = null, o2 = a2;
    if (r2) {
      o2 = r2;
      r2.startsWith("#som(") && r2.endsWith(")") ? n2 = r2.slice(5, -1) : r2.startsWith(".#som(") && r2.endsWith(")") ? n2 = r2.slice(6, -1) : r2.startsWith("#") ? s2 = r2.slice(1) : r2.startsWith(".#") && (s2 = r2.slice(2));
    } else a2.startsWith("#") ? s2 = a2.slice(1) : n2 = a2;
    this.use = this.usehref = "";
    if (s2) i2 = e2.get(s2);
    else {
      i2 = searchNode(e2.get(Qs), this, n2, true, false);
      i2 && (i2 = i2[0]);
    }
    if (!i2) {
      warn(`XFA - Invalid prototype reference: ${o2}.`);
      return null;
    }
    if (i2[Ws] !== this[Ws]) {
      warn(`XFA - Incompatible prototype: ${i2[Ws]} !== ${this[Ws]}.`);
      return null;
    }
    if (t2.has(i2)) {
      warn("XFA - Cycle detected in prototypes use.");
      return null;
    }
    t2.add(i2);
    const c2 = i2[Eo](e2, t2);
    c2 && i2[Fo](c2, e2, t2);
    i2[eo](e2, t2);
    t2.delete(i2);
    return i2;
  }
  [Fo](e2, t2, a2) {
    if (a2.has(e2)) {
      warn("XFA - Cycle detected in prototypes use.");
      return;
    }
    !this[ss] && e2[ss] && (this[ss] = e2[ss]);
    new Set(a2).add(e2);
    for (const t3 of this[Po](e2[qo])) {
      this[t3] = e2[t3];
      this[qo] && this[qo].add(t3);
    }
    for (const r2 of Object.getOwnPropertyNames(this)) {
      if (this[Oo].has(r2)) continue;
      const i2 = this[r2], n2 = e2[r2];
      if (i2 instanceof XFAObjectArray) {
        for (const e3 of i2[Mo]) e3[Xo](t2, a2);
        for (let r3 = i2[Mo].length, s2 = n2[Mo].length; r3 < s2; r3++) {
          const n3 = e2[Mo][r3][is]();
          if (!i2.push(n3)) break;
          n3[Uo] = this;
          this[Mo].push(n3);
          n3[Xo](t2, a2);
        }
      } else if (null === i2) {
        if (null !== n2) {
          const e3 = n2[is]();
          e3[Uo] = this;
          this[r2] = e3;
          this[Mo].push(e3);
          e3[Xo](t2, a2);
        }
      } else {
        i2[eo](t2, a2);
        n2 && i2[Fo](n2, t2, a2);
      }
    }
  }
  static [Do](e2) {
    return Array.isArray(e2) ? e2.map(((e3) => _XFAObject[Do](e3))) : "object" == typeof e2 && null !== e2 ? Object.assign({}, e2) : e2;
  }
  [is]() {
    const e2 = Object.create(Object.getPrototypeOf(this));
    for (const t2 of Object.getOwnPropertySymbols(this)) try {
      e2[t2] = this[t2];
    } catch {
      shadow(e2, t2, this[t2]);
    }
    e2[uo] = `${e2[Ws]}${Wo++}`;
    e2[Mo] = [];
    for (const t2 of Object.getOwnPropertyNames(this)) {
      if (this[Oo].has(t2)) {
        e2[t2] = _XFAObject[Do](this[t2]);
        continue;
      }
      const a2 = this[t2];
      e2[t2] = a2 instanceof XFAObjectArray ? new XFAObjectArray(a2[jo]) : null;
    }
    for (const t2 of this[Mo]) {
      const a2 = t2[Ws], r2 = t2[is]();
      e2[Mo].push(r2);
      r2[Uo] = e2;
      null === e2[a2] ? e2[a2] = r2 : e2[a2][Mo].push(r2);
    }
    return e2;
  }
  [Ss](e2 = null) {
    return e2 ? this[Mo].filter(((t2) => t2[Ws] === e2)) : this[Mo];
  }
  [ps](e2) {
    return this[e2];
  }
  [ms](e2, t2, a2 = true) {
    return Array.from(this[bs](e2, t2, a2));
  }
  *[bs](e2, t2, a2 = true) {
    if ("parent" !== e2) {
      for (const a3 of this[Mo]) {
        a3[Ws] === e2 && (yield a3);
        a3.name === e2 && (yield a3);
        (t2 || a3[Us]()) && (yield* a3[bs](e2, t2, false));
      }
      a2 && this[Oo].has(e2) && (yield new XFAAttribute(this, e2, this[e2]));
    } else yield this[Uo];
  }
};
var XFAObjectArray = class _XFAObjectArray {
  constructor(e2 = 1 / 0) {
    this[jo] = e2;
    this[Mo] = [];
  }
  get isXFAObject() {
    return false;
  }
  get isXFAObjectArray() {
    return true;
  }
  push(e2) {
    if (this[Mo].length <= this[jo]) {
      this[Mo].push(e2);
      return true;
    }
    warn(`XFA - node "${e2[Ws]}" accepts no more than ${this[jo]} children`);
    return false;
  }
  isEmpty() {
    return 0 === this[Mo].length;
  }
  dump() {
    return 1 === this[Mo].length ? this[Mo][0][cs]() : this[Mo].map(((e2) => e2[cs]()));
  }
  [is]() {
    const e2 = new _XFAObjectArray(this[jo]);
    e2[Mo] = this[Mo].map(((e3) => e3[is]()));
    return e2;
  }
  get children() {
    return this[Mo];
  }
  clear() {
    this[Mo].length = 0;
  }
};
var XFAAttribute = class {
  constructor(e2, t2, a2) {
    this[Uo] = e2;
    this[Ws] = t2;
    this[ss] = a2;
    this[ns] = false;
    this[uo] = "attribute" + Wo++;
  }
  [vs]() {
    return this[Uo];
  }
  [Ns]() {
    return true;
  }
  [ys]() {
    return this[ss].trim();
  }
  [io](e2) {
    e2 = e2.value || "";
    this[ss] = e2.toString();
  }
  [so]() {
    return this[ss];
  }
  [Es](e2) {
    return this[Uo] === e2 || this[Uo][Es](e2);
  }
};
var XmlObject = class _XmlObject extends XFAObject {
  constructor(e2, t2, a2 = {}) {
    super(e2, t2);
    this[ss] = "";
    this[Bo] = null;
    if ("#text" !== t2) {
      const e3 = /* @__PURE__ */ new Map();
      this[Io] = e3;
      for (const [t3, r2] of Object.entries(a2)) e3.set(t3, new XFAAttribute(this, t3, r2));
      if (a2.hasOwnProperty(zs)) {
        const e4 = a2[zs].xfa.dataNode;
        void 0 !== e4 && ("dataGroup" === e4 ? this[Bo] = false : "dataValue" === e4 && (this[Bo] = true));
      }
    }
    this[ns] = false;
  }
  [lo](e2) {
    const t2 = this[Ws];
    if ("#text" === t2) {
      e2.push(encodeToXmlString(this[ss]));
      return;
    }
    const a2 = utf8StringToString(t2), r2 = this[Hs] === zo ? "xfa:" : "";
    e2.push(`<${r2}${a2}`);
    for (const [t3, a3] of this[Io].entries()) {
      const r3 = utf8StringToString(t3);
      e2.push(` ${r3}="${encodeToXmlString(a3[ss])}"`);
    }
    null !== this[Bo] && (this[Bo] ? e2.push(' xfa:dataNode="dataValue"') : e2.push(' xfa:dataNode="dataGroup"'));
    if (this[ss] || 0 !== this[Mo].length) {
      e2.push(">");
      if (this[ss]) "string" == typeof this[ss] ? e2.push(encodeToXmlString(this[ss])) : this[ss][lo](e2);
      else for (const t3 of this[Mo]) t3[lo](e2);
      e2.push(`</${r2}${a2}>`);
    } else e2.push("/>");
  }
  [$s](e2) {
    if (this[ss]) {
      const e3 = new _XmlObject(this[Hs], "#text");
      this[Qn](e3);
      e3[ss] = this[ss];
      this[ss] = "";
    }
    this[Qn](e2);
    return true;
  }
  [Vs](e2) {
    this[ss] += e2;
  }
  [hs]() {
    if (this[ss] && this[Mo].length > 0) {
      const e2 = new _XmlObject(this[Hs], "#text");
      this[Qn](e2);
      e2[ss] = this[ss];
      delete this[ss];
    }
  }
  [co]() {
    return "#text" === this[Ws] ? HTMLResult.success({ name: "#text", value: this[ss] }) : HTMLResult.EMPTY;
  }
  [Ss](e2 = null) {
    return e2 ? this[Mo].filter(((t2) => t2[Ws] === e2)) : this[Mo];
  }
  [fs]() {
    return this[Io];
  }
  [ps](e2) {
    const t2 = this[Io].get(e2);
    return void 0 !== t2 ? t2 : this[Ss](e2);
  }
  *[bs](e2, t2) {
    const a2 = this[Io].get(e2);
    a2 && (yield a2);
    for (const a3 of this[Mo]) {
      a3[Ws] === e2 && (yield a3);
      t2 && (yield* a3[bs](e2, t2));
    }
  }
  *[ds](e2, t2) {
    const a2 = this[Io].get(e2);
    !a2 || t2 && a2[ns] || (yield a2);
    for (const a3 of this[Mo]) yield* a3[ds](e2, t2);
  }
  *[xs](e2, t2, a2) {
    for (const r2 of this[Mo]) {
      r2[Ws] !== e2 || a2 && r2[ns] || (yield r2);
      t2 && (yield* r2[xs](e2, t2, a2));
    }
  }
  [Ns]() {
    return null === this[Bo] ? 0 === this[Mo].length || this[Mo][0][Hs] === go.xhtml.id : this[Bo];
  }
  [ys]() {
    return null === this[Bo] ? 0 === this[Mo].length ? this[ss].trim() : this[Mo][0][Hs] === go.xhtml.id ? this[Mo][0][so]().trim() : null : this[ss].trim();
  }
  [io](e2) {
    e2 = e2.value || "";
    this[ss] = e2.toString();
  }
  [cs](e2 = false) {
    const t2 = /* @__PURE__ */ Object.create(null);
    e2 && (t2.$ns = this[Hs]);
    this[ss] && (t2.$content = this[ss]);
    t2.$name = this[Ws];
    t2.children = [];
    for (const a2 of this[Mo]) t2.children.push(a2[cs](e2));
    t2.attributes = /* @__PURE__ */ Object.create(null);
    for (const [e3, a2] of this[Io]) t2.attributes[e3] = a2[ss];
    return t2;
  }
};
var ContentObject = class extends XFAObject {
  constructor(e2, t2) {
    super(e2, t2);
    this[ss] = "";
  }
  [Vs](e2) {
    this[ss] += e2;
  }
  [hs]() {
  }
};
var OptionObject = class extends ContentObject {
  constructor(e2, t2, a2) {
    super(e2, t2);
    this[_o] = a2;
  }
  [hs]() {
    this[ss] = getKeyword({ data: this[ss], defaultValue: this[_o][0], validate: (e2) => this[_o].includes(e2) });
  }
  [ts](e2) {
    super[ts](e2);
    delete this[_o];
  }
};
var StringObject = class extends ContentObject {
  [hs]() {
    this[ss] = this[ss].trim();
  }
};
var IntegerObject = class extends ContentObject {
  constructor(e2, t2, a2, r2) {
    super(e2, t2);
    this[Ro] = a2;
    this[Ho] = r2;
  }
  [hs]() {
    this[ss] = getInteger({ data: this[ss], defaultValue: this[Ro], validate: this[Ho] });
  }
  [ts](e2) {
    super[ts](e2);
    delete this[Ro];
    delete this[Ho];
  }
};
var Option01 = class extends IntegerObject {
  constructor(e2, t2) {
    super(e2, t2, 0, ((e3) => 1 === e3));
  }
};
var Option10 = class extends IntegerObject {
  constructor(e2, t2) {
    super(e2, t2, 1, ((e3) => 0 === e3));
  }
};
function measureToString(e2) {
  return "string" == typeof e2 ? "0px" : Number.isInteger(e2) ? `${e2}px` : `${e2.toFixed(2)}px`;
}
var $o = { anchorType(e2, t2) {
  const a2 = e2[Cs]();
  if (a2 && (!a2.layout || "position" === a2.layout)) {
    "transform" in t2 || (t2.transform = "");
    switch (e2.anchorType) {
      case "bottomCenter":
        t2.transform += "translate(-50%, -100%)";
        break;
      case "bottomLeft":
        t2.transform += "translate(0,-100%)";
        break;
      case "bottomRight":
        t2.transform += "translate(-100%,-100%)";
        break;
      case "middleCenter":
        t2.transform += "translate(-50%,-50%)";
        break;
      case "middleLeft":
        t2.transform += "translate(0,-50%)";
        break;
      case "middleRight":
        t2.transform += "translate(-100%,-50%)";
        break;
      case "topCenter":
        t2.transform += "translate(-50%,0)";
        break;
      case "topRight":
        t2.transform += "translate(-100%,0)";
    }
  }
}, dimensions(e2, t2) {
  const a2 = e2[Cs]();
  let r2 = e2.w;
  const i2 = e2.h;
  if (a2.layout?.includes("row")) {
    const t3 = a2[ls], i3 = e2.colSpan;
    let n2;
    if (-1 === i3) {
      n2 = Math.sumPrecise(t3.columnWidths.slice(t3.currentColumn));
      t3.currentColumn = 0;
    } else {
      n2 = Math.sumPrecise(t3.columnWidths.slice(t3.currentColumn, t3.currentColumn + i3));
      t3.currentColumn = (t3.currentColumn + e2.colSpan) % t3.columnWidths.length;
    }
    isNaN(n2) || (r2 = e2.w = n2);
  }
  t2.width = "" !== r2 ? measureToString(r2) : "auto";
  t2.height = "" !== i2 ? measureToString(i2) : "auto";
}, position(e2, t2) {
  const a2 = e2[Cs]();
  if (!a2?.layout || "position" === a2.layout) {
    t2.position = "absolute";
    t2.left = measureToString(e2.x);
    t2.top = measureToString(e2.y);
  }
}, rotate(e2, t2) {
  if (e2.rotate) {
    "transform" in t2 || (t2.transform = "");
    t2.transform += `rotate(-${e2.rotate}deg)`;
    t2.transformOrigin = "top left";
  }
}, presence(e2, t2) {
  switch (e2.presence) {
    case "invisible":
      t2.visibility = "hidden";
      break;
    case "hidden":
    case "inactive":
      t2.display = "none";
  }
}, hAlign(e2, t2) {
  if ("para" === e2[Ws]) switch (e2.hAlign) {
    case "justifyAll":
      t2.textAlign = "justify-all";
      break;
    case "radix":
      t2.textAlign = "left";
      break;
    default:
      t2.textAlign = e2.hAlign;
  }
  else switch (e2.hAlign) {
    case "left":
      t2.alignSelf = "start";
      break;
    case "center":
      t2.alignSelf = "center";
      break;
    case "right":
      t2.alignSelf = "end";
  }
}, margin(e2, t2) {
  e2.margin && (t2.margin = e2.margin[ho]().margin);
} };
function setMinMaxDimensions(e2, t2) {
  if ("position" === e2[Cs]().layout) {
    e2.minW > 0 && (t2.minWidth = measureToString(e2.minW));
    e2.maxW > 0 && (t2.maxWidth = measureToString(e2.maxW));
    e2.minH > 0 && (t2.minHeight = measureToString(e2.minH));
    e2.maxH > 0 && (t2.maxHeight = measureToString(e2.maxH));
  }
}
function layoutText(e2, t2, a2, r2, i2, n2) {
  const s2 = new TextMeasure(t2, a2, r2, i2);
  "string" == typeof e2 ? s2.addString(e2) : e2[Ks](s2);
  return s2.compute(n2);
}
function layoutNode(e2, t2) {
  let a2 = null, r2 = null, i2 = false;
  if ((!e2.w || !e2.h) && e2.value) {
    let n2 = 0, s2 = 0;
    if (e2.margin) {
      n2 = e2.margin.leftInset + e2.margin.rightInset;
      s2 = e2.margin.topInset + e2.margin.bottomInset;
    }
    let o2 = null, c2 = null;
    if (e2.para) {
      c2 = /* @__PURE__ */ Object.create(null);
      o2 = "" === e2.para.lineHeight ? null : e2.para.lineHeight;
      c2.top = "" === e2.para.spaceAbove ? 0 : e2.para.spaceAbove;
      c2.bottom = "" === e2.para.spaceBelow ? 0 : e2.para.spaceBelow;
      c2.left = "" === e2.para.marginLeft ? 0 : e2.para.marginLeft;
      c2.right = "" === e2.para.marginRight ? 0 : e2.para.marginRight;
    }
    let l2 = e2.font;
    if (!l2) {
      const t3 = e2[Fs]();
      let a3 = e2[vs]();
      for (; a3 && a3 !== t3; ) {
        if (a3.font) {
          l2 = a3.font;
          break;
        }
        a3 = a3[vs]();
      }
    }
    const h2 = (e2.w || t2.width) - n2, u2 = e2[Is].fontFinder;
    if (e2.value.exData && e2.value.exData[ss] && "text/html" === e2.value.exData.contentType) {
      const t3 = layoutText(e2.value.exData[ss], l2, c2, o2, u2, h2);
      r2 = t3.width;
      a2 = t3.height;
      i2 = t3.isBroken;
    } else {
      const t3 = e2.value[so]();
      if (t3) {
        const e3 = layoutText(t3, l2, c2, o2, u2, h2);
        r2 = e3.width;
        a2 = e3.height;
        i2 = e3.isBroken;
      }
    }
    null === r2 || e2.w || (r2 += n2);
    null === a2 || e2.h || (a2 += s2);
  }
  return { w: r2, h: a2, isBroken: i2 };
}
function computeBbox(e2, t2, a2) {
  let r2;
  if ("" !== e2.w && "" !== e2.h) r2 = [e2.x, e2.y, e2.w, e2.h];
  else {
    if (!a2) return null;
    let i2 = e2.w;
    if ("" === i2) {
      if (0 === e2.maxW) {
        const t3 = e2[Cs]();
        i2 = "position" === t3.layout && "" !== t3.w ? 0 : e2.minW;
      } else i2 = Math.min(e2.maxW, a2.width);
      t2.attributes.style.width = measureToString(i2);
    }
    let n2 = e2.h;
    if ("" === n2) {
      if (0 === e2.maxH) {
        const t3 = e2[Cs]();
        n2 = "position" === t3.layout && "" !== t3.h ? 0 : e2.minH;
      } else n2 = Math.min(e2.maxH, a2.height);
      t2.attributes.style.height = measureToString(n2);
    }
    r2 = [e2.x, e2.y, i2, n2];
  }
  return r2;
}
function fixDimensions(e2) {
  const t2 = e2[Cs]();
  if (t2.layout?.includes("row")) {
    const a2 = t2[ls], r2 = e2.colSpan;
    let i2;
    i2 = -1 === r2 ? Math.sumPrecise(a2.columnWidths.slice(a2.currentColumn)) : Math.sumPrecise(a2.columnWidths.slice(a2.currentColumn, a2.currentColumn + r2));
    isNaN(i2) || (e2.w = i2);
  }
  t2.layout && "position" !== t2.layout && (e2.x = e2.y = 0);
  "table" === e2.layout && "" === e2.w && Array.isArray(e2.columnWidths) && (e2.w = Math.sumPrecise(e2.columnWidths));
}
function layoutClass(e2) {
  switch (e2.layout) {
    case "position":
    default:
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
  }
}
function toStyle(e2, ...t2) {
  const a2 = /* @__PURE__ */ Object.create(null);
  for (const r2 of t2) {
    const t3 = e2[r2];
    if (null !== t3) {
      if ($o.hasOwnProperty(r2)) $o[r2](e2, a2);
      else if (t3 instanceof XFAObject) {
        const e3 = t3[ho]();
        e3 ? Object.assign(a2, e3) : warn(`(DEBUG) - XFA - style for ${r2} not implemented yet`);
      }
    }
  }
  return a2;
}
function createWrapper(e2, t2) {
  const { attributes: a2 } = t2, { style: r2 } = a2, i2 = { name: "div", attributes: { class: ["xfaWrapper"], style: /* @__PURE__ */ Object.create(null) }, children: [] };
  a2.class.push("xfaWrapped");
  if (e2.border) {
    const { widths: a3, insets: n2 } = e2.border[ls];
    let s2, o2, c2 = n2[0], l2 = n2[3];
    const h2 = n2[0] + n2[2], u2 = n2[1] + n2[3];
    switch (e2.border.hand) {
      case "even":
        c2 -= a3[0] / 2;
        l2 -= a3[3] / 2;
        s2 = `calc(100% + ${(a3[1] + a3[3]) / 2 - u2}px)`;
        o2 = `calc(100% + ${(a3[0] + a3[2]) / 2 - h2}px)`;
        break;
      case "left":
        c2 -= a3[0];
        l2 -= a3[3];
        s2 = `calc(100% + ${a3[1] + a3[3] - u2}px)`;
        o2 = `calc(100% + ${a3[0] + a3[2] - h2}px)`;
        break;
      case "right":
        s2 = u2 ? `calc(100% - ${u2}px)` : "100%";
        o2 = h2 ? `calc(100% - ${h2}px)` : "100%";
    }
    const d2 = ["xfaBorder"];
    isPrintOnly(e2.border) && d2.push("xfaPrintOnly");
    const f2 = { name: "div", attributes: { class: d2, style: { top: `${c2}px`, left: `${l2}px`, width: s2, height: o2 } }, children: [] };
    for (const e3 of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) if (void 0 !== r2[e3]) {
      f2.attributes.style[e3] = r2[e3];
      delete r2[e3];
    }
    i2.children.push(f2, t2);
  } else i2.children.push(t2);
  for (const e3 of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) if (void 0 !== r2[e3]) {
    i2.attributes.style[e3] = r2[e3];
    delete r2[e3];
  }
  i2.attributes.style.position = "absolute" === r2.position ? "absolute" : "relative";
  delete r2.position;
  if (r2.alignSelf) {
    i2.attributes.style.alignSelf = r2.alignSelf;
    delete r2.alignSelf;
  }
  return i2;
}
function fixTextIndent(e2) {
  const t2 = getMeasurement(e2.textIndent, "0px");
  if (t2 >= 0) return;
  const a2 = "padding" + ("left" === ("right" === e2.textAlign ? "right" : "left") ? "Left" : "Right"), r2 = getMeasurement(e2[a2], "0px");
  e2[a2] = r2 - t2 + "px";
}
function setAccess(e2, t2) {
  switch (e2.access) {
    case "nonInteractive":
      t2.push("xfaNonInteractive");
      break;
    case "readOnly":
      t2.push("xfaReadOnly");
      break;
    case "protected":
      t2.push("xfaDisabled");
  }
}
function isPrintOnly(e2) {
  return e2.relevant.length > 0 && !e2.relevant[0].excluded && "print" === e2.relevant[0].viewname;
}
function getCurrentPara(e2) {
  const t2 = e2[Fs]()[ls].paraStack;
  return t2.length ? t2.at(-1) : null;
}
function setPara(e2, t2, a2) {
  if (a2.attributes.class?.includes("xfaRich")) {
    if (t2) {
      "" === e2.h && (t2.height = "auto");
      "" === e2.w && (t2.width = "auto");
    }
    const r2 = getCurrentPara(e2);
    if (r2) {
      const e3 = a2.attributes.style;
      e3.display = "flex";
      e3.flexDirection = "column";
      switch (r2.vAlign) {
        case "top":
          e3.justifyContent = "start";
          break;
        case "bottom":
          e3.justifyContent = "end";
          break;
        case "middle":
          e3.justifyContent = "center";
      }
      const t3 = r2[ho]();
      for (const [a3, r3] of Object.entries(t3)) a3 in e3 || (e3[a3] = r3);
    }
  }
}
function setFontFamily(e2, t2, a2, r2) {
  if (!a2) {
    delete r2.fontFamily;
    return;
  }
  const i2 = stripQuotes(e2.typeface);
  r2.fontFamily = `"${i2}"`;
  const n2 = a2.find(i2);
  if (n2) {
    const { fontFamily: a3 } = n2.regular.cssFontInfo;
    a3 !== i2 && (r2.fontFamily = `"${a3}"`);
    const s2 = getCurrentPara(t2);
    if (s2 && "" !== s2.lineHeight) return;
    if (r2.lineHeight) return;
    const o2 = selectFont(e2, n2);
    o2 && (r2.lineHeight = Math.max(1.2, o2.lineHeight));
  }
}
function fixURL(e2) {
  const t2 = createValidAbsoluteUrl(e2, null, { addDefaultProtocol: true, tryConvertEncoding: true });
  return t2 ? t2.href : null;
}
function createLine(e2, t2) {
  return { name: "div", attributes: { class: ["lr-tb" === e2.layout ? "xfaLr" : "xfaRl"] }, children: t2 };
}
function flushHTML(e2) {
  if (!e2[ls]) return null;
  const t2 = { name: "div", attributes: e2[ls].attributes, children: e2[ls].children };
  if (e2[ls].failingNode) {
    const a2 = e2[ls].failingNode[us]();
    a2 && (e2.layout.endsWith("-tb") ? t2.children.push(createLine(e2, [a2])) : t2.children.push(a2));
  }
  return 0 === t2.children.length ? null : t2;
}
function addHTML(e2, t2, a2) {
  const r2 = e2[ls], i2 = r2.availableSpace, [n2, s2, o2, c2] = a2;
  switch (e2.layout) {
    case "position":
      r2.width = Math.max(r2.width, n2 + o2);
      r2.height = Math.max(r2.height, s2 + c2);
      r2.children.push(t2);
      break;
    case "lr-tb":
    case "rl-tb":
      if (!r2.line || 1 === r2.attempt) {
        r2.line = createLine(e2, []);
        r2.children.push(r2.line);
        r2.numberInLine = 0;
      }
      r2.numberInLine += 1;
      r2.line.children.push(t2);
      if (0 === r2.attempt) {
        r2.currentWidth += o2;
        r2.height = Math.max(r2.height, r2.prevHeight + c2);
      } else {
        r2.currentWidth = o2;
        r2.prevHeight = r2.height;
        r2.height += c2;
        r2.attempt = 0;
      }
      r2.width = Math.max(r2.width, r2.currentWidth);
      break;
    case "rl-row":
    case "row": {
      r2.children.push(t2);
      r2.width += o2;
      r2.height = Math.max(r2.height, c2);
      const e3 = measureToString(r2.height);
      for (const t3 of r2.children) t3.attributes.style.height = e3;
      break;
    }
    case "table":
    case "tb":
      r2.width = MathClamp(o2, r2.width, i2.width);
      r2.height += c2;
      r2.children.push(t2);
  }
}
function getAvailableSpace(e2) {
  const t2 = e2[ls].availableSpace, a2 = e2.margin ? e2.margin.topInset + e2.margin.bottomInset : 0, r2 = e2.margin ? e2.margin.leftInset + e2.margin.rightInset : 0;
  switch (e2.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === e2[ls].attempt ? { width: t2.width - r2 - e2[ls].currentWidth, height: t2.height - a2 - e2[ls].prevHeight } : { width: t2.width - r2, height: t2.height - a2 - e2[ls].height };
    case "rl-row":
    case "row":
      return { width: Math.sumPrecise(e2[ls].columnWidths.slice(e2[ls].currentColumn)), height: t2.height - r2 };
    case "table":
    case "tb":
      return { width: t2.width - r2, height: t2.height - a2 - e2[ls].height };
    default:
      return t2;
  }
}
function checkDimensions(e2, t2) {
  if (null === e2[Fs]()[ls].firstUnsplittable) return true;
  if (0 === e2.w || 0 === e2.h) return true;
  const a2 = e2[Cs](), r2 = a2[ls]?.attempt || 0, [, i2, n2, s2] = (function getTransformedBBox(e3) {
    let t3, a3, r3 = "" === e3.w ? NaN : e3.w, i3 = "" === e3.h ? NaN : e3.h, [n3, s3] = [0, 0];
    switch (e3.anchorType || "") {
      case "bottomCenter":
        [n3, s3] = [r3 / 2, i3];
        break;
      case "bottomLeft":
        [n3, s3] = [0, i3];
        break;
      case "bottomRight":
        [n3, s3] = [r3, i3];
        break;
      case "middleCenter":
        [n3, s3] = [r3 / 2, i3 / 2];
        break;
      case "middleLeft":
        [n3, s3] = [0, i3 / 2];
        break;
      case "middleRight":
        [n3, s3] = [r3, i3 / 2];
        break;
      case "topCenter":
        [n3, s3] = [r3 / 2, 0];
        break;
      case "topRight":
        [n3, s3] = [r3, 0];
    }
    switch (e3.rotate || 0) {
      case 0:
        [t3, a3] = [-n3, -s3];
        break;
      case 90:
        [t3, a3] = [-s3, n3];
        [r3, i3] = [i3, -r3];
        break;
      case 180:
        [t3, a3] = [n3, s3];
        [r3, i3] = [-r3, -i3];
        break;
      case 270:
        [t3, a3] = [s3, -n3];
        [r3, i3] = [-i3, r3];
    }
    return [e3.x + t3 + Math.min(0, r3), e3.y + a3 + Math.min(0, i3), Math.abs(r3), Math.abs(i3)];
  })(e2);
  switch (a2.layout) {
    case "lr-tb":
    case "rl-tb":
      return 0 === r2 ? e2[Fs]()[ls].noLayoutFailure ? "" !== e2.w ? Math.round(n2 - t2.width) <= 2 : t2.width > 2 : !("" !== e2.h && Math.round(s2 - t2.height) > 2) && ("" !== e2.w ? Math.round(n2 - t2.width) <= 2 || 0 === a2[ls].numberInLine && t2.height > 2 : t2.width > 2) : !!e2[Fs]()[ls].noLayoutFailure || !("" !== e2.h && Math.round(s2 - t2.height) > 2) && (("" === e2.w || Math.round(n2 - t2.width) <= 2 || !a2[_s]()) && t2.height > 2);
    case "table":
    case "tb":
      return !!e2[Fs]()[ls].noLayoutFailure || ("" === e2.h || e2[js]() ? ("" === e2.w || Math.round(n2 - t2.width) <= 2 || !a2[_s]()) && t2.height > 2 : Math.round(s2 - t2.height) <= 2);
    case "position":
      if (e2[Fs]()[ls].noLayoutFailure) return true;
      if ("" === e2.h || Math.round(s2 + i2 - t2.height) <= 2) return true;
      return s2 + i2 > e2[Fs]()[ls].currentContentArea.h;
    case "rl-row":
    case "row":
      return !!e2[Fs]()[ls].noLayoutFailure || ("" === e2.h || Math.round(s2 - t2.height) <= 2);
    default:
      return true;
  }
}
var Go = go.template.id;
var Vo = "http://www.w3.org/2000/svg";
var Ko = /^H(\d+)$/;
var Jo = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]);
var Yo = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
function getBorderDims(e2) {
  if (!e2 || !e2.border) return { w: 0, h: 0 };
  const t2 = e2.border[ws]();
  return t2 ? { w: t2.widths[0] + t2.widths[2] + t2.insets[0] + t2.insets[2], h: t2.widths[1] + t2.widths[3] + t2.insets[1] + t2.insets[3] } : { w: 0, h: 0 };
}
function hasMargin(e2) {
  return e2.margin && (e2.margin.topInset || e2.margin.rightInset || e2.margin.bottomInset || e2.margin.leftInset);
}
function _setValue(e2, t2) {
  if (!e2.value) {
    const t3 = new Value({});
    e2[Qn](t3);
    e2.value = t3;
  }
  e2.value[io](t2);
}
function* getContainedChildren(e2) {
  for (const t2 of e2[Ss]()) t2 instanceof SubformSet ? yield* t2[As]() : yield t2;
}
function isRequired(e2) {
  return "error" === e2.validate?.nullTest;
}
function setTabIndex(e2) {
  for (; e2; ) {
    if (!e2.traversal) {
      e2[no] = e2[vs]()[no];
      return;
    }
    if (e2[no]) return;
    let t2 = null;
    for (const a3 of e2.traversal[Ss]()) if ("next" === a3.operation) {
      t2 = a3;
      break;
    }
    if (!t2 || !t2.ref) {
      e2[no] = e2[vs]()[no];
      return;
    }
    const a2 = e2[Fs]();
    e2[no] = ++a2[no];
    const r2 = a2[to](t2.ref, e2);
    if (!r2) return;
    e2 = r2[0];
  }
}
function applyAssist(e2, t2) {
  const a2 = e2.assist;
  if (a2) {
    const e3 = a2[co]();
    e3 && (t2.title = e3);
    const r2 = a2.role.match(Ko);
    if (r2) {
      const e4 = "heading", a3 = r2[1];
      t2.role = e4;
      t2["aria-level"] = a3;
    }
  }
  if ("table" === e2.layout) t2.role = "table";
  else if ("row" === e2.layout) t2.role = "row";
  else {
    const a3 = e2[vs]();
    "row" === a3.layout && (t2.role = "TH" === a3.assist?.role ? "columnheader" : "cell");
  }
}
function ariaLabel(e2) {
  if (!e2.assist) return null;
  const t2 = e2.assist;
  return t2.speak && "" !== t2.speak[ss] ? t2.speak[ss] : t2.toolTip ? t2.toolTip[ss] : null;
}
function valueToHtml(e2) {
  return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: /* @__PURE__ */ Object.create(null) }, children: [{ name: "span", attributes: { style: /* @__PURE__ */ Object.create(null) }, value: e2 }] });
}
function setFirstUnsplittable(e2) {
  const t2 = e2[Fs]();
  if (null === t2[ls].firstUnsplittable) {
    t2[ls].firstUnsplittable = e2;
    t2[ls].noLayoutFailure = true;
  }
}
function unsetFirstUnsplittable(e2) {
  const t2 = e2[Fs]();
  t2[ls].firstUnsplittable === e2 && (t2[ls].noLayoutFailure = false);
}
function handleBreak(e2) {
  if (e2[ls]) return false;
  e2[ls] = /* @__PURE__ */ Object.create(null);
  if ("auto" === e2.targetType) return false;
  const t2 = e2[Fs]();
  let a2 = null;
  if (e2.target) {
    a2 = t2[to](e2.target, e2[vs]());
    if (!a2) return false;
    a2 = a2[0];
  }
  const { currentPageArea: r2, currentContentArea: i2 } = t2[ls];
  if ("pageArea" === e2.targetType) {
    a2 instanceof PageArea || (a2 = null);
    if (e2.startNew) {
      e2[ls].target = a2 || r2;
      return true;
    }
    if (a2 && a2 !== r2) {
      e2[ls].target = a2;
      return true;
    }
    return false;
  }
  a2 instanceof ContentArea || (a2 = null);
  const n2 = a2 && a2[vs]();
  let s2, o2 = n2;
  if (e2.startNew) if (a2) {
    const e3 = n2.contentArea.children, t3 = e3.indexOf(i2), r3 = e3.indexOf(a2);
    -1 !== t3 && t3 < r3 && (o2 = null);
    s2 = r3 - 1;
  } else s2 = r2.contentArea.children.indexOf(i2);
  else {
    if (!a2 || a2 === i2) return false;
    s2 = n2.contentArea.children.indexOf(a2) - 1;
    o2 = n2 === r2 ? null : n2;
  }
  e2[ls].target = o2;
  e2[ls].index = s2;
  return true;
}
function handleOverflow(e2, t2, a2) {
  const r2 = e2[Fs](), i2 = r2[ls].noLayoutFailure, n2 = t2[Cs];
  t2[Cs] = () => e2;
  r2[ls].noLayoutFailure = true;
  const s2 = t2[co](a2);
  e2[Zn](s2.html, s2.bbox);
  r2[ls].noLayoutFailure = i2;
  t2[Cs] = n2;
}
var AppearanceFilter = class extends StringObject {
  constructor(e2) {
    super(Go, "appearanceFilter");
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Arc = class extends XFAObject {
  constructor(e2) {
    super(Go, "arc", true);
    this.circular = getInteger({ data: e2.circular, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.hand = getStringOption(e2.hand, ["even", "left", "right"]);
    this.id = e2.id || "";
    this.startAngle = getFloat({ data: e2.startAngle, defaultValue: 0, validate: (e3) => true });
    this.sweepAngle = getFloat({ data: e2.sweepAngle, defaultValue: 360, validate: (e3) => true });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.edge = null;
    this.fill = null;
  }
  [co]() {
    const e2 = this.edge || new Edge({}), t2 = e2[ho](), a2 = /* @__PURE__ */ Object.create(null);
    "visible" === this.fill?.presence ? Object.assign(a2, this.fill[ho]()) : a2.fill = "transparent";
    a2.strokeWidth = measureToString("visible" === e2.presence ? e2.thickness : 0);
    a2.stroke = t2.color;
    let r2;
    const i2 = { xmlns: Vo, style: { width: "100%", height: "100%", overflow: "visible" } };
    if (360 === this.sweepAngle) r2 = { name: "ellipse", attributes: { xmlns: Vo, cx: "50%", cy: "50%", rx: "50%", ry: "50%", style: a2 } };
    else {
      const e3 = this.startAngle * Math.PI / 180, t3 = this.sweepAngle * Math.PI / 180, n3 = this.sweepAngle > 180 ? 1 : 0, [s2, o2, c2, l2] = [50 * (1 + Math.cos(e3)), 50 * (1 - Math.sin(e3)), 50 * (1 + Math.cos(e3 + t3)), 50 * (1 - Math.sin(e3 + t3))];
      r2 = { name: "path", attributes: { xmlns: Vo, d: `M ${s2} ${o2} A 50 50 0 ${n3} 0 ${c2} ${l2}`, vectorEffect: "non-scaling-stroke", style: a2 } };
      Object.assign(i2, { viewBox: "0 0 100 100", preserveAspectRatio: "none" });
    }
    const n2 = { name: "svg", children: [r2], attributes: i2 };
    if (hasMargin(this[vs]()[vs]())) return HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [n2] });
    n2.attributes.style.position = "absolute";
    return HTMLResult.success(n2);
  }
};
var Area = class extends XFAObject {
  constructor(e2) {
    super(Go, "area", true);
    this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 });
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.desc = null;
    this.extras = null;
    this.area = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
  }
  *[As]() {
    yield* getContainedChildren(this);
  }
  [Us]() {
    return true;
  }
  [Rs]() {
    return true;
  }
  [Zn](e2, t2) {
    const [a2, r2, i2, n2] = t2;
    this[ls].width = Math.max(this[ls].width, a2 + i2);
    this[ls].height = Math.max(this[ls].height, r2 + n2);
    this[ls].children.push(e2);
  }
  [gs]() {
    return this[ls].availableSpace;
  }
  [co](e2) {
    const t2 = toStyle(this, "position"), a2 = { style: t2, id: this[uo], class: ["xfaArea"] };
    isPrintOnly(this) && a2.class.push("xfaPrintOnly");
    this.name && (a2.xfaName = this.name);
    const r2 = [];
    this[ls] = { children: r2, width: 0, height: 0, availableSpace: e2 };
    const i2 = this[es]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]), include: true });
    if (!i2.success) {
      if (i2.isBreak()) return i2;
      delete this[ls];
      return HTMLResult.FAILURE;
    }
    t2.width = measureToString(this[ls].width);
    t2.height = measureToString(this[ls].height);
    const n2 = { name: "div", attributes: a2, children: r2 }, s2 = [this.x, this.y, this[ls].width, this[ls].height];
    delete this[ls];
    return HTMLResult.success(n2, s2);
  }
};
var Assist = class extends XFAObject {
  constructor(e2) {
    super(Go, "assist", true);
    this.id = e2.id || "";
    this.role = e2.role || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.speak = null;
    this.toolTip = null;
  }
  [co]() {
    return this.toolTip?.[ss] || null;
  }
};
var Barcode = class extends XFAObject {
  constructor(e2) {
    super(Go, "barcode", true);
    this.charEncoding = getKeyword({ data: e2.charEncoding ? e2.charEncoding.toLowerCase() : "", defaultValue: "", validate: (e3) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e3) || e3.match(/iso-8859-\d{2}/) });
    this.checksum = getStringOption(e2.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]);
    this.dataColumnCount = getInteger({ data: e2.dataColumnCount, defaultValue: -1, validate: (e3) => e3 >= 0 });
    this.dataLength = getInteger({ data: e2.dataLength, defaultValue: -1, validate: (e3) => e3 >= 0 });
    this.dataPrep = getStringOption(e2.dataPrep, ["none", "flateCompress"]);
    this.dataRowCount = getInteger({ data: e2.dataRowCount, defaultValue: -1, validate: (e3) => e3 >= 0 });
    this.endChar = e2.endChar || "";
    this.errorCorrectionLevel = getInteger({ data: e2.errorCorrectionLevel, defaultValue: -1, validate: (e3) => e3 >= 0 && e3 <= 8 });
    this.id = e2.id || "";
    this.moduleHeight = getMeasurement(e2.moduleHeight, "5mm");
    this.moduleWidth = getMeasurement(e2.moduleWidth, "0.25mm");
    this.printCheckDigit = getInteger({ data: e2.printCheckDigit, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.rowColumnRatio = getRatio(e2.rowColumnRatio);
    this.startChar = e2.startChar || "";
    this.textLocation = getStringOption(e2.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]);
    this.truncate = getInteger({ data: e2.truncate, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.type = getStringOption(e2.type ? e2.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]);
    this.upsMode = getStringOption(e2.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.wideNarrowRatio = getRatio(e2.wideNarrowRatio);
    this.encrypt = null;
    this.extras = null;
  }
};
var Bind = class extends XFAObject {
  constructor(e2) {
    super(Go, "bind", true);
    this.match = getStringOption(e2.match, ["once", "dataRef", "global", "none"]);
    this.ref = e2.ref || "";
    this.picture = null;
  }
};
var BindItems = class extends XFAObject {
  constructor(e2) {
    super(Go, "bindItems");
    this.connection = e2.connection || "";
    this.labelRef = e2.labelRef || "";
    this.ref = e2.ref || "";
    this.valueRef = e2.valueRef || "";
  }
};
var Bookend = class extends XFAObject {
  constructor(e2) {
    super(Go, "bookend");
    this.id = e2.id || "";
    this.leader = e2.leader || "";
    this.trailer = e2.trailer || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var BooleanElement = class extends Option01 {
  constructor(e2) {
    super(Go, "boolean");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [co](e2) {
    return valueToHtml(1 === this[ss] ? "1" : "0");
  }
};
var Border = class extends XFAObject {
  constructor(e2) {
    super(Go, "border", true);
    this.break = getStringOption(e2.break, ["close", "open"]);
    this.hand = getStringOption(e2.hand, ["even", "left", "right"]);
    this.id = e2.id || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.corner = new XFAObjectArray(4);
    this.edge = new XFAObjectArray(4);
    this.extras = null;
    this.fill = null;
    this.margin = null;
  }
  [ws]() {
    if (!this[ls]) {
      const e2 = this.edge.children.slice();
      if (e2.length < 4) {
        const t3 = e2.at(-1) || new Edge({});
        for (let a3 = e2.length; a3 < 4; a3++) e2.push(t3);
      }
      const t2 = e2.map(((e3) => e3.thickness)), a2 = [0, 0, 0, 0];
      if (this.margin) {
        a2[0] = this.margin.topInset;
        a2[1] = this.margin.rightInset;
        a2[2] = this.margin.bottomInset;
        a2[3] = this.margin.leftInset;
      }
      this[ls] = { widths: t2, insets: a2, edges: e2 };
    }
    return this[ls];
  }
  [ho]() {
    const { edges: e2 } = this[ws](), t2 = e2.map(((e3) => {
      const t3 = e3[ho]();
      t3.color ||= "#000000";
      return t3;
    })), a2 = /* @__PURE__ */ Object.create(null);
    this.margin && Object.assign(a2, this.margin[ho]());
    "visible" === this.fill?.presence && Object.assign(a2, this.fill[ho]());
    if (this.corner.children.some(((e3) => 0 !== e3.radius))) {
      const e3 = this.corner.children.map(((e4) => e4[ho]()));
      if (2 === e3.length || 3 === e3.length) {
        const t3 = e3.at(-1);
        for (let a3 = e3.length; a3 < 4; a3++) e3.push(t3);
      }
      a2.borderRadius = e3.map(((e4) => e4.radius)).join(" ");
    }
    switch (this.presence) {
      case "invisible":
      case "hidden":
        a2.borderStyle = "";
        break;
      case "inactive":
        a2.borderStyle = "none";
        break;
      default:
        a2.borderStyle = t2.map(((e3) => e3.style)).join(" ");
    }
    a2.borderWidth = t2.map(((e3) => e3.width)).join(" ");
    a2.borderColor = t2.map(((e3) => e3.color)).join(" ");
    return a2;
  }
};
var Break = class extends XFAObject {
  constructor(e2) {
    super(Go, "break", true);
    this.after = getStringOption(e2.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.afterTarget = e2.afterTarget || "";
    this.before = getStringOption(e2.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]);
    this.beforeTarget = e2.beforeTarget || "";
    this.bookendLeader = e2.bookendLeader || "";
    this.bookendTrailer = e2.bookendTrailer || "";
    this.id = e2.id || "";
    this.overflowLeader = e2.overflowLeader || "";
    this.overflowTarget = e2.overflowTarget || "";
    this.overflowTrailer = e2.overflowTrailer || "";
    this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
};
var BreakAfter = class extends XFAObject {
  constructor(e2) {
    super(Go, "breakAfter", true);
    this.id = e2.id || "";
    this.leader = e2.leader || "";
    this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.target = e2.target || "";
    this.targetType = getStringOption(e2.targetType, ["auto", "contentArea", "pageArea"]);
    this.trailer = e2.trailer || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.script = null;
  }
};
var BreakBefore = class extends XFAObject {
  constructor(e2) {
    super(Go, "breakBefore", true);
    this.id = e2.id || "";
    this.leader = e2.leader || "";
    this.startNew = getInteger({ data: e2.startNew, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.target = e2.target || "";
    this.targetType = getStringOption(e2.targetType, ["auto", "contentArea", "pageArea"]);
    this.trailer = e2.trailer || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.script = null;
  }
  [co](e2) {
    this[ls] = {};
    return HTMLResult.FAILURE;
  }
};
var Button = class extends XFAObject {
  constructor(e2) {
    super(Go, "button", true);
    this.highlight = getStringOption(e2.highlight, ["inverted", "none", "outline", "push"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
  [co](e2) {
    const t2 = this[vs]()[vs](), a2 = { name: "button", attributes: { id: this[uo], class: ["xfaButton"], style: {} }, children: [] };
    for (const e3 of t2.event.children) {
      if ("click" !== e3.activity || !e3.script) continue;
      const t3 = recoverJsURL(e3.script[ss]);
      if (!t3) continue;
      const r2 = fixURL(t3.url);
      r2 && a2.children.push({ name: "a", attributes: { id: "link" + this[uo], href: r2, newWindow: t3.newWindow, class: ["xfaLink"], style: {} }, children: [] });
    }
    return HTMLResult.success(a2);
  }
};
var Calculate = class extends XFAObject {
  constructor(e2) {
    super(Go, "calculate", true);
    this.id = e2.id || "";
    this.override = getStringOption(e2.override, ["disabled", "error", "ignore", "warning"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.message = null;
    this.script = null;
  }
};
var Caption = class extends XFAObject {
  constructor(e2) {
    super(Go, "caption", true);
    this.id = e2.id || "";
    this.placement = getStringOption(e2.placement, ["left", "bottom", "inline", "right", "top"]);
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.reserve = Math.ceil(getMeasurement(e2.reserve));
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.font = null;
    this.margin = null;
    this.para = null;
    this.value = null;
  }
  [io](e2) {
    _setValue(this, e2);
  }
  [ws](e2) {
    if (!this[ls]) {
      let { width: t2, height: a2 } = e2;
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          t2 = this.reserve <= 0 ? t2 : this.reserve;
          break;
        case "top":
        case "bottom":
          a2 = this.reserve <= 0 ? a2 : this.reserve;
      }
      this[ls] = layoutNode(this, { width: t2, height: a2 });
    }
    return this[ls];
  }
  [co](e2) {
    if (!this.value) return HTMLResult.EMPTY;
    this[Ys]();
    const t2 = this.value[co](e2).html;
    if (!t2) {
      this[Js]();
      return HTMLResult.EMPTY;
    }
    const a2 = this.reserve;
    if (this.reserve <= 0) {
      const { w: t3, h: a3 } = this[ws](e2);
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          this.reserve = t3;
          break;
        case "top":
        case "bottom":
          this.reserve = a3;
      }
    }
    const r2 = [];
    "string" == typeof t2 ? r2.push({ name: "#text", value: t2 }) : r2.push(t2);
    const i2 = toStyle(this, "font", "margin", "visibility");
    switch (this.placement) {
      case "left":
      case "right":
        this.reserve > 0 && (i2.width = measureToString(this.reserve));
        break;
      case "top":
      case "bottom":
        this.reserve > 0 && (i2.height = measureToString(this.reserve));
    }
    setPara(this, null, t2);
    this[Js]();
    this.reserve = a2;
    return HTMLResult.success({ name: "div", attributes: { style: i2, class: ["xfaCaption"] }, children: r2 });
  }
};
var Certificate = class extends StringObject {
  constructor(e2) {
    super(Go, "certificate");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Certificates = class extends XFAObject {
  constructor(e2) {
    super(Go, "certificates", true);
    this.credentialServerPolicy = getStringOption(e2.credentialServerPolicy, ["optional", "required"]);
    this.id = e2.id || "";
    this.url = e2.url || "";
    this.urlPolicy = e2.urlPolicy || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.encryption = null;
    this.issuers = null;
    this.keyUsage = null;
    this.oids = null;
    this.signing = null;
    this.subjectDNs = null;
  }
};
var CheckButton = class extends XFAObject {
  constructor(e2) {
    super(Go, "checkButton", true);
    this.id = e2.id || "";
    this.mark = getStringOption(e2.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]);
    this.shape = getStringOption(e2.shape, ["square", "round"]);
    this.size = getMeasurement(e2.size, "10pt");
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [co](e2) {
    const t2 = toStyle(this, "margin"), a2 = measureToString(this.size);
    t2.width = t2.height = a2;
    let r2, i2, n2;
    const s2 = this[vs]()[vs](), o2 = s2.items.children.length && s2.items.children[0][co]().html || [], c2 = { on: (void 0 !== o2[0] ? o2[0] : "on").toString(), off: (void 0 !== o2[1] ? o2[1] : "off").toString() }, l2 = (s2.value?.[so]() || "off") === c2.on || void 0, h2 = s2[Cs](), u2 = s2[uo];
    let d2;
    if (h2 instanceof ExclGroup) {
      n2 = h2[uo];
      r2 = "radio";
      i2 = "xfaRadio";
      d2 = h2[os]?.[uo] || h2[uo];
    } else {
      r2 = "checkbox";
      i2 = "xfaCheckbox";
      d2 = s2[os]?.[uo] || s2[uo];
    }
    const f2 = { name: "input", attributes: { class: [i2], style: t2, fieldId: u2, dataId: d2, type: r2, checked: l2, xfaOn: c2.on, xfaOff: c2.off, "aria-label": ariaLabel(s2), "aria-required": false } };
    n2 && (f2.attributes.name = n2);
    if (isRequired(s2)) {
      f2.attributes["aria-required"] = true;
      f2.attributes.required = true;
    }
    return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [f2] });
  }
};
var ChoiceList = class extends XFAObject {
  constructor(e2) {
    super(Go, "choiceList", true);
    this.commitOn = getStringOption(e2.commitOn, ["select", "exit"]);
    this.id = e2.id || "";
    this.open = getStringOption(e2.open, ["userControl", "always", "multiSelect", "onEntry"]);
    this.textEntry = getInteger({ data: e2.textEntry, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [co](e2) {
    const t2 = toStyle(this, "border", "margin"), a2 = this[vs]()[vs](), r2 = { fontSize: `calc(${a2.font?.size || 10}px * var(--total-scale-factor))` }, i2 = [];
    if (a2.items.children.length > 0) {
      const e3 = a2.items;
      let t3 = 0, n3 = 0;
      if (2 === e3.children.length) {
        t3 = e3.children[0].save;
        n3 = 1 - t3;
      }
      const s2 = e3.children[t3][co]().html, o2 = e3.children[n3][co]().html;
      let c2 = false;
      const l2 = a2.value?.[so]() || "";
      for (let e4 = 0, t4 = s2.length; e4 < t4; e4++) {
        const t5 = { name: "option", attributes: { value: o2[e4] || s2[e4], style: r2 }, value: s2[e4] };
        o2[e4] === l2 && (t5.attributes.selected = c2 = true);
        i2.push(t5);
      }
      c2 || i2.splice(0, 0, { name: "option", attributes: { hidden: true, selected: true }, value: " " });
    }
    const n2 = { class: ["xfaSelect"], fieldId: a2[uo], dataId: a2[os]?.[uo] || a2[uo], style: t2, "aria-label": ariaLabel(a2), "aria-required": false };
    if (isRequired(a2)) {
      n2["aria-required"] = true;
      n2.required = true;
    }
    "multiSelect" === this.open && (n2.multiple = true);
    return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [{ name: "select", children: i2, attributes: n2 }] });
  }
};
var Color = class extends XFAObject {
  constructor(e2) {
    super(Go, "color", true);
    this.cSpace = getStringOption(e2.cSpace, ["SRGB"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.value = e2.value ? (function getColor(e3, t2 = [0, 0, 0]) {
      let [a2, r2, i2] = t2;
      if (!e3) return { r: a2, g: r2, b: i2 };
      const n2 = e3.split(",", 3).map(((e4) => MathClamp(parseInt(e4.trim(), 10), 0, 255))).map(((e4) => isNaN(e4) ? 0 : e4));
      if (n2.length < 3) return { r: a2, g: r2, b: i2 };
      [a2, r2, i2] = n2;
      return { r: a2, g: r2, b: i2 };
    })(e2.value) : "";
    this.extras = null;
  }
  [Ts]() {
    return false;
  }
  [ho]() {
    return this.value ? Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
  }
};
var Comb = class extends XFAObject {
  constructor(e2) {
    super(Go, "comb");
    this.id = e2.id || "";
    this.numberOfCells = getInteger({ data: e2.numberOfCells, defaultValue: 0, validate: (e3) => e3 >= 0 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Connect = class extends XFAObject {
  constructor(e2) {
    super(Go, "connect", true);
    this.connection = e2.connection || "";
    this.id = e2.id || "";
    this.ref = e2.ref || "";
    this.usage = getStringOption(e2.usage, ["exportAndImport", "exportOnly", "importOnly"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.picture = null;
  }
};
var ContentArea = class extends XFAObject {
  constructor(e2) {
    super(Go, "contentArea", true);
    this.h = getMeasurement(e2.h);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.w = getMeasurement(e2.w);
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.desc = null;
    this.extras = null;
  }
  [co](e2) {
    const t2 = { left: measureToString(this.x), top: measureToString(this.y), width: measureToString(this.w), height: measureToString(this.h) }, a2 = ["xfaContentarea"];
    isPrintOnly(this) && a2.push("xfaPrintOnly");
    return HTMLResult.success({ name: "div", children: [], attributes: { style: t2, class: a2, id: this[uo] } });
  }
};
var Corner = class extends XFAObject {
  constructor(e2) {
    super(Go, "corner", true);
    this.id = e2.id || "";
    this.inverted = getInteger({ data: e2.inverted, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.join = getStringOption(e2.join, ["square", "round"]);
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.radius = getMeasurement(e2.radius);
    this.stroke = getStringOption(e2.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = getMeasurement(e2.thickness, "0.5pt");
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [ho]() {
    const e2 = toStyle(this, "visibility");
    e2.radius = measureToString("square" === this.join ? 0 : this.radius);
    return e2;
  }
};
var DateElement = class extends ContentObject {
  constructor(e2) {
    super(Go, "date");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [hs]() {
    const e2 = this[ss].trim();
    this[ss] = e2 ? new Date(e2) : null;
  }
  [co](e2) {
    return valueToHtml(this[ss] ? this[ss].toString() : "");
  }
};
var DateTime = class extends ContentObject {
  constructor(e2) {
    super(Go, "dateTime");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [hs]() {
    const e2 = this[ss].trim();
    this[ss] = e2 ? new Date(e2) : null;
  }
  [co](e2) {
    return valueToHtml(this[ss] ? this[ss].toString() : "");
  }
};
var DateTimeEdit = class extends XFAObject {
  constructor(e2) {
    super(Go, "dateTimeEdit", true);
    this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]);
    this.id = e2.id || "";
    this.picker = getStringOption(e2.picker, ["host", "none"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [co](e2) {
    const t2 = toStyle(this, "border", "font", "margin"), a2 = this[vs]()[vs](), r2 = { name: "input", attributes: { type: "text", fieldId: a2[uo], dataId: a2[os]?.[uo] || a2[uo], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(a2), "aria-required": false } };
    if (isRequired(a2)) {
      r2.attributes["aria-required"] = true;
      r2.attributes.required = true;
    }
    return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [r2] });
  }
};
var Decimal = class extends ContentObject {
  constructor(e2) {
    super(Go, "decimal");
    this.fracDigits = getInteger({ data: e2.fracDigits, defaultValue: 2, validate: (e3) => true });
    this.id = e2.id || "";
    this.leadDigits = getInteger({ data: e2.leadDigits, defaultValue: -1, validate: (e3) => true });
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [hs]() {
    const e2 = parseFloat(this[ss].trim());
    this[ss] = isNaN(e2) ? null : e2;
  }
  [co](e2) {
    return valueToHtml(null !== this[ss] ? this[ss].toString() : "");
  }
};
var DefaultUi = class extends XFAObject {
  constructor(e2) {
    super(Go, "defaultUi", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
};
var Desc = class extends XFAObject {
  constructor(e2) {
    super(Go, "desc", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
};
var DigestMethod = class extends OptionObject {
  constructor(e2) {
    super(Go, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var DigestMethods = class extends XFAObject {
  constructor(e2) {
    super(Go, "digestMethods", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.digestMethod = new XFAObjectArray();
  }
};
var Draw = class extends XFAObject {
  constructor(e2) {
    super(Go, "draw", true);
    this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 });
    this.h = e2.h ? getMeasurement(e2.h) : "";
    this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = e2.id || "";
    this.locale = e2.locale || "";
    this.maxH = getMeasurement(e2.maxH, "0pt");
    this.maxW = getMeasurement(e2.maxW, "0pt");
    this.minH = getMeasurement(e2.minH, "0pt");
    this.minW = getMeasurement(e2.minW, "0pt");
    this.name = e2.name || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(e2.relevant);
    this.rotate = getInteger({ data: e2.rotate, defaultValue: 0, validate: (e3) => e3 % 90 == 0 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.w = e2.w ? getMeasurement(e2.w) : "";
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.assist = null;
    this.border = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.value = null;
    this.setProperty = new XFAObjectArray();
  }
  [io](e2) {
    _setValue(this, e2);
  }
  [co](e2) {
    setTabIndex(this);
    if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
    fixDimensions(this);
    this[Ys]();
    const t2 = this.w, a2 = this.h, { w: r2, h: i2, isBroken: n2 } = layoutNode(this, e2);
    if (r2 && "" === this.w) {
      if (n2 && this[Cs]()[_s]()) {
        this[Js]();
        return HTMLResult.FAILURE;
      }
      this.w = r2;
    }
    i2 && "" === this.h && (this.h = i2);
    setFirstUnsplittable(this);
    if (!checkDimensions(this, e2)) {
      this.w = t2;
      this.h = a2;
      this[Js]();
      return HTMLResult.FAILURE;
    }
    unsetFirstUnsplittable(this);
    const s2 = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
    setMinMaxDimensions(this, s2);
    if (s2.margin) {
      s2.padding = s2.margin;
      delete s2.margin;
    }
    const o2 = ["xfaDraw"];
    this.font && o2.push("xfaFont");
    isPrintOnly(this) && o2.push("xfaPrintOnly");
    const c2 = { style: s2, id: this[uo], class: o2 };
    this.name && (c2.xfaName = this.name);
    const l2 = { name: "div", attributes: c2, children: [] };
    applyAssist(this, c2);
    const h2 = computeBbox(this, l2, e2), u2 = this.value ? this.value[co](e2).html : null;
    if (null === u2) {
      this.w = t2;
      this.h = a2;
      this[Js]();
      return HTMLResult.success(createWrapper(this, l2), h2);
    }
    l2.children.push(u2);
    setPara(this, s2, u2);
    this.w = t2;
    this.h = a2;
    this[Js]();
    return HTMLResult.success(createWrapper(this, l2), h2);
  }
};
var Edge = class extends XFAObject {
  constructor(e2) {
    super(Go, "edge", true);
    this.cap = getStringOption(e2.cap, ["square", "butt", "round"]);
    this.id = e2.id || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.stroke = getStringOption(e2.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]);
    this.thickness = getMeasurement(e2.thickness, "0.5pt");
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [ho]() {
    const e2 = toStyle(this, "visibility");
    Object.assign(e2, { linecap: this.cap, width: measureToString(this.thickness), color: this.color ? this.color[ho]() : "#000000", style: "" });
    if ("visible" !== this.presence) e2.style = "none";
    else switch (this.stroke) {
      case "solid":
        e2.style = "solid";
        break;
      case "dashDot":
      case "dashDotDot":
      case "dashed":
        e2.style = "dashed";
        break;
      case "dotted":
        e2.style = "dotted";
        break;
      case "embossed":
        e2.style = "ridge";
        break;
      case "etched":
        e2.style = "groove";
        break;
      case "lowered":
        e2.style = "inset";
        break;
      case "raised":
        e2.style = "outset";
    }
    return e2;
  }
};
var Encoding = class extends OptionObject {
  constructor(e2) {
    super(Go, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Encodings = class extends XFAObject {
  constructor(e2) {
    super(Go, "encodings", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.encoding = new XFAObjectArray();
  }
};
var Encrypt = class extends XFAObject {
  constructor(e2) {
    super(Go, "encrypt", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.certificate = null;
  }
};
var EncryptData = class extends XFAObject {
  constructor(e2) {
    super(Go, "encryptData", true);
    this.id = e2.id || "";
    this.operation = getStringOption(e2.operation, ["encrypt", "decrypt"]);
    this.target = e2.target || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.filter = null;
    this.manifest = null;
  }
};
var Encryption = class extends XFAObject {
  constructor(e2) {
    super(Go, "encryption", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.certificate = new XFAObjectArray();
  }
};
var EncryptionMethod = class extends OptionObject {
  constructor(e2) {
    super(Go, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var EncryptionMethods = class extends XFAObject {
  constructor(e2) {
    super(Go, "encryptionMethods", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.encryptionMethod = new XFAObjectArray();
  }
};
var Event = class extends XFAObject {
  constructor(e2) {
    super(Go, "event", true);
    this.activity = getStringOption(e2.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]);
    this.id = e2.id || "";
    this.listen = getStringOption(e2.listen, ["refOnly", "refAndDescendents"]);
    this.name = e2.name || "";
    this.ref = e2.ref || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.encryptData = null;
    this.execute = null;
    this.script = null;
    this.signData = null;
    this.submit = null;
  }
};
var ExData = class extends ContentObject {
  constructor(e2) {
    super(Go, "exData");
    this.contentType = e2.contentType || "";
    this.href = e2.href || "";
    this.id = e2.id || "";
    this.maxLength = getInteger({ data: e2.maxLength, defaultValue: -1, validate: (e3) => e3 >= -1 });
    this.name = e2.name || "";
    this.rid = e2.rid || "";
    this.transferEncoding = getStringOption(e2.transferEncoding, ["none", "base64", "package"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [Bs]() {
    return "text/html" === this.contentType;
  }
  [$s](e2) {
    if ("text/html" === this.contentType && e2[Hs] === go.xhtml.id) {
      this[ss] = e2;
      return true;
    }
    if ("text/xml" === this.contentType) {
      this[ss] = e2;
      return true;
    }
    return false;
  }
  [co](e2) {
    return "text/html" === this.contentType && this[ss] ? this[ss][co](e2) : HTMLResult.EMPTY;
  }
};
var ExObject = class extends XFAObject {
  constructor(e2) {
    super(Go, "exObject", true);
    this.archive = e2.archive || "";
    this.classId = e2.classId || "";
    this.codeBase = e2.codeBase || "";
    this.codeType = e2.codeType || "";
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
};
var ExclGroup = class extends XFAObject {
  constructor(e2) {
    super(Go, "exclGroup", true);
    this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = e2.accessKey || "";
    this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 });
    this.h = e2.h ? getMeasurement(e2.h) : "";
    this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = e2.id || "";
    this.layout = getStringOption(e2.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.maxH = getMeasurement(e2.maxH, "0pt");
    this.maxW = getMeasurement(e2.maxW, "0pt");
    this.minH = getMeasurement(e2.minH, "0pt");
    this.minW = getMeasurement(e2.minW, "0pt");
    this.name = e2.name || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.w = e2.w ? getMeasurement(e2.w) : "";
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.connect = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
  }
  [Rs]() {
    return true;
  }
  [Ts]() {
    return true;
  }
  [io](e2) {
    for (const t2 of this.field.children) {
      if (!t2.value) {
        const e3 = new Value({});
        t2[Qn](e3);
        t2.value = e3;
      }
      t2.value[io](e2);
    }
  }
  [_s]() {
    return this.layout.endsWith("-tb") && 0 === this[ls].attempt && this[ls].numberInLine > 0 || this[vs]()[_s]();
  }
  [js]() {
    const e2 = this[Cs]();
    if (!e2[js]()) return false;
    if (void 0 !== this[ls]._isSplittable) return this[ls]._isSplittable;
    if ("position" === this.layout || this.layout.includes("row")) {
      this[ls]._isSplittable = false;
      return false;
    }
    if (e2.layout?.endsWith("-tb") && 0 !== e2[ls].numberInLine) return false;
    this[ls]._isSplittable = true;
    return true;
  }
  [us]() {
    return flushHTML(this);
  }
  [Zn](e2, t2) {
    addHTML(this, e2, t2);
  }
  [gs]() {
    return getAvailableSpace(this);
  }
  [co](e2) {
    setTabIndex(this);
    if ("hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
    fixDimensions(this);
    const t2 = [], a2 = { id: this[uo], class: [] };
    setAccess(this, a2.class);
    this[ls] ||= /* @__PURE__ */ Object.create(null);
    Object.assign(this[ls], { children: t2, attributes: a2, attempt: 0, line: null, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e2.width), height: Math.min(this.h || 1 / 0, e2.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
    const r2 = this[js]();
    r2 || setFirstUnsplittable(this);
    if (!checkDimensions(this, e2)) return HTMLResult.FAILURE;
    const i2 = /* @__PURE__ */ new Set(["field"]);
    if (this.layout.includes("row")) {
      const e3 = this[Cs]().columnWidths;
      if (Array.isArray(e3) && e3.length > 0) {
        this[ls].columnWidths = e3;
        this[ls].currentColumn = 0;
      }
    }
    const n2 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), s2 = ["xfaExclgroup"], o2 = layoutClass(this);
    o2 && s2.push(o2);
    isPrintOnly(this) && s2.push("xfaPrintOnly");
    a2.style = n2;
    a2.class = s2;
    this.name && (a2.xfaName = this.name);
    this[Ys]();
    const c2 = "lr-tb" === this.layout || "rl-tb" === this.layout, l2 = c2 ? 2 : 1;
    for (; this[ls].attempt < l2; this[ls].attempt++) {
      c2 && 1 === this[ls].attempt && (this[ls].numberInLine = 0);
      const e3 = this[es]({ filter: i2, include: true });
      if (e3.success) break;
      if (e3.isBreak()) {
        this[Js]();
        return e3;
      }
      if (c2 && 0 === this[ls].attempt && 0 === this[ls].numberInLine && !this[Fs]()[ls].noLayoutFailure) {
        this[ls].attempt = l2;
        break;
      }
    }
    this[Js]();
    r2 || unsetFirstUnsplittable(this);
    if (this[ls].attempt === l2) {
      r2 || delete this[ls];
      return HTMLResult.FAILURE;
    }
    let h2 = 0, u2 = 0;
    if (this.margin) {
      h2 = this.margin.leftInset + this.margin.rightInset;
      u2 = this.margin.topInset + this.margin.bottomInset;
    }
    const d2 = Math.max(this[ls].width + h2, this.w || 0), f2 = Math.max(this[ls].height + u2, this.h || 0), g2 = [this.x, this.y, d2, f2];
    "" === this.w && (n2.width = measureToString(d2));
    "" === this.h && (n2.height = measureToString(f2));
    const p2 = { name: "div", attributes: a2, children: t2 };
    applyAssist(this, a2);
    delete this[ls];
    return HTMLResult.success(createWrapper(this, p2), g2);
  }
};
var Execute = class extends XFAObject {
  constructor(e2) {
    super(Go, "execute");
    this.connection = e2.connection || "";
    this.executeType = getStringOption(e2.executeType, ["import", "remerge"]);
    this.id = e2.id || "";
    this.runAt = getStringOption(e2.runAt, ["client", "both", "server"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Extras = class extends XFAObject {
  constructor(e2) {
    super(Go, "extras", true);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.extras = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
};
var Field = class extends XFAObject {
  constructor(e2) {
    super(Go, "field", true);
    this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.accessKey = e2.accessKey || "";
    this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 });
    this.h = e2.h ? getMeasurement(e2.h) : "";
    this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = e2.id || "";
    this.locale = e2.locale || "";
    this.maxH = getMeasurement(e2.maxH, "0pt");
    this.maxW = getMeasurement(e2.maxW, "0pt");
    this.minH = getMeasurement(e2.minH, "0pt");
    this.minW = getMeasurement(e2.minW, "0pt");
    this.name = e2.name || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(e2.relevant);
    this.rotate = getInteger({ data: e2.rotate, defaultValue: 0, validate: (e3) => e3 % 90 == 0 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.w = e2.w ? getMeasurement(e2.w) : "";
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.border = null;
    this.calculate = null;
    this.caption = null;
    this.desc = null;
    this.extras = null;
    this.font = null;
    this.format = null;
    this.items = new XFAObjectArray(2);
    this.keep = null;
    this.margin = null;
    this.para = null;
    this.traversal = null;
    this.ui = null;
    this.validate = null;
    this.value = null;
    this.bindItems = new XFAObjectArray();
    this.connect = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
  }
  [Rs]() {
    return true;
  }
  [io](e2) {
    _setValue(this, e2);
  }
  [co](e2) {
    setTabIndex(this);
    if (!this.ui) {
      this.ui = new Ui({});
      this.ui[Is] = this[Is];
      this[Qn](this.ui);
      let e3;
      switch (this.items.children.length) {
        case 0:
          e3 = new TextEdit({});
          this.ui.textEdit = e3;
          break;
        case 1:
          e3 = new CheckButton({});
          this.ui.checkButton = e3;
          break;
        case 2:
          e3 = new ChoiceList({});
          this.ui.choiceList = e3;
      }
      this.ui[Qn](e3);
    }
    if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
    this.caption && delete this.caption[ls];
    this[Ys]();
    const t2 = this.caption ? this.caption[co](e2).html : null, a2 = this.w, r2 = this.h;
    let i2 = 0, n2 = 0;
    if (this.margin) {
      i2 = this.margin.leftInset + this.margin.rightInset;
      n2 = this.margin.topInset + this.margin.bottomInset;
    }
    let s2 = null;
    if ("" === this.w || "" === this.h) {
      let t3 = null, a3 = null, r3 = 0, o3 = 0;
      if (this.ui.checkButton) r3 = o3 = this.ui.checkButton.size;
      else {
        const { w: t4, h: a4 } = layoutNode(this, e2);
        if (null !== t4) {
          r3 = t4;
          o3 = a4;
        } else o3 = (function fonts_getMetrics(e3, t5 = false) {
          let a5 = null;
          if (e3) {
            const t6 = stripQuotes(e3.typeface), r5 = e3[Is].fontFinder.find(t6);
            a5 = selectFont(e3, r5);
          }
          if (!a5) return { lineHeight: 12, lineGap: 2, lineNoGap: 10 };
          const r4 = e3.size || 10, i3 = a5.lineHeight ? Math.max(t5 ? 0 : 1.2, a5.lineHeight) : 1.2, n3 = void 0 === a5.lineGap ? 0.2 : a5.lineGap;
          return { lineHeight: i3 * r4, lineGap: n3 * r4, lineNoGap: Math.max(1, i3 - n3) * r4 };
        })(this.font, true).lineNoGap;
      }
      s2 = getBorderDims(this.ui[ws]());
      r3 += s2.w;
      o3 += s2.h;
      if (this.caption) {
        const { w: i3, h: n3, isBroken: s3 } = this.caption[ws](e2);
        if (s3 && this[Cs]()[_s]()) {
          this[Js]();
          return HTMLResult.FAILURE;
        }
        t3 = i3;
        a3 = n3;
        switch (this.caption.placement) {
          case "left":
          case "right":
          case "inline":
            t3 += r3;
            break;
          case "top":
          case "bottom":
            a3 += o3;
        }
      } else {
        t3 = r3;
        a3 = o3;
      }
      if (t3 && "" === this.w) {
        t3 += i2;
        this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t3 ? t3 : this.minW);
      }
      if (a3 && "" === this.h) {
        a3 += n2;
        this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < a3 ? a3 : this.minH);
      }
    }
    this[Js]();
    fixDimensions(this);
    setFirstUnsplittable(this);
    if (!checkDimensions(this, e2)) {
      this.w = a2;
      this.h = r2;
      this[Js]();
      return HTMLResult.FAILURE;
    }
    unsetFirstUnsplittable(this);
    const o2 = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
    setMinMaxDimensions(this, o2);
    const c2 = ["xfaField"];
    this.font && c2.push("xfaFont");
    isPrintOnly(this) && c2.push("xfaPrintOnly");
    const l2 = { style: o2, id: this[uo], class: c2 };
    if (o2.margin) {
      o2.padding = o2.margin;
      delete o2.margin;
    }
    setAccess(this, c2);
    this.name && (l2.xfaName = this.name);
    const h2 = [], u2 = { name: "div", attributes: l2, children: h2 };
    applyAssist(this, l2);
    const d2 = this.border ? this.border[ho]() : null, f2 = computeBbox(this, u2, e2), g2 = this.ui[co]().html;
    if (!g2) {
      Object.assign(o2, d2);
      return HTMLResult.success(createWrapper(this, u2), f2);
    }
    this[no] && (g2.children?.[0] ? g2.children[0].attributes.tabindex = this[no] : g2.attributes.tabindex = this[no]);
    g2.attributes.style ||= /* @__PURE__ */ Object.create(null);
    let p2 = null;
    if (this.ui.button) {
      1 === g2.children.length && ([p2] = g2.children.splice(0, 1));
      Object.assign(g2.attributes.style, d2);
    } else Object.assign(o2, d2);
    h2.push(g2);
    if (this.value) {
      if (this.ui.imageEdit) g2.children.push(this.value[co]().html);
      else if (!this.ui.button) {
        let e3 = "";
        if (this.value.exData) e3 = this.value.exData[so]();
        else if (this.value.text) e3 = this.value.text[ws]();
        else {
          const t3 = this.value[co]().html;
          null !== t3 && (e3 = t3.children[0].value);
        }
        this.ui.textEdit && this.value.text?.maxChars && (g2.children[0].attributes.maxLength = this.value.text.maxChars);
        if (e3) {
          if (this.ui.numericEdit) {
            e3 = parseFloat(e3);
            e3 = isNaN(e3) ? "" : e3.toString();
          }
          "textarea" === g2.children[0].name ? g2.children[0].attributes.textContent = e3 : g2.children[0].attributes.value = e3;
        }
      }
    }
    if (!this.ui.imageEdit && g2.children?.[0] && this.h) {
      s2 = s2 || getBorderDims(this.ui[ws]());
      let t3 = 0;
      if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
        t3 = this.caption.reserve;
        t3 <= 0 && (t3 = this.caption[ws](e2).h);
        const a3 = this.h - t3 - n2 - s2.h;
        g2.children[0].attributes.style.height = measureToString(a3);
      } else g2.children[0].attributes.style.height = "100%";
    }
    p2 && g2.children.push(p2);
    if (!t2) {
      g2.attributes.class && g2.attributes.class.push("xfaLeft");
      this.w = a2;
      this.h = r2;
      return HTMLResult.success(createWrapper(this, u2), f2);
    }
    if (this.ui.button) {
      o2.padding && delete o2.padding;
      "div" === t2.name && (t2.name = "span");
      g2.children.push(t2);
      return HTMLResult.success(u2, f2);
    }
    this.ui.checkButton && (t2.attributes.class[0] = "xfaCaptionForCheckButton");
    g2.attributes.class ||= [];
    g2.children.splice(0, 0, t2);
    switch (this.caption.placement) {
      case "left":
      case "inline":
        g2.attributes.class.push("xfaLeft");
        break;
      case "right":
        g2.attributes.class.push("xfaRight");
        break;
      case "top":
        g2.attributes.class.push("xfaTop");
        break;
      case "bottom":
        g2.attributes.class.push("xfaBottom");
    }
    this.w = a2;
    this.h = r2;
    return HTMLResult.success(createWrapper(this, u2), f2);
  }
};
var Fill = class extends XFAObject {
  constructor(e2) {
    super(Go, "fill", true);
    this.id = e2.id || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
    this.linear = null;
    this.pattern = null;
    this.radial = null;
    this.solid = null;
    this.stipple = null;
  }
  [ho]() {
    const e2 = this[vs](), t2 = e2[vs]()[vs](), a2 = /* @__PURE__ */ Object.create(null);
    let r2 = "color", i2 = r2;
    if (e2 instanceof Border) {
      r2 = "background-color";
      i2 = "background";
      t2 instanceof Ui && (a2.backgroundColor = "white");
    }
    if (e2 instanceof Rectangle || e2 instanceof Arc) {
      r2 = i2 = "fill";
      a2.fill = "white";
    }
    for (const e3 of Object.getOwnPropertyNames(this)) {
      if ("extras" === e3 || "color" === e3) continue;
      const t3 = this[e3];
      if (!(t3 instanceof XFAObject)) continue;
      const n2 = t3[ho](this.color);
      n2 && (a2[n2.startsWith("#") ? r2 : i2] = n2);
      return a2;
    }
    if (this.color?.value) {
      const e3 = this.color[ho]();
      a2[e3.startsWith("#") ? r2 : i2] = e3;
    }
    return a2;
  }
};
var Filter = class extends XFAObject {
  constructor(e2) {
    super(Go, "filter", true);
    this.addRevocationInfo = getStringOption(e2.addRevocationInfo, ["", "required", "optional", "none"]);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.version = getInteger({ data: this.version, defaultValue: 5, validate: (e3) => e3 >= 1 && e3 <= 5 });
    this.appearanceFilter = null;
    this.certificates = null;
    this.digestMethods = null;
    this.encodings = null;
    this.encryptionMethods = null;
    this.handler = null;
    this.lockDocument = null;
    this.mdp = null;
    this.reasons = null;
    this.timeStamp = null;
  }
};
var Float = class extends ContentObject {
  constructor(e2) {
    super(Go, "float");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [hs]() {
    const e2 = parseFloat(this[ss].trim());
    this[ss] = isNaN(e2) ? null : e2;
  }
  [co](e2) {
    return valueToHtml(null !== this[ss] ? this[ss].toString() : "");
  }
};
var template_Font = class extends XFAObject {
  constructor(e2) {
    super(Go, "font", true);
    this.baselineShift = getMeasurement(e2.baselineShift);
    this.fontHorizontalScale = getFloat({ data: e2.fontHorizontalScale, defaultValue: 100, validate: (e3) => e3 >= 0 });
    this.fontVerticalScale = getFloat({ data: e2.fontVerticalScale, defaultValue: 100, validate: (e3) => e3 >= 0 });
    this.id = e2.id || "";
    this.kerningMode = getStringOption(e2.kerningMode, ["none", "pair"]);
    this.letterSpacing = getMeasurement(e2.letterSpacing, "0");
    this.lineThrough = getInteger({ data: e2.lineThrough, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 });
    this.lineThroughPeriod = getStringOption(e2.lineThroughPeriod, ["all", "word"]);
    this.overline = getInteger({ data: e2.overline, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 });
    this.overlinePeriod = getStringOption(e2.overlinePeriod, ["all", "word"]);
    this.posture = getStringOption(e2.posture, ["normal", "italic"]);
    this.size = getMeasurement(e2.size, "10pt");
    this.typeface = e2.typeface || "Courier";
    this.underline = getInteger({ data: e2.underline, defaultValue: 0, validate: (e3) => 1 === e3 || 2 === e3 });
    this.underlinePeriod = getStringOption(e2.underlinePeriod, ["all", "word"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.weight = getStringOption(e2.weight, ["normal", "bold"]);
    this.extras = null;
    this.fill = null;
  }
  [ts](e2) {
    super[ts](e2);
    this[Is].usedTypefaces.add(this.typeface);
  }
  [ho]() {
    const e2 = toStyle(this, "fill"), t2 = e2.color;
    if (t2) {
      if ("#000000" === t2) delete e2.color;
      else if (!t2.startsWith("#")) {
        e2.background = t2;
        e2.backgroundClip = "text";
        e2.color = "transparent";
      }
    }
    this.baselineShift && (e2.verticalAlign = measureToString(this.baselineShift));
    e2.fontKerning = "none" === this.kerningMode ? "none" : "normal";
    e2.letterSpacing = measureToString(this.letterSpacing);
    if (0 !== this.lineThrough) {
      e2.textDecoration = "line-through";
      2 === this.lineThrough && (e2.textDecorationStyle = "double");
    }
    if (0 !== this.overline) {
      e2.textDecoration = "overline";
      2 === this.overline && (e2.textDecorationStyle = "double");
    }
    e2.fontStyle = this.posture;
    e2.fontSize = measureToString(0.99 * this.size);
    setFontFamily(this, this, this[Is].fontFinder, e2);
    if (0 !== this.underline) {
      e2.textDecoration = "underline";
      2 === this.underline && (e2.textDecorationStyle = "double");
    }
    e2.fontWeight = this.weight;
    return e2;
  }
};
var Format = class extends XFAObject {
  constructor(e2) {
    super(Go, "format", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.picture = null;
  }
};
var Handler = class extends StringObject {
  constructor(e2) {
    super(Go, "handler");
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Hyphenation = class extends XFAObject {
  constructor(e2) {
    super(Go, "hyphenation");
    this.excludeAllCaps = getInteger({ data: e2.excludeAllCaps, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.excludeInitialCap = getInteger({ data: e2.excludeInitialCap, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.hyphenate = getInteger({ data: e2.hyphenate, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.id = e2.id || "";
    this.pushCharacterCount = getInteger({ data: e2.pushCharacterCount, defaultValue: 3, validate: (e3) => e3 >= 0 });
    this.remainCharacterCount = getInteger({ data: e2.remainCharacterCount, defaultValue: 3, validate: (e3) => e3 >= 0 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.wordCharacterCount = getInteger({ data: e2.wordCharacterCount, defaultValue: 7, validate: (e3) => e3 >= 0 });
  }
};
var Image = class extends StringObject {
  constructor(e2) {
    super(Go, "image");
    this.aspect = getStringOption(e2.aspect, ["fit", "actual", "height", "none", "width"]);
    this.contentType = e2.contentType || "";
    this.href = e2.href || "";
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.transferEncoding = getStringOption(e2.transferEncoding, ["base64", "none", "package"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [co]() {
    if (this.contentType && !Jo.has(this.contentType.toLowerCase())) return HTMLResult.EMPTY;
    let e2 = this[Is].images?.get(this.href);
    if (!e2 && (this.href || !this[ss])) return HTMLResult.EMPTY;
    e2 || "base64" !== this.transferEncoding || (e2 = (function fromBase64Util(e3) {
      return Uint8Array.fromBase64 ? Uint8Array.fromBase64(e3) : stringToBytes(atob(e3));
    })(this[ss]));
    if (!e2) return HTMLResult.EMPTY;
    if (!this.contentType) {
      for (const [t3, a3] of Yo) if (e2.length > t3.length && t3.every(((t4, a4) => t4 === e2[a4]))) {
        this.contentType = a3;
        break;
      }
      if (!this.contentType) return HTMLResult.EMPTY;
    }
    const t2 = new Blob([e2], { type: this.contentType });
    let a2;
    switch (this.aspect) {
      case "fit":
      case "actual":
        break;
      case "height":
        a2 = { height: "100%", objectFit: "fill" };
        break;
      case "none":
        a2 = { width: "100%", height: "100%", objectFit: "fill" };
        break;
      case "width":
        a2 = { width: "100%", objectFit: "fill" };
    }
    const r2 = this[vs]();
    return HTMLResult.success({ name: "img", attributes: { class: ["xfaImage"], style: a2, src: URL.createObjectURL(t2), alt: r2 ? ariaLabel(r2[vs]()) : null } });
  }
};
var ImageEdit = class extends XFAObject {
  constructor(e2) {
    super(Go, "imageEdit", true);
    this.data = getStringOption(e2.data, ["link", "embed"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
  [co](e2) {
    return "embed" === this.data ? HTMLResult.success({ name: "div", children: [], attributes: {} }) : HTMLResult.EMPTY;
  }
};
var Integer = class extends ContentObject {
  constructor(e2) {
    super(Go, "integer");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [hs]() {
    const e2 = parseInt(this[ss].trim(), 10);
    this[ss] = isNaN(e2) ? null : e2;
  }
  [co](e2) {
    return valueToHtml(null !== this[ss] ? this[ss].toString() : "");
  }
};
var Issuers = class extends XFAObject {
  constructor(e2) {
    super(Go, "issuers", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.certificate = new XFAObjectArray();
  }
};
var Items = class extends XFAObject {
  constructor(e2) {
    super(Go, "items", true);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.ref = e2.ref || "";
    this.save = getInteger({ data: e2.save, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
  [co]() {
    const e2 = [];
    for (const t2 of this[Ss]()) e2.push(t2[so]());
    return HTMLResult.success(e2);
  }
};
var Keep = class extends XFAObject {
  constructor(e2) {
    super(Go, "keep", true);
    this.id = e2.id || "";
    const t2 = ["none", "contentArea", "pageArea"];
    this.intact = getStringOption(e2.intact, t2);
    this.next = getStringOption(e2.next, t2);
    this.previous = getStringOption(e2.previous, t2);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
};
var KeyUsage = class extends XFAObject {
  constructor(e2) {
    super(Go, "keyUsage");
    const t2 = ["", "yes", "no"];
    this.crlSign = getStringOption(e2.crlSign, t2);
    this.dataEncipherment = getStringOption(e2.dataEncipherment, t2);
    this.decipherOnly = getStringOption(e2.decipherOnly, t2);
    this.digitalSignature = getStringOption(e2.digitalSignature, t2);
    this.encipherOnly = getStringOption(e2.encipherOnly, t2);
    this.id = e2.id || "";
    this.keyAgreement = getStringOption(e2.keyAgreement, t2);
    this.keyCertSign = getStringOption(e2.keyCertSign, t2);
    this.keyEncipherment = getStringOption(e2.keyEncipherment, t2);
    this.nonRepudiation = getStringOption(e2.nonRepudiation, t2);
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Line = class extends XFAObject {
  constructor(e2) {
    super(Go, "line", true);
    this.hand = getStringOption(e2.hand, ["even", "left", "right"]);
    this.id = e2.id || "";
    this.slope = getStringOption(e2.slope, ["\\", "/"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.edge = null;
  }
  [co]() {
    const e2 = this[vs]()[vs](), t2 = this.edge || new Edge({}), a2 = t2[ho](), r2 = /* @__PURE__ */ Object.create(null), i2 = "visible" === t2.presence ? t2.thickness : 0;
    r2.strokeWidth = measureToString(i2);
    r2.stroke = a2.color;
    let n2, s2, o2, c2, l2 = "100%", h2 = "100%";
    if (e2.w <= i2) {
      [n2, s2, o2, c2] = ["50%", 0, "50%", "100%"];
      l2 = r2.strokeWidth;
    } else if (e2.h <= i2) {
      [n2, s2, o2, c2] = [0, "50%", "100%", "50%"];
      h2 = r2.strokeWidth;
    } else "\\" === this.slope ? [n2, s2, o2, c2] = [0, 0, "100%", "100%"] : [n2, s2, o2, c2] = [0, "100%", "100%", 0];
    const u2 = { name: "svg", children: [{ name: "line", attributes: { xmlns: Vo, x1: n2, y1: s2, x2: o2, y2: c2, style: r2 } }], attributes: { xmlns: Vo, width: l2, height: h2, style: { overflow: "visible" } } };
    if (hasMargin(e2)) return HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [u2] });
    u2.attributes.style.position = "absolute";
    return HTMLResult.success(u2);
  }
};
var Linear = class extends XFAObject {
  constructor(e2) {
    super(Go, "linear", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["toRight", "toBottom", "toLeft", "toTop"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [ho](e2) {
    e2 = e2 ? e2[ho]() : "#FFFFFF";
    return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e2}, ${this.color ? this.color[ho]() : "#000000"})`;
  }
};
var LockDocument = class extends ContentObject {
  constructor(e2) {
    super(Go, "lockDocument");
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [hs]() {
    this[ss] = getStringOption(this[ss], ["auto", "0", "1"]);
  }
};
var Manifest = class extends XFAObject {
  constructor(e2) {
    super(Go, "manifest", true);
    this.action = getStringOption(e2.action, ["include", "all", "exclude"]);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.ref = new XFAObjectArray();
  }
};
var Margin = class extends XFAObject {
  constructor(e2) {
    super(Go, "margin", true);
    this.bottomInset = getMeasurement(e2.bottomInset, "0");
    this.id = e2.id || "";
    this.leftInset = getMeasurement(e2.leftInset, "0");
    this.rightInset = getMeasurement(e2.rightInset, "0");
    this.topInset = getMeasurement(e2.topInset, "0");
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
  [ho]() {
    return { margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset) };
  }
};
var Mdp = class extends XFAObject {
  constructor(e2) {
    super(Go, "mdp");
    this.id = e2.id || "";
    this.permissions = getInteger({ data: e2.permissions, defaultValue: 2, validate: (e3) => 1 === e3 || 3 === e3 });
    this.signatureType = getStringOption(e2.signatureType, ["filler", "author"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Medium = class extends XFAObject {
  constructor(e2) {
    super(Go, "medium");
    this.id = e2.id || "";
    this.imagingBBox = (function getBBox(e3) {
      const t2 = -1;
      if (!e3) return { x: t2, y: t2, width: t2, height: t2 };
      const a2 = e3.split(",", 4).map(((e4) => getMeasurement(e4.trim(), "-1")));
      if (a2.length < 4 || a2[2] < 0 || a2[3] < 0) return { x: t2, y: t2, width: t2, height: t2 };
      const [r2, i2, n2, s2] = a2;
      return { x: r2, y: i2, width: n2, height: s2 };
    })(e2.imagingBBox);
    this.long = getMeasurement(e2.long);
    this.orientation = getStringOption(e2.orientation, ["portrait", "landscape"]);
    this.short = getMeasurement(e2.short);
    this.stock = e2.stock || "";
    this.trayIn = getStringOption(e2.trayIn, ["auto", "delegate", "pageFront"]);
    this.trayOut = getStringOption(e2.trayOut, ["auto", "delegate"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Message = class extends XFAObject {
  constructor(e2) {
    super(Go, "message", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.text = new XFAObjectArray();
  }
};
var NumericEdit = class extends XFAObject {
  constructor(e2) {
    super(Go, "numericEdit", true);
    this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [co](e2) {
    const t2 = toStyle(this, "border", "font", "margin"), a2 = this[vs]()[vs](), r2 = { name: "input", attributes: { type: "text", fieldId: a2[uo], dataId: a2[os]?.[uo] || a2[uo], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(a2), "aria-required": false } };
    if (isRequired(a2)) {
      r2.attributes["aria-required"] = true;
      r2.attributes.required = true;
    }
    return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [r2] });
  }
};
var Occur = class extends XFAObject {
  constructor(e2) {
    super(Go, "occur", true);
    this.id = e2.id || "";
    this.initial = "" !== e2.initial ? getInteger({ data: e2.initial, defaultValue: "", validate: (e3) => true }) : "";
    this.max = "" !== e2.max ? getInteger({ data: e2.max, defaultValue: 1, validate: (e3) => true }) : "";
    this.min = "" !== e2.min ? getInteger({ data: e2.min, defaultValue: 1, validate: (e3) => true }) : "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
  [ts]() {
    const e2 = this[vs](), t2 = this.min;
    "" === this.min && (this.min = e2 instanceof PageArea || e2 instanceof PageSet ? 0 : 1);
    "" === this.max && (this.max = "" === t2 ? e2 instanceof PageArea || e2 instanceof PageSet ? -1 : 1 : this.min);
    -1 !== this.max && this.max < this.min && (this.max = this.min);
    "" === this.initial && (this.initial = e2 instanceof Template ? 1 : this.min);
  }
};
var Oid = class extends StringObject {
  constructor(e2) {
    super(Go, "oid");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Oids = class extends XFAObject {
  constructor(e2) {
    super(Go, "oids", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.oid = new XFAObjectArray();
  }
};
var Overflow = class extends XFAObject {
  constructor(e2) {
    super(Go, "overflow");
    this.id = e2.id || "";
    this.leader = e2.leader || "";
    this.target = e2.target || "";
    this.trailer = e2.trailer || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [ws]() {
    if (!this[ls]) {
      const e2 = this[vs](), t2 = this[Fs](), a2 = t2[to](this.target, e2), r2 = t2[to](this.leader, e2), i2 = t2[to](this.trailer, e2);
      this[ls] = { target: a2?.[0] || null, leader: r2?.[0] || null, trailer: i2?.[0] || null, addLeader: false, addTrailer: false };
    }
    return this[ls];
  }
};
var PageArea = class extends XFAObject {
  constructor(e2) {
    super(Go, "pageArea", true);
    this.blankOrNotBlank = getStringOption(e2.blankOrNotBlank, ["any", "blank", "notBlank"]);
    this.id = e2.id || "";
    this.initialNumber = getInteger({ data: e2.initialNumber, defaultValue: 1, validate: (e3) => true });
    this.name = e2.name || "";
    this.numbered = getInteger({ data: e2.numbered, defaultValue: 1, validate: (e3) => true });
    this.oddOrEven = getStringOption(e2.oddOrEven, ["any", "even", "odd"]);
    this.pagePosition = getStringOption(e2.pagePosition, ["any", "first", "last", "only", "rest"]);
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.desc = null;
    this.extras = null;
    this.medium = null;
    this.occur = null;
    this.area = new XFAObjectArray();
    this.contentArea = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.subform = new XFAObjectArray();
  }
  [Xs]() {
    if (!this[ls]) {
      this[ls] = { numberOfUse: 0 };
      return true;
    }
    return !this.occur || -1 === this.occur.max || this[ls].numberOfUse < this.occur.max;
  }
  [as]() {
    delete this[ls];
  }
  [ks]() {
    this[ls] ||= { numberOfUse: 0 };
    const e2 = this[vs]();
    if ("orderedOccurrence" === e2.relation && this[Xs]()) {
      this[ls].numberOfUse += 1;
      return this;
    }
    return e2[ks]();
  }
  [gs]() {
    return this[ls].space || { width: 0, height: 0 };
  }
  [co]() {
    this[ls] ||= { numberOfUse: 1 };
    const e2 = [];
    this[ls].children = e2;
    const t2 = /* @__PURE__ */ Object.create(null);
    if (this.medium && this.medium.short && this.medium.long) {
      t2.width = measureToString(this.medium.short);
      t2.height = measureToString(this.medium.long);
      this[ls].space = { width: this.medium.short, height: this.medium.long };
      if ("landscape" === this.medium.orientation) {
        const e3 = t2.width;
        t2.width = t2.height;
        t2.height = e3;
        this[ls].space = { width: this.medium.long, height: this.medium.short };
      }
    } else warn("XFA - No medium specified in pageArea: please file a bug.");
    this[es]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]), include: true });
    this[es]({ filter: /* @__PURE__ */ new Set(["contentArea"]), include: true });
    return HTMLResult.success({ name: "div", children: e2, attributes: { class: ["xfaPage"], id: this[uo], style: t2, xfaName: this.name } });
  }
};
var PageSet = class _PageSet extends XFAObject {
  constructor(e2) {
    super(Go, "pageSet", true);
    this.duplexImposition = getStringOption(e2.duplexImposition, ["longEdge", "shortEdge"]);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.relation = getStringOption(e2.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]);
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.occur = null;
    this.pageArea = new XFAObjectArray();
    this.pageSet = new XFAObjectArray();
  }
  [as]() {
    for (const e2 of this.pageArea.children) e2[as]();
    for (const e2 of this.pageSet.children) e2[as]();
  }
  [Xs]() {
    return !this.occur || -1 === this.occur.max || this[ls].numberOfUse < this.occur.max;
  }
  [ks]() {
    this[ls] ||= { numberOfUse: 1, pageIndex: -1, pageSetIndex: -1 };
    if ("orderedOccurrence" === this.relation) {
      if (this[ls].pageIndex + 1 < this.pageArea.children.length) {
        this[ls].pageIndex += 1;
        return this.pageArea.children[this[ls].pageIndex][ks]();
      }
      if (this[ls].pageSetIndex + 1 < this.pageSet.children.length) {
        this[ls].pageSetIndex += 1;
        return this.pageSet.children[this[ls].pageSetIndex][ks]();
      }
      if (this[Xs]()) {
        this[ls].numberOfUse += 1;
        this[ls].pageIndex = -1;
        this[ls].pageSetIndex = -1;
        return this[ks]();
      }
      const e3 = this[vs]();
      if (e3 instanceof _PageSet) return e3[ks]();
      this[as]();
      return this[ks]();
    }
    const e2 = this[Fs]()[ls].pageNumber, t2 = e2 % 2 == 0 ? "even" : "odd", a2 = 0 === e2 ? "first" : "rest";
    let r2 = this.pageArea.children.find(((e3) => e3.oddOrEven === t2 && e3.pagePosition === a2));
    if (r2) return r2;
    r2 = this.pageArea.children.find(((e3) => "any" === e3.oddOrEven && e3.pagePosition === a2));
    if (r2) return r2;
    r2 = this.pageArea.children.find(((e3) => "any" === e3.oddOrEven && "any" === e3.pagePosition));
    return r2 || this.pageArea.children[0];
  }
};
var Para = class extends XFAObject {
  constructor(e2) {
    super(Go, "para", true);
    this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = e2.id || "";
    this.lineHeight = e2.lineHeight ? getMeasurement(e2.lineHeight, "0pt") : "";
    this.marginLeft = e2.marginLeft ? getMeasurement(e2.marginLeft, "0pt") : "";
    this.marginRight = e2.marginRight ? getMeasurement(e2.marginRight, "0pt") : "";
    this.orphans = getInteger({ data: e2.orphans, defaultValue: 0, validate: (e3) => e3 >= 0 });
    this.preserve = e2.preserve || "";
    this.radixOffset = e2.radixOffset ? getMeasurement(e2.radixOffset, "0pt") : "";
    this.spaceAbove = e2.spaceAbove ? getMeasurement(e2.spaceAbove, "0pt") : "";
    this.spaceBelow = e2.spaceBelow ? getMeasurement(e2.spaceBelow, "0pt") : "";
    this.tabDefault = e2.tabDefault ? getMeasurement(this.tabDefault) : "";
    this.tabStops = (e2.tabStops || "").trim().split(/\s+/).map(((e3, t2) => t2 % 2 == 1 ? getMeasurement(e3) : e3));
    this.textIndent = e2.textIndent ? getMeasurement(e2.textIndent, "0pt") : "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.vAlign = getStringOption(e2.vAlign, ["top", "bottom", "middle"]);
    this.widows = getInteger({ data: e2.widows, defaultValue: 0, validate: (e3) => e3 >= 0 });
    this.hyphenation = null;
  }
  [ho]() {
    const e2 = toStyle(this, "hAlign");
    "" !== this.marginLeft && (e2.paddingLeft = measureToString(this.marginLeft));
    "" !== this.marginRight && (e2.paddingRight = measureToString(this.marginRight));
    "" !== this.spaceAbove && (e2.paddingTop = measureToString(this.spaceAbove));
    "" !== this.spaceBelow && (e2.paddingBottom = measureToString(this.spaceBelow));
    if ("" !== this.textIndent) {
      e2.textIndent = measureToString(this.textIndent);
      fixTextIndent(e2);
    }
    this.lineHeight > 0 && (e2.lineHeight = measureToString(this.lineHeight));
    "" !== this.tabDefault && (e2.tabSize = measureToString(this.tabDefault));
    this.tabStops.length;
    this.hyphenatation && Object.assign(e2, this.hyphenatation[ho]());
    return e2;
  }
};
var PasswordEdit = class extends XFAObject {
  constructor(e2) {
    super(Go, "passwordEdit", true);
    this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]);
    this.id = e2.id || "";
    this.passwordChar = e2.passwordChar || "*";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.extras = null;
    this.margin = null;
  }
};
var template_Pattern = class extends XFAObject {
  constructor(e2) {
    super(Go, "pattern", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [ho](e2) {
    e2 = e2 ? e2[ho]() : "#FFFFFF";
    const t2 = this.color ? this.color[ho]() : "#000000", a2 = "repeating-linear-gradient", r2 = `${e2},${e2} 5px,${t2} 5px,${t2} 10px`;
    switch (this.type) {
      case "crossHatch":
        return `${a2}(to top,${r2}) ${a2}(to right,${r2})`;
      case "crossDiagonal":
        return `${a2}(45deg,${r2}) ${a2}(-45deg,${r2})`;
      case "diagonalLeft":
        return `${a2}(45deg,${r2})`;
      case "diagonalRight":
        return `${a2}(-45deg,${r2})`;
      case "horizontal":
        return `${a2}(to top,${r2})`;
      case "vertical":
        return `${a2}(to right,${r2})`;
    }
    return "";
  }
};
var Picture = class extends StringObject {
  constructor(e2) {
    super(Go, "picture");
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Proto = class extends XFAObject {
  constructor(e2) {
    super(Go, "proto", true);
    this.appearanceFilter = new XFAObjectArray();
    this.arc = new XFAObjectArray();
    this.area = new XFAObjectArray();
    this.assist = new XFAObjectArray();
    this.barcode = new XFAObjectArray();
    this.bindItems = new XFAObjectArray();
    this.bookend = new XFAObjectArray();
    this.boolean = new XFAObjectArray();
    this.border = new XFAObjectArray();
    this.break = new XFAObjectArray();
    this.breakAfter = new XFAObjectArray();
    this.breakBefore = new XFAObjectArray();
    this.button = new XFAObjectArray();
    this.calculate = new XFAObjectArray();
    this.caption = new XFAObjectArray();
    this.certificate = new XFAObjectArray();
    this.certificates = new XFAObjectArray();
    this.checkButton = new XFAObjectArray();
    this.choiceList = new XFAObjectArray();
    this.color = new XFAObjectArray();
    this.comb = new XFAObjectArray();
    this.connect = new XFAObjectArray();
    this.contentArea = new XFAObjectArray();
    this.corner = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.dateTimeEdit = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.defaultUi = new XFAObjectArray();
    this.desc = new XFAObjectArray();
    this.digestMethod = new XFAObjectArray();
    this.digestMethods = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.edge = new XFAObjectArray();
    this.encoding = new XFAObjectArray();
    this.encodings = new XFAObjectArray();
    this.encrypt = new XFAObjectArray();
    this.encryptData = new XFAObjectArray();
    this.encryption = new XFAObjectArray();
    this.encryptionMethod = new XFAObjectArray();
    this.encryptionMethods = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.execute = new XFAObjectArray();
    this.extras = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.fill = new XFAObjectArray();
    this.filter = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.font = new XFAObjectArray();
    this.format = new XFAObjectArray();
    this.handler = new XFAObjectArray();
    this.hyphenation = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.imageEdit = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.issuers = new XFAObjectArray();
    this.items = new XFAObjectArray();
    this.keep = new XFAObjectArray();
    this.keyUsage = new XFAObjectArray();
    this.line = new XFAObjectArray();
    this.linear = new XFAObjectArray();
    this.lockDocument = new XFAObjectArray();
    this.manifest = new XFAObjectArray();
    this.margin = new XFAObjectArray();
    this.mdp = new XFAObjectArray();
    this.medium = new XFAObjectArray();
    this.message = new XFAObjectArray();
    this.numericEdit = new XFAObjectArray();
    this.occur = new XFAObjectArray();
    this.oid = new XFAObjectArray();
    this.oids = new XFAObjectArray();
    this.overflow = new XFAObjectArray();
    this.pageArea = new XFAObjectArray();
    this.pageSet = new XFAObjectArray();
    this.para = new XFAObjectArray();
    this.passwordEdit = new XFAObjectArray();
    this.pattern = new XFAObjectArray();
    this.picture = new XFAObjectArray();
    this.radial = new XFAObjectArray();
    this.reason = new XFAObjectArray();
    this.reasons = new XFAObjectArray();
    this.rectangle = new XFAObjectArray();
    this.ref = new XFAObjectArray();
    this.script = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
    this.signData = new XFAObjectArray();
    this.signature = new XFAObjectArray();
    this.signing = new XFAObjectArray();
    this.solid = new XFAObjectArray();
    this.speak = new XFAObjectArray();
    this.stipple = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
    this.subjectDN = new XFAObjectArray();
    this.subjectDNs = new XFAObjectArray();
    this.submit = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.textEdit = new XFAObjectArray();
    this.time = new XFAObjectArray();
    this.timeStamp = new XFAObjectArray();
    this.toolTip = new XFAObjectArray();
    this.traversal = new XFAObjectArray();
    this.traverse = new XFAObjectArray();
    this.ui = new XFAObjectArray();
    this.validate = new XFAObjectArray();
    this.value = new XFAObjectArray();
    this.variables = new XFAObjectArray();
  }
};
var Radial = class extends XFAObject {
  constructor(e2) {
    super(Go, "radial", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["toEdge", "toCenter"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [ho](e2) {
    e2 = e2 ? e2[ho]() : "#FFFFFF";
    const t2 = this.color ? this.color[ho]() : "#000000";
    return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e2},${t2}` : `${t2},${e2}`})`;
  }
};
var Reason = class extends StringObject {
  constructor(e2) {
    super(Go, "reason");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Reasons = class extends XFAObject {
  constructor(e2) {
    super(Go, "reasons", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.reason = new XFAObjectArray();
  }
};
var Rectangle = class extends XFAObject {
  constructor(e2) {
    super(Go, "rectangle", true);
    this.hand = getStringOption(e2.hand, ["even", "left", "right"]);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.corner = new XFAObjectArray(4);
    this.edge = new XFAObjectArray(4);
    this.fill = null;
  }
  [co]() {
    const e2 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t2 = e2[ho](), a2 = /* @__PURE__ */ Object.create(null);
    "visible" === this.fill?.presence ? Object.assign(a2, this.fill[ho]()) : a2.fill = "transparent";
    a2.strokeWidth = measureToString("visible" === e2.presence ? e2.thickness : 0);
    a2.stroke = t2.color;
    const r2 = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[ho](), i2 = { name: "svg", children: [{ name: "rect", attributes: { xmlns: Vo, width: "100%", height: "100%", x: 0, y: 0, rx: r2.radius, ry: r2.radius, style: a2 } }], attributes: { xmlns: Vo, style: { overflow: "visible" }, width: "100%", height: "100%" } };
    if (hasMargin(this[vs]()[vs]())) return HTMLResult.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [i2] });
    i2.attributes.style.position = "absolute";
    return HTMLResult.success(i2);
  }
};
var RefElement = class extends StringObject {
  constructor(e2) {
    super(Go, "ref");
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Script = class extends StringObject {
  constructor(e2) {
    super(Go, "script");
    this.binding = e2.binding || "";
    this.contentType = e2.contentType || "";
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.runAt = getStringOption(e2.runAt, ["client", "both", "server"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var SetProperty = class extends XFAObject {
  constructor(e2) {
    super(Go, "setProperty");
    this.connection = e2.connection || "";
    this.ref = e2.ref || "";
    this.target = e2.target || "";
  }
};
var SignData = class extends XFAObject {
  constructor(e2) {
    super(Go, "signData", true);
    this.id = e2.id || "";
    this.operation = getStringOption(e2.operation, ["sign", "clear", "verify"]);
    this.ref = e2.ref || "";
    this.target = e2.target || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.filter = null;
    this.manifest = null;
  }
};
var Signature = class extends XFAObject {
  constructor(e2) {
    super(Go, "signature", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["PDF1.3", "PDF1.6"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.border = null;
    this.extras = null;
    this.filter = null;
    this.manifest = null;
    this.margin = null;
  }
};
var Signing = class extends XFAObject {
  constructor(e2) {
    super(Go, "signing", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.certificate = new XFAObjectArray();
  }
};
var Solid = class extends XFAObject {
  constructor(e2) {
    super(Go, "solid", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
  }
  [ho](e2) {
    return e2 ? e2[ho]() : "#FFFFFF";
  }
};
var Speak = class extends StringObject {
  constructor(e2) {
    super(Go, "speak");
    this.disable = getInteger({ data: e2.disable, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.id = e2.id || "";
    this.priority = getStringOption(e2.priority, ["custom", "caption", "name", "toolTip"]);
    this.rid = e2.rid || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Stipple = class extends XFAObject {
  constructor(e2) {
    super(Go, "stipple", true);
    this.id = e2.id || "";
    this.rate = getInteger({ data: e2.rate, defaultValue: 50, validate: (e3) => e3 >= 0 && e3 <= 100 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.color = null;
    this.extras = null;
  }
  [ho](e2) {
    const t2 = this.rate / 100;
    return Util.makeHexColor(Math.round(e2.value.r * (1 - t2) + this.value.r * t2), Math.round(e2.value.g * (1 - t2) + this.value.g * t2), Math.round(e2.value.b * (1 - t2) + this.value.b * t2));
  }
};
var Subform = class extends XFAObject {
  constructor(e2) {
    super(Go, "subform", true);
    this.access = getStringOption(e2.access, ["open", "nonInteractive", "protected", "readOnly"]);
    this.allowMacro = getInteger({ data: e2.allowMacro, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.anchorType = getStringOption(e2.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]);
    this.colSpan = getInteger({ data: e2.colSpan, defaultValue: 1, validate: (e3) => e3 >= 1 || -1 === e3 });
    this.columnWidths = (e2.columnWidths || "").trim().split(/\s+/).map(((e3) => "-1" === e3 ? -1 : getMeasurement(e3)));
    this.h = e2.h ? getMeasurement(e2.h) : "";
    this.hAlign = getStringOption(e2.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]);
    this.id = e2.id || "";
    this.layout = getStringOption(e2.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]);
    this.locale = e2.locale || "";
    this.maxH = getMeasurement(e2.maxH, "0pt");
    this.maxW = getMeasurement(e2.maxW, "0pt");
    this.mergeMode = getStringOption(e2.mergeMode, ["consumeData", "matchTemplate"]);
    this.minH = getMeasurement(e2.minH, "0pt");
    this.minW = getMeasurement(e2.minW, "0pt");
    this.name = e2.name || "";
    this.presence = getStringOption(e2.presence, ["visible", "hidden", "inactive", "invisible"]);
    this.relevant = getRelevant(e2.relevant);
    this.restoreState = getStringOption(e2.restoreState, ["manual", "auto"]);
    this.scope = getStringOption(e2.scope, ["name", "none"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.w = e2.w ? getMeasurement(e2.w) : "";
    this.x = getMeasurement(e2.x, "0pt");
    this.y = getMeasurement(e2.y, "0pt");
    this.assist = null;
    this.bind = null;
    this.bookend = null;
    this.border = null;
    this.break = null;
    this.calculate = null;
    this.desc = null;
    this.extras = null;
    this.keep = null;
    this.margin = null;
    this.occur = null;
    this.overflow = null;
    this.pageSet = null;
    this.para = null;
    this.traversal = null;
    this.validate = null;
    this.variables = null;
    this.area = new XFAObjectArray();
    this.breakAfter = new XFAObjectArray();
    this.breakBefore = new XFAObjectArray();
    this.connect = new XFAObjectArray();
    this.draw = new XFAObjectArray();
    this.event = new XFAObjectArray();
    this.exObject = new XFAObjectArray();
    this.exclGroup = new XFAObjectArray();
    this.field = new XFAObjectArray();
    this.proto = new XFAObjectArray();
    this.setProperty = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
  }
  [Cs]() {
    const e2 = this[vs]();
    return e2 instanceof SubformSet ? e2[Cs]() : e2;
  }
  [Rs]() {
    return true;
  }
  [_s]() {
    return this.layout.endsWith("-tb") && 0 === this[ls].attempt && this[ls].numberInLine > 0 || this[vs]()[_s]();
  }
  *[As]() {
    yield* getContainedChildren(this);
  }
  [us]() {
    return flushHTML(this);
  }
  [Zn](e2, t2) {
    addHTML(this, e2, t2);
  }
  [gs]() {
    return getAvailableSpace(this);
  }
  [js]() {
    const e2 = this[Cs]();
    if (!e2[js]()) return false;
    if (void 0 !== this[ls]._isSplittable) return this[ls]._isSplittable;
    if ("position" === this.layout || this.layout.includes("row")) {
      this[ls]._isSplittable = false;
      return false;
    }
    if (this.keep && "none" !== this.keep.intact) {
      this[ls]._isSplittable = false;
      return false;
    }
    if (e2.layout?.endsWith("-tb") && 0 !== e2[ls].numberInLine) return false;
    this[ls]._isSplittable = true;
    return true;
  }
  [co](e2) {
    setTabIndex(this);
    if (this.break) {
      if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
        const e3 = new BreakAfter({ targetType: this.break.after, target: this.break.afterTarget, startNew: this.break.startNew.toString() });
        e3[Is] = this[Is];
        this[Qn](e3);
        this.breakAfter.push(e3);
      }
      if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
        const e3 = new BreakBefore({ targetType: this.break.before, target: this.break.beforeTarget, startNew: this.break.startNew.toString() });
        e3[Is] = this[Is];
        this[Qn](e3);
        this.breakBefore.push(e3);
      }
      if ("" !== this.break.overflowTarget) {
        const e3 = new Overflow({ target: this.break.overflowTarget, leader: this.break.overflowLeader, trailer: this.break.overflowTrailer });
        e3[Is] = this[Is];
        this[Qn](e3);
        this.overflow.push(e3);
      }
      this[Zs](this.break);
      this.break = null;
    }
    if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
    (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
    if (this.breakBefore.children.length >= 1) {
      const e3 = this.breakBefore.children[0];
      if (handleBreak(e3)) return HTMLResult.breakNode(e3);
    }
    if (this[ls]?.afterBreakAfter) return HTMLResult.EMPTY;
    fixDimensions(this);
    const t2 = [], a2 = { id: this[uo], class: [] };
    setAccess(this, a2.class);
    this[ls] ||= /* @__PURE__ */ Object.create(null);
    Object.assign(this[ls], { children: t2, line: null, attributes: a2, attempt: 0, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, e2.width), height: Math.min(this.h || 1 / 0, e2.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
    const r2 = this[Fs](), i2 = r2[ls].noLayoutFailure, n2 = this[js]();
    n2 || setFirstUnsplittable(this);
    if (!checkDimensions(this, e2)) return HTMLResult.FAILURE;
    const s2 = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
    if (this.layout.includes("row")) {
      const e3 = this[Cs]().columnWidths;
      if (Array.isArray(e3) && e3.length > 0) {
        this[ls].columnWidths = e3;
        this[ls].currentColumn = 0;
      }
    }
    const o2 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), c2 = ["xfaSubform"], l2 = layoutClass(this);
    l2 && c2.push(l2);
    a2.style = o2;
    a2.class = c2;
    this.name && (a2.xfaName = this.name);
    if (this.overflow) {
      const t3 = this.overflow[ws]();
      if (t3.addLeader) {
        t3.addLeader = false;
        handleOverflow(this, t3.leader, e2);
      }
    }
    this[Ys]();
    const h2 = "lr-tb" === this.layout || "rl-tb" === this.layout, u2 = h2 ? 2 : 1;
    for (; this[ls].attempt < u2; this[ls].attempt++) {
      h2 && 1 === this[ls].attempt && (this[ls].numberInLine = 0);
      const e3 = this[es]({ filter: s2, include: true });
      if (e3.success) break;
      if (e3.isBreak()) {
        this[Js]();
        return e3;
      }
      if (h2 && 0 === this[ls].attempt && 0 === this[ls].numberInLine && !r2[ls].noLayoutFailure) {
        this[ls].attempt = u2;
        break;
      }
    }
    this[Js]();
    n2 || unsetFirstUnsplittable(this);
    r2[ls].noLayoutFailure = i2;
    if (this[ls].attempt === u2) {
      this.overflow && (this[Fs]()[ls].overflowNode = this.overflow);
      n2 || delete this[ls];
      return HTMLResult.FAILURE;
    }
    if (this.overflow) {
      const t3 = this.overflow[ws]();
      if (t3.addTrailer) {
        t3.addTrailer = false;
        handleOverflow(this, t3.trailer, e2);
      }
    }
    let d2 = 0, f2 = 0;
    if (this.margin) {
      d2 = this.margin.leftInset + this.margin.rightInset;
      f2 = this.margin.topInset + this.margin.bottomInset;
    }
    const g2 = Math.max(this[ls].width + d2, this.w || 0), p2 = Math.max(this[ls].height + f2, this.h || 0), m2 = [this.x, this.y, g2, p2];
    "" === this.w && (o2.width = measureToString(g2));
    "" === this.h && (o2.height = measureToString(p2));
    if (("0px" === o2.width || "0px" === o2.height) && 0 === t2.length) return HTMLResult.EMPTY;
    const b2 = { name: "div", attributes: a2, children: t2 };
    applyAssist(this, a2);
    const y2 = HTMLResult.success(createWrapper(this, b2), m2);
    if (this.breakAfter.children.length >= 1) {
      const e3 = this.breakAfter.children[0];
      if (handleBreak(e3)) {
        this[ls].afterBreakAfter = y2;
        return HTMLResult.breakNode(e3);
      }
    }
    delete this[ls];
    return y2;
  }
};
var SubformSet = class extends XFAObject {
  constructor(e2) {
    super(Go, "subformSet", true);
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.relation = getStringOption(e2.relation, ["ordered", "choice", "unordered"]);
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.bookend = null;
    this.break = null;
    this.desc = null;
    this.extras = null;
    this.occur = null;
    this.overflow = null;
    this.breakAfter = new XFAObjectArray();
    this.breakBefore = new XFAObjectArray();
    this.subform = new XFAObjectArray();
    this.subformSet = new XFAObjectArray();
  }
  *[As]() {
    yield* getContainedChildren(this);
  }
  [Cs]() {
    let e2 = this[vs]();
    for (; !(e2 instanceof Subform); ) e2 = e2[vs]();
    return e2;
  }
  [Rs]() {
    return true;
  }
};
var SubjectDN = class extends ContentObject {
  constructor(e2) {
    super(Go, "subjectDN");
    this.delimiter = e2.delimiter || ",";
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [hs]() {
    this[ss] = new Map(this[ss].split(this.delimiter).map(((e2) => {
      (e2 = e2.split("=", 2))[0] = e2[0].trim();
      return e2;
    })));
  }
};
var SubjectDNs = class extends XFAObject {
  constructor(e2) {
    super(Go, "subjectDNs", true);
    this.id = e2.id || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.subjectDN = new XFAObjectArray();
  }
};
var Submit = class extends XFAObject {
  constructor(e2) {
    super(Go, "submit", true);
    this.embedPDF = getInteger({ data: e2.embedPDF, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.format = getStringOption(e2.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]);
    this.id = e2.id || "";
    this.target = e2.target || "";
    this.textEncoding = getKeyword({ data: e2.textEncoding ? e2.textEncoding.toLowerCase() : "", defaultValue: "", validate: (e3) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e3) || e3.match(/iso-8859-\d{2}/) });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.xdpContent = e2.xdpContent || "";
    this.encrypt = null;
    this.encryptData = new XFAObjectArray();
    this.signData = new XFAObjectArray();
  }
};
var Template = class extends XFAObject {
  constructor(e2) {
    super(Go, "template", true);
    this.baseProfile = getStringOption(e2.baseProfile, ["full", "interactiveForms"]);
    this.extras = null;
    this.subform = new XFAObjectArray();
  }
  [hs]() {
    0 === this.subform.children.length && warn("XFA - No subforms in template node.");
    this.subform.children.length >= 2 && warn("XFA - Several subforms in template node: please file a bug.");
    this[no] = 5e3;
  }
  [js]() {
    return true;
  }
  [to](e2, t2) {
    return e2.startsWith("#") ? [this[Os].get(e2.slice(1))] : searchNode(this, t2, e2, true, true);
  }
  *[oo]() {
    if (!this.subform.children.length) return HTMLResult.success({ name: "div", children: [] });
    this[ls] = { overflowNode: null, firstUnsplittable: null, currentContentArea: null, currentPageArea: null, noLayoutFailure: false, pageNumber: 1, pagePosition: "first", oddOrEven: "odd", blankOrNotBlank: "nonBlank", paraStack: [] };
    const e2 = this.subform.children[0];
    e2.pageSet[as]();
    const t2 = e2.pageSet.pageArea.children, a2 = { name: "div", children: [] };
    let r2 = null, i2 = null, n2 = null;
    if (e2.breakBefore.children.length >= 1) {
      i2 = e2.breakBefore.children[0];
      n2 = i2.target;
    } else if (e2.subform.children.length >= 1 && e2.subform.children[0].breakBefore.children.length >= 1) {
      i2 = e2.subform.children[0].breakBefore.children[0];
      n2 = i2.target;
    } else if (e2.break?.beforeTarget) {
      i2 = e2.break;
      n2 = i2.beforeTarget;
    } else if (e2.subform.children.length >= 1 && e2.subform.children[0].break?.beforeTarget) {
      i2 = e2.subform.children[0].break;
      n2 = i2.beforeTarget;
    }
    if (i2) {
      const e3 = this[to](n2, i2[vs]());
      if (e3 instanceof PageArea) {
        r2 = e3;
        i2[ls] = {};
      }
    }
    r2 ||= t2[0];
    r2[ls] = { numberOfUse: 1 };
    const s2 = r2[vs]();
    s2[ls] = { numberOfUse: 1, pageIndex: s2.pageArea.children.indexOf(r2), pageSetIndex: 0 };
    let o2, c2 = null, l2 = null, h2 = true, u2 = 0, d2 = 0;
    for (; ; ) {
      if (h2) u2 = 0;
      else {
        a2.children.pop();
        if (3 == ++u2) {
          warn("XFA - Something goes wrong: please file a bug.");
          return a2;
        }
      }
      o2 = null;
      this[ls].currentPageArea = r2;
      const t3 = r2[co]().html;
      a2.children.push(t3);
      if (c2) {
        this[ls].noLayoutFailure = true;
        t3.children.push(c2[co](r2[ls].space).html);
        c2 = null;
      }
      if (l2) {
        this[ls].noLayoutFailure = true;
        t3.children.push(l2[co](r2[ls].space).html);
        l2 = null;
      }
      const i3 = r2.contentArea.children, n3 = t3.children.filter(((e3) => e3.attributes.class.includes("xfaContentarea")));
      h2 = false;
      this[ls].firstUnsplittable = null;
      this[ls].noLayoutFailure = false;
      const flush = (t4) => {
        const a3 = e2[us]();
        if (a3) {
          h2 ||= a3.children?.length > 0;
          n3[t4].children.push(a3);
        }
      };
      for (let t4 = d2, r3 = i3.length; t4 < r3; t4++) {
        const r4 = this[ls].currentContentArea = i3[t4], s3 = { width: r4.w, height: r4.h };
        d2 = 0;
        if (c2) {
          n3[t4].children.push(c2[co](s3).html);
          c2 = null;
        }
        if (l2) {
          n3[t4].children.push(l2[co](s3).html);
          l2 = null;
        }
        const u3 = e2[co](s3);
        if (u3.success) {
          if (u3.html) {
            h2 ||= u3.html.children?.length > 0;
            n3[t4].children.push(u3.html);
          } else !h2 && a2.children.length > 1 && a2.children.pop();
          return a2;
        }
        if (u3.isBreak()) {
          const e3 = u3.breakNode;
          flush(t4);
          if ("auto" === e3.targetType) continue;
          if (e3.leader) {
            c2 = this[to](e3.leader, e3[vs]());
            c2 = c2 ? c2[0] : null;
          }
          if (e3.trailer) {
            l2 = this[to](e3.trailer, e3[vs]());
            l2 = l2 ? l2[0] : null;
          }
          if ("pageArea" === e3.targetType) {
            o2 = e3[ls].target;
            t4 = 1 / 0;
          } else if (e3[ls].target) {
            o2 = e3[ls].target;
            d2 = e3[ls].index + 1;
            t4 = 1 / 0;
          } else t4 = e3[ls].index;
        } else if (this[ls].overflowNode) {
          const e3 = this[ls].overflowNode;
          this[ls].overflowNode = null;
          const a3 = e3[ws](), r5 = a3.target;
          a3.addLeader = null !== a3.leader;
          a3.addTrailer = null !== a3.trailer;
          flush(t4);
          const n4 = t4;
          t4 = 1 / 0;
          if (r5 instanceof PageArea) o2 = r5;
          else if (r5 instanceof ContentArea) {
            const e4 = i3.indexOf(r5);
            if (-1 !== e4) e4 > n4 ? t4 = e4 - 1 : d2 = e4;
            else {
              o2 = r5[vs]();
              d2 = o2.contentArea.children.indexOf(r5);
            }
          }
        } else flush(t4);
      }
      this[ls].pageNumber += 1;
      o2 && (o2[Xs]() ? o2[ls].numberOfUse += 1 : o2 = null);
      r2 = o2 || r2[ks]();
      yield null;
    }
  }
};
var Text = class extends ContentObject {
  constructor(e2) {
    super(Go, "text");
    this.id = e2.id || "";
    this.maxChars = getInteger({ data: e2.maxChars, defaultValue: 0, validate: (e3) => e3 >= 0 });
    this.name = e2.name || "";
    this.rid = e2.rid || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [Yn]() {
    return true;
  }
  [$s](e2) {
    if (e2[Hs] === go.xhtml.id) {
      this[ss] = e2;
      return true;
    }
    warn(`XFA - Invalid content in Text: ${e2[Ws]}.`);
    return false;
  }
  [Vs](e2) {
    this[ss] instanceof XFAObject || super[Vs](e2);
  }
  [hs]() {
    "string" == typeof this[ss] && (this[ss] = this[ss].replaceAll("\r\n", "\n"));
  }
  [ws]() {
    return "string" == typeof this[ss] ? this[ss].split(/[\u2029\u2028\n]/).filter(((e2) => !!e2)).join("\n") : this[ss][so]();
  }
  [co](e2) {
    if ("string" == typeof this[ss]) {
      const e3 = valueToHtml(this[ss]).html;
      if (this[ss].includes("\u2029")) {
        e3.name = "div";
        e3.children = [];
        this[ss].split("\u2029").map(((e4) => e4.split(/[\u2028\n]/).flatMap(((e5) => [{ name: "span", value: e5 }, { name: "br" }])))).forEach(((t2) => {
          e3.children.push({ name: "p", children: t2 });
        }));
      } else if (/[\u2028\n]/.test(this[ss])) {
        e3.name = "div";
        e3.children = [];
        this[ss].split(/[\u2028\n]/).forEach(((t2) => {
          e3.children.push({ name: "span", value: t2 }, { name: "br" });
        }));
      }
      return HTMLResult.success(e3);
    }
    return this[ss][co](e2);
  }
};
var TextEdit = class extends XFAObject {
  constructor(e2) {
    super(Go, "textEdit", true);
    this.allowRichText = getInteger({ data: e2.allowRichText, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.hScrollPolicy = getStringOption(e2.hScrollPolicy, ["auto", "off", "on"]);
    this.id = e2.id || "";
    this.multiLine = getInteger({ data: e2.multiLine, defaultValue: "", validate: (e3) => 0 === e3 || 1 === e3 });
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.vScrollPolicy = getStringOption(e2.vScrollPolicy, ["auto", "off", "on"]);
    this.border = null;
    this.comb = null;
    this.extras = null;
    this.margin = null;
  }
  [co](e2) {
    const t2 = toStyle(this, "border", "font", "margin");
    let a2;
    const r2 = this[vs]()[vs]();
    "" === this.multiLine && (this.multiLine = r2 instanceof Draw ? 1 : 0);
    a2 = 1 === this.multiLine ? { name: "textarea", attributes: { dataId: r2[os]?.[uo] || r2[uo], fieldId: r2[uo], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(r2), "aria-required": false } } : { name: "input", attributes: { type: "text", dataId: r2[os]?.[uo] || r2[uo], fieldId: r2[uo], class: ["xfaTextfield"], style: t2, "aria-label": ariaLabel(r2), "aria-required": false } };
    if (isRequired(r2)) {
      a2.attributes["aria-required"] = true;
      a2.attributes.required = true;
    }
    return HTMLResult.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a2] });
  }
};
var Time = class extends StringObject {
  constructor(e2) {
    super(Go, "time");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
  [hs]() {
    const e2 = this[ss].trim();
    this[ss] = e2 ? new Date(e2) : null;
  }
  [co](e2) {
    return valueToHtml(this[ss] ? this[ss].toString() : "");
  }
};
var TimeStamp = class extends XFAObject {
  constructor(e2) {
    super(Go, "timeStamp");
    this.id = e2.id || "";
    this.server = e2.server || "";
    this.type = getStringOption(e2.type, ["optional", "required"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var ToolTip = class extends StringObject {
  constructor(e2) {
    super(Go, "toolTip");
    this.id = e2.id || "";
    this.rid = e2.rid || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Traversal = class extends XFAObject {
  constructor(e2) {
    super(Go, "traversal", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.traverse = new XFAObjectArray();
  }
};
var Traverse = class extends XFAObject {
  constructor(e2) {
    super(Go, "traverse", true);
    this.id = e2.id || "";
    this.operation = getStringOption(e2.operation, ["next", "back", "down", "first", "left", "right", "up"]);
    this.ref = e2.ref || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.script = null;
  }
  get name() {
    return this.operation;
  }
  [Us]() {
    return false;
  }
};
var Ui = class extends XFAObject {
  constructor(e2) {
    super(Go, "ui", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.picture = null;
    this.barcode = null;
    this.button = null;
    this.checkButton = null;
    this.choiceList = null;
    this.dateTimeEdit = null;
    this.defaultUi = null;
    this.imageEdit = null;
    this.numericEdit = null;
    this.passwordEdit = null;
    this.signature = null;
    this.textEdit = null;
  }
  [ws]() {
    if (void 0 === this[ls]) {
      for (const e2 of Object.getOwnPropertyNames(this)) {
        if ("extras" === e2 || "picture" === e2) continue;
        const t2 = this[e2];
        if (t2 instanceof XFAObject) {
          this[ls] = t2;
          return t2;
        }
      }
      this[ls] = null;
    }
    return this[ls];
  }
  [co](e2) {
    const t2 = this[ws]();
    return t2 ? t2[co](e2) : HTMLResult.EMPTY;
  }
};
var Validate = class extends XFAObject {
  constructor(e2) {
    super(Go, "validate", true);
    this.formatTest = getStringOption(e2.formatTest, ["warning", "disabled", "error"]);
    this.id = e2.id || "";
    this.nullTest = getStringOption(e2.nullTest, ["disabled", "error", "warning"]);
    this.scriptTest = getStringOption(e2.scriptTest, ["error", "disabled", "warning"]);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.extras = null;
    this.message = null;
    this.picture = null;
    this.script = null;
  }
};
var Value = class extends XFAObject {
  constructor(e2) {
    super(Go, "value", true);
    this.id = e2.id || "";
    this.override = getInteger({ data: e2.override, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.relevant = getRelevant(e2.relevant);
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.arc = null;
    this.boolean = null;
    this.date = null;
    this.dateTime = null;
    this.decimal = null;
    this.exData = null;
    this.float = null;
    this.image = null;
    this.integer = null;
    this.line = null;
    this.rectangle = null;
    this.text = null;
    this.time = null;
  }
  [io](e2) {
    const t2 = this[vs]();
    if (t2 instanceof Field && t2.ui?.imageEdit) {
      if (!this.image) {
        this.image = new Image({});
        this[Qn](this.image);
      }
      this.image[ss] = e2[ss];
      return;
    }
    const a2 = e2[Ws];
    if (null === this[a2]) {
      for (const e3 of Object.getOwnPropertyNames(this)) {
        const t3 = this[e3];
        if (t3 instanceof XFAObject) {
          this[e3] = null;
          this[Zs](t3);
        }
      }
      this[e2[Ws]] = e2;
      this[Qn](e2);
    } else this[a2][ss] = e2[ss];
  }
  [so]() {
    if (this.exData) return "string" == typeof this.exData[ss] ? this.exData[ss].trim() : this.exData[ss][so]().trim();
    for (const e2 of Object.getOwnPropertyNames(this)) {
      if ("image" === e2) continue;
      const t2 = this[e2];
      if (t2 instanceof XFAObject) return (t2[ss] || "").toString().trim();
    }
    return null;
  }
  [co](e2) {
    for (const t2 of Object.getOwnPropertyNames(this)) {
      const a2 = this[t2];
      if (a2 instanceof XFAObject) return a2[co](e2);
    }
    return HTMLResult.EMPTY;
  }
};
var Variables = class extends XFAObject {
  constructor(e2) {
    super(Go, "variables", true);
    this.id = e2.id || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
    this.boolean = new XFAObjectArray();
    this.date = new XFAObjectArray();
    this.dateTime = new XFAObjectArray();
    this.decimal = new XFAObjectArray();
    this.exData = new XFAObjectArray();
    this.float = new XFAObjectArray();
    this.image = new XFAObjectArray();
    this.integer = new XFAObjectArray();
    this.manifest = new XFAObjectArray();
    this.script = new XFAObjectArray();
    this.text = new XFAObjectArray();
    this.time = new XFAObjectArray();
  }
  [Us]() {
    return true;
  }
};
var TemplateNamespace = class _TemplateNamespace {
  static [fo](e2, t2) {
    if (_TemplateNamespace.hasOwnProperty(e2)) {
      const a2 = _TemplateNamespace[e2](t2);
      a2[ro](t2);
      return a2;
    }
  }
  static appearanceFilter(e2) {
    return new AppearanceFilter(e2);
  }
  static arc(e2) {
    return new Arc(e2);
  }
  static area(e2) {
    return new Area(e2);
  }
  static assist(e2) {
    return new Assist(e2);
  }
  static barcode(e2) {
    return new Barcode(e2);
  }
  static bind(e2) {
    return new Bind(e2);
  }
  static bindItems(e2) {
    return new BindItems(e2);
  }
  static bookend(e2) {
    return new Bookend(e2);
  }
  static boolean(e2) {
    return new BooleanElement(e2);
  }
  static border(e2) {
    return new Border(e2);
  }
  static break(e2) {
    return new Break(e2);
  }
  static breakAfter(e2) {
    return new BreakAfter(e2);
  }
  static breakBefore(e2) {
    return new BreakBefore(e2);
  }
  static button(e2) {
    return new Button(e2);
  }
  static calculate(e2) {
    return new Calculate(e2);
  }
  static caption(e2) {
    return new Caption(e2);
  }
  static certificate(e2) {
    return new Certificate(e2);
  }
  static certificates(e2) {
    return new Certificates(e2);
  }
  static checkButton(e2) {
    return new CheckButton(e2);
  }
  static choiceList(e2) {
    return new ChoiceList(e2);
  }
  static color(e2) {
    return new Color(e2);
  }
  static comb(e2) {
    return new Comb(e2);
  }
  static connect(e2) {
    return new Connect(e2);
  }
  static contentArea(e2) {
    return new ContentArea(e2);
  }
  static corner(e2) {
    return new Corner(e2);
  }
  static date(e2) {
    return new DateElement(e2);
  }
  static dateTime(e2) {
    return new DateTime(e2);
  }
  static dateTimeEdit(e2) {
    return new DateTimeEdit(e2);
  }
  static decimal(e2) {
    return new Decimal(e2);
  }
  static defaultUi(e2) {
    return new DefaultUi(e2);
  }
  static desc(e2) {
    return new Desc(e2);
  }
  static digestMethod(e2) {
    return new DigestMethod(e2);
  }
  static digestMethods(e2) {
    return new DigestMethods(e2);
  }
  static draw(e2) {
    return new Draw(e2);
  }
  static edge(e2) {
    return new Edge(e2);
  }
  static encoding(e2) {
    return new Encoding(e2);
  }
  static encodings(e2) {
    return new Encodings(e2);
  }
  static encrypt(e2) {
    return new Encrypt(e2);
  }
  static encryptData(e2) {
    return new EncryptData(e2);
  }
  static encryption(e2) {
    return new Encryption(e2);
  }
  static encryptionMethod(e2) {
    return new EncryptionMethod(e2);
  }
  static encryptionMethods(e2) {
    return new EncryptionMethods(e2);
  }
  static event(e2) {
    return new Event(e2);
  }
  static exData(e2) {
    return new ExData(e2);
  }
  static exObject(e2) {
    return new ExObject(e2);
  }
  static exclGroup(e2) {
    return new ExclGroup(e2);
  }
  static execute(e2) {
    return new Execute(e2);
  }
  static extras(e2) {
    return new Extras(e2);
  }
  static field(e2) {
    return new Field(e2);
  }
  static fill(e2) {
    return new Fill(e2);
  }
  static filter(e2) {
    return new Filter(e2);
  }
  static float(e2) {
    return new Float(e2);
  }
  static font(e2) {
    return new template_Font(e2);
  }
  static format(e2) {
    return new Format(e2);
  }
  static handler(e2) {
    return new Handler(e2);
  }
  static hyphenation(e2) {
    return new Hyphenation(e2);
  }
  static image(e2) {
    return new Image(e2);
  }
  static imageEdit(e2) {
    return new ImageEdit(e2);
  }
  static integer(e2) {
    return new Integer(e2);
  }
  static issuers(e2) {
    return new Issuers(e2);
  }
  static items(e2) {
    return new Items(e2);
  }
  static keep(e2) {
    return new Keep(e2);
  }
  static keyUsage(e2) {
    return new KeyUsage(e2);
  }
  static line(e2) {
    return new Line(e2);
  }
  static linear(e2) {
    return new Linear(e2);
  }
  static lockDocument(e2) {
    return new LockDocument(e2);
  }
  static manifest(e2) {
    return new Manifest(e2);
  }
  static margin(e2) {
    return new Margin(e2);
  }
  static mdp(e2) {
    return new Mdp(e2);
  }
  static medium(e2) {
    return new Medium(e2);
  }
  static message(e2) {
    return new Message(e2);
  }
  static numericEdit(e2) {
    return new NumericEdit(e2);
  }
  static occur(e2) {
    return new Occur(e2);
  }
  static oid(e2) {
    return new Oid(e2);
  }
  static oids(e2) {
    return new Oids(e2);
  }
  static overflow(e2) {
    return new Overflow(e2);
  }
  static pageArea(e2) {
    return new PageArea(e2);
  }
  static pageSet(e2) {
    return new PageSet(e2);
  }
  static para(e2) {
    return new Para(e2);
  }
  static passwordEdit(e2) {
    return new PasswordEdit(e2);
  }
  static pattern(e2) {
    return new template_Pattern(e2);
  }
  static picture(e2) {
    return new Picture(e2);
  }
  static proto(e2) {
    return new Proto(e2);
  }
  static radial(e2) {
    return new Radial(e2);
  }
  static reason(e2) {
    return new Reason(e2);
  }
  static reasons(e2) {
    return new Reasons(e2);
  }
  static rectangle(e2) {
    return new Rectangle(e2);
  }
  static ref(e2) {
    return new RefElement(e2);
  }
  static script(e2) {
    return new Script(e2);
  }
  static setProperty(e2) {
    return new SetProperty(e2);
  }
  static signData(e2) {
    return new SignData(e2);
  }
  static signature(e2) {
    return new Signature(e2);
  }
  static signing(e2) {
    return new Signing(e2);
  }
  static solid(e2) {
    return new Solid(e2);
  }
  static speak(e2) {
    return new Speak(e2);
  }
  static stipple(e2) {
    return new Stipple(e2);
  }
  static subform(e2) {
    return new Subform(e2);
  }
  static subformSet(e2) {
    return new SubformSet(e2);
  }
  static subjectDN(e2) {
    return new SubjectDN(e2);
  }
  static subjectDNs(e2) {
    return new SubjectDNs(e2);
  }
  static submit(e2) {
    return new Submit(e2);
  }
  static template(e2) {
    return new Template(e2);
  }
  static text(e2) {
    return new Text(e2);
  }
  static textEdit(e2) {
    return new TextEdit(e2);
  }
  static time(e2) {
    return new Time(e2);
  }
  static timeStamp(e2) {
    return new TimeStamp(e2);
  }
  static toolTip(e2) {
    return new ToolTip(e2);
  }
  static traversal(e2) {
    return new Traversal(e2);
  }
  static traverse(e2) {
    return new Traverse(e2);
  }
  static ui(e2) {
    return new Ui(e2);
  }
  static validate(e2) {
    return new Validate(e2);
  }
  static value(e2) {
    return new Value(e2);
  }
  static variables(e2) {
    return new Variables(e2);
  }
};
var Zo = go.datasets.id;
function createText(e2) {
  const t2 = new Text({});
  t2[ss] = e2;
  return t2;
}
var Binder = class {
  constructor(e2) {
    this.root = e2;
    this.datasets = e2.datasets;
    this.data = e2.datasets?.data || new XmlObject(go.datasets.id, "data");
    this.emptyMerge = 0 === this.data[Ss]().length;
    this.root.form = this.form = e2.template[is]();
  }
  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }
  _isMatchTemplate() {
    return !this._isConsumeData();
  }
  bind() {
    this._bindElement(this.form, this.data);
    return this.form;
  }
  getData() {
    return this.data;
  }
  _bindValue(e2, t2, a2) {
    e2[os] = t2;
    if (e2[Ts]()) if (t2[Ns]()) {
      const a3 = t2[ys]();
      e2[io](createText(a3));
    } else if (e2 instanceof Field && "multiSelect" === e2.ui?.choiceList?.open) {
      const a3 = t2[Ss]().map(((e3) => e3[ss].trim())).join("\n");
      e2[io](createText(a3));
    } else this._isConsumeData() && warn("XFA - Nodes haven't the same type.");
    else !t2[Ns]() || this._isMatchTemplate() ? this._bindElement(e2, t2) : warn("XFA - Nodes haven't the same type.");
  }
  _findDataByNameToConsume(e2, t2, a2, r2) {
    if (!e2) return null;
    let i2, n2;
    for (let r3 = 0; r3 < 3; r3++) {
      i2 = a2[xs](e2, false, true);
      for (; ; ) {
        n2 = i2.next().value;
        if (!n2) break;
        if (t2 === n2[Ns]()) return n2;
      }
      if (a2[Hs] === go.datasets.id && "data" === a2[Ws]) break;
      a2 = a2[vs]();
    }
    if (!r2) return null;
    i2 = this.data[xs](e2, true, false);
    n2 = i2.next().value;
    if (n2) return n2;
    i2 = this.data[ds](e2, true);
    n2 = i2.next().value;
    return n2?.[Ns]() ? n2 : null;
  }
  _setProperties(e2, t2) {
    if (e2.hasOwnProperty("setProperty")) for (const { ref: a2, target: r2, connection: i2 } of e2.setProperty.children) {
      if (i2) continue;
      if (!a2) continue;
      const n2 = searchNode(this.root, t2, a2, false, false);
      if (!n2) {
        warn(`XFA - Invalid reference: ${a2}.`);
        continue;
      }
      const [s2] = n2;
      if (!s2[Es](this.data)) {
        warn("XFA - Invalid node: must be a data node.");
        continue;
      }
      const o2 = searchNode(this.root, e2, r2, false, false);
      if (!o2) {
        warn(`XFA - Invalid target: ${r2}.`);
        continue;
      }
      const [c2] = o2;
      if (!c2[Es](e2)) {
        warn("XFA - Invalid target: must be a property or subproperty.");
        continue;
      }
      const l2 = c2[vs]();
      if (c2 instanceof SetProperty || l2 instanceof SetProperty) {
        warn("XFA - Invalid target: cannot be a setProperty or one of its properties.");
        continue;
      }
      if (c2 instanceof BindItems || l2 instanceof BindItems) {
        warn("XFA - Invalid target: cannot be a bindItems or one of its properties.");
        continue;
      }
      const h2 = s2[so](), u2 = c2[Ws];
      if (c2 instanceof XFAAttribute) {
        const e3 = /* @__PURE__ */ Object.create(null);
        e3[u2] = h2;
        const t3 = Reflect.construct(Object.getPrototypeOf(l2).constructor, [e3]);
        l2[u2] = t3[u2];
      } else if (c2.hasOwnProperty(ss)) {
        c2[os] = s2;
        c2[ss] = h2;
        c2[hs]();
      } else warn("XFA - Invalid node to use in setProperty");
    }
  }
  _bindItems(e2, t2) {
    if (!e2.hasOwnProperty("items") || !e2.hasOwnProperty("bindItems") || e2.bindItems.isEmpty()) return;
    for (const t3 of e2.items.children) e2[Zs](t3);
    e2.items.clear();
    const a2 = new Items({}), r2 = new Items({});
    e2[Qn](a2);
    e2.items.push(a2);
    e2[Qn](r2);
    e2.items.push(r2);
    for (const { ref: i2, labelRef: n2, valueRef: s2, connection: o2 } of e2.bindItems.children) {
      if (o2) continue;
      if (!i2) continue;
      const e3 = searchNode(this.root, t2, i2, false, false);
      if (e3) for (const t3 of e3) {
        if (!t3[Es](this.datasets)) {
          warn(`XFA - Invalid ref (${i2}): must be a datasets child.`);
          continue;
        }
        const e4 = searchNode(this.root, t3, n2, true, false);
        if (!e4) {
          warn(`XFA - Invalid label: ${n2}.`);
          continue;
        }
        const [o3] = e4;
        if (!o3[Es](this.datasets)) {
          warn("XFA - Invalid label: must be a datasets child.");
          continue;
        }
        const c2 = searchNode(this.root, t3, s2, true, false);
        if (!c2) {
          warn(`XFA - Invalid value: ${s2}.`);
          continue;
        }
        const [l2] = c2;
        if (!l2[Es](this.datasets)) {
          warn("XFA - Invalid value: must be a datasets child.");
          continue;
        }
        const h2 = createText(o3[so]()), u2 = createText(l2[so]());
        a2[Qn](h2);
        a2.text.push(h2);
        r2[Qn](u2);
        r2.text.push(u2);
      }
      else warn(`XFA - Invalid reference: ${i2}.`);
    }
  }
  _bindOccurrences(e2, t2, a2) {
    let r2;
    if (t2.length > 1) {
      r2 = e2[is]();
      r2[Zs](r2.occur);
      r2.occur = null;
    }
    this._bindValue(e2, t2[0], a2);
    this._setProperties(e2, t2[0]);
    this._bindItems(e2, t2[0]);
    if (1 === t2.length) return;
    const i2 = e2[vs](), n2 = e2[Ws], s2 = i2[Ms](e2);
    for (let e3 = 1, o2 = t2.length; e3 < o2; e3++) {
      const o3 = t2[e3], c2 = r2[is]();
      i2[n2].push(c2);
      i2[Ds](s2 + e3, c2);
      this._bindValue(c2, o3, a2);
      this._setProperties(c2, o3);
      this._bindItems(c2, o3);
    }
  }
  _createOccurrences(e2) {
    if (!this.emptyMerge) return;
    const { occur: t2 } = e2;
    if (!t2 || t2.initial <= 1) return;
    const a2 = e2[vs](), r2 = e2[Ws];
    if (!(a2[r2] instanceof XFAObjectArray)) return;
    let i2;
    i2 = e2.name ? a2[r2].children.filter(((t3) => t3.name === e2.name)).length : a2[r2].children.length;
    const n2 = a2[Ms](e2) + 1, s2 = t2.initial - i2;
    if (s2) {
      const t3 = e2[is]();
      t3[Zs](t3.occur);
      t3.occur = null;
      a2[r2].push(t3);
      a2[Ds](n2, t3);
      for (let e3 = 1; e3 < s2; e3++) {
        const i3 = t3[is]();
        a2[r2].push(i3);
        a2[Ds](n2 + e3, i3);
      }
    }
  }
  _getOccurInfo(e2) {
    const { name: t2, occur: a2 } = e2;
    if (!a2 || !t2) return [1, 1];
    const r2 = -1 === a2.max ? 1 / 0 : a2.max;
    return [a2.min, r2];
  }
  _setAndBind(e2, t2) {
    this._setProperties(e2, t2);
    this._bindItems(e2, t2);
    this._bindElement(e2, t2);
  }
  _bindElement(e2, t2) {
    const a2 = [];
    this._createOccurrences(e2);
    for (const r2 of e2[Ss]()) {
      if (r2[os]) continue;
      if (void 0 === this._mergeMode && "subform" === r2[Ws]) {
        this._mergeMode = "consumeData" === r2.mergeMode;
        const e4 = t2[Ss]();
        if (e4.length > 0) this._bindOccurrences(r2, [e4[0]], null);
        else if (this.emptyMerge) {
          const e5 = t2[Hs] === Zo ? -1 : t2[Hs], a3 = r2[os] = new XmlObject(e5, r2.name || "root");
          t2[Qn](a3);
          this._bindElement(r2, a3);
        }
        continue;
      }
      if (!r2[Rs]()) continue;
      let e3 = false, i2 = null, n2 = null, s2 = null;
      if (r2.bind) {
        switch (r2.bind.match) {
          case "none":
            this._setAndBind(r2, t2);
            continue;
          case "global":
            e3 = true;
            break;
          case "dataRef":
            if (!r2.bind.ref) {
              warn(`XFA - ref is empty in node ${r2[Ws]}.`);
              this._setAndBind(r2, t2);
              continue;
            }
            n2 = r2.bind.ref;
        }
        r2.bind.picture && (i2 = r2.bind.picture[ss]);
      }
      const [o2, c2] = this._getOccurInfo(r2);
      if (n2) {
        s2 = searchNode(this.root, t2, n2, true, false);
        if (null === s2) {
          s2 = createDataNode(this.data, t2, n2);
          if (!s2) continue;
          this._isConsumeData() && (s2[ns] = true);
          this._setAndBind(r2, s2);
          continue;
        }
        this._isConsumeData() && (s2 = s2.filter(((e4) => !e4[ns])));
        s2.length > c2 ? s2 = s2.slice(0, c2) : 0 === s2.length && (s2 = null);
        s2 && this._isConsumeData() && s2.forEach(((e4) => {
          e4[ns] = true;
        }));
      } else {
        if (!r2.name) {
          this._setAndBind(r2, t2);
          continue;
        }
        if (this._isConsumeData()) {
          const a3 = [];
          for (; a3.length < c2; ) {
            const i3 = this._findDataByNameToConsume(r2.name, r2[Ts](), t2, e3);
            if (!i3) break;
            i3[ns] = true;
            a3.push(i3);
          }
          s2 = a3.length > 0 ? a3 : null;
        } else {
          s2 = t2[xs](r2.name, false, this.emptyMerge).next().value;
          if (!s2) {
            if (0 === o2) {
              a2.push(r2);
              continue;
            }
            const e4 = t2[Hs] === Zo ? -1 : t2[Hs];
            s2 = r2[os] = new XmlObject(e4, r2.name);
            this.emptyMerge && (s2[ns] = true);
            t2[Qn](s2);
            this._setAndBind(r2, s2);
            continue;
          }
          this.emptyMerge && (s2[ns] = true);
          s2 = [s2];
        }
      }
      s2 ? this._bindOccurrences(r2, s2, i2) : o2 > 0 ? this._setAndBind(r2, t2) : a2.push(r2);
    }
    a2.forEach(((e3) => e3[vs]()[Zs](e3)));
  }
};
var DataHandler = class {
  constructor(e2, t2) {
    this.data = t2;
    this.dataset = e2.datasets || null;
  }
  serialize(e2) {
    const t2 = [[-1, this.data[Ss]()]];
    for (; t2.length > 0; ) {
      const a3 = t2.at(-1), [r2, i2] = a3;
      if (r2 + 1 === i2.length) {
        t2.pop();
        continue;
      }
      const n2 = i2[++a3[0]], s2 = e2.get(n2[uo]);
      if (s2) n2[io](s2);
      else {
        const t3 = n2[fs]();
        for (const a4 of t3.values()) {
          const t4 = e2.get(a4[uo]);
          if (t4) {
            a4[io](t4);
            break;
          }
        }
      }
      const o2 = n2[Ss]();
      o2.length > 0 && t2.push([-1, o2]);
    }
    const a2 = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
    if (this.dataset) for (const e3 of this.dataset[Ss]()) "data" !== e3[Ws] && e3[lo](a2);
    this.data[lo](a2);
    a2.push("</xfa:datasets>");
    return a2.join("");
  }
};
var Qo = go.config.id;
var Acrobat = class extends XFAObject {
  constructor(e2) {
    super(Qo, "acrobat", true);
    this.acrobat7 = null;
    this.autoSave = null;
    this.common = null;
    this.validate = null;
    this.validateApprovalSignatures = null;
    this.submitUrl = new XFAObjectArray();
  }
};
var Acrobat7 = class extends XFAObject {
  constructor(e2) {
    super(Qo, "acrobat7", true);
    this.dynamicRender = null;
  }
};
var ADBE_JSConsole = class extends OptionObject {
  constructor(e2) {
    super(Qo, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }
};
var ADBE_JSDebugger = class extends OptionObject {
  constructor(e2) {
    super(Qo, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }
};
var AddSilentPrint = class extends Option01 {
  constructor(e2) {
    super(Qo, "addSilentPrint");
  }
};
var AddViewerPreferences = class extends Option01 {
  constructor(e2) {
    super(Qo, "addViewerPreferences");
  }
};
var AdjustData = class extends Option10 {
  constructor(e2) {
    super(Qo, "adjustData");
  }
};
var AdobeExtensionLevel = class extends IntegerObject {
  constructor(e2) {
    super(Qo, "adobeExtensionLevel", 0, ((e3) => e3 >= 1 && e3 <= 8));
  }
};
var Agent = class extends XFAObject {
  constructor(e2) {
    super(Qo, "agent", true);
    this.name = e2.name ? e2.name.trim() : "";
    this.common = new XFAObjectArray();
  }
};
var AlwaysEmbed = class extends ContentObject {
  constructor(e2) {
    super(Qo, "alwaysEmbed");
  }
};
var Amd = class extends StringObject {
  constructor(e2) {
    super(Qo, "amd");
  }
};
var config_Area = class extends XFAObject {
  constructor(e2) {
    super(Qo, "area");
    this.level = getInteger({ data: e2.level, defaultValue: 0, validate: (e3) => e3 >= 1 && e3 <= 3 });
    this.name = getStringOption(e2.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }
};
var Attributes = class extends OptionObject {
  constructor(e2) {
    super(Qo, "attributes", ["preserve", "delegate", "ignore"]);
  }
};
var AutoSave = class extends OptionObject {
  constructor(e2) {
    super(Qo, "autoSave", ["disabled", "enabled"]);
  }
};
var Base = class extends StringObject {
  constructor(e2) {
    super(Qo, "base");
  }
};
var BatchOutput = class extends XFAObject {
  constructor(e2) {
    super(Qo, "batchOutput");
    this.format = getStringOption(e2.format, ["none", "concat", "zip", "zipCompress"]);
  }
};
var BehaviorOverride = class extends ContentObject {
  constructor(e2) {
    super(Qo, "behaviorOverride");
  }
  [hs]() {
    this[ss] = new Map(this[ss].trim().split(/\s+/).filter(((e2) => e2.includes(":"))).map(((e2) => e2.split(":", 2))));
  }
};
var Cache = class extends XFAObject {
  constructor(e2) {
    super(Qo, "cache", true);
    this.templateCache = null;
  }
};
var Change = class extends Option01 {
  constructor(e2) {
    super(Qo, "change");
  }
};
var Common = class extends XFAObject {
  constructor(e2) {
    super(Qo, "common", true);
    this.data = null;
    this.locale = null;
    this.localeSet = null;
    this.messaging = null;
    this.suppressBanner = null;
    this.template = null;
    this.validationMessaging = null;
    this.versionControl = null;
    this.log = new XFAObjectArray();
  }
};
var Compress = class extends XFAObject {
  constructor(e2) {
    super(Qo, "compress");
    this.scope = getStringOption(e2.scope, ["imageOnly", "document"]);
  }
};
var CompressLogicalStructure = class extends Option01 {
  constructor(e2) {
    super(Qo, "compressLogicalStructure");
  }
};
var CompressObjectStream = class extends Option10 {
  constructor(e2) {
    super(Qo, "compressObjectStream");
  }
};
var Compression = class extends XFAObject {
  constructor(e2) {
    super(Qo, "compression", true);
    this.compressLogicalStructure = null;
    this.compressObjectStream = null;
    this.level = null;
    this.type = null;
  }
};
var Config = class extends XFAObject {
  constructor(e2) {
    super(Qo, "config", true);
    this.acrobat = null;
    this.present = null;
    this.trace = null;
    this.agent = new XFAObjectArray();
  }
};
var Conformance = class extends OptionObject {
  constructor(e2) {
    super(Qo, "conformance", ["A", "B"]);
  }
};
var ContentCopy = class extends Option01 {
  constructor(e2) {
    super(Qo, "contentCopy");
  }
};
var Copies = class extends IntegerObject {
  constructor(e2) {
    super(Qo, "copies", 1, ((e3) => e3 >= 1));
  }
};
var Creator = class extends StringObject {
  constructor(e2) {
    super(Qo, "creator");
  }
};
var CurrentPage = class extends IntegerObject {
  constructor(e2) {
    super(Qo, "currentPage", 0, ((e3) => e3 >= 0));
  }
};
var Data = class extends XFAObject {
  constructor(e2) {
    super(Qo, "data", true);
    this.adjustData = null;
    this.attributes = null;
    this.incrementalLoad = null;
    this.outputXSL = null;
    this.range = null;
    this.record = null;
    this.startNode = null;
    this.uri = null;
    this.window = null;
    this.xsl = null;
    this.excludeNS = new XFAObjectArray();
    this.transform = new XFAObjectArray();
  }
};
var Debug = class extends XFAObject {
  constructor(e2) {
    super(Qo, "debug", true);
    this.uri = null;
  }
};
var DefaultTypeface = class extends ContentObject {
  constructor(e2) {
    super(Qo, "defaultTypeface");
    this.writingScript = getStringOption(e2.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }
};
var Destination = class extends OptionObject {
  constructor(e2) {
    super(Qo, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }
};
var DocumentAssembly = class extends Option01 {
  constructor(e2) {
    super(Qo, "documentAssembly");
  }
};
var Driver = class extends XFAObject {
  constructor(e2) {
    super(Qo, "driver", true);
    this.name = e2.name ? e2.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }
};
var DuplexOption = class extends OptionObject {
  constructor(e2) {
    super(Qo, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }
};
var DynamicRender = class extends OptionObject {
  constructor(e2) {
    super(Qo, "dynamicRender", ["forbidden", "required"]);
  }
};
var Embed = class extends Option01 {
  constructor(e2) {
    super(Qo, "embed");
  }
};
var config_Encrypt = class extends Option01 {
  constructor(e2) {
    super(Qo, "encrypt");
  }
};
var config_Encryption = class extends XFAObject {
  constructor(e2) {
    super(Qo, "encryption", true);
    this.encrypt = null;
    this.encryptionLevel = null;
    this.permissions = null;
  }
};
var EncryptionLevel = class extends OptionObject {
  constructor(e2) {
    super(Qo, "encryptionLevel", ["40bit", "128bit"]);
  }
};
var Enforce = class extends StringObject {
  constructor(e2) {
    super(Qo, "enforce");
  }
};
var Equate = class extends XFAObject {
  constructor(e2) {
    super(Qo, "equate");
    this.force = getInteger({ data: e2.force, defaultValue: 1, validate: (e3) => 0 === e3 });
    this.from = e2.from || "";
    this.to = e2.to || "";
  }
};
var EquateRange = class extends XFAObject {
  constructor(e2) {
    super(Qo, "equateRange");
    this.from = e2.from || "";
    this.to = e2.to || "";
    this._unicodeRange = e2.unicodeRange || "";
  }
  get unicodeRange() {
    const e2 = [], t2 = /U\+([0-9a-fA-F]+)/, a2 = this._unicodeRange;
    for (let r2 of a2.split(",").map(((e3) => e3.trim())).filter(((e3) => !!e3))) {
      r2 = r2.split("-", 2).map(((e3) => {
        const a3 = e3.match(t2);
        return a3 ? parseInt(a3[1], 16) : 0;
      }));
      1 === r2.length && r2.push(r2[0]);
      e2.push(r2);
    }
    return shadow(this, "unicodeRange", e2);
  }
};
var Exclude = class extends ContentObject {
  constructor(e2) {
    super(Qo, "exclude");
  }
  [hs]() {
    this[ss] = this[ss].trim().split(/\s+/).filter(((e2) => e2 && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(e2)));
  }
};
var ExcludeNS = class extends StringObject {
  constructor(e2) {
    super(Qo, "excludeNS");
  }
};
var FlipLabel = class extends OptionObject {
  constructor(e2) {
    super(Qo, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }
};
var config_FontInfo = class extends XFAObject {
  constructor(e2) {
    super(Qo, "fontInfo", true);
    this.embed = null;
    this.map = null;
    this.subsetBelow = null;
    this.alwaysEmbed = new XFAObjectArray();
    this.defaultTypeface = new XFAObjectArray();
    this.neverEmbed = new XFAObjectArray();
  }
};
var FormFieldFilling = class extends Option01 {
  constructor(e2) {
    super(Qo, "formFieldFilling");
  }
};
var GroupParent = class extends StringObject {
  constructor(e2) {
    super(Qo, "groupParent");
  }
};
var IfEmpty = class extends OptionObject {
  constructor(e2) {
    super(Qo, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }
};
var IncludeXDPContent = class extends StringObject {
  constructor(e2) {
    super(Qo, "includeXDPContent");
  }
};
var IncrementalLoad = class extends OptionObject {
  constructor(e2) {
    super(Qo, "incrementalLoad", ["none", "forwardOnly"]);
  }
};
var IncrementalMerge = class extends Option01 {
  constructor(e2) {
    super(Qo, "incrementalMerge");
  }
};
var Interactive = class extends Option01 {
  constructor(e2) {
    super(Qo, "interactive");
  }
};
var Jog = class extends OptionObject {
  constructor(e2) {
    super(Qo, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }
};
var LabelPrinter = class extends XFAObject {
  constructor(e2) {
    super(Qo, "labelPrinter", true);
    this.name = getStringOption(e2.name, ["zpl", "dpl", "ipl", "tcpl"]);
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }
};
var Layout = class extends OptionObject {
  constructor(e2) {
    super(Qo, "layout", ["paginate", "panel"]);
  }
};
var Level = class extends IntegerObject {
  constructor(e2) {
    super(Qo, "level", 0, ((e3) => e3 > 0));
  }
};
var Linearized = class extends Option01 {
  constructor(e2) {
    super(Qo, "linearized");
  }
};
var Locale = class extends StringObject {
  constructor(e2) {
    super(Qo, "locale");
  }
};
var LocaleSet = class extends StringObject {
  constructor(e2) {
    super(Qo, "localeSet");
  }
};
var Log = class extends XFAObject {
  constructor(e2) {
    super(Qo, "log", true);
    this.mode = null;
    this.threshold = null;
    this.to = null;
    this.uri = null;
  }
};
var MapElement = class extends XFAObject {
  constructor(e2) {
    super(Qo, "map", true);
    this.equate = new XFAObjectArray();
    this.equateRange = new XFAObjectArray();
  }
};
var MediumInfo = class extends XFAObject {
  constructor(e2) {
    super(Qo, "mediumInfo", true);
    this.map = null;
  }
};
var config_Message = class extends XFAObject {
  constructor(e2) {
    super(Qo, "message", true);
    this.msgId = null;
    this.severity = null;
  }
};
var Messaging = class extends XFAObject {
  constructor(e2) {
    super(Qo, "messaging", true);
    this.message = new XFAObjectArray();
  }
};
var Mode = class extends OptionObject {
  constructor(e2) {
    super(Qo, "mode", ["append", "overwrite"]);
  }
};
var ModifyAnnots = class extends Option01 {
  constructor(e2) {
    super(Qo, "modifyAnnots");
  }
};
var MsgId = class extends IntegerObject {
  constructor(e2) {
    super(Qo, "msgId", 1, ((e3) => e3 >= 1));
  }
};
var NameAttr = class extends StringObject {
  constructor(e2) {
    super(Qo, "nameAttr");
  }
};
var NeverEmbed = class extends ContentObject {
  constructor(e2) {
    super(Qo, "neverEmbed");
  }
};
var NumberOfCopies = class extends IntegerObject {
  constructor(e2) {
    super(Qo, "numberOfCopies", null, ((e3) => e3 >= 2 && e3 <= 5));
  }
};
var OpenAction = class extends XFAObject {
  constructor(e2) {
    super(Qo, "openAction", true);
    this.destination = null;
  }
};
var Output = class extends XFAObject {
  constructor(e2) {
    super(Qo, "output", true);
    this.to = null;
    this.type = null;
    this.uri = null;
  }
};
var OutputBin = class extends StringObject {
  constructor(e2) {
    super(Qo, "outputBin");
  }
};
var OutputXSL = class extends XFAObject {
  constructor(e2) {
    super(Qo, "outputXSL", true);
    this.uri = null;
  }
};
var Overprint = class extends OptionObject {
  constructor(e2) {
    super(Qo, "overprint", ["none", "both", "draw", "field"]);
  }
};
var Packets = class extends StringObject {
  constructor(e2) {
    super(Qo, "packets");
  }
  [hs]() {
    "*" !== this[ss] && (this[ss] = this[ss].trim().split(/\s+/).filter(((e2) => ["config", "datasets", "template", "xfdf", "xslt"].includes(e2))));
  }
};
var PageOffset = class extends XFAObject {
  constructor(e2) {
    super(Qo, "pageOffset");
    this.x = getInteger({ data: e2.x, defaultValue: "useXDCSetting", validate: (e3) => true });
    this.y = getInteger({ data: e2.y, defaultValue: "useXDCSetting", validate: (e3) => true });
  }
};
var PageRange = class extends StringObject {
  constructor(e2) {
    super(Qo, "pageRange");
  }
  [hs]() {
    const e2 = this[ss].trim().split(/\s+/).map(((e3) => parseInt(e3, 10))), t2 = [];
    for (let a2 = 0, r2 = e2.length; a2 < r2; a2 += 2) t2.push(e2.slice(a2, a2 + 2));
    this[ss] = t2;
  }
};
var Pagination = class extends OptionObject {
  constructor(e2) {
    super(Qo, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }
};
var PaginationOverride = class extends OptionObject {
  constructor(e2) {
    super(Qo, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }
};
var Part = class extends IntegerObject {
  constructor(e2) {
    super(Qo, "part", 1, ((e3) => false));
  }
};
var Pcl = class extends XFAObject {
  constructor(e2) {
    super(Qo, "pcl", true);
    this.name = e2.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.pageOffset = null;
    this.staple = null;
    this.xdc = null;
  }
};
var Pdf = class extends XFAObject {
  constructor(e2) {
    super(Qo, "pdf", true);
    this.name = e2.name || "";
    this.adobeExtensionLevel = null;
    this.batchOutput = null;
    this.compression = null;
    this.creator = null;
    this.encryption = null;
    this.fontInfo = null;
    this.interactive = null;
    this.linearized = null;
    this.openAction = null;
    this.pdfa = null;
    this.producer = null;
    this.renderPolicy = null;
    this.scriptModel = null;
    this.silentPrint = null;
    this.submitFormat = null;
    this.tagged = null;
    this.version = null;
    this.viewerPreferences = null;
    this.xdc = null;
  }
};
var Pdfa = class extends XFAObject {
  constructor(e2) {
    super(Qo, "pdfa", true);
    this.amd = null;
    this.conformance = null;
    this.includeXDPContent = null;
    this.part = null;
  }
};
var Permissions = class extends XFAObject {
  constructor(e2) {
    super(Qo, "permissions", true);
    this.accessibleContent = null;
    this.change = null;
    this.contentCopy = null;
    this.documentAssembly = null;
    this.formFieldFilling = null;
    this.modifyAnnots = null;
    this.plaintextMetadata = null;
    this.print = null;
    this.printHighQuality = null;
  }
};
var PickTrayByPDFSize = class extends Option01 {
  constructor(e2) {
    super(Qo, "pickTrayByPDFSize");
  }
};
var config_Picture = class extends StringObject {
  constructor(e2) {
    super(Qo, "picture");
  }
};
var PlaintextMetadata = class extends Option01 {
  constructor(e2) {
    super(Qo, "plaintextMetadata");
  }
};
var Presence = class extends OptionObject {
  constructor(e2) {
    super(Qo, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }
};
var Present = class extends XFAObject {
  constructor(e2) {
    super(Qo, "present", true);
    this.behaviorOverride = null;
    this.cache = null;
    this.common = null;
    this.copies = null;
    this.destination = null;
    this.incrementalMerge = null;
    this.layout = null;
    this.output = null;
    this.overprint = null;
    this.pagination = null;
    this.paginationOverride = null;
    this.script = null;
    this.validate = null;
    this.xdp = null;
    this.driver = new XFAObjectArray();
    this.labelPrinter = new XFAObjectArray();
    this.pcl = new XFAObjectArray();
    this.pdf = new XFAObjectArray();
    this.ps = new XFAObjectArray();
    this.submitUrl = new XFAObjectArray();
    this.webClient = new XFAObjectArray();
    this.zpl = new XFAObjectArray();
  }
};
var Print = class extends Option01 {
  constructor(e2) {
    super(Qo, "print");
  }
};
var PrintHighQuality = class extends Option01 {
  constructor(e2) {
    super(Qo, "printHighQuality");
  }
};
var PrintScaling = class extends OptionObject {
  constructor(e2) {
    super(Qo, "printScaling", ["appdefault", "noScaling"]);
  }
};
var PrinterName = class extends StringObject {
  constructor(e2) {
    super(Qo, "printerName");
  }
};
var Producer = class extends StringObject {
  constructor(e2) {
    super(Qo, "producer");
  }
};
var Ps = class extends XFAObject {
  constructor(e2) {
    super(Qo, "ps", true);
    this.name = e2.name || "";
    this.batchOutput = null;
    this.fontInfo = null;
    this.jog = null;
    this.mediumInfo = null;
    this.outputBin = null;
    this.staple = null;
    this.xdc = null;
  }
};
var Range = class extends ContentObject {
  constructor(e2) {
    super(Qo, "range");
  }
  [hs]() {
    this[ss] = this[ss].split(",", 2).map(((e2) => e2.split("-").map(((e3) => parseInt(e3.trim(), 10))))).filter(((e2) => e2.every(((e3) => !isNaN(e3))))).map(((e2) => {
      1 === e2.length && e2.push(e2[0]);
      return e2;
    }));
  }
};
var Record = class extends ContentObject {
  constructor(e2) {
    super(Qo, "record");
  }
  [hs]() {
    this[ss] = this[ss].trim();
    const e2 = parseInt(this[ss], 10);
    !isNaN(e2) && e2 >= 0 && (this[ss] = e2);
  }
};
var Relevant = class extends ContentObject {
  constructor(e2) {
    super(Qo, "relevant");
  }
  [hs]() {
    this[ss] = this[ss].trim().split(/\s+/);
  }
};
var Rename = class extends ContentObject {
  constructor(e2) {
    super(Qo, "rename");
  }
  [hs]() {
    this[ss] = this[ss].trim();
    (this[ss].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[ss])) && warn("XFA - Rename: invalid XFA name");
  }
};
var RenderPolicy = class extends OptionObject {
  constructor(e2) {
    super(Qo, "renderPolicy", ["server", "client"]);
  }
};
var RunScripts = class extends OptionObject {
  constructor(e2) {
    super(Qo, "runScripts", ["both", "client", "none", "server"]);
  }
};
var config_Script = class extends XFAObject {
  constructor(e2) {
    super(Qo, "script", true);
    this.currentPage = null;
    this.exclude = null;
    this.runScripts = null;
  }
};
var ScriptModel = class extends OptionObject {
  constructor(e2) {
    super(Qo, "scriptModel", ["XFA", "none"]);
  }
};
var Severity = class extends OptionObject {
  constructor(e2) {
    super(Qo, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }
};
var SilentPrint = class extends XFAObject {
  constructor(e2) {
    super(Qo, "silentPrint", true);
    this.addSilentPrint = null;
    this.printerName = null;
  }
};
var Staple = class extends XFAObject {
  constructor(e2) {
    super(Qo, "staple");
    this.mode = getStringOption(e2.mode, ["usePrinterSetting", "on", "off"]);
  }
};
var StartNode = class extends StringObject {
  constructor(e2) {
    super(Qo, "startNode");
  }
};
var StartPage = class extends IntegerObject {
  constructor(e2) {
    super(Qo, "startPage", 0, ((e3) => true));
  }
};
var SubmitFormat = class extends OptionObject {
  constructor(e2) {
    super(Qo, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }
};
var SubmitUrl = class extends StringObject {
  constructor(e2) {
    super(Qo, "submitUrl");
  }
};
var SubsetBelow = class extends IntegerObject {
  constructor(e2) {
    super(Qo, "subsetBelow", 100, ((e3) => e3 >= 0 && e3 <= 100));
  }
};
var SuppressBanner = class extends Option01 {
  constructor(e2) {
    super(Qo, "suppressBanner");
  }
};
var Tagged = class extends Option01 {
  constructor(e2) {
    super(Qo, "tagged");
  }
};
var config_Template = class extends XFAObject {
  constructor(e2) {
    super(Qo, "template", true);
    this.base = null;
    this.relevant = null;
    this.startPage = null;
    this.uri = null;
    this.xsl = null;
  }
};
var Threshold = class extends OptionObject {
  constructor(e2) {
    super(Qo, "threshold", ["trace", "error", "information", "warning"]);
  }
};
var To = class extends OptionObject {
  constructor(e2) {
    super(Qo, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }
};
var TemplateCache = class extends XFAObject {
  constructor(e2) {
    super(Qo, "templateCache");
    this.maxEntries = getInteger({ data: e2.maxEntries, defaultValue: 5, validate: (e3) => e3 >= 0 });
  }
};
var Trace = class extends XFAObject {
  constructor(e2) {
    super(Qo, "trace", true);
    this.area = new XFAObjectArray();
  }
};
var Transform = class extends XFAObject {
  constructor(e2) {
    super(Qo, "transform", true);
    this.groupParent = null;
    this.ifEmpty = null;
    this.nameAttr = null;
    this.picture = null;
    this.presence = null;
    this.rename = null;
    this.whitespace = null;
  }
};
var Type = class extends OptionObject {
  constructor(e2) {
    super(Qo, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }
};
var Uri = class extends StringObject {
  constructor(e2) {
    super(Qo, "uri");
  }
};
var config_Validate = class extends OptionObject {
  constructor(e2) {
    super(Qo, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }
};
var ValidateApprovalSignatures = class extends ContentObject {
  constructor(e2) {
    super(Qo, "validateApprovalSignatures");
  }
  [hs]() {
    this[ss] = this[ss].trim().split(/\s+/).filter(((e2) => ["docReady", "postSign"].includes(e2)));
  }
};
var ValidationMessaging = class extends OptionObject {
  constructor(e2) {
    super(Qo, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }
};
var Version = class extends OptionObject {
  constructor(e2) {
    super(Qo, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }
};
var VersionControl = class extends XFAObject {
  constructor(e2) {
    super(Qo, "VersionControl");
    this.outputBelow = getStringOption(e2.outputBelow, ["warn", "error", "update"]);
    this.sourceAbove = getStringOption(e2.sourceAbove, ["warn", "error"]);
    this.sourceBelow = getStringOption(e2.sourceBelow, ["update", "maintain"]);
  }
};
var ViewerPreferences = class extends XFAObject {
  constructor(e2) {
    super(Qo, "viewerPreferences", true);
    this.ADBE_JSConsole = null;
    this.ADBE_JSDebugger = null;
    this.addViewerPreferences = null;
    this.duplexOption = null;
    this.enforce = null;
    this.numberOfCopies = null;
    this.pageRange = null;
    this.pickTrayByPDFSize = null;
    this.printScaling = null;
  }
};
var WebClient = class extends XFAObject {
  constructor(e2) {
    super(Qo, "webClient", true);
    this.name = e2.name ? e2.name.trim() : "";
    this.fontInfo = null;
    this.xdc = null;
  }
};
var Whitespace = class extends OptionObject {
  constructor(e2) {
    super(Qo, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }
};
var Window = class extends ContentObject {
  constructor(e2) {
    super(Qo, "window");
  }
  [hs]() {
    const e2 = this[ss].split(",", 2).map(((e3) => parseInt(e3.trim(), 10)));
    if (e2.some(((e3) => isNaN(e3)))) this[ss] = [0, 0];
    else {
      1 === e2.length && e2.push(e2[0]);
      this[ss] = e2;
    }
  }
};
var Xdc = class extends XFAObject {
  constructor(e2) {
    super(Qo, "xdc", true);
    this.uri = new XFAObjectArray();
    this.xsl = new XFAObjectArray();
  }
};
var Xdp = class extends XFAObject {
  constructor(e2) {
    super(Qo, "xdp", true);
    this.packets = null;
  }
};
var Xsl = class extends XFAObject {
  constructor(e2) {
    super(Qo, "xsl", true);
    this.debug = null;
    this.uri = null;
  }
};
var Zpl = class extends XFAObject {
  constructor(e2) {
    super(Qo, "zpl", true);
    this.name = e2.name ? e2.name.trim() : "";
    this.batchOutput = null;
    this.flipLabel = null;
    this.fontInfo = null;
    this.xdc = null;
  }
};
var ConfigNamespace = class _ConfigNamespace {
  static [fo](e2, t2) {
    if (_ConfigNamespace.hasOwnProperty(e2)) return _ConfigNamespace[e2](t2);
  }
  static acrobat(e2) {
    return new Acrobat(e2);
  }
  static acrobat7(e2) {
    return new Acrobat7(e2);
  }
  static ADBE_JSConsole(e2) {
    return new ADBE_JSConsole(e2);
  }
  static ADBE_JSDebugger(e2) {
    return new ADBE_JSDebugger(e2);
  }
  static addSilentPrint(e2) {
    return new AddSilentPrint(e2);
  }
  static addViewerPreferences(e2) {
    return new AddViewerPreferences(e2);
  }
  static adjustData(e2) {
    return new AdjustData(e2);
  }
  static adobeExtensionLevel(e2) {
    return new AdobeExtensionLevel(e2);
  }
  static agent(e2) {
    return new Agent(e2);
  }
  static alwaysEmbed(e2) {
    return new AlwaysEmbed(e2);
  }
  static amd(e2) {
    return new Amd(e2);
  }
  static area(e2) {
    return new config_Area(e2);
  }
  static attributes(e2) {
    return new Attributes(e2);
  }
  static autoSave(e2) {
    return new AutoSave(e2);
  }
  static base(e2) {
    return new Base(e2);
  }
  static batchOutput(e2) {
    return new BatchOutput(e2);
  }
  static behaviorOverride(e2) {
    return new BehaviorOverride(e2);
  }
  static cache(e2) {
    return new Cache(e2);
  }
  static change(e2) {
    return new Change(e2);
  }
  static common(e2) {
    return new Common(e2);
  }
  static compress(e2) {
    return new Compress(e2);
  }
  static compressLogicalStructure(e2) {
    return new CompressLogicalStructure(e2);
  }
  static compressObjectStream(e2) {
    return new CompressObjectStream(e2);
  }
  static compression(e2) {
    return new Compression(e2);
  }
  static config(e2) {
    return new Config(e2);
  }
  static conformance(e2) {
    return new Conformance(e2);
  }
  static contentCopy(e2) {
    return new ContentCopy(e2);
  }
  static copies(e2) {
    return new Copies(e2);
  }
  static creator(e2) {
    return new Creator(e2);
  }
  static currentPage(e2) {
    return new CurrentPage(e2);
  }
  static data(e2) {
    return new Data(e2);
  }
  static debug(e2) {
    return new Debug(e2);
  }
  static defaultTypeface(e2) {
    return new DefaultTypeface(e2);
  }
  static destination(e2) {
    return new Destination(e2);
  }
  static documentAssembly(e2) {
    return new DocumentAssembly(e2);
  }
  static driver(e2) {
    return new Driver(e2);
  }
  static duplexOption(e2) {
    return new DuplexOption(e2);
  }
  static dynamicRender(e2) {
    return new DynamicRender(e2);
  }
  static embed(e2) {
    return new Embed(e2);
  }
  static encrypt(e2) {
    return new config_Encrypt(e2);
  }
  static encryption(e2) {
    return new config_Encryption(e2);
  }
  static encryptionLevel(e2) {
    return new EncryptionLevel(e2);
  }
  static enforce(e2) {
    return new Enforce(e2);
  }
  static equate(e2) {
    return new Equate(e2);
  }
  static equateRange(e2) {
    return new EquateRange(e2);
  }
  static exclude(e2) {
    return new Exclude(e2);
  }
  static excludeNS(e2) {
    return new ExcludeNS(e2);
  }
  static flipLabel(e2) {
    return new FlipLabel(e2);
  }
  static fontInfo(e2) {
    return new config_FontInfo(e2);
  }
  static formFieldFilling(e2) {
    return new FormFieldFilling(e2);
  }
  static groupParent(e2) {
    return new GroupParent(e2);
  }
  static ifEmpty(e2) {
    return new IfEmpty(e2);
  }
  static includeXDPContent(e2) {
    return new IncludeXDPContent(e2);
  }
  static incrementalLoad(e2) {
    return new IncrementalLoad(e2);
  }
  static incrementalMerge(e2) {
    return new IncrementalMerge(e2);
  }
  static interactive(e2) {
    return new Interactive(e2);
  }
  static jog(e2) {
    return new Jog(e2);
  }
  static labelPrinter(e2) {
    return new LabelPrinter(e2);
  }
  static layout(e2) {
    return new Layout(e2);
  }
  static level(e2) {
    return new Level(e2);
  }
  static linearized(e2) {
    return new Linearized(e2);
  }
  static locale(e2) {
    return new Locale(e2);
  }
  static localeSet(e2) {
    return new LocaleSet(e2);
  }
  static log(e2) {
    return new Log(e2);
  }
  static map(e2) {
    return new MapElement(e2);
  }
  static mediumInfo(e2) {
    return new MediumInfo(e2);
  }
  static message(e2) {
    return new config_Message(e2);
  }
  static messaging(e2) {
    return new Messaging(e2);
  }
  static mode(e2) {
    return new Mode(e2);
  }
  static modifyAnnots(e2) {
    return new ModifyAnnots(e2);
  }
  static msgId(e2) {
    return new MsgId(e2);
  }
  static nameAttr(e2) {
    return new NameAttr(e2);
  }
  static neverEmbed(e2) {
    return new NeverEmbed(e2);
  }
  static numberOfCopies(e2) {
    return new NumberOfCopies(e2);
  }
  static openAction(e2) {
    return new OpenAction(e2);
  }
  static output(e2) {
    return new Output(e2);
  }
  static outputBin(e2) {
    return new OutputBin(e2);
  }
  static outputXSL(e2) {
    return new OutputXSL(e2);
  }
  static overprint(e2) {
    return new Overprint(e2);
  }
  static packets(e2) {
    return new Packets(e2);
  }
  static pageOffset(e2) {
    return new PageOffset(e2);
  }
  static pageRange(e2) {
    return new PageRange(e2);
  }
  static pagination(e2) {
    return new Pagination(e2);
  }
  static paginationOverride(e2) {
    return new PaginationOverride(e2);
  }
  static part(e2) {
    return new Part(e2);
  }
  static pcl(e2) {
    return new Pcl(e2);
  }
  static pdf(e2) {
    return new Pdf(e2);
  }
  static pdfa(e2) {
    return new Pdfa(e2);
  }
  static permissions(e2) {
    return new Permissions(e2);
  }
  static pickTrayByPDFSize(e2) {
    return new PickTrayByPDFSize(e2);
  }
  static picture(e2) {
    return new config_Picture(e2);
  }
  static plaintextMetadata(e2) {
    return new PlaintextMetadata(e2);
  }
  static presence(e2) {
    return new Presence(e2);
  }
  static present(e2) {
    return new Present(e2);
  }
  static print(e2) {
    return new Print(e2);
  }
  static printHighQuality(e2) {
    return new PrintHighQuality(e2);
  }
  static printScaling(e2) {
    return new PrintScaling(e2);
  }
  static printerName(e2) {
    return new PrinterName(e2);
  }
  static producer(e2) {
    return new Producer(e2);
  }
  static ps(e2) {
    return new Ps(e2);
  }
  static range(e2) {
    return new Range(e2);
  }
  static record(e2) {
    return new Record(e2);
  }
  static relevant(e2) {
    return new Relevant(e2);
  }
  static rename(e2) {
    return new Rename(e2);
  }
  static renderPolicy(e2) {
    return new RenderPolicy(e2);
  }
  static runScripts(e2) {
    return new RunScripts(e2);
  }
  static script(e2) {
    return new config_Script(e2);
  }
  static scriptModel(e2) {
    return new ScriptModel(e2);
  }
  static severity(e2) {
    return new Severity(e2);
  }
  static silentPrint(e2) {
    return new SilentPrint(e2);
  }
  static staple(e2) {
    return new Staple(e2);
  }
  static startNode(e2) {
    return new StartNode(e2);
  }
  static startPage(e2) {
    return new StartPage(e2);
  }
  static submitFormat(e2) {
    return new SubmitFormat(e2);
  }
  static submitUrl(e2) {
    return new SubmitUrl(e2);
  }
  static subsetBelow(e2) {
    return new SubsetBelow(e2);
  }
  static suppressBanner(e2) {
    return new SuppressBanner(e2);
  }
  static tagged(e2) {
    return new Tagged(e2);
  }
  static template(e2) {
    return new config_Template(e2);
  }
  static templateCache(e2) {
    return new TemplateCache(e2);
  }
  static threshold(e2) {
    return new Threshold(e2);
  }
  static to(e2) {
    return new To(e2);
  }
  static trace(e2) {
    return new Trace(e2);
  }
  static transform(e2) {
    return new Transform(e2);
  }
  static type(e2) {
    return new Type(e2);
  }
  static uri(e2) {
    return new Uri(e2);
  }
  static validate(e2) {
    return new config_Validate(e2);
  }
  static validateApprovalSignatures(e2) {
    return new ValidateApprovalSignatures(e2);
  }
  static validationMessaging(e2) {
    return new ValidationMessaging(e2);
  }
  static version(e2) {
    return new Version(e2);
  }
  static versionControl(e2) {
    return new VersionControl(e2);
  }
  static viewerPreferences(e2) {
    return new ViewerPreferences(e2);
  }
  static webClient(e2) {
    return new WebClient(e2);
  }
  static whitespace(e2) {
    return new Whitespace(e2);
  }
  static window(e2) {
    return new Window(e2);
  }
  static xdc(e2) {
    return new Xdc(e2);
  }
  static xdp(e2) {
    return new Xdp(e2);
  }
  static xsl(e2) {
    return new Xsl(e2);
  }
  static zpl(e2) {
    return new Zpl(e2);
  }
};
var ec = go.connectionSet.id;
var ConnectionSet = class extends XFAObject {
  constructor(e2) {
    super(ec, "connectionSet", true);
    this.wsdlConnection = new XFAObjectArray();
    this.xmlConnection = new XFAObjectArray();
    this.xsdConnection = new XFAObjectArray();
  }
};
var EffectiveInputPolicy = class extends XFAObject {
  constructor(e2) {
    super(ec, "effectiveInputPolicy");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var EffectiveOutputPolicy = class extends XFAObject {
  constructor(e2) {
    super(ec, "effectiveOutputPolicy");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var Operation = class extends StringObject {
  constructor(e2) {
    super(ec, "operation");
    this.id = e2.id || "";
    this.input = e2.input || "";
    this.name = e2.name || "";
    this.output = e2.output || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var RootElement = class extends StringObject {
  constructor(e2) {
    super(ec, "rootElement");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var SoapAction = class extends StringObject {
  constructor(e2) {
    super(ec, "soapAction");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var SoapAddress = class extends StringObject {
  constructor(e2) {
    super(ec, "soapAddress");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var connection_set_Uri = class extends StringObject {
  constructor(e2) {
    super(ec, "uri");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var WsdlAddress = class extends StringObject {
  constructor(e2) {
    super(ec, "wsdlAddress");
    this.id = e2.id || "";
    this.name = e2.name || "";
    this.use = e2.use || "";
    this.usehref = e2.usehref || "";
  }
};
var WsdlConnection = class extends XFAObject {
  constructor(e2) {
    super(ec, "wsdlConnection", true);
    this.dataDescription = e2.dataDescription || "";
    this.name = e2.name || "";
    this.effectiveInputPolicy = null;
    this.effectiveOutputPolicy = null;
    this.operation = null;
    this.soapAction = null;
    this.soapAddress = null;
    this.wsdlAddress = null;
  }
};
var XmlConnection = class extends XFAObject {
  constructor(e2) {
    super(ec, "xmlConnection", true);
    this.dataDescription = e2.dataDescription || "";
    this.name = e2.name || "";
    this.uri = null;
  }
};
var XsdConnection = class extends XFAObject {
  constructor(e2) {
    super(ec, "xsdConnection", true);
    this.dataDescription = e2.dataDescription || "";
    this.name = e2.name || "";
    this.rootElement = null;
    this.uri = null;
  }
};
var ConnectionSetNamespace = class _ConnectionSetNamespace {
  static [fo](e2, t2) {
    if (_ConnectionSetNamespace.hasOwnProperty(e2)) return _ConnectionSetNamespace[e2](t2);
  }
  static connectionSet(e2) {
    return new ConnectionSet(e2);
  }
  static effectiveInputPolicy(e2) {
    return new EffectiveInputPolicy(e2);
  }
  static effectiveOutputPolicy(e2) {
    return new EffectiveOutputPolicy(e2);
  }
  static operation(e2) {
    return new Operation(e2);
  }
  static rootElement(e2) {
    return new RootElement(e2);
  }
  static soapAction(e2) {
    return new SoapAction(e2);
  }
  static soapAddress(e2) {
    return new SoapAddress(e2);
  }
  static uri(e2) {
    return new connection_set_Uri(e2);
  }
  static wsdlAddress(e2) {
    return new WsdlAddress(e2);
  }
  static wsdlConnection(e2) {
    return new WsdlConnection(e2);
  }
  static xmlConnection(e2) {
    return new XmlConnection(e2);
  }
  static xsdConnection(e2) {
    return new XsdConnection(e2);
  }
};
var tc = go.datasets.id;
var datasets_Data = class extends XmlObject {
  constructor(e2) {
    super(tc, "data", e2);
  }
  [Ls]() {
    return true;
  }
};
var Datasets = class extends XFAObject {
  constructor(e2) {
    super(tc, "datasets", true);
    this.data = null;
    this.Signature = null;
  }
  [$s](e2) {
    const t2 = e2[Ws];
    ("data" === t2 && e2[Hs] === tc || "Signature" === t2 && e2[Hs] === go.signature.id) && (this[t2] = e2);
    this[Qn](e2);
  }
};
var DatasetsNamespace = class _DatasetsNamespace {
  static [fo](e2, t2) {
    if (_DatasetsNamespace.hasOwnProperty(e2)) return _DatasetsNamespace[e2](t2);
  }
  static datasets(e2) {
    return new Datasets(e2);
  }
  static data(e2) {
    return new datasets_Data(e2);
  }
};
var ac = go.localeSet.id;
var CalendarSymbols = class extends XFAObject {
  constructor(e2) {
    super(ac, "calendarSymbols", true);
    this.name = "gregorian";
    this.dayNames = new XFAObjectArray(2);
    this.eraNames = null;
    this.meridiemNames = null;
    this.monthNames = new XFAObjectArray(2);
  }
};
var CurrencySymbol = class extends StringObject {
  constructor(e2) {
    super(ac, "currencySymbol");
    this.name = getStringOption(e2.name, ["symbol", "isoname", "decimal"]);
  }
};
var CurrencySymbols = class extends XFAObject {
  constructor(e2) {
    super(ac, "currencySymbols", true);
    this.currencySymbol = new XFAObjectArray(3);
  }
};
var DatePattern = class extends StringObject {
  constructor(e2) {
    super(ac, "datePattern");
    this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
  }
};
var DatePatterns = class extends XFAObject {
  constructor(e2) {
    super(ac, "datePatterns", true);
    this.datePattern = new XFAObjectArray(4);
  }
};
var DateTimeSymbols = class extends ContentObject {
  constructor(e2) {
    super(ac, "dateTimeSymbols");
  }
};
var Day = class extends StringObject {
  constructor(e2) {
    super(ac, "day");
  }
};
var DayNames = class extends XFAObject {
  constructor(e2) {
    super(ac, "dayNames", true);
    this.abbr = getInteger({ data: e2.abbr, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.day = new XFAObjectArray(7);
  }
};
var Era = class extends StringObject {
  constructor(e2) {
    super(ac, "era");
  }
};
var EraNames = class extends XFAObject {
  constructor(e2) {
    super(ac, "eraNames", true);
    this.era = new XFAObjectArray(2);
  }
};
var locale_set_Locale = class extends XFAObject {
  constructor(e2) {
    super(ac, "locale", true);
    this.desc = e2.desc || "";
    this.name = "isoname";
    this.calendarSymbols = null;
    this.currencySymbols = null;
    this.datePatterns = null;
    this.dateTimeSymbols = null;
    this.numberPatterns = null;
    this.numberSymbols = null;
    this.timePatterns = null;
    this.typeFaces = null;
  }
};
var locale_set_LocaleSet = class extends XFAObject {
  constructor(e2) {
    super(ac, "localeSet", true);
    this.locale = new XFAObjectArray();
  }
};
var Meridiem = class extends StringObject {
  constructor(e2) {
    super(ac, "meridiem");
  }
};
var MeridiemNames = class extends XFAObject {
  constructor(e2) {
    super(ac, "meridiemNames", true);
    this.meridiem = new XFAObjectArray(2);
  }
};
var Month = class extends StringObject {
  constructor(e2) {
    super(ac, "month");
  }
};
var MonthNames = class extends XFAObject {
  constructor(e2) {
    super(ac, "monthNames", true);
    this.abbr = getInteger({ data: e2.abbr, defaultValue: 0, validate: (e3) => 1 === e3 });
    this.month = new XFAObjectArray(12);
  }
};
var NumberPattern = class extends StringObject {
  constructor(e2) {
    super(ac, "numberPattern");
    this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
  }
};
var NumberPatterns = class extends XFAObject {
  constructor(e2) {
    super(ac, "numberPatterns", true);
    this.numberPattern = new XFAObjectArray(4);
  }
};
var NumberSymbol = class extends StringObject {
  constructor(e2) {
    super(ac, "numberSymbol");
    this.name = getStringOption(e2.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }
};
var NumberSymbols = class extends XFAObject {
  constructor(e2) {
    super(ac, "numberSymbols", true);
    this.numberSymbol = new XFAObjectArray(5);
  }
};
var TimePattern = class extends StringObject {
  constructor(e2) {
    super(ac, "timePattern");
    this.name = getStringOption(e2.name, ["full", "long", "med", "short"]);
  }
};
var TimePatterns = class extends XFAObject {
  constructor(e2) {
    super(ac, "timePatterns", true);
    this.timePattern = new XFAObjectArray(4);
  }
};
var TypeFace = class extends XFAObject {
  constructor(e2) {
    super(ac, "typeFace", true);
    this.name = "" | e2.name;
  }
};
var TypeFaces = class extends XFAObject {
  constructor(e2) {
    super(ac, "typeFaces", true);
    this.typeFace = new XFAObjectArray();
  }
};
var LocaleSetNamespace = class _LocaleSetNamespace {
  static [fo](e2, t2) {
    if (_LocaleSetNamespace.hasOwnProperty(e2)) return _LocaleSetNamespace[e2](t2);
  }
  static calendarSymbols(e2) {
    return new CalendarSymbols(e2);
  }
  static currencySymbol(e2) {
    return new CurrencySymbol(e2);
  }
  static currencySymbols(e2) {
    return new CurrencySymbols(e2);
  }
  static datePattern(e2) {
    return new DatePattern(e2);
  }
  static datePatterns(e2) {
    return new DatePatterns(e2);
  }
  static dateTimeSymbols(e2) {
    return new DateTimeSymbols(e2);
  }
  static day(e2) {
    return new Day(e2);
  }
  static dayNames(e2) {
    return new DayNames(e2);
  }
  static era(e2) {
    return new Era(e2);
  }
  static eraNames(e2) {
    return new EraNames(e2);
  }
  static locale(e2) {
    return new locale_set_Locale(e2);
  }
  static localeSet(e2) {
    return new locale_set_LocaleSet(e2);
  }
  static meridiem(e2) {
    return new Meridiem(e2);
  }
  static meridiemNames(e2) {
    return new MeridiemNames(e2);
  }
  static month(e2) {
    return new Month(e2);
  }
  static monthNames(e2) {
    return new MonthNames(e2);
  }
  static numberPattern(e2) {
    return new NumberPattern(e2);
  }
  static numberPatterns(e2) {
    return new NumberPatterns(e2);
  }
  static numberSymbol(e2) {
    return new NumberSymbol(e2);
  }
  static numberSymbols(e2) {
    return new NumberSymbols(e2);
  }
  static timePattern(e2) {
    return new TimePattern(e2);
  }
  static timePatterns(e2) {
    return new TimePatterns(e2);
  }
  static typeFace(e2) {
    return new TypeFace(e2);
  }
  static typeFaces(e2) {
    return new TypeFaces(e2);
  }
};
var rc = go.signature.id;
var signature_Signature = class extends XFAObject {
  constructor(e2) {
    super(rc, "signature", true);
  }
};
var SignatureNamespace = class _SignatureNamespace {
  static [fo](e2, t2) {
    if (_SignatureNamespace.hasOwnProperty(e2)) return _SignatureNamespace[e2](t2);
  }
  static signature(e2) {
    return new signature_Signature(e2);
  }
};
var ic = go.stylesheet.id;
var Stylesheet = class extends XFAObject {
  constructor(e2) {
    super(ic, "stylesheet", true);
  }
};
var StylesheetNamespace = class _StylesheetNamespace {
  static [fo](e2, t2) {
    if (_StylesheetNamespace.hasOwnProperty(e2)) return _StylesheetNamespace[e2](t2);
  }
  static stylesheet(e2) {
    return new Stylesheet(e2);
  }
};
var nc = go.xdp.id;
var xdp_Xdp = class extends XFAObject {
  constructor(e2) {
    super(nc, "xdp", true);
    this.uuid = e2.uuid || "";
    this.timeStamp = e2.timeStamp || "";
    this.config = null;
    this.connectionSet = null;
    this.datasets = null;
    this.localeSet = null;
    this.stylesheet = new XFAObjectArray();
    this.template = null;
  }
  [Gs](e2) {
    const t2 = go[e2[Ws]];
    return t2 && e2[Hs] === t2.id;
  }
};
var XdpNamespace = class _XdpNamespace {
  static [fo](e2, t2) {
    if (_XdpNamespace.hasOwnProperty(e2)) return _XdpNamespace[e2](t2);
  }
  static xdp(e2) {
    return new xdp_Xdp(e2);
  }
};
var sc = go.xhtml.id;
var oc = Symbol();
var cc = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]);
var lc = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (e2) => "none" === e2 ? "none" : "normal"], ["xfa-font-horizontal-scale", (e2) => `scaleX(${Math.max(0, parseInt(e2) / 100).toFixed(2)})`], ["xfa-font-vertical-scale", (e2) => `scaleY(${Math.max(0, parseInt(e2) / 100).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (e2, t2) => measureToString(0.99 * (e2 = t2.fontSize = Math.abs(getMeasurement(e2))))], ["letter-spacing", (e2) => measureToString(getMeasurement(e2))], ["line-height", (e2) => measureToString(getMeasurement(e2))], ["margin", (e2) => measureToString(getMeasurement(e2))], ["margin-bottom", (e2) => measureToString(getMeasurement(e2))], ["margin-left", (e2) => measureToString(getMeasurement(e2))], ["margin-right", (e2) => measureToString(getMeasurement(e2))], ["margin-top", (e2) => measureToString(getMeasurement(e2))], ["text-indent", (e2) => measureToString(getMeasurement(e2))], ["font-family", (e2) => e2], ["vertical-align", (e2) => measureToString(getMeasurement(e2))]]);
var hc = /\s+/g;
var uc = /[\r\n]+/g;
var dc = /\r\n?/g;
function mapStyle(e2, t2, a2) {
  const r2 = /* @__PURE__ */ Object.create(null);
  if (!e2) return r2;
  const i2 = /* @__PURE__ */ Object.create(null);
  for (const [t3, a3] of e2.split(";").map(((e3) => e3.split(":", 2)))) {
    const e3 = lc.get(t3);
    if ("" === e3) continue;
    let n2 = a3;
    e3 && (n2 = "string" == typeof e3 ? e3 : e3(a3, i2));
    t3.endsWith("scale") ? r2.transform = r2.transform ? `${r2[t3]} ${n2}` : n2 : r2[t3.replaceAll(/-([a-zA-Z])/g, ((e4, t4) => t4.toUpperCase()))] = n2;
  }
  r2.fontFamily && setFontFamily({ typeface: r2.fontFamily, weight: r2.fontWeight || "normal", posture: r2.fontStyle || "normal", size: i2.fontSize || 0 }, t2, t2[Is].fontFinder, r2);
  if (a2 && r2.verticalAlign && "0px" !== r2.verticalAlign && r2.fontSize) {
    const e3 = 0.583, t3 = 0.333, a3 = getMeasurement(r2.fontSize);
    r2.fontSize = measureToString(a3 * e3);
    r2.verticalAlign = measureToString(Math.sign(getMeasurement(r2.verticalAlign)) * a3 * t3);
  }
  a2 && r2.fontSize && (r2.fontSize = `calc(${r2.fontSize} * var(--total-scale-factor))`);
  fixTextIndent(r2);
  return r2;
}
var fc = /* @__PURE__ */ new Set(["body", "html"]);
var XhtmlObject = class extends XmlObject {
  constructor(e2, t2) {
    super(sc, t2);
    this[oc] = false;
    this.style = e2.style || "";
  }
  [ts](e2) {
    super[ts](e2);
    this.style = (function checkStyle(e3) {
      return e3.style ? e3.style.split(";").filter(((e4) => !!e4.trim())).map(((e4) => e4.split(":", 2).map(((e5) => e5.trim())))).filter((([t2, a2]) => {
        "font-family" === t2 && e3[Is].usedTypefaces.add(a2);
        return cc.has(t2);
      })).map(((e4) => e4.join(":"))).join(";") : "";
    })(this);
  }
  [Yn]() {
    return !fc.has(this[Ws]);
  }
  [Vs](e2, t2 = false) {
    if (t2) this[oc] = true;
    else {
      e2 = e2.replaceAll(uc, "");
      this.style.includes("xfa-spacerun:yes") || (e2 = e2.replaceAll(hc, " "));
    }
    e2 && (this[ss] += e2);
  }
  [Ks](e2, t2 = true) {
    const a2 = /* @__PURE__ */ Object.create(null), r2 = { top: NaN, bottom: NaN, left: NaN, right: NaN };
    let i2 = null;
    for (const [e3, t3] of this.style.split(";").map(((e4) => e4.split(":", 2)))) switch (e3) {
      case "font-family":
        a2.typeface = stripQuotes(t3);
        break;
      case "font-size":
        a2.size = getMeasurement(t3);
        break;
      case "font-weight":
        a2.weight = t3;
        break;
      case "font-style":
        a2.posture = t3;
        break;
      case "letter-spacing":
        a2.letterSpacing = getMeasurement(t3);
        break;
      case "margin":
        const e4 = t3.split(/ \t/).map(((e5) => getMeasurement(e5)));
        switch (e4.length) {
          case 1:
            r2.top = r2.bottom = r2.left = r2.right = e4[0];
            break;
          case 2:
            r2.top = r2.bottom = e4[0];
            r2.left = r2.right = e4[1];
            break;
          case 3:
            r2.top = e4[0];
            r2.bottom = e4[2];
            r2.left = r2.right = e4[1];
            break;
          case 4:
            r2.top = e4[0];
            r2.left = e4[1];
            r2.bottom = e4[2];
            r2.right = e4[3];
        }
        break;
      case "margin-top":
        r2.top = getMeasurement(t3);
        break;
      case "margin-bottom":
        r2.bottom = getMeasurement(t3);
        break;
      case "margin-left":
        r2.left = getMeasurement(t3);
        break;
      case "margin-right":
        r2.right = getMeasurement(t3);
        break;
      case "line-height":
        i2 = getMeasurement(t3);
    }
    e2.pushData(a2, r2, i2);
    if (this[ss]) e2.addString(this[ss]);
    else for (const t3 of this[Ss]()) "#text" !== t3[Ws] ? t3[Ks](e2) : e2.addString(t3[ss]);
    t2 && e2.popFont();
  }
  [co](e2) {
    const t2 = [];
    this[ls] = { children: t2 };
    this[es]({});
    if (0 === t2.length && !this[ss]) return HTMLResult.EMPTY;
    let a2;
    a2 = this[oc] ? this[ss] ? this[ss].replaceAll(dc, "\n") : void 0 : this[ss] || void 0;
    return HTMLResult.success({ name: this[Ws], attributes: { href: this.href, style: mapStyle(this.style, this, this[oc]) }, children: t2, value: a2 });
  }
};
var A = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "a");
    this.href = fixURL(e2.href) || "";
  }
};
var B = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "b");
  }
  [Ks](e2) {
    e2.pushFont({ weight: "bold" });
    super[Ks](e2);
    e2.popFont();
  }
};
var Body = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "body");
  }
  [co](e2) {
    const t2 = super[co](e2), { html: a2 } = t2;
    if (!a2) return HTMLResult.EMPTY;
    a2.name = "div";
    a2.attributes.class = ["xfaRich"];
    return t2;
  }
};
var Br = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "br");
  }
  [so]() {
    return "\n";
  }
  [Ks](e2) {
    e2.addString("\n");
  }
  [co](e2) {
    return HTMLResult.success({ name: "br" });
  }
};
var Html = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "html");
  }
  [co](e2) {
    const t2 = [];
    this[ls] = { children: t2 };
    this[es]({});
    if (0 === t2.length) return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, value: this[ss] || "" });
    if (1 === t2.length) {
      const e3 = t2[0];
      if (e3.attributes?.class.includes("xfaRich")) return HTMLResult.success(e3);
    }
    return HTMLResult.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, children: t2 });
  }
};
var I = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "i");
  }
  [Ks](e2) {
    e2.pushFont({ posture: "italic" });
    super[Ks](e2);
    e2.popFont();
  }
};
var Li = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "li");
  }
};
var Ol = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "ol");
  }
};
var P = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "p");
  }
  [Ks](e2) {
    super[Ks](e2, false);
    e2.addString("\n");
    e2.addPara();
    e2.popFont();
  }
  [so]() {
    return this[vs]()[Ss]().at(-1) === this ? super[so]() : super[so]() + "\n";
  }
};
var Span = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "span");
  }
};
var Sub = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "sub");
  }
};
var Sup = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "sup");
  }
};
var Ul = class extends XhtmlObject {
  constructor(e2) {
    super(e2, "ul");
  }
};
var XhtmlNamespace = class _XhtmlNamespace {
  static [fo](e2, t2) {
    if (_XhtmlNamespace.hasOwnProperty(e2)) return _XhtmlNamespace[e2](t2);
  }
  static a(e2) {
    return new A(e2);
  }
  static b(e2) {
    return new B(e2);
  }
  static body(e2) {
    return new Body(e2);
  }
  static br(e2) {
    return new Br(e2);
  }
  static html(e2) {
    return new Html(e2);
  }
  static i(e2) {
    return new I(e2);
  }
  static li(e2) {
    return new Li(e2);
  }
  static ol(e2) {
    return new Ol(e2);
  }
  static p(e2) {
    return new P(e2);
  }
  static span(e2) {
    return new Span(e2);
  }
  static sub(e2) {
    return new Sub(e2);
  }
  static sup(e2) {
    return new Sup(e2);
  }
  static ul(e2) {
    return new Ul(e2);
  }
};
var gc = { config: ConfigNamespace, connection: ConnectionSetNamespace, datasets: DatasetsNamespace, localeSet: LocaleSetNamespace, signature: SignatureNamespace, stylesheet: StylesheetNamespace, template: TemplateNamespace, xdp: XdpNamespace, xhtml: XhtmlNamespace };
var UnknownNamespace = class {
  constructor(e2) {
    this.namespaceId = e2;
  }
  [fo](e2, t2) {
    return new XmlObject(this.namespaceId, e2, t2);
  }
};
var Root = class extends XFAObject {
  constructor(e2) {
    super(-1, "root", /* @__PURE__ */ Object.create(null));
    this.element = null;
    this[Os] = e2;
  }
  [$s](e2) {
    this.element = e2;
    return true;
  }
  [hs]() {
    super[hs]();
    if (this.element.template instanceof Template) {
      this[Os].set(Qs, this.element);
      this.element.template[eo](this[Os]);
      this.element.template[Os] = this[Os];
    }
  }
};
var Empty = class extends XFAObject {
  constructor() {
    super(-1, "", /* @__PURE__ */ Object.create(null));
  }
  [$s](e2) {
    return false;
  }
};
var Builder = class {
  constructor(e2 = null) {
    this._namespaceStack = [];
    this._nsAgnosticLevel = 0;
    this._namespacePrefixes = /* @__PURE__ */ new Map();
    this._namespaces = /* @__PURE__ */ new Map();
    this._nextNsId = Math.max(...Object.values(go).map((({ id: e3 }) => e3)));
    this._currentNamespace = e2 || new UnknownNamespace(++this._nextNsId);
  }
  buildRoot(e2) {
    return new Root(e2);
  }
  build({ nsPrefix: e2, name: t2, attributes: a2, namespace: r2, prefixes: i2 }) {
    const n2 = null !== r2;
    if (n2) {
      this._namespaceStack.push(this._currentNamespace);
      this._currentNamespace = this._searchNamespace(r2);
    }
    i2 && this._addNamespacePrefix(i2);
    if (a2.hasOwnProperty(zs)) {
      const e3 = gc.datasets, t3 = a2[zs];
      let r3 = null;
      for (const [a3, i3] of Object.entries(t3)) {
        if (this._getNamespaceToUse(a3) === e3) {
          r3 = { xfa: i3 };
          break;
        }
      }
      r3 ? a2[zs] = r3 : delete a2[zs];
    }
    const s2 = this._getNamespaceToUse(e2), o2 = s2?.[fo](t2, a2) || new Empty();
    o2[Ls]() && this._nsAgnosticLevel++;
    (n2 || i2 || o2[Ls]()) && (o2[rs] = { hasNamespace: n2, prefixes: i2, nsAgnostic: o2[Ls]() });
    return o2;
  }
  isNsAgnostic() {
    return this._nsAgnosticLevel > 0;
  }
  _searchNamespace(e2) {
    let t2 = this._namespaces.get(e2);
    if (t2) return t2;
    for (const [a2, { check: r2 }] of Object.entries(go)) if (r2(e2)) {
      t2 = gc[a2];
      if (t2) {
        this._namespaces.set(e2, t2);
        return t2;
      }
      break;
    }
    t2 = new UnknownNamespace(++this._nextNsId);
    this._namespaces.set(e2, t2);
    return t2;
  }
  _addNamespacePrefix(e2) {
    for (const { prefix: t2, value: a2 } of e2) {
      const e3 = this._searchNamespace(a2);
      let r2 = this._namespacePrefixes.get(t2);
      if (!r2) {
        r2 = [];
        this._namespacePrefixes.set(t2, r2);
      }
      r2.push(e3);
    }
  }
  _getNamespaceToUse(e2) {
    if (!e2) return this._currentNamespace;
    const t2 = this._namespacePrefixes.get(e2);
    if (t2?.length > 0) return t2.at(-1);
    warn(`Unknown namespace prefix: ${e2}.`);
    return null;
  }
  clean(e2) {
    const { hasNamespace: t2, prefixes: a2, nsAgnostic: r2 } = e2;
    t2 && (this._currentNamespace = this._namespaceStack.pop());
    a2 && a2.forEach((({ prefix: e3 }) => {
      this._namespacePrefixes.get(e3).pop();
    }));
    r2 && this._nsAgnosticLevel--;
  }
};
var XFAParser = class _XFAParser extends XMLParserBase {
  constructor(e2 = null, t2 = false) {
    super();
    this._builder = new Builder(e2);
    this._stack = [];
    this._globalData = { usedTypefaces: /* @__PURE__ */ new Set() };
    this._ids = /* @__PURE__ */ new Map();
    this._current = this._builder.buildRoot(this._ids);
    this._errorCode = jn;
    this._whiteRegex = /^\s+$/;
    this._nbsps = /\xa0+/g;
    this._richText = t2;
  }
  parse(e2) {
    this.parseXml(e2);
    if (this._errorCode === jn) {
      this._current[hs]();
      return this._current.element;
    }
  }
  onText(e2) {
    e2 = e2.replace(this._nbsps, ((e3) => e3.slice(1) + " "));
    this._richText || this._current[Yn]() ? this._current[Vs](e2, this._richText) : this._whiteRegex.test(e2) || this._current[Vs](e2.trim());
  }
  onCdata(e2) {
    this._current[Vs](e2);
  }
  _mkAttributes(e2, t2) {
    let a2 = null, r2 = null;
    const i2 = /* @__PURE__ */ Object.create({});
    for (const { name: n2, value: s2 } of e2) if ("xmlns" === n2) a2 ? warn(`XFA - multiple namespace definition in <${t2}>`) : a2 = s2;
    else if (n2.startsWith("xmlns:")) {
      const e3 = n2.substring(6);
      r2 ??= [];
      r2.push({ prefix: e3, value: s2 });
    } else {
      const e3 = n2.indexOf(":");
      if (-1 === e3) i2[n2] = s2;
      else {
        const t3 = i2[zs] ??= /* @__PURE__ */ Object.create(null), [a3, r3] = [n2.slice(0, e3), n2.slice(e3 + 1)];
        (t3[a3] ||= /* @__PURE__ */ Object.create(null))[r3] = s2;
      }
    }
    return [a2, r2, i2];
  }
  _getNameAndPrefix(e2, t2) {
    const a2 = e2.indexOf(":");
    return -1 === a2 ? [e2, null] : [e2.substring(a2 + 1), t2 ? "" : e2.substring(0, a2)];
  }
  onBeginElement(e2, t2, a2) {
    const [r2, i2, n2] = this._mkAttributes(t2, e2), [s2, o2] = this._getNameAndPrefix(e2, this._builder.isNsAgnostic()), c2 = this._builder.build({ nsPrefix: o2, name: s2, attributes: n2, namespace: r2, prefixes: i2 });
    c2[Is] = this._globalData;
    if (a2) {
      c2[hs]();
      this._current[$s](c2) && c2[ao](this._ids);
      c2[ts](this._builder);
    } else {
      this._stack.push(this._current);
      this._current = c2;
    }
  }
  onEndElement(e2) {
    const t2 = this._current;
    if (t2[Bs]() && "string" == typeof t2[ss]) {
      const e3 = new _XFAParser();
      e3._globalData = this._globalData;
      const a2 = e3.parse(t2[ss]);
      t2[ss] = null;
      t2[$s](a2);
    }
    t2[hs]();
    this._current = this._stack.pop();
    this._current[$s](t2) && t2[ao](this._ids);
    t2[ts](this._builder);
  }
  onError(e2) {
    this._errorCode = e2;
  }
};
var XFAFactory = class _XFAFactory {
  constructor(e2) {
    try {
      this.root = new XFAParser().parse(_XFAFactory._createDocument(e2));
      const t2 = new Binder(this.root);
      this.form = t2.bind();
      this.dataHandler = new DataHandler(this.root, t2.getData());
      this.form[Is].template = this.form;
    } catch (e3) {
      warn(`XFA - an error occurred during parsing and binding: ${e3}`);
    }
  }
  isValid() {
    return !(!this.root || !this.form);
  }
  _createPagesHelper() {
    const e2 = this.form[oo]();
    return new Promise(((t2, a2) => {
      const nextIteration = () => {
        try {
          const a3 = e2.next();
          a3.done ? t2(a3.value) : setTimeout(nextIteration, 0);
        } catch (e3) {
          a2(e3);
        }
      };
      setTimeout(nextIteration, 0);
    }));
  }
  async _createPages() {
    try {
      this.pages = await this._createPagesHelper();
      this.dims = this.pages.children.map(((e2) => {
        const { width: t2, height: a2 } = e2.attributes.style;
        return [0, 0, parseInt(t2), parseInt(a2)];
      }));
    } catch (e2) {
      warn(`XFA - an error occurred during layout: ${e2}`);
    }
  }
  getBoundingBox(e2) {
    return this.dims[e2];
  }
  async getNumPages() {
    this.pages || await this._createPages();
    return this.dims.length;
  }
  setImages(e2) {
    this.form[Is].images = e2;
  }
  setFonts(e2) {
    this.form[Is].fontFinder = new FontFinder(e2);
    const t2 = [];
    for (let e3 of this.form[Is].usedTypefaces) {
      e3 = stripQuotes(e3);
      this.form[Is].fontFinder.find(e3) || t2.push(e3);
    }
    return t2.length > 0 ? t2 : null;
  }
  appendFonts(e2, t2) {
    this.form[Is].fontFinder.add(e2, t2);
  }
  async getPages() {
    this.pages || await this._createPages();
    const e2 = this.pages;
    this.pages = null;
    return e2;
  }
  serializeData(e2) {
    return this.dataHandler.serialize(e2);
  }
  static _createDocument(e2) {
    return e2["/xdp:xdp"] ? Object.values(e2).join("") : e2["xdp:xdp"];
  }
  static getRichTextAsHtml(e2) {
    if (!e2 || "string" != typeof e2) return null;
    try {
      let t2 = new XFAParser(XhtmlNamespace, true).parse(e2);
      if (!["body", "xhtml"].includes(t2[Ws])) {
        const e3 = XhtmlNamespace.body({});
        e3[Qn](t2);
        t2 = e3;
      }
      const a2 = t2[co]();
      if (!a2.success) return null;
      const { html: r2 } = a2, { attributes: i2 } = r2;
      if (i2) {
        i2.class && (i2.class = i2.class.filter(((e3) => !e3.startsWith("xfa"))));
        i2.dir = "auto";
      }
      return { html: r2, str: t2[so]() };
    } catch (e3) {
      warn(`XFA - an error occurred during parsing of rich text: ${e3}`);
    }
    return null;
  }
};
var AnnotationFactory = class {
  static createGlobals(e2) {
    return Promise.all([e2.ensureCatalog("acroForm"), e2.ensureDoc("xfaDatasets"), e2.ensureCatalog("structTreeRoot"), e2.ensureCatalog("baseUrl"), e2.ensureCatalog("attachments"), e2.ensureCatalog("globalColorSpaceCache")]).then((([t2, a2, r2, i2, n2, s2]) => ({ pdfManager: e2, acroForm: t2 instanceof Dict ? t2 : Dict.empty, xfaDatasets: a2, structTreeRoot: r2, baseUrl: i2, attachments: n2, globalColorSpaceCache: s2 })), ((e3) => {
      warn(`createGlobals: "${e3}".`);
      return null;
    }));
  }
  static async create(e2, t2, a2, r2, i2, n2, s2) {
    const o2 = i2 ? await this._getPageIndex(e2, t2, a2.pdfManager) : null;
    return a2.pdfManager.ensure(this, "_create", [e2, t2, a2, r2, i2, n2, o2, s2]);
  }
  static _create(e2, t2, a2, r2, i2 = false, n2 = null, s2 = null, o2 = null) {
    const c2 = e2.fetchIfRef(t2);
    if (!(c2 instanceof Dict)) return;
    const { acroForm: l2, pdfManager: h2 } = a2, u2 = t2 instanceof Ref ? t2.toString() : `annot_${r2.createObjId()}`;
    let d2 = c2.get("Subtype");
    d2 = d2 instanceof Name ? d2.name : null;
    const f2 = { xref: e2, ref: t2, dict: c2, subtype: d2, id: u2, annotationGlobals: a2, collectFields: i2, orphanFields: n2, needAppearances: !i2 && true === l2.get("NeedAppearances"), pageIndex: s2, evaluatorOptions: h2.evaluatorOptions, pageRef: o2 };
    switch (d2) {
      case "Link":
        return new LinkAnnotation(f2);
      case "Text":
        return new TextAnnotation(f2);
      case "Widget":
        let e3 = getInheritableProperty({ dict: c2, key: "FT" });
        e3 = e3 instanceof Name ? e3.name : null;
        switch (e3) {
          case "Tx":
            return new TextWidgetAnnotation(f2);
          case "Btn":
            return new ButtonWidgetAnnotation(f2);
          case "Ch":
            return new ChoiceWidgetAnnotation(f2);
          case "Sig":
            return new SignatureWidgetAnnotation(f2);
        }
        warn(`Unimplemented widget field type "${e3}", falling back to base field type.`);
        return new WidgetAnnotation(f2);
      case "Popup":
        return new PopupAnnotation(f2);
      case "FreeText":
        return new FreeTextAnnotation(f2);
      case "Line":
        return new LineAnnotation(f2);
      case "Square":
        return new SquareAnnotation(f2);
      case "Circle":
        return new CircleAnnotation(f2);
      case "PolyLine":
        return new PolylineAnnotation(f2);
      case "Polygon":
        return new PolygonAnnotation(f2);
      case "Caret":
        return new CaretAnnotation(f2);
      case "Ink":
        return new InkAnnotation(f2);
      case "Highlight":
        return new HighlightAnnotation(f2);
      case "Underline":
        return new UnderlineAnnotation(f2);
      case "Squiggly":
        return new SquigglyAnnotation(f2);
      case "StrikeOut":
        return new StrikeOutAnnotation(f2);
      case "Stamp":
        return new StampAnnotation(f2);
      case "FileAttachment":
        return new FileAttachmentAnnotation(f2);
      default:
        i2 || warn(d2 ? `Unimplemented annotation type "${d2}", falling back to base annotation.` : "Annotation is missing the required /Subtype.");
        return new Annotation(f2);
    }
  }
  static async _getPageIndex(e2, t2, a2) {
    try {
      const r2 = await e2.fetchIfRefAsync(t2);
      if (!(r2 instanceof Dict)) return -1;
      const i2 = r2.getRaw("P");
      if (i2 instanceof Ref) try {
        return await a2.ensureCatalog("getPageIndex", [i2]);
      } catch (e3) {
        info(`_getPageIndex -- not a valid page reference: "${e3}".`);
      }
      if (r2.has("Kids")) return -1;
      const n2 = await a2.ensureDoc("numPages");
      for (let e3 = 0; e3 < n2; e3++) {
        const r3 = await a2.getPage(e3), i3 = await a2.ensure(r3, "annotations");
        for (const a3 of i3) if (a3 instanceof Ref && isRefsEqual(a3, t2)) return e3;
      }
    } catch (e3) {
      warn(`_getPageIndex: "${e3}".`);
    }
    return -1;
  }
  static generateImages(e2, t2, a2) {
    if (!a2) {
      warn("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.");
      return null;
    }
    let r2;
    for (const { bitmapId: a3, bitmap: i2 } of e2) if (i2) {
      r2 ||= /* @__PURE__ */ new Map();
      r2.set(a3, StampAnnotation.createImage(i2, t2));
    }
    return r2;
  }
  static async saveNewAnnotations(e2, t2, a2, r2, i2) {
    const n2 = e2.xref;
    let s2;
    const o2 = [], { isOffscreenCanvasSupported: c2 } = e2.options;
    for (const l2 of a2) if (!l2.deleted) switch (l2.annotationType) {
      case g:
        if (!s2) {
          const e3 = new Dict(n2);
          e3.setIfName("BaseFont", "Helvetica");
          e3.setIfName("Type", "Font");
          e3.setIfName("Subtype", "Type1");
          e3.setIfName("Encoding", "WinAnsiEncoding");
          s2 = n2.getNewTemporaryRef();
          i2.put(s2, { data: e3 });
        }
        o2.push(FreeTextAnnotation.createNewAnnotation(n2, l2, i2, { evaluator: e2, task: t2, baseFontRef: s2 }));
        break;
      case p:
        l2.quadPoints ? o2.push(HighlightAnnotation.createNewAnnotation(n2, l2, i2)) : o2.push(InkAnnotation.createNewAnnotation(n2, l2, i2));
        break;
      case b:
        o2.push(InkAnnotation.createNewAnnotation(n2, l2, i2));
        break;
      case m:
        const a3 = c2 ? await r2?.get(l2.bitmapId) : null;
        if (a3?.imageStream) {
          const { imageStream: e3, smaskStream: t3 } = a3;
          if (t3) {
            const a4 = n2.getNewTemporaryRef();
            i2.put(a4, { data: t3 });
            e3.dict.set("SMask", a4);
          }
          const r3 = a3.imageRef = n2.getNewTemporaryRef();
          i2.put(r3, { data: e3 });
          a3.imageStream = a3.smaskStream = null;
        }
        o2.push(StampAnnotation.createNewAnnotation(n2, l2, i2, { image: a3 }));
        break;
      case y:
        o2.push(StampAnnotation.createNewAnnotation(n2, l2, i2, {}));
    }
    return { annotations: (await Promise.all(o2)).flat() };
  }
  static async printNewAnnotations(e2, t2, a2, r2, i2) {
    if (!r2) return null;
    const { options: n2, xref: s2 } = t2, o2 = [];
    for (const c2 of r2) if (!c2.deleted) switch (c2.annotationType) {
      case g:
        o2.push(FreeTextAnnotation.createNewPrintAnnotation(e2, s2, c2, { evaluator: t2, task: a2, evaluatorOptions: n2 }));
        break;
      case p:
        c2.quadPoints ? o2.push(HighlightAnnotation.createNewPrintAnnotation(e2, s2, c2, { evaluatorOptions: n2 })) : o2.push(InkAnnotation.createNewPrintAnnotation(e2, s2, c2, { evaluatorOptions: n2 }));
        break;
      case b:
        o2.push(InkAnnotation.createNewPrintAnnotation(e2, s2, c2, { evaluatorOptions: n2 }));
        break;
      case m:
        const r3 = n2.isOffscreenCanvasSupported ? await i2?.get(c2.bitmapId) : null;
        if (r3?.imageStream) {
          const { imageStream: e3, smaskStream: t3 } = r3;
          t3 && e3.dict.set("SMask", t3);
          r3.imageRef = new JpegStream(e3, e3.length);
          r3.imageStream = r3.smaskStream = null;
        }
        o2.push(StampAnnotation.createNewPrintAnnotation(e2, s2, c2, { image: r3, evaluatorOptions: n2 }));
        break;
      case y:
        o2.push(StampAnnotation.createNewPrintAnnotation(e2, s2, c2, { evaluatorOptions: n2 }));
    }
    return Promise.all(o2);
  }
};
function getRgbColor(e2, t2 = new Uint8ClampedArray(3)) {
  if (!Array.isArray(e2)) return t2;
  const a2 = t2 || new Uint8ClampedArray(3);
  switch (e2.length) {
    case 0:
      return null;
    case 1:
      ColorSpaceUtils.gray.getRgbItem(e2, 0, a2, 0);
      return a2;
    case 3:
      ColorSpaceUtils.rgb.getRgbItem(e2, 0, a2, 0);
      return a2;
    case 4:
      ColorSpaceUtils.cmyk.getRgbItem(e2, 0, a2, 0);
      return a2;
    default:
      return t2;
  }
}
function getPdfColorArray(e2, t2 = null) {
  return e2 && Array.from(e2, ((e3) => e3 / 255)) || t2;
}
function getQuadPoints(e2, t2) {
  const a2 = e2.getArray("QuadPoints");
  if (!isNumberArray(a2, null) || 0 === a2.length || a2.length % 8 > 0) return null;
  const r2 = new Float32Array(a2.length);
  for (let e3 = 0, i2 = a2.length; e3 < i2; e3 += 8) {
    const [i3, n2, s2, o2, c2, l2, h2, u2] = a2.slice(e3, e3 + 8), d2 = Math.min(i3, s2, c2, h2), f2 = Math.max(i3, s2, c2, h2), g2 = Math.min(n2, o2, l2, u2), p2 = Math.max(n2, o2, l2, u2);
    if (null !== t2 && (d2 < t2[0] || f2 > t2[2] || g2 < t2[1] || p2 > t2[3])) return null;
    r2.set([d2, p2, f2, p2, d2, g2, f2, g2], e3);
  }
  return r2;
}
function getTransformMatrix(e2, t2, a2) {
  const r2 = new Float32Array([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
  Util.axialAlignedBoundingBox(t2, a2, r2);
  const [i2, n2, s2, o2] = r2;
  if (i2 === s2 || n2 === o2) return [1, 0, 0, 1, e2[0], e2[1]];
  const c2 = (e2[2] - e2[0]) / (s2 - i2), l2 = (e2[3] - e2[1]) / (o2 - n2);
  return [c2, 0, 0, l2, e2[0] - i2 * c2, e2[1] - n2 * l2];
}
var Annotation = class {
  constructor(e2) {
    const { dict: t2, xref: a2, annotationGlobals: r2, ref: i2, orphanFields: n2 } = e2, s2 = n2?.get(i2);
    s2 && t2.set("Parent", s2);
    this.setTitle(t2.get("T"));
    this.setContents(t2.get("Contents"));
    this.setModificationDate(t2.get("M"));
    this.setFlags(t2.get("F"));
    this.setRectangle(t2.getArray("Rect"));
    this.setColor(t2.getArray("C"));
    this.setBorderStyle(t2);
    this.setAppearance(t2);
    this.setOptionalContent(t2);
    const o2 = t2.get("MK");
    this.setBorderAndBackgroundColors(o2);
    this.setRotation(o2, t2);
    this.ref = e2.ref instanceof Ref ? e2.ref : null;
    this._streams = [];
    this.appearance && this._streams.push(this.appearance);
    const c2 = !!(this.flags & ee), l2 = !!(this.flags & te);
    this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: e2.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: e2.subtype, hasOwnCanvas: false, noRotate: !!(this.flags & Z), noHTML: c2 && l2, isEditable: false, structParent: -1 };
    if (r2.structTreeRoot) {
      let a3 = t2.get("StructParent");
      this.data.structParent = a3 = Number.isInteger(a3) && a3 >= 0 ? a3 : -1;
      r2.structTreeRoot.addAnnotationIdToPage(e2.pageRef, a3);
    }
    if (e2.collectFields) {
      const r3 = t2.get("Kids");
      if (Array.isArray(r3)) {
        const e3 = [];
        for (const t3 of r3) t3 instanceof Ref && e3.push(t3.toString());
        0 !== e3.length && (this.data.kidIds = e3);
      }
      this.data.actions = collectActions(a2, t2, ye);
      this.data.fieldName = this._constructFieldName(t2);
      this.data.pageIndex = e2.pageIndex;
    }
    const h2 = t2.get("IT");
    h2 instanceof Name && (this.data.it = h2.name);
    this._isOffscreenCanvasSupported = e2.evaluatorOptions.isOffscreenCanvasSupported;
    this._fallbackFontDict = null;
    this._needAppearances = false;
  }
  _hasFlag(e2, t2) {
    return !!(e2 & t2);
  }
  _buildFlags(e2, t2) {
    let { flags: a2 } = this;
    if (void 0 === e2) {
      if (void 0 === t2) return;
      return t2 ? a2 & ~Y : a2 & ~J | Y;
    }
    if (e2) {
      a2 |= Y;
      return t2 ? a2 & ~Q | J : a2 & ~J | Q;
    }
    a2 &= ~(J | Q);
    return t2 ? a2 & ~Y : a2 | Y;
  }
  _isViewable(e2) {
    return !this._hasFlag(e2, K) && !this._hasFlag(e2, Q);
  }
  _isPrintable(e2) {
    return this._hasFlag(e2, Y) && !this._hasFlag(e2, J) && !this._hasFlag(e2, K);
  }
  mustBeViewed(e2, t2) {
    const a2 = e2?.get(this.data.id)?.noView;
    return void 0 !== a2 ? !a2 : this.viewable && !this._hasFlag(this.flags, J);
  }
  mustBePrinted(e2) {
    const t2 = e2?.get(this.data.id)?.noPrint;
    return void 0 !== t2 ? !t2 : this.printable;
  }
  mustBeViewedWhenEditing(e2, t2 = null) {
    return e2 ? !this.data.isEditable : !t2?.has(this.data.id);
  }
  get viewable() {
    return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
  }
  get printable() {
    return null !== this.data.quadPoints && (0 !== this.flags && this._isPrintable(this.flags));
  }
  _parseStringHelper(e2) {
    const t2 = "string" == typeof e2 ? stringToPDFString(e2) : "";
    return { str: t2, dir: t2 && "rtl" === bidi(t2).dir ? "rtl" : "ltr" };
  }
  setDefaultAppearance(e2) {
    const { dict: t2, annotationGlobals: a2 } = e2, r2 = getInheritableProperty({ dict: t2, key: "DA" }) || a2.acroForm.get("DA");
    this._defaultAppearance = "string" == typeof r2 ? r2 : "";
    this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
  }
  setTitle(e2) {
    this._title = this._parseStringHelper(e2);
  }
  setContents(e2) {
    this._contents = this._parseStringHelper(e2);
  }
  setModificationDate(e2) {
    this.modificationDate = "string" == typeof e2 ? e2 : null;
  }
  setFlags(e2) {
    this.flags = Number.isInteger(e2) && e2 > 0 ? e2 : 0;
    this.flags & K && "Annotation" !== this.constructor.name && (this.flags ^= K);
  }
  hasFlag(e2) {
    return this._hasFlag(this.flags, e2);
  }
  setRectangle(e2) {
    this.rectangle = lookupNormalRect(e2, [0, 0, 0, 0]);
  }
  setColor(e2) {
    this.color = getRgbColor(e2);
  }
  setLineEndings(e2) {
    this.lineEndings = ["None", "None"];
    if (Array.isArray(e2) && 2 === e2.length) for (let t2 = 0; t2 < 2; t2++) {
      const a2 = e2[t2];
      if (a2 instanceof Name) switch (a2.name) {
        case "None":
          continue;
        case "Square":
        case "Circle":
        case "Diamond":
        case "OpenArrow":
        case "ClosedArrow":
        case "Butt":
        case "ROpenArrow":
        case "RClosedArrow":
        case "Slash":
          this.lineEndings[t2] = a2.name;
          continue;
      }
      warn(`Ignoring invalid lineEnding: ${a2}`);
    }
  }
  setRotation(e2, t2) {
    this.rotation = 0;
    let a2 = e2 instanceof Dict ? e2.get("R") || 0 : t2.get("Rotate") || 0;
    if (Number.isInteger(a2) && 0 !== a2) {
      a2 %= 360;
      a2 < 0 && (a2 += 360);
      a2 % 90 == 0 && (this.rotation = a2);
    }
  }
  setBorderAndBackgroundColors(e2) {
    if (e2 instanceof Dict) {
      this.borderColor = getRgbColor(e2.getArray("BC"), null);
      this.backgroundColor = getRgbColor(e2.getArray("BG"), null);
    } else this.borderColor = this.backgroundColor = null;
  }
  setBorderStyle(e2) {
    this.borderStyle = new AnnotationBorderStyle();
    if (e2 instanceof Dict) if (e2.has("BS")) {
      const t2 = e2.get("BS");
      if (t2 instanceof Dict) {
        const e3 = t2.get("Type");
        if (!e3 || isName(e3, "Border")) {
          this.borderStyle.setWidth(t2.get("W"), this.rectangle);
          this.borderStyle.setStyle(t2.get("S"));
          this.borderStyle.setDashArray(t2.getArray("D"));
        }
      }
    } else if (e2.has("Border")) {
      const t2 = e2.getArray("Border");
      if (Array.isArray(t2) && t2.length >= 3) {
        this.borderStyle.setHorizontalCornerRadius(t2[0]);
        this.borderStyle.setVerticalCornerRadius(t2[1]);
        this.borderStyle.setWidth(t2[2], this.rectangle);
        4 === t2.length && this.borderStyle.setDashArray(t2[3], true);
      }
    } else this.borderStyle.setWidth(0);
  }
  setAppearance(e2) {
    this.appearance = null;
    const t2 = e2.get("AP");
    if (!(t2 instanceof Dict)) return;
    const a2 = t2.get("N");
    if (a2 instanceof BaseStream) {
      this.appearance = a2;
      return;
    }
    if (!(a2 instanceof Dict)) return;
    const r2 = e2.get("AS");
    if (!(r2 instanceof Name && a2.has(r2.name))) return;
    const i2 = a2.get(r2.name);
    i2 instanceof BaseStream && (this.appearance = i2);
  }
  setOptionalContent(e2) {
    this.oc = null;
    const t2 = e2.get("OC");
    t2 instanceof Name ? warn("setOptionalContent: Support for /Name-entry is not implemented.") : t2 instanceof Dict && (this.oc = t2);
  }
  async loadResources(e2, t2) {
    const a2 = await t2.dict.getAsync("Resources");
    a2 && await ObjectLoader.load(a2, e2, a2.xref);
    return a2;
  }
  async getOperatorList(e2, t2, a2, r2) {
    const { hasOwnCanvas: i2, id: n2, rect: o2 } = this.data;
    let c2 = this.appearance;
    const l2 = !!(i2 && a2 & s);
    if (l2 && (0 === this.width || 0 === this.height)) {
      this.data.hasOwnCanvas = false;
      return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
    }
    if (!c2) {
      if (!l2) return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
      c2 = new StringStream("");
      c2.dict = new Dict();
    }
    const h2 = c2.dict, u2 = await this.loadResources(Ia, c2), d2 = lookupRect(h2.getArray("BBox"), [0, 0, 1, 1]), f2 = lookupMatrix(h2.getArray("Matrix"), Fa), g2 = getTransformMatrix(o2, d2, f2), p2 = new OperatorList();
    let m2;
    this.oc && (m2 = await e2.parseMarkedContentProps(this.oc, null));
    void 0 !== m2 && p2.addOp(jt, ["OC", m2]);
    p2.addOp($t, [n2, o2, g2, f2, l2]);
    await e2.getOperatorList({ stream: c2, task: t2, resources: u2, operatorList: p2, fallbackFontDict: this._fallbackFontDict });
    p2.addOp(Gt, []);
    void 0 !== m2 && p2.addOp(_t, []);
    this.reset();
    return { opList: p2, separateForm: false, separateCanvas: l2 };
  }
  async save(e2, t2, a2, r2) {
    return null;
  }
  get overlaysTextContent() {
    return false;
  }
  get hasTextContent() {
    return false;
  }
  async extractTextContent(e2, t2, a2) {
    if (!this.appearance) return;
    const r2 = await this.loadResources(Ta, this.appearance), i2 = [], n2 = [];
    let s2 = null;
    const o2 = { desiredSize: Math.Infinity, ready: true, enqueue(e3, t3) {
      for (const t4 of e3.items) if (void 0 !== t4.str) {
        s2 ||= t4.transform.slice(-2);
        n2.push(t4.str);
        if (t4.hasEOL) {
          i2.push(n2.join("").trimEnd());
          n2.length = 0;
        }
      }
    } };
    await e2.getTextContent({ stream: this.appearance, task: t2, resources: r2, includeMarkedContent: true, keepWhiteSpace: true, sink: o2, viewBox: a2 });
    this.reset();
    n2.length && i2.push(n2.join("").trimEnd());
    if (i2.length > 1 || i2[0]) {
      const e3 = this.appearance.dict, t3 = lookupRect(e3.getArray("BBox"), null), a3 = lookupMatrix(e3.getArray("Matrix"), null);
      this.data.textPosition = this._transformPoint(s2, t3, a3);
      this.data.textContent = i2;
    }
  }
  _transformPoint(e2, t2, a2) {
    const { rect: r2 } = this.data;
    t2 ||= [0, 0, 1, 1];
    a2 ||= [1, 0, 0, 1, 0, 0];
    const i2 = getTransformMatrix(r2, t2, a2);
    i2[4] -= r2[0];
    i2[5] -= r2[1];
    const n2 = e2.slice();
    Util.applyTransform(n2, i2);
    Util.applyTransform(n2, a2);
    return n2;
  }
  getFieldObject() {
    return this.data.kidIds ? { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: "", kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation } : null;
  }
  reset() {
    for (const e2 of this._streams) e2.reset();
  }
  _constructFieldName(e2) {
    if (!e2.has("T") && !e2.has("Parent")) {
      warn("Unknown field name, falling back to empty field name.");
      return "";
    }
    if (!e2.has("Parent")) return stringToPDFString(e2.get("T"));
    const t2 = [];
    e2.has("T") && t2.unshift(stringToPDFString(e2.get("T")));
    let a2 = e2;
    const r2 = new RefSet();
    e2.objId && r2.put(e2.objId);
    for (; a2.has("Parent"); ) {
      a2 = a2.get("Parent");
      if (!(a2 instanceof Dict) || a2.objId && r2.has(a2.objId)) break;
      a2.objId && r2.put(a2.objId);
      a2.has("T") && t2.unshift(stringToPDFString(a2.get("T")));
    }
    return t2.join(".");
  }
  get width() {
    return this.data.rect[2] - this.data.rect[0];
  }
  get height() {
    return this.data.rect[3] - this.data.rect[1];
  }
};
var AnnotationBorderStyle = class {
  constructor() {
    this.width = 1;
    this.rawWidth = 1;
    this.style = fe;
    this.dashArray = [3];
    this.horizontalCornerRadius = 0;
    this.verticalCornerRadius = 0;
  }
  setWidth(e2, t2 = [0, 0, 0, 0]) {
    if (e2 instanceof Name) this.width = 0;
    else if ("number" == typeof e2) {
      if (e2 > 0) {
        this.rawWidth = e2;
        const a2 = (t2[2] - t2[0]) / 2, r2 = (t2[3] - t2[1]) / 2;
        if (a2 > 0 && r2 > 0 && (e2 > a2 || e2 > r2)) {
          warn(`AnnotationBorderStyle.setWidth - ignoring width: ${e2}`);
          e2 = 1;
        }
      }
      this.width = e2;
    }
  }
  setStyle(e2) {
    if (e2 instanceof Name) switch (e2.name) {
      case "S":
        this.style = fe;
        break;
      case "D":
        this.style = ge;
        break;
      case "B":
        this.style = pe;
        break;
      case "I":
        this.style = me;
        break;
      case "U":
        this.style = be;
    }
  }
  setDashArray(e2, t2 = false) {
    if (Array.isArray(e2)) {
      let a2 = true, r2 = true;
      for (const t3 of e2) {
        if (!(+t3 >= 0)) {
          a2 = false;
          break;
        }
        t3 > 0 && (r2 = false);
      }
      if (0 === e2.length || a2 && !r2) {
        this.dashArray = e2;
        t2 && this.setStyle(Name.get("D"));
      } else this.width = 0;
    } else e2 && (this.width = 0);
  }
  setHorizontalCornerRadius(e2) {
    Number.isInteger(e2) && (this.horizontalCornerRadius = e2);
  }
  setVerticalCornerRadius(e2) {
    Number.isInteger(e2) && (this.verticalCornerRadius = e2);
  }
};
var MarkupAnnotation = class extends Annotation {
  constructor(e2) {
    super(e2);
    const { dict: t2 } = e2;
    if (t2.has("IRT")) {
      const e3 = t2.getRaw("IRT");
      this.data.inReplyTo = e3 instanceof Ref ? e3.toString() : null;
      const a3 = t2.get("RT");
      this.data.replyType = a3 instanceof Name ? a3.name : V;
    }
    let a2 = null;
    if (this.data.replyType === G) {
      const e3 = t2.get("IRT");
      this.setTitle(e3.get("T"));
      this.data.titleObj = this._title;
      this.setContents(e3.get("Contents"));
      this.data.contentsObj = this._contents;
      if (e3.has("CreationDate")) {
        this.setCreationDate(e3.get("CreationDate"));
        this.data.creationDate = this.creationDate;
      } else this.data.creationDate = null;
      if (e3.has("M")) {
        this.setModificationDate(e3.get("M"));
        this.data.modificationDate = this.modificationDate;
      } else this.data.modificationDate = null;
      a2 = e3.getRaw("Popup");
      if (e3.has("C")) {
        this.setColor(e3.getArray("C"));
        this.data.color = this.color;
      } else this.data.color = null;
    } else {
      this.data.titleObj = this._title;
      this.setCreationDate(t2.get("CreationDate"));
      this.data.creationDate = this.creationDate;
      a2 = t2.getRaw("Popup");
      t2.has("C") || (this.data.color = null);
    }
    this.data.popupRef = a2 instanceof Ref ? a2.toString() : null;
    t2.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(t2.get("RC")));
  }
  setCreationDate(e2) {
    this.creationDate = "string" == typeof e2 ? e2 : null;
  }
  _setDefaultAppearance({ xref: e2, extra: t2, strokeColor: a2, fillColor: r2, blendMode: i2, strokeAlpha: n2, fillAlpha: s2, pointsCallback: o2 }) {
    const c2 = this.data.rect = [1 / 0, 1 / 0, -1 / 0, -1 / 0], l2 = ["q"];
    t2 && l2.push(t2);
    a2 && l2.push(`${a2[0]} ${a2[1]} ${a2[2]} RG`);
    r2 && l2.push(`${r2[0]} ${r2[1]} ${r2[2]} rg`);
    const h2 = this.data.quadPoints || Float32Array.from([this.rectangle[0], this.rectangle[3], this.rectangle[2], this.rectangle[3], this.rectangle[0], this.rectangle[1], this.rectangle[2], this.rectangle[1]]);
    for (let e3 = 0, t3 = h2.length; e3 < t3; e3 += 8) {
      const t4 = o2(l2, h2.subarray(e3, e3 + 8));
      Util.rectBoundingBox(...t4, c2);
    }
    l2.push("Q");
    const u2 = new Dict(e2), d2 = new Dict(e2);
    d2.setIfName("Subtype", "Form");
    const f2 = new StringStream(l2.join(" "));
    f2.dict = d2;
    u2.set("Fm0", f2);
    const g2 = new Dict(e2);
    i2 && g2.setIfName("BM", i2);
    g2.setIfNumber("CA", n2);
    g2.setIfNumber("ca", s2);
    const p2 = new Dict(e2);
    p2.set("GS0", g2);
    const m2 = new Dict(e2);
    m2.set("ExtGState", p2);
    m2.set("XObject", u2);
    const b2 = new Dict(e2);
    b2.set("Resources", m2);
    b2.set("BBox", c2);
    this.appearance = new StringStream("/GS0 gs /Fm0 Do");
    this.appearance.dict = b2;
    this._streams.push(this.appearance, f2);
  }
  static async createNewAnnotation(e2, t2, a2, r2) {
    const i2 = t2.ref ||= e2.getNewTemporaryRef(), n2 = await this.createNewAppearanceStream(t2, e2, r2);
    let s2;
    if (n2) {
      const r3 = e2.getNewTemporaryRef();
      s2 = this.createNewDict(t2, e2, { apRef: r3 });
      a2.put(r3, { data: n2 });
    } else s2 = this.createNewDict(t2, e2, {});
    Number.isInteger(t2.parentTreeId) && s2.set("StructParent", t2.parentTreeId);
    a2.put(i2, { data: s2 });
    const o2 = { ref: i2 };
    if (t2.popup) {
      const r3 = t2.popup;
      if (r3.deleted) {
        s2.delete("Popup");
        s2.delete("Contents");
        s2.delete("RC");
        return o2;
      }
      const n3 = r3.ref ||= e2.getNewTemporaryRef();
      r3.parent = i2;
      const c2 = PopupAnnotation.createNewDict(r3, e2);
      a2.put(n3, { data: c2 });
      s2.setIfDefined("Contents", stringToAsciiOrUTF16BE(r3.contents));
      s2.set("Popup", n3);
      return [o2, { ref: n3 }];
    }
    return o2;
  }
  static async createNewPrintAnnotation(e2, t2, a2, r2) {
    const i2 = await this.createNewAppearanceStream(a2, t2, r2), n2 = this.createNewDict(a2, t2, i2 ? { ap: i2 } : {}), s2 = new this.prototype.constructor({ dict: n2, xref: t2, annotationGlobals: e2, evaluatorOptions: r2.evaluatorOptions });
    a2.ref && (s2.ref = s2.refToReplace = a2.ref);
    return s2;
  }
};
var WidgetAnnotation = class _WidgetAnnotation extends Annotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2, annotationGlobals: r2 } = e2, i2 = this.data;
    this._needAppearances = e2.needAppearances;
    i2.annotationType = $;
    void 0 === i2.fieldName && (i2.fieldName = this._constructFieldName(t2));
    void 0 === i2.actions && (i2.actions = collectActions(a2, t2, ye));
    let n2 = getInheritableProperty({ dict: t2, key: "V", getArray: true });
    i2.fieldValue = this._decodeFormValue(n2);
    const s2 = getInheritableProperty({ dict: t2, key: "DV", getArray: true });
    i2.defaultFieldValue = this._decodeFormValue(s2);
    if (void 0 === n2 && r2.xfaDatasets) {
      const e3 = this._title.str;
      if (e3) {
        this._hasValueFromXFA = true;
        i2.fieldValue = n2 = r2.xfaDatasets.getValue(e3);
      }
    }
    void 0 === n2 && null !== i2.defaultFieldValue && (i2.fieldValue = i2.defaultFieldValue);
    i2.alternativeText = stringToPDFString(t2.get("TU") || "");
    this.setDefaultAppearance(e2);
    i2.hasAppearance ||= this._needAppearances && void 0 !== i2.fieldValue && null !== i2.fieldValue;
    const o2 = getInheritableProperty({ dict: t2, key: "FT" });
    i2.fieldType = o2 instanceof Name ? o2.name : null;
    const c2 = getInheritableProperty({ dict: t2, key: "DR" }), l2 = r2.acroForm.get("DR"), h2 = this.appearance?.dict.get("Resources");
    this._fieldResources = { localResources: c2, acroFormResources: l2, appearanceResources: h2, mergedResources: Dict.merge({ xref: a2, dictArray: [c2, h2, l2], mergeSubDicts: true }) };
    i2.fieldFlags = getInheritableProperty({ dict: t2, key: "Ff" });
    (!Number.isInteger(i2.fieldFlags) || i2.fieldFlags < 0) && (i2.fieldFlags = 0);
    i2.password = this.hasFieldFlag(ne);
    i2.readOnly = this.hasFieldFlag(ae);
    i2.required = this.hasFieldFlag(re);
    i2.hidden = this._hasFlag(i2.annotationFlags, J) || this._hasFlag(i2.annotationFlags, Q);
  }
  _decodeFormValue(e2) {
    return Array.isArray(e2) ? e2.filter(((e3) => "string" == typeof e3)).map(((e3) => stringToPDFString(e3))) : e2 instanceof Name ? stringToPDFString(e2.name) : "string" == typeof e2 ? stringToPDFString(e2) : null;
  }
  hasFieldFlag(e2) {
    return !!(this.data.fieldFlags & e2);
  }
  _isViewable(e2) {
    return true;
  }
  mustBeViewed(e2, t2) {
    return t2 ? this.viewable : super.mustBeViewed(e2, t2) && !this._hasFlag(this.flags, Q);
  }
  getRotationMatrix(e2) {
    let t2 = e2?.get(this.data.id)?.rotation;
    void 0 === t2 && (t2 = this.rotation);
    return 0 === t2 ? Fa : getRotationMatrix(t2, this.width, this.height);
  }
  getBorderAndBackgroundAppearances(e2) {
    let t2 = e2?.get(this.data.id)?.rotation;
    void 0 === t2 && (t2 = this.rotation);
    if (!this.backgroundColor && !this.borderColor) return "";
    const a2 = 0 === t2 || 180 === t2 ? `0 0 ${this.width} ${this.height} re` : `0 0 ${this.height} ${this.width} re`;
    let r2 = "";
    this.backgroundColor && (r2 = `${getPdfColor(this.backgroundColor, true)} ${a2} f `);
    if (this.borderColor) {
      r2 += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, false)} ${a2} S `;
    }
    return r2;
  }
  async getOperatorList(e2, t2, a2, r2) {
    if (a2 & l && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) return { opList: new OperatorList(), separateForm: true, separateCanvas: false };
    if (!this._hasText) return super.getOperatorList(e2, t2, a2, r2);
    const i2 = await this._getAppearance(e2, t2, a2, r2);
    if (this.appearance && null === i2) return super.getOperatorList(e2, t2, a2, r2);
    const n2 = new OperatorList();
    if (!this._defaultAppearance || null === i2) return { opList: n2, separateForm: false, separateCanvas: false };
    const o2 = !!(this.data.hasOwnCanvas && a2 & s), c2 = [0, 0, this.width, this.height], h2 = getTransformMatrix(this.data.rect, c2, [1, 0, 0, 1, 0, 0]);
    let u2;
    this.oc && (u2 = await e2.parseMarkedContentProps(this.oc, null));
    void 0 !== u2 && n2.addOp(jt, ["OC", u2]);
    n2.addOp($t, [this.data.id, this.data.rect, h2, this.getRotationMatrix(r2), o2]);
    const d2 = new StringStream(i2);
    await e2.getOperatorList({ stream: d2, task: t2, resources: this._fieldResources.mergedResources, operatorList: n2 });
    n2.addOp(Gt, []);
    void 0 !== u2 && n2.addOp(_t, []);
    return { opList: n2, separateForm: false, separateCanvas: o2 };
  }
  _getMKDict(e2) {
    const t2 = new Dict(null);
    e2 && t2.set("R", e2);
    t2.setIfArray("BC", getPdfColorArray(this.borderColor));
    t2.setIfArray("BG", getPdfColorArray(this.backgroundColor));
    return t2.size > 0 ? t2 : null;
  }
  amendSavedDict(e2, t2) {
  }
  setValue(e2, t2, a2, r2) {
    const { dict: i2, ref: n2 } = (function getParentToUpdate(e3, t3, a3) {
      const r3 = new RefSet(), i3 = e3, n3 = { dict: null, ref: null };
      for (; e3 instanceof Dict && !r3.has(t3); ) {
        r3.put(t3);
        if (e3.has("T")) break;
        if (!((t3 = e3.getRaw("Parent")) instanceof Ref)) return n3;
        e3 = a3.fetch(t3);
      }
      if (e3 instanceof Dict && e3 !== i3) {
        n3.dict = e3;
        n3.ref = t3;
      }
      return n3;
    })(e2, this.ref, a2);
    if (i2) {
      if (!r2.has(n2)) {
        const e3 = i2.clone();
        e3.set("V", t2);
        r2.put(n2, { data: e3 });
        return e3;
      }
    } else e2.set("V", t2);
    return null;
  }
  async save(e2, t2, a2, r2) {
    const i2 = a2?.get(this.data.id), n2 = this._buildFlags(i2?.noView, i2?.noPrint);
    let s2 = i2?.value, o2 = i2?.rotation;
    if (s2 === this.data.fieldValue || void 0 === s2) {
      if (!this._hasValueFromXFA && void 0 === o2 && void 0 === n2) return;
      s2 ||= this.data.fieldValue;
    }
    if (void 0 === o2 && !this._hasValueFromXFA && Array.isArray(s2) && Array.isArray(this.data.fieldValue) && isArrayEqual(s2, this.data.fieldValue) && void 0 === n2) return;
    void 0 === o2 && (o2 = this.rotation);
    let l2 = null;
    if (!this._needAppearances) {
      l2 = await this._getAppearance(e2, t2, c, a2);
      if (null === l2 && void 0 === n2) return;
    }
    let h2 = false;
    if (l2?.needAppearances) {
      h2 = true;
      l2 = null;
    }
    const { xref: u2 } = e2, d2 = u2.fetchIfRef(this.ref);
    if (!(d2 instanceof Dict)) return;
    const f2 = new Dict(u2);
    for (const e3 of d2.getKeys()) "AP" !== e3 && f2.set(e3, d2.getRaw(e3));
    if (void 0 !== n2) {
      f2.set("F", n2);
      if (null === l2 && !h2) {
        const e3 = d2.getRaw("AP");
        e3 && f2.set("AP", e3);
      }
    }
    const g2 = { path: this.data.fieldName, value: s2 }, p2 = this.setValue(f2, Array.isArray(s2) ? s2.map(stringToAsciiOrUTF16BE) : stringToAsciiOrUTF16BE(s2), u2, r2);
    this.amendSavedDict(a2, p2 || f2);
    const m2 = this._getMKDict(o2);
    m2 && f2.set("MK", m2);
    r2.put(this.ref, { data: f2, xfa: g2, needAppearances: h2 });
    if (null !== l2) {
      const e3 = u2.getNewTemporaryRef(), t3 = new Dict(u2);
      f2.set("AP", t3);
      t3.set("N", e3);
      const i3 = this._getSaveFieldResources(u2), n3 = new StringStream(l2), s3 = n3.dict = new Dict(u2);
      s3.setIfName("Subtype", "Form");
      s3.set("Resources", i3);
      const c2 = o2 % 180 == 0 ? [0, 0, this.width, this.height] : [0, 0, this.height, this.width];
      s3.set("BBox", c2);
      const h3 = this.getRotationMatrix(a2);
      h3 !== Fa && s3.set("Matrix", h3);
      r2.put(e3, { data: n3, xfa: null, needAppearances: false });
    }
    f2.set("M", `D:${getModificationDate()}`);
  }
  async _getAppearance(e2, t2, a2, r2) {
    if (this.data.password) return null;
    const n2 = r2?.get(this.data.id);
    let s2, o2;
    if (n2) {
      s2 = n2.formattedValue || n2.value;
      o2 = n2.rotation;
    }
    if (void 0 === o2 && void 0 === s2 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;
    const l2 = this.getBorderAndBackgroundAppearances(r2);
    if (void 0 === s2) {
      s2 = this.data.fieldValue;
      if (!s2) return `/Tx BMC q ${l2}Q EMC`;
    }
    Array.isArray(s2) && 1 === s2.length && (s2 = s2[0]);
    assert("string" == typeof s2, "Expected `value` to be a string.");
    s2 = s2.trimEnd();
    if (this.data.combo) {
      const e3 = this.data.options.find((({ exportValue: e4 }) => s2 === e4));
      s2 = e3?.displayValue || s2;
    }
    if ("" === s2) return `/Tx BMC q ${l2}Q EMC`;
    void 0 === o2 && (o2 = this.rotation);
    let h2, u2 = -1;
    if (this.data.multiLine) {
      h2 = s2.split(/\r\n?|\n/).map(((e3) => e3.normalize("NFC")));
      u2 = h2.length;
    } else h2 = [s2.replace(/\r\n?|\n/, "").normalize("NFC")];
    let { width: d2, height: f2 } = this;
    90 !== o2 && 270 !== o2 || ([d2, f2] = [f2, d2]);
    this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    let g2, p2, m2, b2 = await _WidgetAnnotation._getFontData(e2, t2, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    const y2 = [];
    let w2 = false;
    for (const e3 of h2) {
      const t3 = b2.encodeString(e3);
      t3.length > 1 && (w2 = true);
      y2.push(t3.join(""));
    }
    if (w2 && a2 & c) return { needAppearances: true };
    if (w2 && this._isOffscreenCanvasSupported) {
      const a3 = this.data.comb ? "monospace" : "sans-serif", r3 = new FakeUnicodeFont(e2.xref, a3), i2 = r3.createFontResources(h2.join("")), n3 = i2.getRaw("Font");
      if (this._fieldResources.mergedResources.has("Font")) {
        const e3 = this._fieldResources.mergedResources.get("Font");
        for (const t3 of n3.getKeys()) e3.set(t3, n3.getRaw(t3));
      } else this._fieldResources.mergedResources.set("Font", n3);
      const o3 = r3.fontName.name;
      b2 = await _WidgetAnnotation._getFontData(e2, t2, { fontName: o3, fontSize: 0 }, i2);
      for (let e3 = 0, t3 = y2.length; e3 < t3; e3++) y2[e3] = stringToUTF16String(h2[e3]);
      const c2 = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
      this.data.defaultAppearanceData.fontSize = 0;
      this.data.defaultAppearanceData.fontName = o3;
      [g2, p2, m2] = this._computeFontSize(f2 - 2, d2 - 4, s2, b2, u2);
      this.data.defaultAppearanceData = c2;
    } else {
      this._isOffscreenCanvasSupported || warn("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.");
      [g2, p2, m2] = this._computeFontSize(f2 - 2, d2 - 4, s2, b2, u2);
    }
    let x2 = b2.descent;
    x2 = isNaN(x2) ? i * m2 : Math.max(i * m2, Math.abs(x2) * p2);
    const S2 = Math.min(Math.floor((f2 - p2) / 2), 1), k2 = this.data.textAlignment;
    if (this.data.multiLine) return this._getMultilineAppearance(g2, y2, b2, p2, d2, f2, k2, 2, S2, x2, m2, r2);
    if (this.data.comb) return this._getCombAppearance(g2, b2, y2[0], p2, d2, f2, 2, S2, x2, m2, r2);
    const C2 = S2 + x2;
    if (0 === k2 || k2 > 2) return `/Tx BMC q ${l2}BT ` + g2 + ` 1 0 0 1 ${numberToString(2)} ${numberToString(C2)} Tm (${escapeString(y2[0])}) Tj ET Q EMC`;
    return `/Tx BMC q ${l2}BT ` + g2 + ` 1 0 0 1 0 0 Tm ${this._renderText(y2[0], b2, p2, d2, k2, { shift: 0 }, 2, C2)} ET Q EMC`;
  }
  static async _getFontData(e2, t2, a2, r2) {
    const i2 = new OperatorList(), n2 = { font: null, clone() {
      return this;
    } }, { fontName: s2, fontSize: o2 } = a2;
    await e2.handleSetFont(r2, [s2 && Name.get(s2), o2], null, i2, t2, n2, null);
    return n2.font;
  }
  _getTextWidth(e2, t2) {
    return Math.sumPrecise(t2.charsToGlyphs(e2).map(((e3) => e3.width))) / 1e3;
  }
  _computeFontSize(e2, t2, r2, i2, n2) {
    let { fontSize: s2 } = this.data.defaultAppearanceData, o2 = (s2 || 12) * a, c2 = Math.round(e2 / o2);
    if (!s2) {
      const roundWithTwoDigits = (e3) => Math.floor(100 * e3) / 100;
      if (-1 === n2) {
        const n3 = this._getTextWidth(r2, i2);
        s2 = roundWithTwoDigits(Math.min(e2 / a, t2 / n3));
        c2 = 1;
      } else {
        const l3 = r2.split(/\r\n?|\n/), h3 = [];
        for (const e3 of l3) {
          const t3 = i2.encodeString(e3).join(""), a2 = i2.charsToGlyphs(t3), r3 = i2.getCharPositions(t3);
          h3.push({ line: t3, glyphs: a2, positions: r3 });
        }
        const isTooBig = (a2) => {
          let r3 = 0;
          for (const n3 of h3) {
            r3 += this._splitLine(null, i2, a2, t2, n3).length * a2;
            if (r3 > e2) return true;
          }
          return false;
        };
        c2 = Math.max(c2, n2);
        for (; ; ) {
          o2 = e2 / c2;
          s2 = roundWithTwoDigits(o2 / a);
          if (!isTooBig(s2)) break;
          c2++;
        }
      }
      const { fontName: l2, fontColor: h2 } = this.data.defaultAppearanceData;
      this._defaultAppearance = (function createDefaultAppearance({ fontSize: e3, fontName: t3, fontColor: a2 }) {
        return `/${escapePDFName(t3)} ${e3} Tf ${getPdfColor(a2, true)}`;
      })({ fontSize: s2, fontName: l2, fontColor: h2 });
    }
    return [this._defaultAppearance, s2, e2 / c2];
  }
  _renderText(e2, t2, a2, r2, i2, n2, s2, o2) {
    let c2;
    if (1 === i2) {
      c2 = (r2 - this._getTextWidth(e2, t2) * a2) / 2;
    } else if (2 === i2) {
      c2 = r2 - this._getTextWidth(e2, t2) * a2 - s2;
    } else c2 = s2;
    const l2 = numberToString(c2 - n2.shift);
    n2.shift = c2;
    return `${l2} ${o2 = numberToString(o2)} Td (${escapeString(e2)}) Tj`;
  }
  _getSaveFieldResources(e2) {
    const { localResources: t2, appearanceResources: a2, acroFormResources: r2 } = this._fieldResources, i2 = this.data.defaultAppearanceData?.fontName;
    if (!i2) return t2 || Dict.empty;
    for (const e3 of [t2, a2]) if (e3 instanceof Dict) {
      const t3 = e3.get("Font");
      if (t3 instanceof Dict && t3.has(i2)) return e3;
    }
    if (r2 instanceof Dict) {
      const a3 = r2.get("Font");
      if (a3 instanceof Dict && a3.has(i2)) {
        const r3 = new Dict(e2);
        r3.set(i2, a3.getRaw(i2));
        const n2 = new Dict(e2);
        n2.set("Font", r3);
        return Dict.merge({ xref: e2, dictArray: [n2, t2], mergeSubDicts: true });
      }
    }
    return t2 || Dict.empty;
  }
  getFieldObject() {
    return null;
  }
};
var TextWidgetAnnotation = class extends WidgetAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2 } = e2;
    if (t2.has("PMD")) {
      this.flags |= J;
      this.data.hidden = true;
      warn("Barcodes are not supported");
    }
    this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
    this._hasText = true;
    "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
    let a2 = getInheritableProperty({ dict: t2, key: "Q" });
    (!Number.isInteger(a2) || a2 < 0 || a2 > 2) && (a2 = null);
    this.data.textAlignment = a2;
    let r2 = getInheritableProperty({ dict: t2, key: "MaxLen" });
    (!Number.isInteger(r2) || r2 < 0) && (r2 = 0);
    this.data.maxLen = r2;
    this.data.multiLine = this.hasFieldFlag(ie);
    this.data.comb = this.hasFieldFlag(de) && !this.data.multiLine && !this.data.password && !this.hasFieldFlag(le) && 0 !== this.data.maxLen;
    this.data.doNotScroll = this.hasFieldFlag(ue);
    const { data: { actions: i2 } } = this;
    if (!i2) return;
    const n2 = /^AF(Date|Time)_(?:Keystroke|Format)(?:Ex)?\(['"]?([^'"]+)['"]?\);$/;
    let s2 = false;
    (1 === i2.Format?.length && 1 === i2.Keystroke?.length && n2.test(i2.Format[0]) && n2.test(i2.Keystroke[0]) || 0 === i2.Format?.length && 1 === i2.Keystroke?.length && n2.test(i2.Keystroke[0]) || 0 === i2.Keystroke?.length && 1 === i2.Format?.length && n2.test(i2.Format[0])) && (s2 = true);
    const o2 = [];
    i2.Format && o2.push(...i2.Format);
    i2.Keystroke && o2.push(...i2.Keystroke);
    if (s2) {
      delete i2.Keystroke;
      i2.Format = o2;
    }
    for (const e3 of o2) {
      const t3 = e3.match(n2);
      if (!t3) continue;
      const a3 = "Date" === t3[1];
      let r3 = t3[2];
      const i3 = parseInt(r3, 10);
      isNaN(i3) || Math.floor(Math.log10(i3)) + 1 !== t3[2].length || (r3 = (a3 ? Pn : Ln)[i3] ?? r3);
      this.data.datetimeFormat = r3;
      if (!s2) break;
      if (a3) {
        if (/HH|MM|ss|h/.test(r3)) {
          this.data.datetimeType = "datetime-local";
          this.data.timeStep = /ss/.test(r3) ? 1 : 60;
        } else this.data.datetimeType = "date";
        break;
      }
      this.data.datetimeType = "time";
      this.data.timeStep = /ss/.test(r3) ? 1 : 60;
      break;
    }
  }
  get hasTextContent() {
    return !!this.appearance && !this._needAppearances;
  }
  _getCombAppearance(e2, t2, a2, r2, i2, n2, s2, o2, c2, l2, h2) {
    const u2 = i2 / this.data.maxLen, d2 = this.getBorderAndBackgroundAppearances(h2), f2 = [], g2 = t2.getCharPositions(a2);
    for (const [e3, t3] of g2) f2.push(`(${escapeString(a2.substring(e3, t3))}) Tj`);
    const p2 = f2.join(` ${numberToString(u2)} 0 Td `);
    return `/Tx BMC q ${d2}BT ` + e2 + ` 1 0 0 1 ${numberToString(s2)} ${numberToString(o2 + c2)} Tm ${p2} ET Q EMC`;
  }
  _getMultilineAppearance(e2, t2, a2, r2, i2, n2, s2, o2, c2, l2, h2, u2) {
    const d2 = [], f2 = i2 - 2 * o2, g2 = { shift: 0 };
    for (let e3 = 0, n3 = t2.length; e3 < n3; e3++) {
      const n4 = t2[e3], u3 = this._splitLine(n4, a2, r2, f2);
      for (let t3 = 0, n5 = u3.length; t3 < n5; t3++) {
        const n6 = u3[t3], f3 = 0 === e3 && 0 === t3 ? -c2 - (h2 - l2) : -h2;
        d2.push(this._renderText(n6, a2, r2, i2, s2, g2, o2, f3));
      }
    }
    const p2 = this.getBorderAndBackgroundAppearances(u2), m2 = d2.join("\n");
    return `/Tx BMC q ${p2}BT ` + e2 + ` 1 0 0 1 0 ${numberToString(n2)} Tm ${m2} ET Q EMC`;
  }
  _splitLine(e2, t2, a2, r2, i2 = {}) {
    e2 = i2.line || e2;
    const n2 = i2.glyphs || t2.charsToGlyphs(e2);
    if (n2.length <= 1) return [e2];
    const s2 = i2.positions || t2.getCharPositions(e2), o2 = a2 / 1e3, c2 = [];
    let l2 = -1, h2 = -1, u2 = -1, d2 = 0, f2 = 0;
    for (let t3 = 0, a3 = n2.length; t3 < a3; t3++) {
      const [a4, i3] = s2[t3], g2 = n2[t3], p2 = g2.width * o2;
      if (" " === g2.unicode) if (f2 + p2 > r2) {
        c2.push(e2.substring(d2, a4));
        d2 = a4;
        f2 = p2;
        l2 = -1;
        u2 = -1;
      } else {
        f2 += p2;
        l2 = a4;
        h2 = i3;
        u2 = t3;
      }
      else if (f2 + p2 > r2) if (-1 !== l2) {
        c2.push(e2.substring(d2, h2));
        d2 = h2;
        t3 = u2 + 1;
        l2 = -1;
        f2 = 0;
      } else {
        c2.push(e2.substring(d2, a4));
        d2 = a4;
        f2 = p2;
      }
      else f2 += p2;
    }
    d2 < e2.length && c2.push(e2.substring(d2, e2.length));
    return c2;
  }
  async extractTextContent(e2, t2, a2) {
    await super.extractTextContent(e2, t2, a2);
    const r2 = this.data.textContent;
    if (!r2) return;
    const i2 = r2.join("\n");
    if (i2 === this.data.fieldValue) return;
    const n2 = i2.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, ((e3, t3) => t3 ? `\\${t3}` : "\\s+"));
    new RegExp(`^\\s*${n2}\\s*$`).test(this.data.fieldValue) && (this.data.textContent = this.data.fieldValue.split("\n"));
  }
  getFieldObject() {
    return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || "", multiline: this.data.multiLine, password: this.data.password, charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, datetimeFormat: this.data.datetimeFormat, hasDatetimeHTML: !!this.data.datetimeType, type: "text" };
  }
};
var ButtonWidgetAnnotation = class extends WidgetAnnotation {
  constructor(e2) {
    super(e2);
    this.checkedAppearance = null;
    this.uncheckedAppearance = null;
    const t2 = this.hasFieldFlag(se), a2 = this.hasFieldFlag(oe);
    this.data.checkBox = !t2 && !a2;
    this.data.radioButton = t2 && !a2;
    this.data.pushButton = a2;
    this.data.isTooltipOnly = false;
    if (this.data.checkBox) this._processCheckBox(e2);
    else if (this.data.radioButton) this._processRadioButton(e2);
    else if (this.data.pushButton) {
      this.data.hasOwnCanvas = true;
      this.data.noHTML = false;
      this._processPushButton(e2);
    } else warn("Invalid field flags for button widget annotation");
  }
  async getOperatorList(e2, t2, a2, r2) {
    if (this.data.pushButton) return super.getOperatorList(e2, t2, a2, false, r2);
    let i2 = null, n2 = null;
    if (r2) {
      const e3 = r2.get(this.data.id);
      i2 = e3 ? e3.value : null;
      n2 = e3 ? e3.rotation : null;
    }
    if (null === i2 && this.appearance) return super.getOperatorList(e2, t2, a2, r2);
    null == i2 && (i2 = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
    const s2 = i2 ? this.checkedAppearance : this.uncheckedAppearance;
    if (s2) {
      const i3 = this.appearance, o2 = lookupMatrix(s2.dict.getArray("Matrix"), Fa);
      n2 && s2.dict.set("Matrix", this.getRotationMatrix(r2));
      this.appearance = s2;
      const c2 = super.getOperatorList(e2, t2, a2, r2);
      this.appearance = i3;
      s2.dict.set("Matrix", o2);
      return c2;
    }
    return { opList: new OperatorList(), separateForm: false, separateCanvas: false };
  }
  async save(e2, t2, a2, r2) {
    this.data.checkBox ? this._saveCheckbox(e2, t2, a2, r2) : this.data.radioButton && this._saveRadioButton(e2, t2, a2, r2);
  }
  async _saveCheckbox(e2, t2, a2, r2) {
    if (!a2) return;
    const i2 = a2.get(this.data.id), n2 = this._buildFlags(i2?.noView, i2?.noPrint);
    let s2 = i2?.rotation, o2 = i2?.value;
    if (void 0 === s2 && void 0 === n2) {
      if (void 0 === o2) return;
      if (this.data.fieldValue === this.data.exportValue === o2) return;
    }
    let c2 = e2.xref.fetchIfRef(this.ref);
    if (!(c2 instanceof Dict)) return;
    c2 = c2.clone();
    void 0 === s2 && (s2 = this.rotation);
    void 0 === o2 && (o2 = this.data.fieldValue === this.data.exportValue);
    const l2 = { path: this.data.fieldName, value: o2 ? this.data.exportValue : "" }, h2 = Name.get(o2 ? this.data.exportValue : "Off");
    this.setValue(c2, h2, e2.xref, r2);
    c2.set("AS", h2);
    c2.set("M", `D:${getModificationDate()}`);
    void 0 !== n2 && c2.set("F", n2);
    const u2 = this._getMKDict(s2);
    u2 && c2.set("MK", u2);
    r2.put(this.ref, { data: c2, xfa: l2, needAppearances: false });
  }
  async _saveRadioButton(e2, t2, a2, r2) {
    if (!a2) return;
    const i2 = a2.get(this.data.id), n2 = this._buildFlags(i2?.noView, i2?.noPrint);
    let s2 = i2?.rotation, o2 = i2?.value;
    if (void 0 === s2 && void 0 === n2) {
      if (void 0 === o2) return;
      if (this.data.fieldValue === this.data.buttonValue === o2) return;
    }
    let c2 = e2.xref.fetchIfRef(this.ref);
    if (!(c2 instanceof Dict)) return;
    c2 = c2.clone();
    void 0 === o2 && (o2 = this.data.fieldValue === this.data.buttonValue);
    void 0 === s2 && (s2 = this.rotation);
    const l2 = { path: this.data.fieldName, value: o2 ? this.data.buttonValue : "" }, h2 = Name.get(o2 ? this.data.buttonValue : "Off");
    o2 && this.setValue(c2, h2, e2.xref, r2);
    c2.set("AS", h2);
    c2.set("M", `D:${getModificationDate()}`);
    void 0 !== n2 && c2.set("F", n2);
    const u2 = this._getMKDict(s2);
    u2 && c2.set("MK", u2);
    r2.put(this.ref, { data: c2, xfa: l2, needAppearances: false });
  }
  _getDefaultCheckedAppearance(e2, t2) {
    const { width: a2, height: r2 } = this, i2 = [0, 0, a2, r2], n2 = 0.8 * Math.min(a2, r2);
    let s2, o2;
    if ("check" === t2) {
      s2 = { width: 0.755 * n2, height: 0.705 * n2 };
      o2 = "3";
    } else if ("disc" === t2) {
      s2 = { width: 0.791 * n2, height: 0.705 * n2 };
      o2 = "l";
    } else unreachable(`_getDefaultCheckedAppearance - unsupported type: ${t2}`);
    const c2 = `q BT /PdfJsZaDb ${n2} Tf 0 g ${numberToString((a2 - s2.width) / 2)} ${numberToString((r2 - s2.height) / 2)} Td (${o2}) Tj ET Q`, l2 = new Dict(e2.xref);
    l2.set("FormType", 1);
    l2.setIfName("Subtype", "Form");
    l2.setIfName("Type", "XObject");
    l2.set("BBox", i2);
    l2.set("Matrix", [1, 0, 0, 1, 0, 0]);
    l2.set("Length", c2.length);
    const h2 = new Dict(e2.xref), u2 = new Dict(e2.xref);
    u2.set("PdfJsZaDb", this.fallbackFontDict);
    h2.set("Font", u2);
    l2.set("Resources", h2);
    this.checkedAppearance = new StringStream(c2);
    this.checkedAppearance.dict = l2;
    this._streams.push(this.checkedAppearance);
  }
  _processCheckBox(e2) {
    const t2 = e2.dict.get("AP");
    if (!(t2 instanceof Dict)) return;
    const a2 = t2.get("N");
    if (!(a2 instanceof Dict)) return;
    const r2 = this._decodeFormValue(e2.dict.get("AS"));
    "string" == typeof r2 && (this.data.fieldValue = r2);
    const i2 = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", n2 = this._decodeFormValue(a2.getKeys());
    if (0 === n2.length) n2.push("Off", i2);
    else if (1 === n2.length) "Off" === n2[0] ? n2.push(i2) : n2.unshift("Off");
    else if (n2.includes(i2)) {
      n2.length = 0;
      n2.push("Off", i2);
    } else {
      const e3 = n2.find(((e4) => "Off" !== e4));
      n2.length = 0;
      n2.push("Off", e3);
    }
    n2.includes(this.data.fieldValue) || (this.data.fieldValue = "Off");
    this.data.exportValue = n2[1];
    const s2 = a2.get(this.data.exportValue);
    this.checkedAppearance = s2 instanceof BaseStream ? s2 : null;
    const o2 = a2.get("Off");
    this.uncheckedAppearance = o2 instanceof BaseStream ? o2 : null;
    this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e2, "check");
    this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
    this._fallbackFontDict = this.fallbackFontDict;
    null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
  }
  _processRadioButton(e2) {
    this.data.buttonValue = null;
    const t2 = e2.dict.get("Parent");
    if (t2 instanceof Dict) {
      this.parent = e2.dict.getRaw("Parent");
      const a3 = t2.get("V");
      a3 instanceof Name && (this.data.fieldValue = this._decodeFormValue(a3));
    }
    const a2 = e2.dict.get("AP");
    if (!(a2 instanceof Dict)) return;
    const r2 = a2.get("N");
    if (!(r2 instanceof Dict)) return;
    for (const e3 of r2.getKeys()) if ("Off" !== e3) {
      this.data.buttonValue = this._decodeFormValue(e3);
      break;
    }
    const i2 = r2.get(this.data.buttonValue);
    this.checkedAppearance = i2 instanceof BaseStream ? i2 : null;
    const n2 = r2.get("Off");
    this.uncheckedAppearance = n2 instanceof BaseStream ? n2 : null;
    this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e2, "disc");
    this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
    this._fallbackFontDict = this.fallbackFontDict;
    null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
  }
  _processPushButton(e2) {
    const { dict: t2, annotationGlobals: a2 } = e2;
    if (t2.has("A") || t2.has("AA") || this.data.alternativeText) {
      this.data.isTooltipOnly = !t2.has("A") && !t2.has("AA");
      Catalog.parseDestDictionary({ destDict: t2, resultObj: this.data, docBaseUrl: a2.baseUrl, docAttachments: a2.attachments });
    } else warn("Push buttons without action dictionaries are not supported");
  }
  getFieldObject() {
    let e2, t2 = "button";
    if (this.data.checkBox) {
      t2 = "checkbox";
      e2 = this.data.exportValue;
    } else if (this.data.radioButton) {
      t2 = "radiobutton";
      e2 = this.data.buttonValue;
    }
    return { id: this.data.id, value: this.data.fieldValue || "Off", defaultValue: this.data.defaultFieldValue, exportValues: e2, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: t2 };
  }
  get fallbackFontDict() {
    const e2 = new Dict();
    e2.setIfName("BaseFont", "ZapfDingbats");
    e2.setIfName("Type", "FallbackType");
    e2.setIfName("Subtype", "FallbackType");
    e2.setIfName("Encoding", "ZapfDingbatsEncoding");
    return shadow(this, "fallbackFontDict", e2);
  }
};
var ChoiceWidgetAnnotation = class extends WidgetAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2 } = e2;
    this.indices = t2.getArray("I");
    this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
    this.data.options = [];
    const r2 = getInheritableProperty({ dict: t2, key: "Opt" });
    if (Array.isArray(r2)) for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) {
      const t4 = a2.fetchIfRef(r2[e3]), i2 = Array.isArray(t4);
      this.data.options[e3] = { exportValue: this._decodeFormValue(i2 ? a2.fetchIfRef(t4[0]) : t4), displayValue: this._decodeFormValue(i2 ? a2.fetchIfRef(t4[1]) : t4) };
    }
    if (this.hasIndices) {
      this.data.fieldValue = [];
      const e3 = this.data.options.length;
      for (const t3 of this.indices) Number.isInteger(t3) && t3 >= 0 && t3 < e3 && this.data.fieldValue.push(this.data.options[t3].exportValue);
    } else "string" == typeof this.data.fieldValue ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue ||= [];
    0 === this.data.options.length && this.data.fieldValue.length > 0 && (this.data.options = this.data.fieldValue.map(((e3) => ({ exportValue: e3, displayValue: e3 }))));
    this.data.combo = this.hasFieldFlag(ce);
    this.data.multiSelect = this.hasFieldFlag(he);
    this._hasText = true;
  }
  getFieldObject() {
    const e2 = this.data.combo ? "combobox" : "listbox", t2 = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    return { id: this.data.id, value: t2, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: e2 };
  }
  amendSavedDict(e2, t2) {
    if (!this.hasIndices) return;
    let a2 = e2?.get(this.data.id)?.value;
    Array.isArray(a2) || (a2 = [a2]);
    const r2 = [], { options: i2 } = this.data;
    for (let e3 = 0, t3 = 0, n2 = i2.length; e3 < n2; e3++) if (i2[e3].exportValue === a2[t3]) {
      r2.push(e3);
      t3 += 1;
    }
    t2.set("I", r2);
  }
  async _getAppearance(e2, t2, r2, i2) {
    if (this.data.combo) return super._getAppearance(e2, t2, r2, i2);
    let n2, s2;
    const o2 = i2?.get(this.data.id);
    if (o2) {
      s2 = o2.rotation;
      n2 = o2.value;
    }
    if (void 0 === s2 && void 0 === n2 && !this._needAppearances) return null;
    void 0 === n2 ? n2 = this.data.fieldValue : Array.isArray(n2) || (n2 = [n2]);
    let { width: c2, height: l2 } = this;
    90 !== s2 && 270 !== s2 || ([c2, l2] = [l2, c2]);
    const h2 = this.data.options.length, u2 = [];
    for (let e3 = 0; e3 < h2; e3++) {
      const { exportValue: t3 } = this.data.options[e3];
      n2.includes(t3) && u2.push(e3);
    }
    this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    const d2 = await WidgetAnnotation._getFontData(e2, t2, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    let f2, { fontSize: g2 } = this.data.defaultAppearanceData;
    if (g2) f2 = this._defaultAppearance;
    else {
      const e3 = (l2 - 1) / h2;
      let t3, a2 = -1;
      for (const { displayValue: e4 } of this.data.options) {
        const r3 = this._getTextWidth(e4, d2);
        if (r3 > a2) {
          a2 = r3;
          t3 = e4;
        }
      }
      [f2, g2] = this._computeFontSize(e3, c2 - 4, t3, d2, -1);
    }
    const p2 = g2 * a, m2 = (p2 - g2) / 2, b2 = Math.floor(l2 / p2);
    let y2 = 0;
    if (u2.length > 0) {
      const e3 = Math.min(...u2), t3 = Math.max(...u2);
      y2 = Math.max(0, t3 - b2 + 1);
      y2 > e3 && (y2 = e3);
    }
    const w2 = Math.min(y2 + b2 + 1, h2), x2 = ["/Tx BMC q", `1 1 ${c2} ${l2} re W n`];
    if (u2.length) {
      x2.push("0.600006 0.756866 0.854904 rg");
      for (const e3 of u2) y2 <= e3 && e3 < w2 && x2.push(`1 ${l2 - (e3 - y2 + 1) * p2} ${c2} ${p2} re f`);
    }
    x2.push("BT", f2, `1 0 0 1 0 ${l2} Tm`);
    const S2 = { shift: 0 };
    for (let e3 = y2; e3 < w2; e3++) {
      const { displayValue: t3 } = this.data.options[e3], a2 = e3 === y2 ? m2 : 0;
      x2.push(this._renderText(t3, d2, g2, c2, 0, S2, 2, -p2 + a2));
    }
    x2.push("ET Q EMC");
    return x2.join("\n");
  }
};
var SignatureWidgetAnnotation = class extends WidgetAnnotation {
  constructor(e2) {
    super(e2);
    this.data.fieldValue = null;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = !this.data.hasOwnCanvas;
  }
  getFieldObject() {
    return { id: this.data.id, value: null, page: this.data.pageIndex, type: "signature" };
  }
};
var TextAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    this.data.noRotate = true;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    const { dict: t2 } = e2;
    this.data.annotationType = F;
    if (this.data.hasAppearance) this.data.name = "NoIcon";
    else {
      this.data.rect[1] = this.data.rect[3] - 22;
      this.data.rect[2] = this.data.rect[0] + 22;
      this.data.name = t2.has("Name") ? t2.get("Name").name : "Note";
    }
    if (t2.has("State")) {
      this.data.state = t2.get("State") || null;
      this.data.stateModel = t2.get("StateModel") || null;
    } else {
      this.data.state = null;
      this.data.stateModel = null;
    }
  }
};
var LinkAnnotation = class extends Annotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, annotationGlobals: a2 } = e2;
    this.data.annotationType = T;
    this.data.noHTML = false;
    const r2 = getQuadPoints(t2, this.rectangle);
    r2 && (this.data.quadPoints = r2);
    this.data.borderColor ||= this.data.color;
    Catalog.parseDestDictionary({ destDict: t2, resultObj: this.data, docBaseUrl: a2.baseUrl, docAttachments: a2.attachments });
  }
  get overlaysTextContent() {
    return true;
  }
};
var PopupAnnotation = class extends Annotation {
  constructor(e2) {
    super(e2);
    const { dict: t2 } = e2;
    this.data.annotationType = W;
    this.data.noHTML = false;
    0 !== this.width && 0 !== this.height || (this.data.rect = null);
    let a2 = t2.get("Parent");
    if (!a2) {
      warn("Popup annotation has a missing or invalid parent annotation.");
      return;
    }
    this.data.parentRect = lookupNormalRect(a2.getArray("Rect"), null);
    this.data.creationDate = a2.get("CreationDate") || "";
    isName(a2.get("RT"), G) && (a2 = a2.get("IRT"));
    if (a2.has("M")) {
      this.setModificationDate(a2.get("M"));
      this.data.modificationDate = this.modificationDate;
    } else this.data.modificationDate = null;
    if (a2.has("C")) {
      this.setColor(a2.getArray("C"));
      this.data.color = this.color;
    } else this.data.color = null;
    if (!this.viewable) {
      const e3 = a2.get("F");
      this._isViewable(e3) && this.setFlags(e3);
    }
    this.setTitle(a2.get("T"));
    this.data.titleObj = this._title;
    this.setContents(a2.get("Contents"));
    this.data.contentsObj = this._contents;
    a2.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(a2.get("RC")));
    this.data.open = !!t2.get("Open");
  }
  static createNewDict(e2, t2, a2) {
    const { oldAnnotation: r2, rect: i2, parent: n2 } = e2, s2 = r2 || new Dict(t2);
    s2.setIfNotExists("Type", Name.get("Annot"));
    s2.setIfNotExists("Subtype", Name.get("Popup"));
    s2.setIfNotExists("Open", false);
    s2.setIfArray("Rect", i2);
    s2.set("Parent", n2);
    return s2;
  }
  static async createNewAppearanceStream(e2, t2, a2) {
    return null;
  }
};
var FreeTextAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.isEditable = !this.data.noHTML;
    this.data.noHTML = false;
    const { annotationGlobals: t2, evaluatorOptions: a2, xref: r2 } = e2;
    this.data.annotationType = O;
    this.setDefaultAppearance(e2);
    this._hasAppearance = !!this.appearance;
    if (this._hasAppearance) {
      const { fontColor: e3, fontSize: i2 } = (function parseAppearanceStream(e4, t3, a3, r3) {
        return new AppearanceStreamEvaluator(e4, t3, a3, r3).parse();
      })(this.appearance, a2, r2, t2.globalColorSpaceCache);
      this.data.defaultAppearanceData.fontColor = e3;
      this.data.defaultAppearanceData.fontSize = i2 || 10;
    } else {
      this.data.defaultAppearanceData.fontSize ||= 10;
      const { fontColor: t3, fontSize: a3 } = this.data.defaultAppearanceData;
      if (this._contents.str) {
        this.data.textContent = this._contents.str.split(/\r\n?|\n/).map(((e4) => e4.trimEnd()));
        const { coords: e3, bbox: t4, matrix: r3 } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, a3);
        this.data.textPosition = this._transformPoint(e3, t4, r3);
      }
      if (this._isOffscreenCanvasSupported) {
        const i2 = e2.dict.get("CA"), n2 = new FakeUnicodeFont(r2, "sans-serif");
        this.appearance = n2.createAppearance(this._contents.str, this.rectangle, this.rotation, a3, t3, i2);
        this._streams.push(this.appearance);
      } else warn("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
    }
  }
  get hasTextContent() {
    return this._hasAppearance;
  }
  static createNewDict(e2, t2, { apRef: a2, ap: r2 }) {
    const { color: i2, date: n2, fontSize: s2, oldAnnotation: o2, rect: c2, rotation: l2, user: h2, value: u2 } = e2, d2 = o2 || new Dict(t2);
    d2.setIfNotExists("Type", Name.get("Annot"));
    d2.setIfNotExists("Subtype", Name.get("FreeText"));
    d2.set(o2 ? "M" : "CreationDate", `D:${getModificationDate(n2)}`);
    o2 && d2.delete("RC");
    d2.setIfArray("Rect", c2);
    const f2 = `/Helv ${s2} Tf ${getPdfColor(i2, true)}`;
    d2.set("DA", f2);
    d2.setIfDefined("Contents", stringToAsciiOrUTF16BE(u2));
    d2.setIfNotExists("F", 4);
    d2.setIfNotExists("Border", [0, 0, 0]);
    d2.setIfNumber("Rotate", l2);
    d2.setIfDefined("T", stringToAsciiOrUTF16BE(h2));
    if (a2 || r2) {
      const e3 = new Dict(t2);
      d2.set("AP", e3);
      e3.set("N", a2 || r2);
    }
    return d2;
  }
  static async createNewAppearanceStream(e2, t2, r2) {
    const { baseFontRef: i2, evaluator: n2, task: s2 } = r2, { color: o2, fontSize: c2, rect: l2, rotation: h2, value: u2 } = e2;
    if (!o2) return null;
    const d2 = new Dict(t2), f2 = new Dict(t2);
    if (i2) f2.set("Helv", i2);
    else {
      const e3 = new Dict(t2);
      e3.setIfName("BaseFont", "Helvetica");
      e3.setIfName("Type", "Font");
      e3.setIfName("Subtype", "Type1");
      e3.setIfName("Encoding", "WinAnsiEncoding");
      f2.set("Helv", e3);
    }
    d2.set("Font", f2);
    const g2 = await WidgetAnnotation._getFontData(n2, s2, { fontName: "Helv", fontSize: c2 }, d2), [p2, m2, b2, y2] = l2;
    let w2 = b2 - p2, x2 = y2 - m2;
    h2 % 180 != 0 && ([w2, x2] = [x2, w2]);
    const S2 = u2.split("\n"), k2 = c2 / 1e3;
    let C2 = -1 / 0;
    const v2 = [];
    for (let e3 of S2) {
      const t3 = g2.encodeString(e3);
      if (t3.length > 1) return null;
      e3 = t3.join("");
      v2.push(e3);
      let a2 = 0;
      const r3 = g2.charsToGlyphs(e3);
      for (const e4 of r3) a2 += e4.width * k2;
      C2 = Math.max(C2, a2);
    }
    let F2 = 1;
    C2 > w2 && (F2 = w2 / C2);
    let T2 = 1;
    const O2 = a * c2, M2 = 1 * c2, D2 = O2 * S2.length;
    D2 > x2 && (T2 = x2 / D2);
    const R2 = c2 * Math.min(F2, T2);
    let N2, E2, L2;
    switch (h2) {
      case 0:
        L2 = [1, 0, 0, 1];
        E2 = [l2[0], l2[1], w2, x2];
        N2 = [l2[0], l2[3] - M2];
        break;
      case 90:
        L2 = [0, 1, -1, 0];
        E2 = [l2[1], -l2[2], w2, x2];
        N2 = [l2[1], -l2[0] - M2];
        break;
      case 180:
        L2 = [-1, 0, 0, -1];
        E2 = [-l2[2], -l2[3], w2, x2];
        N2 = [-l2[2], -l2[1] - M2];
        break;
      case 270:
        L2 = [0, -1, 1, 0];
        E2 = [-l2[3], l2[0], w2, x2];
        N2 = [-l2[3], l2[2] - M2];
    }
    const j2 = ["q", `${L2.join(" ")} 0 0 cm`, `${E2.join(" ")} re W n`, "BT", `${getPdfColor(o2, true)}`, `0 Tc /Helv ${numberToString(R2)} Tf`];
    j2.push(`${N2.join(" ")} Td (${escapeString(v2[0])}) Tj`);
    const _2 = numberToString(O2);
    for (let e3 = 1, t3 = v2.length; e3 < t3; e3++) {
      const t4 = v2[e3];
      j2.push(`0 -${_2} Td (${escapeString(t4)}) Tj`);
    }
    j2.push("ET", "Q");
    const U2 = j2.join("\n"), X2 = new Dict(t2);
    X2.set("FormType", 1);
    X2.setIfName("Subtype", "Form");
    X2.setIfName("Type", "XObject");
    X2.set("BBox", l2);
    X2.set("Resources", d2);
    X2.set("Matrix", [1, 0, 0, 1, -l2[0], -l2[1]]);
    const q2 = new StringStream(U2);
    q2.dict = X2;
    return q2;
  }
};
var LineAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2 } = e2;
    this.data.annotationType = M;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    const r2 = lookupRect(t2.getArray("L"), [0, 0, 0, 0]);
    this.data.lineCoordinates = Util.normalizeRect(r2);
    this.setLineEndings(t2.getArray("LE"));
    this.data.lineEndings = this.lineEndings;
    if (!this.appearance) {
      const e3 = getPdfColorArray(this.color, [0, 0, 0]), i2 = t2.get("CA"), n2 = getPdfColorArray(getRgbColor(t2.getArray("IC"), null)), s2 = n2 ? i2 : null, o2 = this.borderStyle.width || 1, c2 = 2 * o2, l2 = [this.data.lineCoordinates[0] - c2, this.data.lineCoordinates[1] - c2, this.data.lineCoordinates[2] + c2, this.data.lineCoordinates[3] + c2];
      Util.intersect(this.rectangle, l2) || (this.rectangle = l2);
      this._setDefaultAppearance({ xref: a2, extra: `${o2} w`, strokeColor: e3, fillColor: n2, strokeAlpha: i2, fillAlpha: s2, pointsCallback: (e4, t3) => {
        e4.push(`${r2[0]} ${r2[1]} m`, `${r2[2]} ${r2[3]} l`, "S");
        return [t3[0] - o2, t3[7] - o2, t3[2] + o2, t3[3] + o2];
      } });
    }
  }
};
var SquareAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2 } = e2;
    this.data.annotationType = D;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    if (!this.appearance) {
      const e3 = getPdfColorArray(this.color, [0, 0, 0]), r2 = t2.get("CA"), i2 = getPdfColorArray(getRgbColor(t2.getArray("IC"), null)), n2 = i2 ? r2 : null;
      if (0 === this.borderStyle.width && !i2) return;
      this._setDefaultAppearance({ xref: a2, extra: `${this.borderStyle.width} w`, strokeColor: e3, fillColor: i2, strokeAlpha: r2, fillAlpha: n2, pointsCallback: (e4, t3) => {
        const a3 = t3[4] + this.borderStyle.width / 2, r3 = t3[5] + this.borderStyle.width / 2, n3 = t3[6] - t3[4] - this.borderStyle.width, s2 = t3[3] - t3[7] - this.borderStyle.width;
        e4.push(`${a3} ${r3} ${n3} ${s2} re`);
        i2 ? e4.push("B") : e4.push("S");
        return [t3[0], t3[7], t3[2], t3[3]];
      } });
    }
  }
};
var CircleAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2 } = e2;
    this.data.annotationType = R;
    if (!this.appearance) {
      const e3 = getPdfColorArray(this.color, [0, 0, 0]), r2 = t2.get("CA"), i2 = getPdfColorArray(getRgbColor(t2.getArray("IC"), null)), n2 = i2 ? r2 : null;
      if (0 === this.borderStyle.width && !i2) return;
      const s2 = 4 / 3 * Math.tan(Math.PI / 8);
      this._setDefaultAppearance({ xref: a2, extra: `${this.borderStyle.width} w`, strokeColor: e3, fillColor: i2, strokeAlpha: r2, fillAlpha: n2, pointsCallback: (e4, t3) => {
        const a3 = t3[0] + this.borderStyle.width / 2, r3 = t3[1] - this.borderStyle.width / 2, n3 = t3[6] - this.borderStyle.width / 2, o2 = t3[7] + this.borderStyle.width / 2, c2 = a3 + (n3 - a3) / 2, l2 = r3 + (o2 - r3) / 2, h2 = (n3 - a3) / 2 * s2, u2 = (o2 - r3) / 2 * s2;
        e4.push(`${c2} ${o2} m`, `${c2 + h2} ${o2} ${n3} ${l2 + u2} ${n3} ${l2} c`, `${n3} ${l2 - u2} ${c2 + h2} ${r3} ${c2} ${r3} c`, `${c2 - h2} ${r3} ${a3} ${l2 - u2} ${a3} ${l2} c`, `${a3} ${l2 + u2} ${c2 - h2} ${o2} ${c2} ${o2} c`, "h");
        i2 ? e4.push("B") : e4.push("S");
        return [t3[0], t3[7], t3[2], t3[3]];
      } });
    }
  }
};
var PolylineAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2 } = e2;
    this.data.annotationType = E;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    this.data.vertices = null;
    if (!(this instanceof PolygonAnnotation)) {
      this.setLineEndings(t2.getArray("LE"));
      this.data.lineEndings = this.lineEndings;
    }
    const r2 = t2.getArray("Vertices");
    if (!isNumberArray(r2, null)) return;
    const i2 = this.data.vertices = Float32Array.from(r2);
    if (!this.appearance) {
      const e3 = getPdfColorArray(this.color, [0, 0, 0]), r3 = t2.get("CA");
      let n2, s2 = getRgbColor(t2.getArray("IC"), null);
      s2 && (s2 = getPdfColorArray(s2));
      n2 = s2 ? this.color ? s2.every(((t3, a3) => t3 === e3[a3])) ? "f" : "B" : "f" : "S";
      const o2 = this.borderStyle.width || 1, c2 = 2 * o2, l2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let e4 = 0, t3 = i2.length; e4 < t3; e4 += 2) Util.rectBoundingBox(i2[e4] - c2, i2[e4 + 1] - c2, i2[e4] + c2, i2[e4 + 1] + c2, l2);
      Util.intersect(this.rectangle, l2) || (this.rectangle = l2);
      this._setDefaultAppearance({ xref: a2, extra: `${o2} w`, strokeColor: e3, strokeAlpha: r3, fillColor: s2, fillAlpha: s2 ? r3 : null, pointsCallback: (e4, t3) => {
        for (let t4 = 0, a3 = i2.length; t4 < a3; t4 += 2) e4.push(`${i2[t4]} ${i2[t4 + 1]} ${0 === t4 ? "m" : "l"}`);
        e4.push(n2);
        return [t3[0], t3[7], t3[2], t3[3]];
      } });
    }
  }
};
var PolygonAnnotation = class extends PolylineAnnotation {
  constructor(e2) {
    super(e2);
    this.data.annotationType = N;
  }
};
var CaretAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    this.data.annotationType = q;
  }
};
var InkAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    const { dict: t2, xref: a2 } = e2;
    this.data.annotationType = H;
    this.data.inkLists = [];
    this.data.isEditable = !this.data.noHTML;
    this.data.noHTML = false;
    this.data.opacity = t2.get("CA") || 1;
    const r2 = t2.getArray("InkList");
    if (Array.isArray(r2)) {
      for (let e3 = 0, t3 = r2.length; e3 < t3; ++e3) {
        if (!Array.isArray(r2[e3])) continue;
        const t4 = new Float32Array(r2[e3].length);
        this.data.inkLists.push(t4);
        for (let i2 = 0, n2 = r2[e3].length; i2 < n2; i2 += 2) {
          const n3 = a2.fetchIfRef(r2[e3][i2]), s2 = a2.fetchIfRef(r2[e3][i2 + 1]);
          if ("number" == typeof n3 && "number" == typeof s2) {
            t4[i2] = n3;
            t4[i2 + 1] = s2;
          }
        }
      }
      if (!this.appearance) {
        const e3 = getPdfColorArray(this.color, [0, 0, 0]), r3 = t2.get("CA"), i2 = this.borderStyle.width || 1, n2 = 2 * i2, s2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const e4 of this.data.inkLists) for (let t3 = 0, a3 = e4.length; t3 < a3; t3 += 2) Util.rectBoundingBox(e4[t3] - n2, e4[t3 + 1] - n2, e4[t3] + n2, e4[t3 + 1] + n2, s2);
        Util.intersect(this.rectangle, s2) || (this.rectangle = s2);
        this._setDefaultAppearance({ xref: a2, extra: `${i2} w`, strokeColor: e3, strokeAlpha: r3, pointsCallback: (e4, t3) => {
          for (const t4 of this.data.inkLists) {
            for (let a3 = 0, r4 = t4.length; a3 < r4; a3 += 2) e4.push(`${t4[a3]} ${t4[a3 + 1]} ${0 === a3 ? "m" : "l"}`);
            e4.push("S");
          }
          return [t3[0], t3[7], t3[2], t3[3]];
        } });
      }
    }
  }
  static createNewDict(e2, t2, { apRef: a2, ap: r2 }) {
    const { oldAnnotation: i2, color: n2, date: s2, opacity: o2, paths: c2, outlines: l2, rect: h2, rotation: u2, thickness: d2, user: f2 } = e2, g2 = i2 || new Dict(t2);
    g2.setIfNotExists("Type", Name.get("Annot"));
    g2.setIfNotExists("Subtype", Name.get("Ink"));
    g2.set(i2 ? "M" : "CreationDate", `D:${getModificationDate(s2)}`);
    g2.setIfArray("Rect", h2);
    g2.setIfArray("InkList", l2?.points || c2?.points);
    g2.setIfNotExists("F", 4);
    g2.setIfNumber("Rotate", u2);
    g2.setIfDefined("T", stringToAsciiOrUTF16BE(f2));
    l2 && g2.setIfName("IT", "InkHighlight");
    if (d2 > 0) {
      const e3 = new Dict(t2);
      g2.set("BS", e3);
      e3.set("W", d2);
    }
    g2.setIfArray("C", getPdfColorArray(n2));
    g2.setIfNumber("CA", o2);
    if (r2 || a2) {
      const e3 = new Dict(t2);
      g2.set("AP", e3);
      e3.set("N", a2 || r2);
    }
    return g2;
  }
  static async createNewAppearanceStream(e2, t2, a2) {
    if (e2.outlines) return this.createNewAppearanceStreamForHighlight(e2, t2, a2);
    const { color: r2, rect: i2, paths: n2, thickness: s2, opacity: o2 } = e2;
    if (!r2) return null;
    const c2 = [`${s2} w 1 J 1 j`, `${getPdfColor(r2, false)}`];
    1 !== o2 && c2.push("/R0 gs");
    for (const e3 of n2.lines) {
      c2.push(`${numberToString(e3[4])} ${numberToString(e3[5])} m`);
      for (let t3 = 6, a3 = e3.length; t3 < a3; t3 += 6) if (isNaN(e3[t3])) c2.push(`${numberToString(e3[t3 + 4])} ${numberToString(e3[t3 + 5])} l`);
      else {
        const [a4, r3, i3, n3, s3, o3] = e3.slice(t3, t3 + 6);
        c2.push([a4, r3, i3, n3, s3, o3].map(numberToString).join(" ") + " c");
      }
      6 === e3.length && c2.push(`${numberToString(e3[4])} ${numberToString(e3[5])} l`);
    }
    c2.push("S");
    const l2 = c2.join("\n"), h2 = new Dict(t2);
    h2.set("FormType", 1);
    h2.setIfName("Subtype", "Form");
    h2.setIfName("Type", "XObject");
    h2.set("BBox", i2);
    h2.set("Length", l2.length);
    if (1 !== o2) {
      const e3 = new Dict(t2), a3 = new Dict(t2), r3 = new Dict(t2);
      r3.set("CA", o2);
      r3.setIfName("Type", "ExtGState");
      a3.set("R0", r3);
      e3.set("ExtGState", a3);
      h2.set("Resources", e3);
    }
    const u2 = new StringStream(l2);
    u2.dict = h2;
    return u2;
  }
  static async createNewAppearanceStreamForHighlight(e2, t2, a2) {
    const { color: r2, rect: i2, outlines: { outline: n2 }, opacity: s2 } = e2;
    if (!r2) return null;
    const o2 = [`${getPdfColor(r2, true)}`, "/R0 gs"];
    o2.push(`${numberToString(n2[4])} ${numberToString(n2[5])} m`);
    for (let e3 = 6, t3 = n2.length; e3 < t3; e3 += 6) if (isNaN(n2[e3])) o2.push(`${numberToString(n2[e3 + 4])} ${numberToString(n2[e3 + 5])} l`);
    else {
      const [t4, a3, r3, i3, s3, c3] = n2.slice(e3, e3 + 6);
      o2.push([t4, a3, r3, i3, s3, c3].map(numberToString).join(" ") + " c");
    }
    o2.push("h f");
    const c2 = o2.join("\n"), l2 = new Dict(t2);
    l2.set("FormType", 1);
    l2.setIfName("Subtype", "Form");
    l2.setIfName("Type", "XObject");
    l2.set("BBox", i2);
    l2.set("Length", c2.length);
    const h2 = new Dict(t2), u2 = new Dict(t2);
    h2.set("ExtGState", u2);
    l2.set("Resources", h2);
    const d2 = new Dict(t2);
    u2.set("R0", d2);
    d2.setIfName("BM", "Multiply");
    if (1 !== s2) {
      d2.set("ca", s2);
      d2.setIfName("Type", "ExtGState");
    }
    const f2 = new StringStream(c2);
    f2.dict = l2;
    return f2;
  }
};
var HighlightAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2 } = e2;
    this.data.annotationType = L;
    this.data.isEditable = !this.data.noHTML;
    this.data.noHTML = false;
    this.data.opacity = t2.get("CA") || 1;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      const e3 = this.appearance?.dict.get("Resources");
      if (!this.appearance || !e3?.has("ExtGState")) {
        this.appearance && warn("HighlightAnnotation - ignoring built-in appearance stream.");
        const e4 = getPdfColorArray(this.color, [1, 1, 0]), r2 = t2.get("CA");
        this._setDefaultAppearance({ xref: a2, fillColor: e4, blendMode: "Multiply", fillAlpha: r2, pointsCallback: (e5, t3) => {
          e5.push(`${t3[0]} ${t3[1]} m`, `${t3[2]} ${t3[3]} l`, `${t3[6]} ${t3[7]} l`, `${t3[4]} ${t3[5]} l`, "f");
          return [t3[0], t3[7], t3[2], t3[3]];
        } });
      }
    } else this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return true;
  }
  static createNewDict(e2, t2, { apRef: a2, ap: r2 }) {
    const { color: i2, date: n2, oldAnnotation: s2, opacity: o2, rect: c2, rotation: l2, user: h2, quadPoints: u2 } = e2, d2 = s2 || new Dict(t2);
    d2.setIfNotExists("Type", Name.get("Annot"));
    d2.setIfNotExists("Subtype", Name.get("Highlight"));
    d2.set(s2 ? "M" : "CreationDate", `D:${getModificationDate(n2)}`);
    d2.setIfArray("Rect", c2);
    d2.setIfNotExists("F", 4);
    d2.setIfNotExists("Border", [0, 0, 0]);
    d2.setIfNumber("Rotate", l2);
    d2.setIfArray("QuadPoints", u2);
    d2.setIfArray("C", getPdfColorArray(i2));
    d2.setIfNumber("CA", o2);
    d2.setIfDefined("T", stringToAsciiOrUTF16BE(h2));
    if (a2 || r2) {
      const e3 = new Dict(t2);
      d2.set("AP", e3);
      e3.set("N", a2 || r2);
    }
    return d2;
  }
  static async createNewAppearanceStream(e2, t2, a2) {
    const { color: r2, rect: i2, outlines: n2, opacity: s2 } = e2;
    if (!r2) return null;
    const o2 = [`${getPdfColor(r2, true)}`, "/R0 gs"], c2 = [];
    for (const e3 of n2) {
      c2.length = 0;
      c2.push(`${numberToString(e3[0])} ${numberToString(e3[1])} m`);
      for (let t3 = 2, a3 = e3.length; t3 < a3; t3 += 2) c2.push(`${numberToString(e3[t3])} ${numberToString(e3[t3 + 1])} l`);
      c2.push("h");
      o2.push(c2.join("\n"));
    }
    o2.push("f*");
    const l2 = o2.join("\n"), h2 = new Dict(t2);
    h2.set("FormType", 1);
    h2.setIfName("Subtype", "Form");
    h2.setIfName("Type", "XObject");
    h2.set("BBox", i2);
    h2.set("Length", l2.length);
    const u2 = new Dict(t2), d2 = new Dict(t2);
    u2.set("ExtGState", d2);
    h2.set("Resources", u2);
    const f2 = new Dict(t2);
    d2.set("R0", f2);
    f2.setIfName("BM", "Multiply");
    if (1 !== s2) {
      f2.set("ca", s2);
      f2.setIfName("Type", "ExtGState");
    }
    const g2 = new StringStream(l2);
    g2.dict = h2;
    return g2;
  }
};
var UnderlineAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2 } = e2;
    this.data.annotationType = j;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      if (!this.appearance) {
        const e3 = getPdfColorArray(this.color, [0, 0, 0]), r2 = t2.get("CA");
        this._setDefaultAppearance({ xref: a2, extra: "[] 0 d 0.571 w", strokeColor: e3, strokeAlpha: r2, pointsCallback: (e4, t3) => {
          e4.push(`${t3[4]} ${t3[5] + 1.3} m`, `${t3[6]} ${t3[7] + 1.3} l`, "S");
          return [t3[0], t3[7], t3[2], t3[3]];
        } });
      }
    } else this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return true;
  }
};
var SquigglyAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2 } = e2;
    this.data.annotationType = _;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      if (!this.appearance) {
        const e3 = getPdfColorArray(this.color, [0, 0, 0]), r2 = t2.get("CA");
        this._setDefaultAppearance({ xref: a2, extra: "[] 0 d 1 w", strokeColor: e3, strokeAlpha: r2, pointsCallback: (e4, t3) => {
          const a3 = (t3[1] - t3[5]) / 6;
          let r3 = a3, i2 = t3[4];
          const n2 = t3[5], s2 = t3[6];
          e4.push(`${i2} ${n2 + r3} m`);
          do {
            i2 += 2;
            r3 = 0 === r3 ? a3 : 0;
            e4.push(`${i2} ${n2 + r3} l`);
          } while (i2 < s2);
          e4.push("S");
          return [t3[4], n2 - 2 * a3, s2, n2 + 2 * a3];
        } });
      }
    } else this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return true;
  }
};
var StrikeOutAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2 } = e2;
    this.data.annotationType = U;
    if (this.data.quadPoints = getQuadPoints(t2, null)) {
      if (!this.appearance) {
        const e3 = getPdfColorArray(this.color, [0, 0, 0]), r2 = t2.get("CA");
        this._setDefaultAppearance({ xref: a2, extra: "[] 0 d 1 w", strokeColor: e3, strokeAlpha: r2, pointsCallback: (e4, t3) => {
          e4.push((t3[0] + t3[4]) / 2 + " " + (t3[1] + t3[5]) / 2 + " m", (t3[2] + t3[6]) / 2 + " " + (t3[3] + t3[7]) / 2 + " l", "S");
          return [t3[0], t3[7], t3[2], t3[3]];
        } });
      }
    } else this.data.popupRef = null;
  }
  get overlaysTextContent() {
    return true;
  }
};
var StampAnnotation = class extends MarkupAnnotation {
  #pe = null;
  constructor(e2) {
    super(e2);
    this.data.annotationType = X;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.isEditable = !this.data.noHTML;
    this.data.noHTML = false;
  }
  mustBeViewedWhenEditing(e2, t2 = null) {
    if (e2) {
      if (!this.data.isEditable) return true;
      this.#pe ??= this.data.hasOwnCanvas;
      this.data.hasOwnCanvas = true;
      return true;
    }
    if (null !== this.#pe) {
      this.data.hasOwnCanvas = this.#pe;
      this.#pe = null;
    }
    return !t2?.has(this.data.id);
  }
  static async createImage(e2, t2) {
    const { width: a2, height: r2 } = e2, i2 = new OffscreenCanvas(a2, r2), n2 = i2.getContext("2d", { alpha: true });
    n2.drawImage(e2, 0, 0);
    const s2 = n2.getImageData(0, 0, a2, r2).data, o2 = new Uint32Array(s2.buffer), c2 = o2.some(FeatureTest.isLittleEndian ? (e3) => e3 >>> 24 != 255 : (e3) => !!(255 & ~e3));
    if (c2) {
      n2.fillStyle = "white";
      n2.fillRect(0, 0, a2, r2);
      n2.drawImage(e2, 0, 0);
    }
    const l2 = i2.convertToBlob({ type: "image/jpeg", quality: 1 }).then(((e3) => e3.arrayBuffer())), h2 = Name.get("XObject"), u2 = Name.get("Image"), d2 = new Dict(t2);
    d2.set("Type", h2);
    d2.set("Subtype", u2);
    d2.set("BitsPerComponent", 8);
    d2.setIfName("ColorSpace", "DeviceRGB");
    d2.setIfName("Filter", "DCTDecode");
    d2.set("BBox", [0, 0, a2, r2]);
    d2.set("Width", a2);
    d2.set("Height", r2);
    let f2 = null;
    if (c2) {
      const e3 = new Uint8Array(o2.length);
      if (FeatureTest.isLittleEndian) for (let t3 = 0, a3 = o2.length; t3 < a3; t3++) e3[t3] = o2[t3] >>> 24;
      else for (let t3 = 0, a3 = o2.length; t3 < a3; t3++) e3[t3] = 255 & o2[t3];
      const i3 = new Dict(t2);
      i3.set("Type", h2);
      i3.set("Subtype", u2);
      i3.set("BitsPerComponent", 8);
      i3.setIfName("ColorSpace", "DeviceGray");
      i3.set("Width", a2);
      i3.set("Height", r2);
      f2 = new Stream(e3, 0, 0, i3);
    }
    return { imageStream: new Stream(await l2, 0, 0, d2), smaskStream: f2, width: a2, height: r2 };
  }
  static createNewDict(e2, t2, { apRef: a2, ap: r2 }) {
    const { date: i2, oldAnnotation: n2, rect: s2, rotation: o2, user: c2 } = e2, l2 = n2 || new Dict(t2);
    l2.setIfNotExists("Type", Name.get("Annot"));
    l2.setIfNotExists("Subtype", Name.get("Stamp"));
    l2.set(n2 ? "M" : "CreationDate", `D:${getModificationDate(i2)}`);
    l2.setIfArray("Rect", s2);
    l2.setIfNotExists("F", 4);
    l2.setIfNotExists("Border", [0, 0, 0]);
    l2.setIfNumber("Rotate", o2);
    l2.setIfDefined("T", stringToAsciiOrUTF16BE(c2));
    if (a2 || r2) {
      const e3 = new Dict(t2);
      l2.set("AP", e3);
      e3.set("N", a2 || r2);
    }
    return l2;
  }
  static async #me(e2, t2) {
    const { areContours: a2, color: r2, rect: i2, lines: n2, thickness: s2 } = e2;
    if (!r2) return null;
    const o2 = [`${s2} w 1 J 1 j`, `${getPdfColor(r2, a2)}`];
    for (const e3 of n2) {
      o2.push(`${numberToString(e3[4])} ${numberToString(e3[5])} m`);
      for (let t3 = 6, a3 = e3.length; t3 < a3; t3 += 6) if (isNaN(e3[t3])) o2.push(`${numberToString(e3[t3 + 4])} ${numberToString(e3[t3 + 5])} l`);
      else {
        const [a4, r3, i3, n3, s3, c3] = e3.slice(t3, t3 + 6);
        o2.push([a4, r3, i3, n3, s3, c3].map(numberToString).join(" ") + " c");
      }
      6 === e3.length && o2.push(`${numberToString(e3[4])} ${numberToString(e3[5])} l`);
    }
    o2.push(a2 ? "F" : "S");
    const c2 = o2.join("\n"), l2 = new Dict(t2);
    l2.set("FormType", 1);
    l2.setIfName("Subtype", "Form");
    l2.setIfName("Type", "XObject");
    l2.set("BBox", i2);
    l2.set("Length", c2.length);
    const h2 = new StringStream(c2);
    h2.dict = l2;
    return h2;
  }
  static async createNewAppearanceStream(e2, t2, a2) {
    if (e2.oldAnnotation) return null;
    if (e2.isSignature) return this.#me(e2, t2);
    const { rotation: r2 } = e2, { imageRef: i2, width: n2, height: s2 } = a2.image, o2 = new Dict(t2), c2 = new Dict(t2);
    o2.set("XObject", c2);
    c2.set("Im0", i2);
    const l2 = `q ${n2} 0 0 ${s2} 0 0 cm /Im0 Do Q`, h2 = new Dict(t2);
    h2.set("FormType", 1);
    h2.setIfName("Subtype", "Form");
    h2.setIfName("Type", "XObject");
    h2.set("BBox", [0, 0, n2, s2]);
    h2.set("Resources", o2);
    if (r2) {
      const e3 = getRotationMatrix(r2, n2, s2);
      h2.set("Matrix", e3);
    }
    const u2 = new StringStream(l2);
    u2.dict = h2;
    return u2;
  }
};
var FileAttachmentAnnotation = class extends MarkupAnnotation {
  constructor(e2) {
    super(e2);
    const { dict: t2, xref: a2 } = e2, r2 = new FileSpec(t2.get("FS"), a2);
    this.data.annotationType = z;
    this.data.hasOwnCanvas = this.data.noRotate;
    this.data.noHTML = false;
    this.data.file = r2.serializable;
    const i2 = t2.get("Name");
    this.data.name = i2 instanceof Name ? stringToPDFString(i2.name) : "PushPin";
    const n2 = t2.get("ca");
    this.data.fillAlpha = "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? n2 : null;
  }
};
var pc = { get r() {
  return shadow(this, "r", new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]));
}, get k() {
  return shadow(this, "k", new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]));
} };
function calculateMD5(e2, t2, a2) {
  let r2 = 1732584193, i2 = -271733879, n2 = -1732584194, s2 = 271733878;
  const o2 = a2 + 72 & -64, c2 = new Uint8Array(o2);
  let l2, h2;
  for (l2 = 0; l2 < a2; ++l2) c2[l2] = e2[t2++];
  c2[l2++] = 128;
  const u2 = o2 - 8;
  l2 < u2 && (l2 = u2);
  c2[l2++] = a2 << 3 & 255;
  c2[l2++] = a2 >> 5 & 255;
  c2[l2++] = a2 >> 13 & 255;
  c2[l2++] = a2 >> 21 & 255;
  c2[l2++] = a2 >>> 29 & 255;
  l2 += 3;
  const d2 = new Int32Array(16), { k: f2, r: g2 } = pc;
  for (l2 = 0; l2 < o2; ) {
    for (h2 = 0; h2 < 16; ++h2, l2 += 4) d2[h2] = c2[l2] | c2[l2 + 1] << 8 | c2[l2 + 2] << 16 | c2[l2 + 3] << 24;
    let e3, t3, a3 = r2, o3 = i2, u3 = n2, p2 = s2;
    for (h2 = 0; h2 < 64; ++h2) {
      if (h2 < 16) {
        e3 = o3 & u3 | ~o3 & p2;
        t3 = h2;
      } else if (h2 < 32) {
        e3 = p2 & o3 | ~p2 & u3;
        t3 = 5 * h2 + 1 & 15;
      } else if (h2 < 48) {
        e3 = o3 ^ u3 ^ p2;
        t3 = 3 * h2 + 5 & 15;
      } else {
        e3 = u3 ^ (o3 | ~p2);
        t3 = 7 * h2 & 15;
      }
      const r3 = p2, i3 = a3 + e3 + f2[h2] + d2[t3] | 0, n3 = g2[h2];
      p2 = u3;
      u3 = o3;
      o3 = o3 + (i3 << n3 | i3 >>> 32 - n3) | 0;
      a3 = r3;
    }
    r2 = r2 + a3 | 0;
    i2 = i2 + o3 | 0;
    n2 = n2 + u3 | 0;
    s2 = s2 + p2 | 0;
  }
  return new Uint8Array([255 & r2, r2 >> 8 & 255, r2 >> 16 & 255, r2 >>> 24 & 255, 255 & i2, i2 >> 8 & 255, i2 >> 16 & 255, i2 >>> 24 & 255, 255 & n2, n2 >> 8 & 255, n2 >> 16 & 255, n2 >>> 24 & 255, 255 & s2, s2 >> 8 & 255, s2 >> 16 & 255, s2 >>> 24 & 255]);
}
function decodeString(e2) {
  try {
    return stringToUTF8String(e2);
  } catch (t2) {
    warn(`UTF-8 decoding failed: "${t2}".`);
    return e2;
  }
}
var DatasetXMLParser = class extends SimpleXMLParser {
  constructor(e2) {
    super(e2);
    this.node = null;
  }
  onEndElement(e2) {
    const t2 = super.onEndElement(e2);
    if (t2 && "xfa:datasets" === e2) {
      this.node = t2;
      throw new Error("Aborting DatasetXMLParser.");
    }
  }
};
var DatasetReader = class {
  constructor(e2) {
    if (e2.datasets) this.node = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e2.datasets).documentElement;
    else {
      const t2 = new DatasetXMLParser({ hasAttributes: true });
      try {
        t2.parseFromString(e2["xdp:xdp"]);
      } catch {
      }
      this.node = t2.node;
    }
  }
  getValue(e2) {
    if (!this.node || !e2) return "";
    const t2 = this.node.searchNode(parseXFAPath(e2), 0);
    if (!t2) return "";
    const a2 = t2.firstChild;
    return "value" === a2?.nodeName ? t2.children.map(((e3) => decodeString(e3.textContent))) : decodeString(t2.textContent);
  }
};
var SingleIntersector = class {
  #be;
  #ye = 1 / 0;
  #we = 1 / 0;
  #xe = -1 / 0;
  #Se = -1 / 0;
  #Ae = null;
  #ke = [];
  #Ce = [];
  #ve = -1;
  #Fe = false;
  constructor(e2) {
    this.#be = e2;
    const t2 = e2.data.quadPoints;
    if (t2) {
      for (let e3 = 0, a2 = t2.length; e3 < a2; e3 += 8) {
        this.#ye = Math.min(this.#ye, t2[e3]);
        this.#xe = Math.max(this.#xe, t2[e3 + 2]);
        this.#we = Math.min(this.#we, t2[e3 + 5]);
        this.#Se = Math.max(this.#Se, t2[e3 + 1]);
      }
      t2.length > 8 && (this.#Ae = t2);
    } else [this.#ye, this.#we, this.#xe, this.#Se] = e2.data.rect;
  }
  overlaps(e2) {
    return !(this.#ye >= e2.#xe || this.#xe <= e2.#ye || this.#we >= e2.#Se || this.#Se <= e2.#we);
  }
  #Ie(e2, t2) {
    if (this.#ye >= e2 || this.#xe <= e2 || this.#we >= t2 || this.#Se <= t2) return false;
    const a2 = this.#Ae;
    if (!a2) return true;
    if (this.#ve >= 0) {
      const r2 = this.#ve;
      if (!(a2[r2] >= e2 || a2[r2 + 2] <= e2 || a2[r2 + 5] >= t2 || a2[r2 + 1] <= t2)) return true;
      this.#ve = -1;
    }
    for (let r2 = 0, i2 = a2.length; r2 < i2; r2 += 8) if (!(a2[r2] >= e2 || a2[r2 + 2] <= e2 || a2[r2 + 5] >= t2 || a2[r2 + 1] <= t2)) {
      this.#ve = r2;
      return true;
    }
    return false;
  }
  addGlyph(e2, t2, a2) {
    if (!this.#Ie(e2, t2)) {
      this.disableExtraChars();
      return false;
    }
    if (this.#Ce.length > 0) {
      this.#ke.push(this.#Ce.join(""));
      this.#Ce.length = 0;
    }
    this.#ke.push(a2);
    this.#Fe = true;
    return true;
  }
  addExtraChar(e2) {
    this.#Fe && this.#Ce.push(e2);
  }
  disableExtraChars() {
    if (this.#Fe) {
      this.#Fe = false;
      this.#Ce.length = 0;
    }
  }
  setText() {
    this.#be.data.overlaidText = this.#ke.join("");
  }
};
var Intersector = class {
  #Te = /* @__PURE__ */ new Map();
  constructor(e2) {
    for (const t2 of e2) {
      if (!t2.data.quadPoints && !t2.data.rect) continue;
      const e3 = new SingleIntersector(t2);
      for (const [t3, a2] of this.#Te) t3.overlaps(e3) && (a2 ? a2.add(e3) : this.#Te.set(t3, /* @__PURE__ */ new Set([e3])));
      this.#Te.set(e3, null);
    }
  }
  addGlyph(e2, t2, a2, r2) {
    const i2 = e2[4] + t2 / 2, n2 = e2[5] + a2 / 2;
    let s2;
    for (const [e3, t3] of this.#Te) s2 ? s2.has(e3) ? e3.addGlyph(i2, n2, r2) : e3.disableExtraChars() : e3.addGlyph(i2, n2, r2) && (s2 = t3);
  }
  addExtraChar(e2) {
    for (const t2 of this.#Te.keys()) t2.addExtraChar(e2);
  }
  setText() {
    for (const e2 of this.#Te.keys()) e2.setText();
  }
};
var Word64 = class {
  constructor(e2, t2) {
    this.high = 0 | e2;
    this.low = 0 | t2;
  }
  and(e2) {
    this.high &= e2.high;
    this.low &= e2.low;
  }
  xor(e2) {
    this.high ^= e2.high;
    this.low ^= e2.low;
  }
  shiftRight(e2) {
    if (e2 >= 32) {
      this.low = this.high >>> e2 - 32 | 0;
      this.high = 0;
    } else {
      this.low = this.low >>> e2 | this.high << 32 - e2;
      this.high = this.high >>> e2 | 0;
    }
  }
  rotateRight(e2) {
    let t2, a2;
    if (32 & e2) {
      a2 = this.low;
      t2 = this.high;
    } else {
      t2 = this.low;
      a2 = this.high;
    }
    e2 &= 31;
    this.low = t2 >>> e2 | a2 << 32 - e2;
    this.high = a2 >>> e2 | t2 << 32 - e2;
  }
  not() {
    this.high = ~this.high;
    this.low = ~this.low;
  }
  add(e2) {
    const t2 = (this.low >>> 0) + (e2.low >>> 0);
    let a2 = (this.high >>> 0) + (e2.high >>> 0);
    t2 > 4294967295 && (a2 += 1);
    this.low = 0 | t2;
    this.high = 0 | a2;
  }
  copyTo(e2, t2) {
    e2[t2] = this.high >>> 24 & 255;
    e2[t2 + 1] = this.high >> 16 & 255;
    e2[t2 + 2] = this.high >> 8 & 255;
    e2[t2 + 3] = 255 & this.high;
    e2[t2 + 4] = this.low >>> 24 & 255;
    e2[t2 + 5] = this.low >> 16 & 255;
    e2[t2 + 6] = this.low >> 8 & 255;
    e2[t2 + 7] = 255 & this.low;
  }
  assign(e2) {
    this.high = e2.high;
    this.low = e2.low;
  }
};
var mc = { get k() {
  return shadow(this, "k", [new Word64(1116352408, 3609767458), new Word64(1899447441, 602891725), new Word64(3049323471, 3964484399), new Word64(3921009573, 2173295548), new Word64(961987163, 4081628472), new Word64(1508970993, 3053834265), new Word64(2453635748, 2937671579), new Word64(2870763221, 3664609560), new Word64(3624381080, 2734883394), new Word64(310598401, 1164996542), new Word64(607225278, 1323610764), new Word64(1426881987, 3590304994), new Word64(1925078388, 4068182383), new Word64(2162078206, 991336113), new Word64(2614888103, 633803317), new Word64(3248222580, 3479774868), new Word64(3835390401, 2666613458), new Word64(4022224774, 944711139), new Word64(264347078, 2341262773), new Word64(604807628, 2007800933), new Word64(770255983, 1495990901), new Word64(1249150122, 1856431235), new Word64(1555081692, 3175218132), new Word64(1996064986, 2198950837), new Word64(2554220882, 3999719339), new Word64(2821834349, 766784016), new Word64(2952996808, 2566594879), new Word64(3210313671, 3203337956), new Word64(3336571891, 1034457026), new Word64(3584528711, 2466948901), new Word64(113926993, 3758326383), new Word64(338241895, 168717936), new Word64(666307205, 1188179964), new Word64(773529912, 1546045734), new Word64(1294757372, 1522805485), new Word64(1396182291, 2643833823), new Word64(1695183700, 2343527390), new Word64(1986661051, 1014477480), new Word64(2177026350, 1206759142), new Word64(2456956037, 344077627), new Word64(2730485921, 1290863460), new Word64(2820302411, 3158454273), new Word64(3259730800, 3505952657), new Word64(3345764771, 106217008), new Word64(3516065817, 3606008344), new Word64(3600352804, 1432725776), new Word64(4094571909, 1467031594), new Word64(275423344, 851169720), new Word64(430227734, 3100823752), new Word64(506948616, 1363258195), new Word64(659060556, 3750685593), new Word64(883997877, 3785050280), new Word64(958139571, 3318307427), new Word64(1322822218, 3812723403), new Word64(1537002063, 2003034995), new Word64(1747873779, 3602036899), new Word64(1955562222, 1575990012), new Word64(2024104815, 1125592928), new Word64(2227730452, 2716904306), new Word64(2361852424, 442776044), new Word64(2428436474, 593698344), new Word64(2756734187, 3733110249), new Word64(3204031479, 2999351573), new Word64(3329325298, 3815920427), new Word64(3391569614, 3928383900), new Word64(3515267271, 566280711), new Word64(3940187606, 3454069534), new Word64(4118630271, 4000239992), new Word64(116418474, 1914138554), new Word64(174292421, 2731055270), new Word64(289380356, 3203993006), new Word64(460393269, 320620315), new Word64(685471733, 587496836), new Word64(852142971, 1086792851), new Word64(1017036298, 365543100), new Word64(1126000580, 2618297676), new Word64(1288033470, 3409855158), new Word64(1501505948, 4234509866), new Word64(1607167915, 987167468), new Word64(1816402316, 1246189591)]);
} };
function ch(e2, t2, a2, r2, i2) {
  e2.assign(t2);
  e2.and(a2);
  i2.assign(t2);
  i2.not();
  i2.and(r2);
  e2.xor(i2);
}
function maj(e2, t2, a2, r2, i2) {
  e2.assign(t2);
  e2.and(a2);
  i2.assign(t2);
  i2.and(r2);
  e2.xor(i2);
  i2.assign(a2);
  i2.and(r2);
  e2.xor(i2);
}
function sigma(e2, t2, a2) {
  e2.assign(t2);
  e2.rotateRight(28);
  a2.assign(t2);
  a2.rotateRight(34);
  e2.xor(a2);
  a2.assign(t2);
  a2.rotateRight(39);
  e2.xor(a2);
}
function sigmaPrime(e2, t2, a2) {
  e2.assign(t2);
  e2.rotateRight(14);
  a2.assign(t2);
  a2.rotateRight(18);
  e2.xor(a2);
  a2.assign(t2);
  a2.rotateRight(41);
  e2.xor(a2);
}
function littleSigma(e2, t2, a2) {
  e2.assign(t2);
  e2.rotateRight(1);
  a2.assign(t2);
  a2.rotateRight(8);
  e2.xor(a2);
  a2.assign(t2);
  a2.shiftRight(7);
  e2.xor(a2);
}
function littleSigmaPrime(e2, t2, a2) {
  e2.assign(t2);
  e2.rotateRight(19);
  a2.assign(t2);
  a2.rotateRight(61);
  e2.xor(a2);
  a2.assign(t2);
  a2.shiftRight(6);
  e2.xor(a2);
}
function calculateSHA512(e2, t2, a2, r2 = false) {
  let i2, n2, s2, o2, c2, l2, h2, u2;
  if (r2) {
    i2 = new Word64(3418070365, 3238371032);
    n2 = new Word64(1654270250, 914150663);
    s2 = new Word64(2438529370, 812702999);
    o2 = new Word64(355462360, 4144912697);
    c2 = new Word64(1731405415, 4290775857);
    l2 = new Word64(2394180231, 1750603025);
    h2 = new Word64(3675008525, 1694076839);
    u2 = new Word64(1203062813, 3204075428);
  } else {
    i2 = new Word64(1779033703, 4089235720);
    n2 = new Word64(3144134277, 2227873595);
    s2 = new Word64(1013904242, 4271175723);
    o2 = new Word64(2773480762, 1595750129);
    c2 = new Word64(1359893119, 2917565137);
    l2 = new Word64(2600822924, 725511199);
    h2 = new Word64(528734635, 4215389547);
    u2 = new Word64(1541459225, 327033209);
  }
  const d2 = 128 * Math.ceil((a2 + 17) / 128), f2 = new Uint8Array(d2);
  let g2, p2;
  for (g2 = 0; g2 < a2; ++g2) f2[g2] = e2[t2++];
  f2[g2++] = 128;
  const m2 = d2 - 16;
  g2 < m2 && (g2 = m2);
  g2 += 11;
  f2[g2++] = a2 >>> 29 & 255;
  f2[g2++] = a2 >> 21 & 255;
  f2[g2++] = a2 >> 13 & 255;
  f2[g2++] = a2 >> 5 & 255;
  f2[g2++] = a2 << 3 & 255;
  const b2 = new Array(80);
  for (g2 = 0; g2 < 80; g2++) b2[g2] = new Word64(0, 0);
  const { k: y2 } = mc;
  let w2 = new Word64(0, 0), x2 = new Word64(0, 0), S2 = new Word64(0, 0), k2 = new Word64(0, 0), C2 = new Word64(0, 0), v2 = new Word64(0, 0), F2 = new Word64(0, 0), T2 = new Word64(0, 0);
  const O2 = new Word64(0, 0), M2 = new Word64(0, 0), D2 = new Word64(0, 0), R2 = new Word64(0, 0);
  let N2, E2;
  for (g2 = 0; g2 < d2; ) {
    for (p2 = 0; p2 < 16; ++p2) {
      b2[p2].high = f2[g2] << 24 | f2[g2 + 1] << 16 | f2[g2 + 2] << 8 | f2[g2 + 3];
      b2[p2].low = f2[g2 + 4] << 24 | f2[g2 + 5] << 16 | f2[g2 + 6] << 8 | f2[g2 + 7];
      g2 += 8;
    }
    for (p2 = 16; p2 < 80; ++p2) {
      N2 = b2[p2];
      littleSigmaPrime(N2, b2[p2 - 2], R2);
      N2.add(b2[p2 - 7]);
      littleSigma(D2, b2[p2 - 15], R2);
      N2.add(D2);
      N2.add(b2[p2 - 16]);
    }
    w2.assign(i2);
    x2.assign(n2);
    S2.assign(s2);
    k2.assign(o2);
    C2.assign(c2);
    v2.assign(l2);
    F2.assign(h2);
    T2.assign(u2);
    for (p2 = 0; p2 < 80; ++p2) {
      O2.assign(T2);
      sigmaPrime(D2, C2, R2);
      O2.add(D2);
      ch(D2, C2, v2, F2, R2);
      O2.add(D2);
      O2.add(y2[p2]);
      O2.add(b2[p2]);
      sigma(M2, w2, R2);
      maj(D2, w2, x2, S2, R2);
      M2.add(D2);
      N2 = T2;
      T2 = F2;
      F2 = v2;
      v2 = C2;
      k2.add(O2);
      C2 = k2;
      k2 = S2;
      S2 = x2;
      x2 = w2;
      N2.assign(O2);
      N2.add(M2);
      w2 = N2;
    }
    i2.add(w2);
    n2.add(x2);
    s2.add(S2);
    o2.add(k2);
    c2.add(C2);
    l2.add(v2);
    h2.add(F2);
    u2.add(T2);
  }
  if (r2) {
    E2 = new Uint8Array(48);
    i2.copyTo(E2, 0);
    n2.copyTo(E2, 8);
    s2.copyTo(E2, 16);
    o2.copyTo(E2, 24);
    c2.copyTo(E2, 32);
    l2.copyTo(E2, 40);
  } else {
    E2 = new Uint8Array(64);
    i2.copyTo(E2, 0);
    n2.copyTo(E2, 8);
    s2.copyTo(E2, 16);
    o2.copyTo(E2, 24);
    c2.copyTo(E2, 32);
    l2.copyTo(E2, 40);
    h2.copyTo(E2, 48);
    u2.copyTo(E2, 56);
  }
  return E2;
}
var bc = { get k() {
  return shadow(this, "k", [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
} };
function rotr(e2, t2) {
  return e2 >>> t2 | e2 << 32 - t2;
}
function calculate_sha256_ch(e2, t2, a2) {
  return e2 & t2 ^ ~e2 & a2;
}
function calculate_sha256_maj(e2, t2, a2) {
  return e2 & t2 ^ e2 & a2 ^ t2 & a2;
}
function calculate_sha256_sigma(e2) {
  return rotr(e2, 2) ^ rotr(e2, 13) ^ rotr(e2, 22);
}
function calculate_sha256_sigmaPrime(e2) {
  return rotr(e2, 6) ^ rotr(e2, 11) ^ rotr(e2, 25);
}
function calculate_sha256_littleSigma(e2) {
  return rotr(e2, 7) ^ rotr(e2, 18) ^ e2 >>> 3;
}
function calculateSHA256(e2, t2, a2) {
  let r2 = 1779033703, i2 = 3144134277, n2 = 1013904242, s2 = 2773480762, o2 = 1359893119, c2 = 2600822924, l2 = 528734635, h2 = 1541459225;
  const u2 = 64 * Math.ceil((a2 + 9) / 64), d2 = new Uint8Array(u2);
  let f2, g2;
  for (f2 = 0; f2 < a2; ++f2) d2[f2] = e2[t2++];
  d2[f2++] = 128;
  const p2 = u2 - 8;
  f2 < p2 && (f2 = p2);
  f2 += 3;
  d2[f2++] = a2 >>> 29 & 255;
  d2[f2++] = a2 >> 21 & 255;
  d2[f2++] = a2 >> 13 & 255;
  d2[f2++] = a2 >> 5 & 255;
  d2[f2++] = a2 << 3 & 255;
  const m2 = new Uint32Array(64), { k: b2 } = bc;
  for (f2 = 0; f2 < u2; ) {
    for (g2 = 0; g2 < 16; ++g2) {
      m2[g2] = d2[f2] << 24 | d2[f2 + 1] << 16 | d2[f2 + 2] << 8 | d2[f2 + 3];
      f2 += 4;
    }
    for (g2 = 16; g2 < 64; ++g2) m2[g2] = (rotr(y2 = m2[g2 - 2], 17) ^ rotr(y2, 19) ^ y2 >>> 10) + m2[g2 - 7] + calculate_sha256_littleSigma(m2[g2 - 15]) + m2[g2 - 16] | 0;
    let e3, t3, a3 = r2, u3 = i2, p3 = n2, w2 = s2, x2 = o2, S2 = c2, k2 = l2, C2 = h2;
    for (g2 = 0; g2 < 64; ++g2) {
      e3 = C2 + calculate_sha256_sigmaPrime(x2) + calculate_sha256_ch(x2, S2, k2) + b2[g2] + m2[g2];
      t3 = calculate_sha256_sigma(a3) + calculate_sha256_maj(a3, u3, p3);
      C2 = k2;
      k2 = S2;
      S2 = x2;
      x2 = w2 + e3 | 0;
      w2 = p3;
      p3 = u3;
      u3 = a3;
      a3 = e3 + t3 | 0;
    }
    r2 = r2 + a3 | 0;
    i2 = i2 + u3 | 0;
    n2 = n2 + p3 | 0;
    s2 = s2 + w2 | 0;
    o2 = o2 + x2 | 0;
    c2 = c2 + S2 | 0;
    l2 = l2 + k2 | 0;
    h2 = h2 + C2 | 0;
  }
  var y2;
  return new Uint8Array([r2 >> 24 & 255, r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2, i2 >> 24 & 255, i2 >> 16 & 255, i2 >> 8 & 255, 255 & i2, n2 >> 24 & 255, n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2, s2 >> 24 & 255, s2 >> 16 & 255, s2 >> 8 & 255, 255 & s2, o2 >> 24 & 255, o2 >> 16 & 255, o2 >> 8 & 255, 255 & o2, c2 >> 24 & 255, c2 >> 16 & 255, c2 >> 8 & 255, 255 & c2, l2 >> 24 & 255, l2 >> 16 & 255, l2 >> 8 & 255, 255 & l2, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, 255 & h2]);
}
var DecryptStream = class extends DecodeStream {
  constructor(e2, t2, a2) {
    super(t2);
    this.str = e2;
    this.dict = e2.dict;
    this.decrypt = a2;
    this.nextChunk = null;
    this.initialized = false;
  }
  readBlock() {
    let e2;
    if (this.initialized) e2 = this.nextChunk;
    else {
      e2 = this.str.getBytes(512);
      this.initialized = true;
    }
    if (!e2?.length) {
      this.eof = true;
      return;
    }
    this.nextChunk = this.str.getBytes(512);
    const t2 = this.nextChunk?.length > 0;
    e2 = (0, this.decrypt)(e2, !t2);
    const a2 = this.bufferLength, r2 = a2 + e2.length;
    this.ensureBuffer(r2).set(e2, a2);
    this.bufferLength = r2;
  }
};
var ARCFourCipher = class {
  constructor(e2) {
    this.a = 0;
    this.b = 0;
    const t2 = new Uint8Array(256), a2 = e2.length;
    for (let e3 = 0; e3 < 256; ++e3) t2[e3] = e3;
    for (let r2 = 0, i2 = 0; r2 < 256; ++r2) {
      const n2 = t2[r2];
      i2 = i2 + n2 + e2[r2 % a2] & 255;
      t2[r2] = t2[i2];
      t2[i2] = n2;
    }
    this.s = t2;
  }
  encryptBlock(e2) {
    let t2 = this.a, a2 = this.b;
    const r2 = this.s, i2 = e2.length, n2 = new Uint8Array(i2);
    for (let s2 = 0; s2 < i2; ++s2) {
      t2 = t2 + 1 & 255;
      const i3 = r2[t2];
      a2 = a2 + i3 & 255;
      const o2 = r2[a2];
      r2[t2] = o2;
      r2[a2] = i3;
      n2[s2] = e2[s2] ^ r2[i3 + o2 & 255];
    }
    this.a = t2;
    this.b = a2;
    return n2;
  }
  decryptBlock(e2) {
    return this.encryptBlock(e2);
  }
  encrypt(e2) {
    return this.encryptBlock(e2);
  }
};
var NullCipher = class {
  decryptBlock(e2) {
    return e2;
  }
  encrypt(e2) {
    return e2;
  }
};
var AESBaseCipher = class {
  _s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]);
  _inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
  _mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]);
  _mixCol = new Uint8Array(256).map(((e2, t2) => t2 < 128 ? t2 << 1 : t2 << 1 ^ 27));
  constructor() {
    this.buffer = new Uint8Array(16);
    this.bufferPosition = 0;
  }
  _expandKey(e2) {
    unreachable("Cannot call `_expandKey` on the base class");
  }
  _decrypt(e2, t2) {
    let a2, r2, i2;
    const n2 = new Uint8Array(16);
    n2.set(e2);
    for (let e3 = 0, a3 = this._keySize; e3 < 16; ++e3, ++a3) n2[e3] ^= t2[a3];
    for (let e3 = this._cyclesOfRepetition - 1; e3 >= 1; --e3) {
      a2 = n2[13];
      n2[13] = n2[9];
      n2[9] = n2[5];
      n2[5] = n2[1];
      n2[1] = a2;
      a2 = n2[14];
      r2 = n2[10];
      n2[14] = n2[6];
      n2[10] = n2[2];
      n2[6] = a2;
      n2[2] = r2;
      a2 = n2[15];
      r2 = n2[11];
      i2 = n2[7];
      n2[15] = n2[3];
      n2[11] = a2;
      n2[7] = r2;
      n2[3] = i2;
      for (let e4 = 0; e4 < 16; ++e4) n2[e4] = this._inv_s[n2[e4]];
      for (let a3 = 0, r3 = 16 * e3; a3 < 16; ++a3, ++r3) n2[a3] ^= t2[r3];
      for (let e4 = 0; e4 < 16; e4 += 4) {
        const t3 = this._mix[n2[e4]], r3 = this._mix[n2[e4 + 1]], i3 = this._mix[n2[e4 + 2]], s2 = this._mix[n2[e4 + 3]];
        a2 = t3 ^ r3 >>> 8 ^ r3 << 24 ^ i3 >>> 16 ^ i3 << 16 ^ s2 >>> 24 ^ s2 << 8;
        n2[e4] = a2 >>> 24 & 255;
        n2[e4 + 1] = a2 >> 16 & 255;
        n2[e4 + 2] = a2 >> 8 & 255;
        n2[e4 + 3] = 255 & a2;
      }
    }
    a2 = n2[13];
    n2[13] = n2[9];
    n2[9] = n2[5];
    n2[5] = n2[1];
    n2[1] = a2;
    a2 = n2[14];
    r2 = n2[10];
    n2[14] = n2[6];
    n2[10] = n2[2];
    n2[6] = a2;
    n2[2] = r2;
    a2 = n2[15];
    r2 = n2[11];
    i2 = n2[7];
    n2[15] = n2[3];
    n2[11] = a2;
    n2[7] = r2;
    n2[3] = i2;
    for (let e3 = 0; e3 < 16; ++e3) {
      n2[e3] = this._inv_s[n2[e3]];
      n2[e3] ^= t2[e3];
    }
    return n2;
  }
  _encrypt(e2, t2) {
    const a2 = this._s;
    let r2, i2, n2;
    const s2 = new Uint8Array(16);
    s2.set(e2);
    for (let e3 = 0; e3 < 16; ++e3) s2[e3] ^= t2[e3];
    for (let e3 = 1; e3 < this._cyclesOfRepetition; e3++) {
      for (let e4 = 0; e4 < 16; ++e4) s2[e4] = a2[s2[e4]];
      n2 = s2[1];
      s2[1] = s2[5];
      s2[5] = s2[9];
      s2[9] = s2[13];
      s2[13] = n2;
      n2 = s2[2];
      i2 = s2[6];
      s2[2] = s2[10];
      s2[6] = s2[14];
      s2[10] = n2;
      s2[14] = i2;
      n2 = s2[3];
      i2 = s2[7];
      r2 = s2[11];
      s2[3] = s2[15];
      s2[7] = n2;
      s2[11] = i2;
      s2[15] = r2;
      for (let e4 = 0; e4 < 16; e4 += 4) {
        const t3 = s2[e4], a3 = s2[e4 + 1], i3 = s2[e4 + 2], n3 = s2[e4 + 3];
        r2 = t3 ^ a3 ^ i3 ^ n3;
        s2[e4] ^= r2 ^ this._mixCol[t3 ^ a3];
        s2[e4 + 1] ^= r2 ^ this._mixCol[a3 ^ i3];
        s2[e4 + 2] ^= r2 ^ this._mixCol[i3 ^ n3];
        s2[e4 + 3] ^= r2 ^ this._mixCol[n3 ^ t3];
      }
      for (let a3 = 0, r3 = 16 * e3; a3 < 16; ++a3, ++r3) s2[a3] ^= t2[r3];
    }
    for (let e3 = 0; e3 < 16; ++e3) s2[e3] = a2[s2[e3]];
    n2 = s2[1];
    s2[1] = s2[5];
    s2[5] = s2[9];
    s2[9] = s2[13];
    s2[13] = n2;
    n2 = s2[2];
    i2 = s2[6];
    s2[2] = s2[10];
    s2[6] = s2[14];
    s2[10] = n2;
    s2[14] = i2;
    n2 = s2[3];
    i2 = s2[7];
    r2 = s2[11];
    s2[3] = s2[15];
    s2[7] = n2;
    s2[11] = i2;
    s2[15] = r2;
    for (let e3 = 0, a3 = this._keySize; e3 < 16; ++e3, ++a3) s2[e3] ^= t2[a3];
    return s2;
  }
  _decryptBlock2(e2, t2) {
    const a2 = e2.length;
    let r2 = this.buffer, i2 = this.bufferPosition;
    const n2 = [];
    let s2 = this.iv;
    for (let t3 = 0; t3 < a2; ++t3) {
      r2[i2] = e2[t3];
      ++i2;
      if (i2 < 16) continue;
      const a3 = this._decrypt(r2, this._key);
      for (let e3 = 0; e3 < 16; ++e3) a3[e3] ^= s2[e3];
      s2 = r2;
      n2.push(a3);
      r2 = new Uint8Array(16);
      i2 = 0;
    }
    this.buffer = r2;
    this.bufferLength = i2;
    this.iv = s2;
    if (0 === n2.length) return new Uint8Array(0);
    let o2 = 16 * n2.length;
    if (t2) {
      const e3 = n2.at(-1);
      let t3 = e3[15];
      if (t3 <= 16) {
        for (let a3 = 15, r3 = 16 - t3; a3 >= r3; --a3) if (e3[a3] !== t3) {
          t3 = 0;
          break;
        }
        o2 -= t3;
        n2[n2.length - 1] = e3.subarray(0, 16 - t3);
      }
    }
    const c2 = new Uint8Array(o2);
    for (let e3 = 0, t3 = 0, a3 = n2.length; e3 < a3; ++e3, t3 += 16) c2.set(n2[e3], t3);
    return c2;
  }
  decryptBlock(e2, t2, a2 = null) {
    const r2 = e2.length, i2 = this.buffer;
    let n2 = this.bufferPosition;
    if (a2) this.iv = a2;
    else {
      for (let t3 = 0; n2 < 16 && t3 < r2; ++t3, ++n2) i2[n2] = e2[t3];
      if (n2 < 16) {
        this.bufferLength = n2;
        return new Uint8Array(0);
      }
      this.iv = i2;
      e2 = e2.subarray(16);
    }
    this.buffer = new Uint8Array(16);
    this.bufferLength = 0;
    this.decryptBlock = this._decryptBlock2;
    return this.decryptBlock(e2, t2);
  }
  encrypt(e2, t2) {
    const a2 = e2.length;
    let r2 = this.buffer, i2 = this.bufferPosition;
    const n2 = [];
    t2 ||= new Uint8Array(16);
    for (let s3 = 0; s3 < a2; ++s3) {
      r2[i2] = e2[s3];
      ++i2;
      if (i2 < 16) continue;
      for (let e3 = 0; e3 < 16; ++e3) r2[e3] ^= t2[e3];
      const a3 = this._encrypt(r2, this._key);
      t2 = a3;
      n2.push(a3);
      r2 = new Uint8Array(16);
      i2 = 0;
    }
    this.buffer = r2;
    this.bufferLength = i2;
    this.iv = t2;
    if (0 === n2.length) return new Uint8Array(0);
    const s2 = 16 * n2.length, o2 = new Uint8Array(s2);
    for (let e3 = 0, t3 = 0, a3 = n2.length; e3 < a3; ++e3, t3 += 16) o2.set(n2[e3], t3);
    return o2;
  }
};
var AES128Cipher = class extends AESBaseCipher {
  _rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]);
  constructor(e2) {
    super();
    this._cyclesOfRepetition = 10;
    this._keySize = 160;
    this._key = this._expandKey(e2);
  }
  _expandKey(e2) {
    const t2 = this._s, a2 = this._rcon, r2 = new Uint8Array(176);
    r2.set(e2);
    for (let e3 = 16, i2 = 1; e3 < 176; ++i2) {
      let n2 = r2[e3 - 3], s2 = r2[e3 - 2], o2 = r2[e3 - 1], c2 = r2[e3 - 4];
      n2 = t2[n2];
      s2 = t2[s2];
      o2 = t2[o2];
      c2 = t2[c2];
      n2 ^= a2[i2];
      for (let t3 = 0; t3 < 4; ++t3) {
        r2[e3] = n2 ^= r2[e3 - 16];
        e3++;
        r2[e3] = s2 ^= r2[e3 - 16];
        e3++;
        r2[e3] = o2 ^= r2[e3 - 16];
        e3++;
        r2[e3] = c2 ^= r2[e3 - 16];
        e3++;
      }
    }
    return r2;
  }
};
var AES256Cipher = class extends AESBaseCipher {
  constructor(e2) {
    super();
    this._cyclesOfRepetition = 14;
    this._keySize = 224;
    this._key = this._expandKey(e2);
  }
  _expandKey(e2) {
    const t2 = this._s, a2 = new Uint8Array(240);
    a2.set(e2);
    let r2, i2, n2, s2, o2 = 1;
    for (let e3 = 32, c2 = 1; e3 < 240; ++c2) {
      if (e3 % 32 == 16) {
        r2 = t2[r2];
        i2 = t2[i2];
        n2 = t2[n2];
        s2 = t2[s2];
      } else if (e3 % 32 == 0) {
        r2 = a2[e3 - 3];
        i2 = a2[e3 - 2];
        n2 = a2[e3 - 1];
        s2 = a2[e3 - 4];
        r2 = t2[r2];
        i2 = t2[i2];
        n2 = t2[n2];
        s2 = t2[s2];
        r2 ^= o2;
        (o2 <<= 1) >= 256 && (o2 = 255 & (27 ^ o2));
      }
      for (let t3 = 0; t3 < 4; ++t3) {
        a2[e3] = r2 ^= a2[e3 - 32];
        e3++;
        a2[e3] = i2 ^= a2[e3 - 32];
        e3++;
        a2[e3] = n2 ^= a2[e3 - 32];
        e3++;
        a2[e3] = s2 ^= a2[e3 - 32];
        e3++;
      }
    }
    return a2;
  }
};
var PDFBase = class {
  _hash(e2, t2, a2) {
    unreachable("Abstract method `_hash` called");
  }
  checkOwnerPassword(e2, t2, a2, r2) {
    const i2 = new Uint8Array(e2.length + 56);
    i2.set(e2, 0);
    i2.set(t2, e2.length);
    i2.set(a2, e2.length + t2.length);
    return isArrayEqual(this._hash(e2, i2, a2), r2);
  }
  checkUserPassword(e2, t2, a2) {
    const r2 = new Uint8Array(e2.length + 8);
    r2.set(e2, 0);
    r2.set(t2, e2.length);
    return isArrayEqual(this._hash(e2, r2, []), a2);
  }
  getOwnerKey(e2, t2, a2, r2) {
    const i2 = new Uint8Array(e2.length + 56);
    i2.set(e2, 0);
    i2.set(t2, e2.length);
    i2.set(a2, e2.length + t2.length);
    const n2 = this._hash(e2, i2, a2);
    return new AES256Cipher(n2).decryptBlock(r2, false, new Uint8Array(16));
  }
  getUserKey(e2, t2, a2) {
    const r2 = new Uint8Array(e2.length + 8);
    r2.set(e2, 0);
    r2.set(t2, e2.length);
    const i2 = this._hash(e2, r2, []);
    return new AES256Cipher(i2).decryptBlock(a2, false, new Uint8Array(16));
  }
};
var PDF17 = class extends PDFBase {
  _hash(e2, t2, a2) {
    return calculateSHA256(t2, 0, t2.length);
  }
};
var PDF20 = class extends PDFBase {
  _hash(e2, t2, a2) {
    let r2 = calculateSHA256(t2, 0, t2.length).subarray(0, 32), i2 = [0], n2 = 0;
    for (; n2 < 64 || i2.at(-1) > n2 - 32; ) {
      const t3 = e2.length + r2.length + a2.length, l2 = new Uint8Array(t3);
      let h2 = 0;
      l2.set(e2, h2);
      h2 += e2.length;
      l2.set(r2, h2);
      h2 += r2.length;
      l2.set(a2, h2);
      const u2 = new Uint8Array(64 * t3);
      for (let e3 = 0, a3 = 0; e3 < 64; e3++, a3 += t3) u2.set(l2, a3);
      i2 = new AES128Cipher(r2.subarray(0, 16)).encrypt(u2, r2.subarray(16, 32));
      const d2 = Math.sumPrecise(i2.slice(0, 16)) % 3;
      0 === d2 ? r2 = calculateSHA256(i2, 0, i2.length) : 1 === d2 ? r2 = (s2 = i2, o2 = 0, c2 = i2.length, calculateSHA512(s2, o2, c2, true)) : 2 === d2 && (r2 = calculateSHA512(i2, 0, i2.length));
      n2++;
    }
    var s2, o2, c2;
    return r2.subarray(0, 32);
  }
};
var CipherTransform = class {
  constructor(e2, t2) {
    this.StringCipherConstructor = e2;
    this.StreamCipherConstructor = t2;
  }
  createStream(e2, t2) {
    const a2 = new this.StreamCipherConstructor();
    return new DecryptStream(e2, t2, (function cipherTransformDecryptStream(e3, t3) {
      return a2.decryptBlock(e3, t3);
    }));
  }
  decryptString(e2) {
    const t2 = new this.StringCipherConstructor();
    let a2 = stringToBytes(e2);
    a2 = t2.decryptBlock(a2, true);
    return bytesToString(a2);
  }
  encryptString(e2) {
    const t2 = new this.StringCipherConstructor();
    if (t2 instanceof AESBaseCipher) {
      const a3 = 16 - e2.length % 16;
      e2 += String.fromCharCode(a3).repeat(a3);
      const r2 = new Uint8Array(16);
      crypto.getRandomValues(r2);
      let i2 = stringToBytes(e2);
      i2 = t2.encrypt(i2, r2);
      const n2 = new Uint8Array(16 + i2.length);
      n2.set(r2);
      n2.set(i2, 16);
      return bytesToString(n2);
    }
    let a2 = stringToBytes(e2);
    a2 = t2.encrypt(a2);
    return bytesToString(a2);
  }
};
var CipherTransformFactory = class _CipherTransformFactory {
  static get _defaultPasswordBytes() {
    return shadow(this, "_defaultPasswordBytes", new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
  }
  #Oe(e2, t2, a2, r2, i2, n2, s2, o2, c2, l2, h2, u2) {
    if (t2) {
      const e3 = Math.min(127, t2.length);
      t2 = t2.subarray(0, e3);
    } else t2 = [];
    const d2 = 6 === e2 ? new PDF20() : new PDF17();
    return d2.checkUserPassword(t2, o2, s2) ? d2.getUserKey(t2, c2, h2) : t2.length && d2.checkOwnerPassword(t2, r2, n2, a2) ? d2.getOwnerKey(t2, i2, n2, l2) : null;
  }
  #Me(e2, t2, a2, r2, i2, n2, s2, o2) {
    const c2 = 40 + a2.length + e2.length, l2 = new Uint8Array(c2);
    let h2, u2, d2 = 0;
    if (t2) {
      u2 = Math.min(32, t2.length);
      for (; d2 < u2; ++d2) l2[d2] = t2[d2];
    }
    h2 = 0;
    for (; d2 < 32; ) l2[d2++] = _CipherTransformFactory._defaultPasswordBytes[h2++];
    l2.set(a2, d2);
    d2 += a2.length;
    l2[d2++] = 255 & i2;
    l2[d2++] = i2 >> 8 & 255;
    l2[d2++] = i2 >> 16 & 255;
    l2[d2++] = i2 >>> 24 & 255;
    l2.set(e2, d2);
    d2 += e2.length;
    if (n2 >= 4 && !o2) {
      l2.fill(255, d2, d2 + 4);
      d2 += 4;
    }
    let f2 = calculateMD5(l2, 0, d2);
    const g2 = s2 >> 3;
    if (n2 >= 3) for (h2 = 0; h2 < 50; ++h2) f2 = calculateMD5(f2, 0, g2);
    const p2 = f2.subarray(0, g2);
    let m2, b2;
    if (n2 >= 3) {
      d2 = 0;
      l2.set(_CipherTransformFactory._defaultPasswordBytes, d2);
      d2 += 32;
      l2.set(e2, d2);
      d2 += e2.length;
      m2 = new ARCFourCipher(p2);
      b2 = m2.encryptBlock(calculateMD5(l2, 0, d2));
      u2 = p2.length;
      const t3 = new Uint8Array(u2);
      for (h2 = 1; h2 <= 19; ++h2) {
        for (let e3 = 0; e3 < u2; ++e3) t3[e3] = p2[e3] ^ h2;
        m2 = new ARCFourCipher(t3);
        b2 = m2.encryptBlock(b2);
      }
    } else {
      m2 = new ARCFourCipher(p2);
      b2 = m2.encryptBlock(_CipherTransformFactory._defaultPasswordBytes);
    }
    return b2.every(((e3, t3) => r2[t3] === e3)) ? p2 : null;
  }
  #De(e2, t2, a2, r2) {
    const i2 = new Uint8Array(32);
    let n2 = 0;
    const s2 = Math.min(32, e2.length);
    for (; n2 < s2; ++n2) i2[n2] = e2[n2];
    let o2 = 0;
    for (; n2 < 32; ) i2[n2++] = _CipherTransformFactory._defaultPasswordBytes[o2++];
    let c2 = calculateMD5(i2, 0, n2);
    const l2 = r2 >> 3;
    if (a2 >= 3) for (o2 = 0; o2 < 50; ++o2) c2 = calculateMD5(c2, 0, c2.length);
    let h2, u2;
    if (a2 >= 3) {
      u2 = t2;
      const e3 = new Uint8Array(l2);
      for (o2 = 19; o2 >= 0; o2--) {
        for (let t3 = 0; t3 < l2; ++t3) e3[t3] = c2[t3] ^ o2;
        h2 = new ARCFourCipher(e3);
        u2 = h2.encryptBlock(u2);
      }
    } else {
      h2 = new ARCFourCipher(c2.subarray(0, l2));
      u2 = h2.encryptBlock(t2);
    }
    return u2;
  }
  #Be(e2, t2, a2, r2 = false) {
    const i2 = a2.length, n2 = new Uint8Array(i2 + 9);
    n2.set(a2);
    let s2 = i2;
    n2[s2++] = 255 & e2;
    n2[s2++] = e2 >> 8 & 255;
    n2[s2++] = e2 >> 16 & 255;
    n2[s2++] = 255 & t2;
    n2[s2++] = t2 >> 8 & 255;
    if (r2) {
      n2[s2++] = 115;
      n2[s2++] = 65;
      n2[s2++] = 108;
      n2[s2++] = 84;
    }
    return calculateMD5(n2, 0, s2).subarray(0, Math.min(i2 + 5, 16));
  }
  #Re(e2, t2, a2, r2, i2) {
    if (!(t2 instanceof Name)) throw new FormatError("Invalid crypt filter name.");
    const n2 = this, s2 = e2.get(t2.name), o2 = s2?.get("CFM");
    if (!o2 || "None" === o2.name) return function() {
      return new NullCipher();
    };
    if ("V2" === o2.name) return function() {
      return new ARCFourCipher(n2.#Be(a2, r2, i2, false));
    };
    if ("AESV2" === o2.name) return function() {
      return new AES128Cipher(n2.#Be(a2, r2, i2, true));
    };
    if ("AESV3" === o2.name) return function() {
      return new AES256Cipher(i2);
    };
    throw new FormatError("Unknown crypto method");
  }
  constructor(e2, t2, a2) {
    const r2 = e2.get("Filter");
    if (!isName(r2, "Standard")) throw new FormatError("unknown encryption method");
    this.filterName = r2.name;
    this.dict = e2;
    const i2 = e2.get("V");
    if (!Number.isInteger(i2) || 1 !== i2 && 2 !== i2 && 4 !== i2 && 5 !== i2) throw new FormatError("unsupported encryption algorithm");
    this.algorithm = i2;
    let n2 = e2.get("Length");
    if (!n2) if (i2 <= 3) n2 = 40;
    else {
      const t3 = e2.get("CF"), a3 = e2.get("StmF");
      if (t3 instanceof Dict && a3 instanceof Name) {
        t3.suppressEncryption = true;
        const e3 = t3.get(a3.name);
        n2 = e3?.get("Length") || 128;
        n2 < 40 && (n2 <<= 3);
      }
    }
    if (!Number.isInteger(n2) || n2 < 40 || n2 % 8 != 0) throw new FormatError("invalid key length");
    const s2 = stringToBytes(e2.get("O")), o2 = stringToBytes(e2.get("U")), c2 = s2.subarray(0, 32), l2 = o2.subarray(0, 32), h2 = e2.get("P"), u2 = e2.get("R"), d2 = (4 === i2 || 5 === i2) && false !== e2.get("EncryptMetadata");
    this.encryptMetadata = d2;
    const f2 = stringToBytes(t2);
    let g2, p2;
    if (a2) {
      if (6 === u2) try {
        a2 = utf8StringToString(a2);
      } catch {
        warn("CipherTransformFactory: Unable to convert UTF8 encoded password.");
      }
      g2 = stringToBytes(a2);
    }
    if (5 !== i2) p2 = this.#Me(f2, g2, c2, l2, h2, u2, n2, d2);
    else {
      const t3 = s2.subarray(32, 40), a3 = s2.subarray(40, 48), r3 = o2.subarray(0, 48), i3 = o2.subarray(32, 40), n3 = o2.subarray(40, 48), h3 = stringToBytes(e2.get("OE")), d3 = stringToBytes(e2.get("UE")), f3 = stringToBytes(e2.get("Perms"));
      p2 = this.#Oe(u2, g2, c2, t3, a3, r3, l2, i3, n3, h3, d3, f3);
    }
    if (!p2) {
      if (!a2) throw new PasswordException("No password given", ha);
      const e3 = this.#De(g2, c2, u2, n2);
      p2 = this.#Me(f2, e3, c2, l2, h2, u2, n2, d2);
    }
    if (!p2) throw new PasswordException("Incorrect Password", ua);
    if (4 === i2 && p2.length < 16) {
      this.encryptionKey = new Uint8Array(16);
      this.encryptionKey.set(p2);
    } else this.encryptionKey = p2;
    if (i2 >= 4) {
      const t3 = e2.get("CF");
      t3 instanceof Dict && (t3.suppressEncryption = true);
      this.cf = t3;
      this.stmf = e2.get("StmF") || Name.get("Identity");
      this.strf = e2.get("StrF") || Name.get("Identity");
      this.eff = e2.get("EFF") || this.stmf;
    }
  }
  createCipherTransform(e2, t2) {
    if (4 === this.algorithm || 5 === this.algorithm) return new CipherTransform(this.#Re(this.cf, this.strf, e2, t2, this.encryptionKey), this.#Re(this.cf, this.stmf, e2, t2, this.encryptionKey));
    const a2 = this.#Be(e2, t2, this.encryptionKey, false), cipherConstructor = function() {
      return new ARCFourCipher(a2);
    };
    return new CipherTransform(cipherConstructor, cipherConstructor);
  }
};
var XRef = class {
  #Ne = null;
  constructor(e2, t2) {
    this.stream = e2;
    this.pdfManager = t2;
    this.entries = [];
    this._xrefStms = /* @__PURE__ */ new Set();
    this._cacheMap = /* @__PURE__ */ new Map();
    this._pendingRefs = new RefSet();
    this._newPersistentRefNum = null;
    this._newTemporaryRefNum = null;
    this._persistentRefsCache = null;
  }
  getNewPersistentRef(e2) {
    null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
    const t2 = this._newPersistentRefNum++;
    this._cacheMap.set(t2, e2);
    return Ref.get(t2, 0);
  }
  getNewTemporaryRef() {
    if (null === this._newTemporaryRefNum) {
      this._newTemporaryRefNum = this.entries.length || 1;
      if (this._newPersistentRefNum) {
        this._persistentRefsCache = /* @__PURE__ */ new Map();
        for (let e2 = this._newTemporaryRefNum; e2 < this._newPersistentRefNum; e2++) {
          this._persistentRefsCache.set(e2, this._cacheMap.get(e2));
          this._cacheMap.delete(e2);
        }
      }
    }
    return Ref.get(this._newTemporaryRefNum++, 0);
  }
  resetNewTemporaryRef() {
    this._newTemporaryRefNum = null;
    if (this._persistentRefsCache) for (const [e2, t2] of this._persistentRefsCache) this._cacheMap.set(e2, t2);
    this._persistentRefsCache = null;
  }
  setStartXRef(e2) {
    this.startXRefQueue = [e2];
  }
  parse(e2 = false) {
    let t2, a2, r2;
    if (e2) {
      warn("Indexing all PDF objects");
      t2 = this.indexObjects();
    } else t2 = this.readXRef();
    t2.assignXref(this);
    this.trailer = t2;
    try {
      a2 = t2.get("Encrypt");
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn(`XRef.parse - Invalid "Encrypt" reference: "${e3}".`);
    }
    if (a2 instanceof Dict) {
      const e3 = t2.get("ID"), r3 = e3?.length ? e3[0] : "";
      a2.suppressEncryption = true;
      this.encrypt = new CipherTransformFactory(a2, r3, this.pdfManager.password);
    }
    try {
      r2 = t2.get("Root");
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn(`XRef.parse - Invalid "Root" reference: "${e3}".`);
    }
    if (r2 instanceof Dict) try {
      if (r2.get("Pages") instanceof Dict) {
        this.root = r2;
        return;
      }
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn(`XRef.parse - Invalid "Pages" reference: "${e3}".`);
    }
    if (!e2) throw new XRefParseException();
    throw new InvalidPDFException("Invalid Root reference.");
  }
  processXRefTable(e2) {
    "tableState" in this || (this.tableState = { entryNum: 0, streamPos: e2.lexer.stream.pos, parserBuf1: e2.buf1, parserBuf2: e2.buf2 });
    if (!isCmd(this.readXRefTable(e2), "trailer")) throw new FormatError("Invalid XRef table: could not find trailer dictionary");
    let t2 = e2.getObj();
    t2 instanceof Dict || !t2.dict || (t2 = t2.dict);
    if (!(t2 instanceof Dict)) throw new FormatError("Invalid XRef table: could not parse trailer dictionary");
    delete this.tableState;
    return t2;
  }
  readXRefTable(e2) {
    const t2 = e2.lexer.stream, a2 = this.tableState;
    t2.pos = a2.streamPos;
    e2.buf1 = a2.parserBuf1;
    e2.buf2 = a2.parserBuf2;
    let r2;
    for (; ; ) {
      if (!("firstEntryNum" in a2) || !("entryCount" in a2)) {
        if (isCmd(r2 = e2.getObj(), "trailer")) break;
        a2.firstEntryNum = r2;
        a2.entryCount = e2.getObj();
      }
      let i2 = a2.firstEntryNum;
      const n2 = a2.entryCount;
      if (!Number.isInteger(i2) || !Number.isInteger(n2)) throw new FormatError("Invalid XRef table: wrong types in subsection header");
      for (let r3 = a2.entryNum; r3 < n2; r3++) {
        a2.streamPos = t2.pos;
        a2.entryNum = r3;
        a2.parserBuf1 = e2.buf1;
        a2.parserBuf2 = e2.buf2;
        const s2 = {};
        s2.offset = e2.getObj();
        s2.gen = e2.getObj();
        const o2 = e2.getObj();
        if (o2 instanceof Cmd) switch (o2.cmd) {
          case "f":
            s2.free = true;
            break;
          case "n":
            s2.uncompressed = true;
        }
        if (!Number.isInteger(s2.offset) || !Number.isInteger(s2.gen) || !s2.free && !s2.uncompressed) throw new FormatError(`Invalid entry in XRef subsection: ${i2}, ${n2}`);
        0 === r3 && s2.free && 1 === i2 && (i2 = 0);
        this.entries[r3 + i2] || (this.entries[r3 + i2] = s2);
      }
      a2.entryNum = 0;
      a2.streamPos = t2.pos;
      a2.parserBuf1 = e2.buf1;
      a2.parserBuf2 = e2.buf2;
      delete a2.firstEntryNum;
      delete a2.entryCount;
    }
    if (this.entries[0] && !this.entries[0].free) throw new FormatError("Invalid XRef table: unexpected first object");
    return r2;
  }
  processXRefStream(e2) {
    if (!("streamState" in this)) {
      const { dict: t2, pos: a2 } = e2, r2 = t2.get("W"), i2 = t2.get("Index") || [0, t2.get("Size")];
      this.streamState = { entryRanges: i2, byteWidths: r2, entryNum: 0, streamPos: a2 };
    }
    this.readXRefStream(e2);
    delete this.streamState;
    return e2.dict;
  }
  readXRefStream(e2) {
    const t2 = this.streamState;
    e2.pos = t2.streamPos;
    const [a2, r2, i2] = t2.byteWidths, n2 = t2.entryRanges;
    for (; n2.length > 0; ) {
      const [s2, o2] = n2;
      if (!Number.isInteger(s2) || !Number.isInteger(o2)) throw new FormatError(`Invalid XRef range fields: ${s2}, ${o2}`);
      if (!Number.isInteger(a2) || !Number.isInteger(r2) || !Number.isInteger(i2)) throw new FormatError(`Invalid XRef entry fields length: ${s2}, ${o2}`);
      for (let n3 = t2.entryNum; n3 < o2; ++n3) {
        t2.entryNum = n3;
        t2.streamPos = e2.pos;
        let o3 = 0, c2 = 0, l2 = 0;
        for (let t3 = 0; t3 < a2; ++t3) {
          const t4 = e2.getByte();
          if (-1 === t4) throw new FormatError("Invalid XRef byteWidths 'type'.");
          o3 = o3 << 8 | t4;
        }
        0 === a2 && (o3 = 1);
        for (let t3 = 0; t3 < r2; ++t3) {
          const t4 = e2.getByte();
          if (-1 === t4) throw new FormatError("Invalid XRef byteWidths 'offset'.");
          c2 = c2 << 8 | t4;
        }
        for (let t3 = 0; t3 < i2; ++t3) {
          const t4 = e2.getByte();
          if (-1 === t4) throw new FormatError("Invalid XRef byteWidths 'generation'.");
          l2 = l2 << 8 | t4;
        }
        const h2 = {};
        h2.offset = c2;
        h2.gen = l2;
        switch (o3) {
          case 0:
            h2.free = true;
            break;
          case 1:
            h2.uncompressed = true;
            break;
          case 2:
            break;
          default:
            throw new FormatError(`Invalid XRef entry type: ${o3}`);
        }
        this.entries[s2 + n3] || (this.entries[s2 + n3] = h2);
      }
      t2.entryNum = 0;
      t2.streamPos = e2.pos;
      n2.splice(0, 2);
    }
  }
  indexObjects() {
    function readToken(e3, t3) {
      let a3 = "", r3 = e3[t3];
      for (; 10 !== r3 && 13 !== r3 && 60 !== r3 && !(++t3 >= e3.length); ) {
        a3 += String.fromCharCode(r3);
        r3 = e3[t3];
      }
      return a3;
    }
    function skipUntil(e3, t3, a3) {
      const r3 = a3.length, i3 = e3.length;
      let n3 = 0;
      for (; t3 < i3; ) {
        let i4 = 0;
        for (; i4 < r3 && e3[t3 + i4] === a3[i4]; ) ++i4;
        if (i4 >= r3) break;
        t3++;
        n3++;
      }
      return n3;
    }
    const e2 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t2 = /\b(startxref|\d+\s+\d+\s+obj)\b/g, a2 = /^(\d+)\s+(\d+)\s+obj\b/, r2 = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), i2 = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), n2 = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0;
    this._cacheMap.clear();
    const s2 = this.stream;
    s2.pos = 0;
    const o2 = s2.getBytes(), c2 = bytesToString(o2), l2 = o2.length;
    let h2 = s2.start;
    const u2 = [], d2 = [];
    for (; h2 < l2; ) {
      let f3 = o2[h2];
      if (9 === f3 || 10 === f3 || 13 === f3 || 32 === f3) {
        ++h2;
        continue;
      }
      if (37 === f3) {
        do {
          ++h2;
          if (h2 >= l2) break;
          f3 = o2[h2];
        } while (10 !== f3 && 13 !== f3);
        continue;
      }
      const g3 = readToken(o2, h2);
      let p3;
      if (g3.startsWith("xref") && (4 === g3.length || /\s/.test(g3[4]))) {
        h2 += skipUntil(o2, h2, r2);
        u2.push(h2);
        h2 += skipUntil(o2, h2, i2);
      } else if (p3 = a2.exec(g3)) {
        const t3 = 0 | p3[1], a3 = 0 | p3[2], r3 = h2 + g3.length;
        let i3, u3 = false;
        if (this.entries[t3]) {
          if (this.entries[t3].gen === a3) try {
            new Parser({ lexer: new Lexer(s2.makeSubStream(r3)) }).getObj();
            u3 = true;
          } catch (e3) {
            e3 instanceof ParserEOFException ? warn(`indexObjects -- checking object (${g3}): "${e3}".`) : u3 = true;
          }
        } else u3 = true;
        u3 && (this.entries[t3] = { offset: h2 - s2.start, gen: a3, uncompressed: true });
        e2.lastIndex = r3;
        const f4 = e2.exec(c2);
        if (f4) {
          i3 = e2.lastIndex + 1 - h2;
          if ("endobj" !== f4[1]) {
            warn(`indexObjects: Found "${f4[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`);
            i3 -= f4[1].length + 1;
          }
        } else i3 = l2 - h2;
        const m3 = o2.subarray(h2, h2 + i3), b2 = skipUntil(m3, 0, n2);
        if (b2 < i3 && m3[b2 + 5] < 64) {
          d2.push(h2 - s2.start);
          this._xrefStms.add(h2 - s2.start);
        }
        h2 += i3;
      } else if (g3.startsWith("trailer") && (7 === g3.length || /\s/.test(g3[7]))) {
        u2.push(h2);
        const e3 = h2 + g3.length;
        let a3;
        t2.lastIndex = e3;
        const r3 = t2.exec(c2);
        if (r3) {
          a3 = t2.lastIndex + 1 - h2;
          if ("startxref" !== r3[1]) {
            warn(`indexObjects: Found "${r3[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`);
            a3 -= r3[1].length + 1;
          }
        } else a3 = l2 - h2;
        h2 += a3;
      } else h2 += g3.length + 1;
    }
    for (const e3 of d2) {
      this.startXRefQueue.push(e3);
      this.readXRef(true);
    }
    const f2 = [];
    let g2, p2, m2 = false;
    for (const e3 of u2) {
      s2.pos = e3;
      const t3 = new Parser({ lexer: new Lexer(s2), xref: this, allowStreams: true, recoveryMode: true });
      if (!isCmd(t3.getObj(), "trailer")) continue;
      const a3 = t3.getObj();
      if (a3 instanceof Dict) {
        f2.push(a3);
        a3.has("Encrypt") && (m2 = true);
      }
    }
    for (const e3 of [...f2, "genFallback", ...f2]) {
      if ("genFallback" === e3) {
        if (!p2) break;
        this._generationFallback = true;
        continue;
      }
      let t3 = false;
      try {
        const a3 = e3.get("Root");
        if (!(a3 instanceof Dict)) continue;
        const r3 = a3.get("Pages");
        if (!(r3 instanceof Dict)) continue;
        const i3 = r3.get("Count");
        Number.isInteger(i3) && (t3 = true);
      } catch (e4) {
        p2 = e4;
        continue;
      }
      if (t3 && (!m2 || e3.has("Encrypt")) && e3.has("ID")) return e3;
      g2 = e3;
    }
    if (g2) return g2;
    if (this.topDict) return this.topDict;
    if (!f2.length) for (const [e3, t3] of this.entries.entries()) {
      if (!t3) continue;
      const a3 = Ref.get(e3, t3.gen);
      let r3;
      try {
        r3 = this.fetch(a3);
      } catch {
        continue;
      }
      r3 instanceof BaseStream && (r3 = r3.dict);
      if (r3 instanceof Dict && r3.has("Root")) return r3;
    }
    throw new InvalidPDFException("Invalid PDF structure.");
  }
  readXRef(e2 = false) {
    const t2 = this.stream, a2 = /* @__PURE__ */ new Set();
    for (; this.startXRefQueue.length; ) {
      try {
        const e3 = this.startXRefQueue[0];
        if (a2.has(e3)) {
          warn("readXRef - skipping XRef table since it was already parsed.");
          this.startXRefQueue.shift();
          continue;
        }
        a2.add(e3);
        t2.pos = e3 + t2.start;
        const r2 = new Parser({ lexer: new Lexer(t2), xref: this, allowStreams: true });
        let i2, n2 = r2.getObj();
        if (isCmd(n2, "xref")) {
          i2 = this.processXRefTable(r2);
          this.topDict || (this.topDict = i2);
          n2 = i2.get("XRefStm");
          if (Number.isInteger(n2) && !this._xrefStms.has(n2)) {
            this._xrefStms.add(n2);
            this.startXRefQueue.push(n2);
            this.#Ne ??= n2;
          }
        } else {
          if (!Number.isInteger(n2)) throw new FormatError("Invalid XRef stream header");
          if (!(Number.isInteger(r2.getObj()) && isCmd(r2.getObj(), "obj") && (n2 = r2.getObj()) instanceof BaseStream)) throw new FormatError("Invalid XRef stream");
          i2 = this.processXRefStream(n2);
          this.topDict || (this.topDict = i2);
          if (!i2) throw new FormatError("Failed to read XRef stream");
        }
        n2 = i2.get("Prev");
        Number.isInteger(n2) ? this.startXRefQueue.push(n2) : n2 instanceof Ref && this.startXRefQueue.push(n2.num);
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        info("(while reading XRef): " + e3);
      }
      this.startXRefQueue.shift();
    }
    if (this.topDict) return this.topDict;
    if (!e2) throw new XRefParseException();
  }
  get lastXRefStreamPos() {
    return this.#Ne ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
  }
  getEntry(e2) {
    const t2 = this.entries[e2];
    return t2 && !t2.free && t2.offset ? t2 : null;
  }
  fetchIfRef(e2, t2 = false) {
    return e2 instanceof Ref ? this.fetch(e2, t2) : e2;
  }
  fetch(e2, t2 = false) {
    if (!(e2 instanceof Ref)) throw new Error("ref object is not a reference");
    const a2 = e2.num, r2 = this._cacheMap.get(a2);
    if (void 0 !== r2) {
      r2 instanceof Dict && !r2.objId && (r2.objId = e2.toString());
      return r2;
    }
    let i2 = this.getEntry(a2);
    if (null === i2) return i2;
    if (this._pendingRefs.has(e2)) {
      this._pendingRefs.remove(e2);
      warn(`Ignoring circular reference: ${e2}.`);
      return ya;
    }
    this._pendingRefs.put(e2);
    try {
      i2 = i2.uncompressed ? this.fetchUncompressed(e2, i2, t2) : this.fetchCompressed(e2, i2, t2);
      this._pendingRefs.remove(e2);
    } catch (t3) {
      this._pendingRefs.remove(e2);
      throw t3;
    }
    i2 instanceof Dict ? i2.objId = e2.toString() : i2 instanceof BaseStream && (i2.dict.objId = e2.toString());
    return i2;
  }
  fetchUncompressed(e2, t2, a2 = false) {
    const r2 = e2.gen;
    let i2 = e2.num;
    if (t2.gen !== r2) {
      const n3 = `Inconsistent generation in XRef: ${e2}`;
      if (this._generationFallback && t2.gen < r2) {
        warn(n3);
        return this.fetchUncompressed(Ref.get(i2, t2.gen), t2, a2);
      }
      throw new XRefEntryException(n3);
    }
    const n2 = this.stream.makeSubStream(t2.offset + this.stream.start), s2 = new Parser({ lexer: new Lexer(n2), xref: this, allowStreams: true }), o2 = s2.getObj(), c2 = s2.getObj(), l2 = s2.getObj();
    if (o2 !== i2 || c2 !== r2 || !(l2 instanceof Cmd)) throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e2}`);
    if ("obj" !== l2.cmd) {
      if (l2.cmd.startsWith("obj")) {
        i2 = parseInt(l2.cmd.substring(3), 10);
        if (!Number.isNaN(i2)) return i2;
      }
      throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e2}`);
    }
    (t2 = this.encrypt && !a2 ? s2.getObj(this.encrypt.createCipherTransform(i2, r2)) : s2.getObj()) instanceof BaseStream || this._cacheMap.set(i2, t2);
    return t2;
  }
  fetchCompressed(e2, t2, a2 = false) {
    const r2 = t2.offset, i2 = this.fetch(Ref.get(r2, 0));
    if (!(i2 instanceof BaseStream)) throw new FormatError("bad ObjStm stream");
    const n2 = i2.dict.get("First"), s2 = i2.dict.get("N");
    if (!Number.isInteger(n2) || !Number.isInteger(s2)) throw new FormatError("invalid first and n parameters for ObjStm stream");
    let o2 = new Parser({ lexer: new Lexer(i2), xref: this, allowStreams: true });
    const c2 = new Array(s2), l2 = new Array(s2);
    for (let e3 = 0; e3 < s2; ++e3) {
      const t3 = o2.getObj();
      if (!Number.isInteger(t3)) throw new FormatError(`invalid object number in the ObjStm stream: ${t3}`);
      const a3 = o2.getObj();
      if (!Number.isInteger(a3)) throw new FormatError(`invalid object offset in the ObjStm stream: ${a3}`);
      c2[e3] = t3;
      const i3 = this.getEntry(t3);
      i3?.offset === r2 && i3.gen !== e3 && (i3.gen = e3);
      l2[e3] = a3;
    }
    const h2 = (i2.start || 0) + n2, u2 = new Array(s2);
    for (let e3 = 0; e3 < s2; ++e3) {
      const t3 = e3 < s2 - 1 ? l2[e3 + 1] - l2[e3] : void 0;
      if (t3 < 0) throw new FormatError("Invalid offset in the ObjStm stream.");
      o2 = new Parser({ lexer: new Lexer(i2.makeSubStream(h2 + l2[e3], t3, i2.dict)), xref: this, allowStreams: true });
      const a3 = o2.getObj();
      u2[e3] = a3;
      if (a3 instanceof BaseStream) continue;
      const n3 = c2[e3], d2 = this.entries[n3];
      d2 && d2.offset === r2 && d2.gen === e3 && this._cacheMap.set(n3, a3);
    }
    if (void 0 === (t2 = u2[t2.gen])) throw new XRefEntryException(`Bad (compressed) XRef entry: ${e2}`);
    return t2;
  }
  async fetchIfRefAsync(e2, t2) {
    return e2 instanceof Ref ? this.fetchAsync(e2, t2) : e2;
  }
  async fetchAsync(e2, t2) {
    try {
      return this.fetch(e2, t2);
    } catch (a2) {
      if (!(a2 instanceof MissingDataException)) throw a2;
      await this.pdfManager.requestRange(a2.begin, a2.end);
      return this.fetchAsync(e2, t2);
    }
  }
  getCatalogObj() {
    return this.root;
  }
};
var yc = [0, 0, 612, 792];
var Page = class {
  #Ee = null;
  constructor({ pdfManager: e2, xref: t2, pageIndex: a2, pageDict: r2, ref: i2, globalIdFactory: n2, fontCache: s2, builtInCMapCache: o2, standardFontDataCache: c2, globalColorSpaceCache: l2, globalImageCache: h2, systemFontCache: u2, nonBlendModesSet: d2, xfaFactory: f2 }) {
    this.pdfManager = e2;
    this.pageIndex = a2;
    this.pageDict = r2;
    this.xref = t2;
    this.ref = i2;
    this.fontCache = s2;
    this.builtInCMapCache = o2;
    this.standardFontDataCache = c2;
    this.globalColorSpaceCache = l2;
    this.globalImageCache = h2;
    this.systemFontCache = u2;
    this.nonBlendModesSet = d2;
    this.evaluatorOptions = e2.evaluatorOptions;
    this.xfaFactory = f2;
    const g2 = { obj: 0 };
    this._localIdFactory = class extends n2 {
      static createObjId() {
        return `p${a2}_${++g2.obj}`;
      }
      static getPageObjId() {
        return `p${i2.toString()}`;
      }
    };
  }
  #Pe(e2) {
    return new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalColorSpaceCache: this.globalColorSpaceCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions });
  }
  #Le(e2, t2 = false) {
    const a2 = getInheritableProperty({ dict: this.pageDict, key: e2, getArray: t2, stopWhenFound: false });
    return Array.isArray(a2) ? 1 !== a2.length && a2[0] instanceof Dict ? Dict.merge({ xref: this.xref, dictArray: a2 }) : a2[0] : a2;
  }
  get content() {
    return this.pageDict.getArray("Contents");
  }
  get resources() {
    const e2 = this.#Le("Resources");
    return shadow(this, "resources", e2 instanceof Dict ? e2 : Dict.empty);
  }
  #je(e2) {
    if (this.xfaData) return this.xfaData.bbox;
    const t2 = lookupNormalRect(this.#Le(e2, true), null);
    if (t2) {
      if (t2[2] - t2[0] > 0 && t2[3] - t2[1] > 0) return t2;
      warn(`Empty, or invalid, /${e2} entry.`);
    }
    return null;
  }
  get mediaBox() {
    return shadow(this, "mediaBox", this.#je("MediaBox") || yc);
  }
  get cropBox() {
    return shadow(this, "cropBox", this.#je("CropBox") || this.mediaBox);
  }
  get userUnit() {
    const e2 = this.pageDict.get("UserUnit");
    return shadow(this, "userUnit", "number" == typeof e2 && e2 > 0 ? e2 : 1);
  }
  get view() {
    const { cropBox: e2, mediaBox: t2 } = this;
    if (e2 !== t2 && !isArrayEqual(e2, t2)) {
      const a2 = Util.intersect(e2, t2);
      if (a2 && a2[2] - a2[0] > 0 && a2[3] - a2[1] > 0) return shadow(this, "view", a2);
      warn("Empty /CropBox and /MediaBox intersection.");
    }
    return shadow(this, "view", t2);
  }
  get rotate() {
    let e2 = this.#Le("Rotate") || 0;
    e2 % 90 != 0 ? e2 = 0 : e2 >= 360 ? e2 %= 360 : e2 < 0 && (e2 = (e2 % 360 + 360) % 360);
    return shadow(this, "rotate", e2);
  }
  #_e(e2, t2) {
    if (!this.evaluatorOptions.ignoreErrors) throw e2;
    warn(`getContentStream - ignoring sub-stream (${t2}): "${e2}".`);
  }
  async getContentStream() {
    const e2 = await this.pdfManager.ensure(this, "content");
    return e2 instanceof BaseStream ? e2 : Array.isArray(e2) ? new StreamsSequenceStream(e2, this.#_e.bind(this)) : new NullStream();
  }
  get xfaData() {
    return shadow(this, "xfaData", this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null);
  }
  async #Ue(e2, t2, a2) {
    const r2 = [];
    for (const i2 of e2) if (i2.id) {
      const e3 = Ref.fromString(i2.id);
      if (!e3) {
        warn(`A non-linked annotation cannot be modified: ${i2.id}`);
        continue;
      }
      if (i2.deleted) {
        t2.put(e3, e3);
        if (i2.popupRef) {
          const e4 = Ref.fromString(i2.popupRef);
          e4 && t2.put(e4, e4);
        }
        continue;
      }
      if (i2.popup?.deleted) {
        const e4 = Ref.fromString(i2.popupRef);
        e4 && t2.put(e4, e4);
      }
      a2?.put(e3);
      i2.ref = e3;
      r2.push(this.xref.fetchAsync(e3).then(((e4) => {
        e4 instanceof Dict && (i2.oldAnnotation = e4.clone());
      }), (() => {
        warn(`Cannot fetch \`oldAnnotation\` for: ${e3}.`);
      })));
      delete i2.id;
    }
    await Promise.all(r2);
  }
  async saveNewAnnotations(e2, t2, a2, r2, i2) {
    if (this.xfaFactory) throw new Error("XFA: Cannot save new annotations.");
    const n2 = this.#Pe(e2), s2 = new RefSetCache(), o2 = new RefSet();
    await this.#Ue(a2, s2, o2);
    const c2 = this.pageDict, l2 = this.annotations.filter(((e3) => !(e3 instanceof Ref && s2.has(e3)))), h2 = await AnnotationFactory.saveNewAnnotations(n2, t2, a2, r2, i2);
    for (const { ref: e3 } of h2.annotations) e3 instanceof Ref && !o2.has(e3) && l2.push(e3);
    const u2 = c2.clone();
    u2.set("Annots", l2);
    i2.put(this.ref, { data: u2 });
    for (const e3 of s2) i2.put(e3, { data: null });
  }
  async save(e2, t2, a2, r2) {
    const i2 = this.#Pe(e2), n2 = await this._parsedAnnotations, s2 = [];
    for (const e3 of n2) s2.push(e3.save(i2, t2, a2, r2).catch((function(e4) {
      warn(`save - ignoring annotation data during "${t2.name}" task: "${e4}".`);
      return null;
    })));
    return Promise.all(s2);
  }
  async loadResources(e2) {
    await (this.#Ee ??= this.pdfManager.ensure(this, "resources"));
    await ObjectLoader.load(this.resources, e2, this.xref);
  }
  async #Xe(e2, t2) {
    const a2 = e2?.get("Resources");
    if (!(a2 instanceof Dict && a2.size)) return this.resources;
    await ObjectLoader.load(a2, t2, this.xref);
    return Dict.merge({ xref: this.xref, dictArray: [a2, this.resources], mergeSubDicts: true });
  }
  async getOperatorList({ handler: e2, sink: t2, task: a2, intent: r2, cacheKey: i2, annotationStorage: c2 = null, modifiedIds: d2 = null }) {
    const g2 = this.getContentStream(), p2 = this.loadResources(Ia), m2 = this.#Pe(e2), b2 = this.xfaFactory ? null : getNewAnnotationsMap(c2), y2 = b2?.get(this.pageIndex);
    let w2 = Promise.resolve(null), x2 = null;
    if (y2) {
      const e3 = this.pdfManager.ensureDoc("annotationGlobals");
      let t3;
      const r3 = /* @__PURE__ */ new Set();
      for (const { bitmapId: e4, bitmap: t4 } of y2) !e4 || t4 || r3.has(e4) || r3.add(e4);
      const { isOffscreenCanvasSupported: i3 } = this.evaluatorOptions;
      if (r3.size > 0) {
        const e4 = y2.slice();
        for (const [t4, a3] of c2) t4.startsWith(f) && a3.bitmap && r3.has(a3.bitmapId) && e4.push(a3);
        t3 = AnnotationFactory.generateImages(e4, this.xref, i3);
      } else t3 = AnnotationFactory.generateImages(y2, this.xref, i3);
      x2 = new RefSet();
      w2 = Promise.all([e3, this.#Ue(y2, x2, null)]).then((([e4]) => e4 ? AnnotationFactory.printNewAnnotations(e4, m2, a2, y2, t3) : null));
    }
    const S2 = Promise.all([g2, p2]).then((async ([n2]) => {
      const s2 = await this.#Xe(n2.dict, Ia), o2 = new OperatorList(r2, t2);
      e2.send("StartRenderPage", { transparency: m2.hasBlendModes(s2, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey: i2 });
      await m2.getOperatorList({ stream: n2, task: a2, resources: s2, operatorList: o2 });
      return o2;
    }));
    let [k2, C2, v2] = await Promise.all([S2, this._parsedAnnotations, w2]);
    if (v2) {
      C2 = C2.filter(((e3) => !(e3.ref && x2.has(e3.ref))));
      for (let e3 = 0, t3 = v2.length; e3 < t3; e3++) {
        const a3 = v2[e3];
        if (a3.refToReplace) {
          const r3 = C2.findIndex(((e4) => e4.ref && isRefsEqual(e4.ref, a3.refToReplace)));
          if (r3 >= 0) {
            C2.splice(r3, 1, a3);
            v2.splice(e3--, 1);
            t3--;
          }
        }
      }
      C2 = C2.concat(v2);
    }
    if (0 === C2.length || r2 & h) {
      k2.flush(true);
      return { length: k2.totalLength };
    }
    const F2 = !!(r2 & l), T2 = !!(r2 & u), O2 = !!(r2 & n), M2 = !!(r2 & s), D2 = !!(r2 & o), R2 = [];
    for (const e3 of C2) (O2 || M2 && e3.mustBeViewed(c2, F2) && e3.mustBeViewedWhenEditing(T2, d2) || D2 && e3.mustBePrinted(c2)) && R2.push(e3.getOperatorList(m2, a2, r2, c2).catch((function(e4) {
      warn(`getOperatorList - ignoring annotation data during "${a2.name}" task: "${e4}".`);
      return { opList: null, separateForm: false, separateCanvas: false };
    })));
    const N2 = await Promise.all(R2);
    let E2 = false, L2 = false;
    for (const { opList: e3, separateForm: t3, separateCanvas: a3 } of N2) {
      k2.addOpList(e3);
      E2 ||= t3;
      L2 ||= a3;
    }
    k2.flush(true, { form: E2, canvas: L2 });
    return { length: k2.totalLength };
  }
  async extractTextContent({ handler: e2, task: t2, includeMarkedContent: a2, disableNormalization: r2, sink: i2, intersector: n2 = null }) {
    const s2 = this.getContentStream(), o2 = this.loadResources(Ta), c2 = this.pdfManager.ensureCatalog("lang"), [l2, , h2] = await Promise.all([s2, o2, c2]), u2 = await this.#Xe(l2.dict, Ta);
    return this.#Pe(e2).getTextContent({ stream: l2, task: t2, resources: u2, includeMarkedContent: a2, disableNormalization: r2, sink: i2, viewBox: this.view, lang: h2, intersector: n2 });
  }
  async getStructTree() {
    const e2 = await this.pdfManager.ensureCatalog("structTreeRoot");
    if (!e2) return null;
    await this._parsedAnnotations;
    try {
      const t2 = await this.pdfManager.ensure(this, "_parseStructTree", [e2]);
      return await this.pdfManager.ensure(t2, "serializable");
    } catch (e3) {
      warn(`getStructTree: "${e3}".`);
      return null;
    }
  }
  _parseStructTree(e2) {
    const t2 = new StructTreePage(e2, this.pageDict);
    t2.parse(this.ref);
    return t2;
  }
  async getAnnotationsData(e2, t2, a2) {
    const r2 = await this._parsedAnnotations;
    if (0 === r2.length) return r2;
    const i2 = [], c2 = [];
    let l2;
    const h2 = !!(a2 & n), u2 = !!(a2 & s), d2 = !!(a2 & o), f2 = [];
    for (const a3 of r2) {
      const r3 = h2 || u2 && a3.viewable;
      (r3 || d2 && a3.printable) && i2.push(a3.data);
      if (a3.hasTextContent && r3) {
        l2 ??= this.#Pe(e2);
        c2.push(a3.extractTextContent(l2, t2, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch((function(e3) {
          warn(`getAnnotationsData - ignoring textContent during "${t2.name}" task: "${e3}".`);
        })));
      } else a3.overlaysTextContent && r3 && f2.push(a3);
    }
    if (f2.length > 0) {
      const a3 = new Intersector(f2);
      c2.push(this.extractTextContent({ handler: e2, task: t2, includeMarkedContent: false, disableNormalization: false, sink: null, viewBox: this.view, lang: null, intersector: a3 }).then((() => {
        a3.setText();
      })));
    }
    await Promise.all(c2);
    return i2;
  }
  get annotations() {
    const e2 = this.#Le("Annots");
    return shadow(this, "annotations", Array.isArray(e2) ? e2 : []);
  }
  get _parsedAnnotations() {
    return shadow(this, "_parsedAnnotations", this.pdfManager.ensure(this, "annotations").then((async (e2) => {
      if (0 === e2.length) return e2;
      const [t2, a2] = await Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureDoc("fieldObjects")]);
      if (!t2) return [];
      const r2 = a2?.orphanFields, i2 = [];
      for (const a3 of e2) i2.push(AnnotationFactory.create(this.xref, a3, t2, this._localIdFactory, false, r2, this.ref).catch((function(e3) {
        warn(`_parsedAnnotations: "${e3}".`);
        return null;
      })));
      const n2 = [];
      let s2, o2;
      for (const e3 of await Promise.all(i2)) e3 && (e3 instanceof WidgetAnnotation ? (o2 ||= []).push(e3) : e3 instanceof PopupAnnotation ? (s2 ||= []).push(e3) : n2.push(e3));
      o2 && n2.push(...o2);
      s2 && n2.push(...s2);
      return n2;
    })));
  }
  get jsActions() {
    return shadow(this, "jsActions", collectActions(this.xref, this.pageDict, xe));
  }
};
var wc = new Uint8Array([37, 80, 68, 70, 45]);
var xc = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]);
var Sc = new Uint8Array([101, 110, 100, 111, 98, 106]);
function find(e2, t2, a2 = 1024, r2 = false) {
  const i2 = t2.length, n2 = e2.peekBytes(a2), s2 = n2.length - i2;
  if (s2 <= 0) return false;
  if (r2) {
    const a3 = i2 - 1;
    let r3 = n2.length - 1;
    for (; r3 >= a3; ) {
      let s3 = 0;
      for (; s3 < i2 && n2[r3 - s3] === t2[a3 - s3]; ) s3++;
      if (s3 >= i2) {
        e2.pos += r3 - a3;
        return true;
      }
      r3--;
    }
  } else {
    let a3 = 0;
    for (; a3 <= s2; ) {
      let r3 = 0;
      for (; r3 < i2 && n2[a3 + r3] === t2[r3]; ) r3++;
      if (r3 >= i2) {
        e2.pos += a3;
        return true;
      }
      a3++;
    }
  }
  return false;
}
var PDFDocument = class {
  #qe = /* @__PURE__ */ new Map();
  #He = null;
  constructor(e2, t2) {
    if (t2.length <= 0) throw new InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
    this.pdfManager = e2;
    this.stream = t2;
    this.xref = new XRef(t2, e2);
    const a2 = { font: 0 };
    this._globalIdFactory = class {
      static getDocId() {
        return `g_${e2.docId}`;
      }
      static createFontId() {
        return "f" + ++a2.font;
      }
      static createObjId() {
        unreachable("Abstract method `createObjId` called.");
      }
      static getPageObjId() {
        unreachable("Abstract method `getPageObjId` called.");
      }
    };
  }
  parse(e2) {
    this.xref.parse(e2);
    this.catalog = new Catalog(this.pdfManager, this.xref);
  }
  get linearization() {
    let e2 = null;
    try {
      e2 = Linearization.create(this.stream);
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      info(e3);
    }
    return shadow(this, "linearization", e2);
  }
  get startXRef() {
    const e2 = this.stream;
    let t2 = 0;
    if (this.linearization) {
      e2.reset();
      if (find(e2, Sc)) {
        e2.skip(6);
        let a2 = e2.peekByte();
        for (; isWhiteSpace(a2); ) {
          e2.pos++;
          a2 = e2.peekByte();
        }
        t2 = e2.pos - e2.start;
      }
    } else {
      const a2 = 1024, r2 = xc.length;
      let i2 = false, n2 = e2.end;
      for (; !i2 && n2 > 0; ) {
        n2 -= a2 - r2;
        n2 < 0 && (n2 = 0);
        e2.pos = n2;
        i2 = find(e2, xc, a2, true);
      }
      if (i2) {
        e2.skip(9);
        let a3;
        do {
          a3 = e2.getByte();
        } while (isWhiteSpace(a3));
        let r3 = "";
        for (; a3 >= 32 && a3 <= 57; ) {
          r3 += String.fromCharCode(a3);
          a3 = e2.getByte();
        }
        t2 = parseInt(r3, 10);
        isNaN(t2) && (t2 = 0);
      }
    }
    return shadow(this, "startXRef", t2);
  }
  checkHeader() {
    const e2 = this.stream;
    e2.reset();
    if (!find(e2, wc)) return;
    e2.moveStart();
    e2.skip(wc.length);
    let t2, a2 = "";
    for (; (t2 = e2.getByte()) > 32 && a2.length < 7; ) a2 += String.fromCharCode(t2);
    Ca.test(a2) ? this.#He = a2 : warn(`Invalid PDF header version: ${a2}`);
  }
  parseStartXRef() {
    this.xref.setStartXRef(this.startXRef);
  }
  get numPages() {
    let e2 = 0;
    e2 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages;
    return shadow(this, "numPages", e2);
  }
  #We(e2, t2 = 0) {
    return !!Array.isArray(e2) && e2.every(((e3) => {
      if (!((e3 = this.xref.fetchIfRef(e3)) instanceof Dict)) return false;
      if (e3.has("Kids")) {
        if (++t2 > 10) {
          warn("#hasOnlyDocumentSignatures: maximum recursion depth reached");
          return false;
        }
        return this.#We(e3.get("Kids"), t2);
      }
      const a2 = isName(e3.get("FT"), "Sig"), r2 = e3.get("Rect"), i2 = Array.isArray(r2) && r2.every(((e4) => 0 === e4));
      return a2 && i2;
    }));
  }
  #ze(e2, t2, a2 = new RefSet()) {
    if (Array.isArray(e2)) for (let r2 of e2) {
      if (r2 instanceof Ref) {
        if (a2.has(r2)) continue;
        a2.put(r2);
      }
      r2 = this.xref.fetchIfRef(r2);
      if (!(r2 instanceof Dict)) continue;
      if (r2.has("Kids")) {
        this.#ze(r2.get("Kids"), t2, a2);
        continue;
      }
      if (!isName(r2.get("FT"), "Sig")) continue;
      const e3 = r2.get("V");
      if (!(e3 instanceof Dict)) continue;
      const i2 = e3.get("SubFilter");
      i2 instanceof Name && t2.add(i2.name);
    }
  }
  get _xfaStreams() {
    const { acroForm: e2 } = this.catalog;
    if (!e2) return null;
    const t2 = e2.get("XFA"), a2 = new Map(["xdp:xdp", "template", "datasets", "config", "connectionSet", "localeSet", "stylesheet", "/xdp:xdp"].map(((e3) => [e3, null])));
    if (t2 instanceof BaseStream && !t2.isEmpty) {
      a2.set("xdp:xdp", t2);
      return a2;
    }
    if (!Array.isArray(t2) || 0 === t2.length) return null;
    for (let e3 = 0, r2 = t2.length; e3 < r2; e3 += 2) {
      let i2;
      i2 = 0 === e3 ? "xdp:xdp" : e3 === r2 - 2 ? "/xdp:xdp" : t2[e3];
      if (!a2.has(i2)) continue;
      const n2 = this.xref.fetchIfRef(t2[e3 + 1]);
      n2 instanceof BaseStream && !n2.isEmpty && a2.set(i2, n2);
    }
    return a2;
  }
  get xfaDatasets() {
    const e2 = this._xfaStreams;
    if (!e2) return shadow(this, "xfaDatasets", null);
    for (const t2 of ["datasets", "xdp:xdp"]) {
      const a2 = e2.get(t2);
      if (a2) try {
        const e3 = stringToUTF8String(a2.getString());
        return shadow(this, "xfaDatasets", new DatasetReader({ [t2]: e3 }));
      } catch {
        warn("XFA - Invalid utf-8 string.");
        break;
      }
    }
    return shadow(this, "xfaDatasets", null);
  }
  get xfaData() {
    const e2 = this._xfaStreams;
    if (!e2) return null;
    const t2 = /* @__PURE__ */ Object.create(null);
    for (const [a2, r2] of e2) if (r2) try {
      t2[a2] = stringToUTF8String(r2.getString());
    } catch {
      warn("XFA - Invalid utf-8 string.");
      return null;
    }
    return t2;
  }
  get xfaFactory() {
    let e2;
    this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e2 = this.xfaData);
    return shadow(this, "xfaFactory", e2 ? new XFAFactory(e2) : null);
  }
  get isPureXfa() {
    return !!this.xfaFactory && this.xfaFactory.isValid();
  }
  get htmlForXfa() {
    return this.xfaFactory ? this.xfaFactory.getPages() : null;
  }
  async #$e() {
    const e2 = await this.pdfManager.ensureCatalog("xfaImages");
    e2 && this.xfaFactory.setImages(e2);
  }
  async #Ge(e2, t2) {
    const a2 = await this.pdfManager.ensureCatalog("acroForm");
    if (!a2) return;
    const r2 = await a2.getAsync("DR");
    if (!(r2 instanceof Dict)) return;
    await ObjectLoader.load(r2, ["Font"], this.xref);
    const i2 = r2.get("Font");
    if (!(i2 instanceof Dict)) return;
    const n2 = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions, { useSystemFonts: false }), { builtInCMapCache: s2, fontCache: o2, standardFontDataCache: c2 } = this.catalog, l2 = new PartialEvaluator({ xref: this.xref, handler: e2, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: o2, builtInCMapCache: s2, standardFontDataCache: c2, options: n2 }), h2 = new OperatorList(), u2 = [], d2 = { get font() {
      return u2.at(-1);
    }, set font(e3) {
      u2.push(e3);
    }, clone() {
      return this;
    } }, parseFont = (e3, a3, i3) => l2.handleSetFont(r2, [Name.get(e3), 1], null, h2, t2, d2, a3, i3).catch(((e4) => {
      warn(`loadXfaFonts: "${e4}".`);
      return null;
    })), f2 = [];
    for (const [e3, t3] of i2) {
      const a3 = t3.get("FontDescriptor");
      if (!(a3 instanceof Dict)) continue;
      let r3 = a3.get("FontFamily");
      r3 = r3.replaceAll(/[ ]+(\d)/g, "$1");
      const i3 = { fontFamily: r3, fontWeight: a3.get("FontWeight"), italicAngle: -a3.get("ItalicAngle") };
      validateCSSFont(i3) && f2.push(parseFont(e3, null, i3));
    }
    await Promise.all(f2);
    const g2 = this.xfaFactory.setFonts(u2);
    if (!g2) return;
    n2.ignoreErrors = true;
    f2.length = 0;
    u2.length = 0;
    const p2 = /* @__PURE__ */ new Set();
    for (const e3 of g2) getXfaFontName(`${e3}-Regular`) || p2.add(e3);
    p2.size && g2.push("PdfJS-Fallback");
    for (const e3 of g2) if (!p2.has(e3)) for (const t3 of [{ name: "Regular", fontWeight: 400, italicAngle: 0 }, { name: "Bold", fontWeight: 700, italicAngle: 0 }, { name: "Italic", fontWeight: 400, italicAngle: 12 }, { name: "BoldItalic", fontWeight: 700, italicAngle: 12 }]) {
      const a3 = `${e3}-${t3.name}`;
      f2.push(parseFont(a3, getXfaFontDict(a3), { fontFamily: e3, fontWeight: t3.fontWeight, italicAngle: t3.italicAngle }));
    }
    await Promise.all(f2);
    this.xfaFactory.appendFonts(u2, p2);
  }
  loadXfaResources(e2, t2) {
    return Promise.all([this.#Ge(e2, t2).catch((() => {
    })), this.#$e()]);
  }
  serializeXfaData(e2) {
    return this.xfaFactory ? this.xfaFactory.serializeData(e2) : null;
  }
  get version() {
    return this.catalog.version || this.#He;
  }
  get formInfo() {
    const e2 = { hasFields: false, hasAcroForm: false, hasXfa: false, hasSignatures: false }, { acroForm: t2 } = this.catalog;
    if (!t2) return shadow(this, "formInfo", e2);
    try {
      const a2 = t2.get("Fields"), r2 = Array.isArray(a2) && a2.length > 0;
      e2.hasFields = r2;
      const i2 = t2.get("XFA");
      e2.hasXfa = Array.isArray(i2) && i2.length > 0 || i2 instanceof BaseStream && !i2.isEmpty;
      const n2 = !!(1 & t2.get("SigFlags")), s2 = n2 && this.#We(a2);
      e2.hasAcroForm = r2 && !s2;
      e2.hasSignatures = n2;
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn(`Cannot fetch form information: "${e3}".`);
    }
    return shadow(this, "formInfo", e2);
  }
  get documentInfo() {
    const { catalog: e2, formInfo: t2, xref: a2 } = this, r2 = { PDFFormatVersion: this.version, Language: e2.lang, EncryptFilterName: a2.encrypt?.filterName ?? null, IsLinearized: !!this.linearization, IsAcroFormPresent: t2.hasAcroForm, IsXFAPresent: t2.hasXfa, IsCollectionPresent: !!e2.collection, IsSignaturesPresent: t2.hasSignatures };
    let i2;
    try {
      i2 = a2.trailer.get("Info");
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      info("The document information dictionary is invalid.");
    }
    if (!(i2 instanceof Dict)) return shadow(this, "documentInfo", r2);
    for (const [e3, t3] of i2) {
      switch (e3) {
        case "Title":
        case "Author":
        case "Subject":
        case "Keywords":
        case "Creator":
        case "Producer":
        case "CreationDate":
        case "ModDate":
          if ("string" == typeof t3) {
            r2[e3] = stringToPDFString(t3);
            continue;
          }
          break;
        case "Trapped":
          if (t3 instanceof Name) {
            r2[e3] = t3;
            continue;
          }
          break;
        default:
          let a3;
          switch (typeof t3) {
            case "string":
              a3 = stringToPDFString(t3);
              break;
            case "number":
            case "boolean":
              a3 = t3;
              break;
            default:
              t3 instanceof Name && (a3 = t3);
          }
          if (void 0 === a3) {
            warn(`Bad value, for custom key "${e3}", in Info: ${t3}.`);
            continue;
          }
          r2.Custom ??= /* @__PURE__ */ Object.create(null);
          r2.Custom[e3] = a3;
          continue;
      }
      warn(`Bad value, for key "${e3}", in Info: ${t3}.`);
    }
    return shadow(this, "documentInfo", r2);
  }
  get fingerprints() {
    const e2 = "\0".repeat(16);
    function validate(t3) {
      return "string" == typeof t3 && 16 === t3.length && t3 !== e2;
    }
    const t2 = this.xref.trailer.get("ID");
    let a2, r2;
    if (Array.isArray(t2) && validate(t2[0])) {
      a2 = stringToBytes(t2[0]);
      t2[1] !== t2[0] && validate(t2[1]) && (r2 = stringToBytes(t2[1]));
    } else a2 = calculateMD5(this.stream.getByteRange(0, 1024), 0, 1024);
    return shadow(this, "fingerprints", [toHexUtil(a2), r2 ? toHexUtil(r2) : null]);
  }
  async #Ve(e2) {
    const { catalog: t2, linearization: a2, xref: r2 } = this, i2 = Ref.get(a2.objectNumberFirst, 0);
    try {
      const e3 = await r2.fetchAsync(i2);
      if (e3 instanceof Dict) {
        let a3 = e3.getRaw("Type");
        a3 instanceof Ref && (a3 = await r2.fetchAsync(a3));
        if (isName(a3, "Page") || !e3.has("Type") && !e3.has("Kids") && e3.has("Contents")) {
          t2.pageKidsCountCache.has(i2) || t2.pageKidsCountCache.put(i2, 1);
          t2.pageIndexCache.has(i2) || t2.pageIndexCache.put(i2, 0);
          return [e3, i2];
        }
      }
      throw new FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
    } catch (a3) {
      warn(`_getLinearizationPage: "${a3.message}".`);
      return t2.getPageDict(e2);
    }
  }
  getPage(e2) {
    const t2 = this.#qe.get(e2);
    if (t2) return t2;
    const { catalog: a2, linearization: r2, xfaFactory: i2 } = this;
    let n2;
    n2 = i2 ? Promise.resolve([Dict.empty, null]) : r2?.pageFirst === e2 ? this.#Ve(e2) : a2.getPageDict(e2);
    n2 = n2.then((([t3, r3]) => new Page({ pdfManager: this.pdfManager, xref: this.xref, pageIndex: e2, pageDict: t3, ref: r3, globalIdFactory: this._globalIdFactory, fontCache: a2.fontCache, builtInCMapCache: a2.builtInCMapCache, standardFontDataCache: a2.standardFontDataCache, globalColorSpaceCache: a2.globalColorSpaceCache, globalImageCache: a2.globalImageCache, systemFontCache: a2.systemFontCache, nonBlendModesSet: a2.nonBlendModesSet, xfaFactory: i2 })));
    this.#qe.set(e2, n2);
    return n2;
  }
  async checkFirstPage(e2 = false) {
    if (!e2) try {
      await this.getPage(0);
    } catch (e3) {
      if (e3 instanceof XRefEntryException) {
        this.#qe.delete(0);
        await this.cleanup();
        throw new XRefParseException();
      }
    }
  }
  async checkLastPage(e2 = false) {
    const { catalog: t2, pdfManager: a2 } = this;
    t2.setActualNumPages();
    let r2;
    try {
      await Promise.all([a2.ensureDoc("xfaFactory"), a2.ensureDoc("linearization"), a2.ensureCatalog("numPages")]);
      if (this.xfaFactory) return;
      r2 = this.linearization ? this.linearization.numPages : t2.numPages;
      if (!Number.isInteger(r2)) throw new FormatError("Page count is not an integer.");
      if (r2 <= 1) return;
      await this.getPage(r2 - 1);
    } catch (i2) {
      this.#qe.delete(r2 - 1);
      await this.cleanup();
      if (i2 instanceof XRefEntryException && !e2) throw new XRefParseException();
      warn(`checkLastPage - invalid /Pages tree /Count: ${r2}.`);
      let n2;
      try {
        n2 = await t2.getAllPageDicts(e2);
      } catch (a3) {
        if (a3 instanceof XRefEntryException && !e2) throw new XRefParseException();
        t2.setActualNumPages(1);
        return;
      }
      for (const [e3, [r3, i3]] of n2) {
        let n3;
        if (r3 instanceof Error) {
          n3 = Promise.reject(r3);
          n3.catch((() => {
          }));
        } else n3 = Promise.resolve(new Page({ pdfManager: a2, xref: this.xref, pageIndex: e3, pageDict: r3, ref: i3, globalIdFactory: this._globalIdFactory, fontCache: t2.fontCache, builtInCMapCache: t2.builtInCMapCache, standardFontDataCache: t2.standardFontDataCache, globalColorSpaceCache: this.globalColorSpaceCache, globalImageCache: t2.globalImageCache, systemFontCache: t2.systemFontCache, nonBlendModesSet: t2.nonBlendModesSet, xfaFactory: null }));
        this.#qe.set(e3, n3);
      }
      t2.setActualNumPages(n2.size);
    }
  }
  async fontFallback(e2, t2) {
    const { catalog: a2, pdfManager: r2 } = this;
    for (const i2 of await Promise.all(a2.fontCache)) if (i2.loadedName === e2) {
      i2.fallback(t2, r2.evaluatorOptions);
      return;
    }
  }
  async cleanup(e2 = false) {
    return this.catalog ? this.catalog.cleanup(e2) : clearGlobalCaches();
  }
  async #Ke(e2, t2, a2, r2, i2, n2, s2) {
    const { xref: o2 } = this;
    if (!(a2 instanceof Ref) || n2.has(a2)) return;
    n2.put(a2);
    const c2 = await o2.fetchAsync(a2);
    if (!(c2 instanceof Dict)) return;
    let l2 = await c2.getAsync("Subtype");
    l2 = l2 instanceof Name ? l2.name : null;
    if ("Link" === l2) return;
    if (c2.has("T")) {
      const t3 = stringToPDFString(await c2.getAsync("T"));
      e2 = "" === e2 ? t3 : `${e2}.${t3}`;
    } else {
      let a3 = c2;
      for (; ; ) {
        a3 = a3.getRaw("Parent") || t2;
        if (a3 instanceof Ref) {
          if (n2.has(a3)) break;
          a3 = await o2.fetchAsync(a3);
        }
        if (!(a3 instanceof Dict)) break;
        if (a3.has("T")) {
          const t3 = stringToPDFString(await a3.getAsync("T"));
          e2 = "" === e2 ? t3 : `${e2}.${t3}`;
          break;
        }
      }
    }
    t2 && !c2.has("Parent") && isName(c2.get("Subtype"), "Widget") && s2.put(a2, t2);
    r2.has(e2) || r2.set(e2, []);
    r2.get(e2).push(AnnotationFactory.create(o2, a2, i2, null, true, s2, null).then(((e3) => e3?.getFieldObject())).catch((function(e3) {
      warn(`#collectFieldObjects: "${e3}".`);
      return null;
    })));
    if (!c2.has("Kids")) return;
    const h2 = await c2.getAsync("Kids");
    if (Array.isArray(h2)) for (const t3 of h2) await this.#Ke(e2, a2, t3, r2, i2, n2, s2);
  }
  get fieldObjects() {
    return shadow(this, "fieldObjects", this.pdfManager.ensureDoc("formInfo").then((async (e2) => {
      if (!e2.hasFields) return null;
      const t2 = await this.annotationGlobals;
      if (!t2) return null;
      const { acroForm: a2 } = t2, r2 = new RefSet(), i2 = /* @__PURE__ */ Object.create(null), n2 = /* @__PURE__ */ new Map(), s2 = new RefSetCache();
      for (const e3 of a2.get("Fields")) await this.#Ke("", null, e3, n2, t2, r2, s2);
      const o2 = [];
      for (const [e3, t3] of n2) o2.push(Promise.all(t3).then(((t4) => {
        (t4 = t4.filter(((e4) => !!e4))).length > 0 && (i2[e3] = t4);
      })));
      await Promise.all(o2);
      return { allFields: objectSize(i2) > 0 ? i2 : null, orphanFields: s2 };
    })));
  }
  get hasJSActions() {
    return shadow(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
  }
  async _parseHasJSActions() {
    const [e2, t2] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
    return !!e2 || !!t2?.allFields && Object.values(t2.allFields).some(((e3) => e3.some(((e4) => null !== e4.actions))));
  }
  get calculationOrderIds() {
    const e2 = this.catalog.acroForm?.get("CO");
    if (!Array.isArray(e2) || 0 === e2.length) return shadow(this, "calculationOrderIds", null);
    const t2 = [];
    for (const a2 of e2) a2 instanceof Ref && t2.push(a2.toString());
    return shadow(this, "calculationOrderIds", t2.length ? t2 : null);
  }
  get annotationGlobals() {
    return shadow(this, "annotationGlobals", AnnotationFactory.createGlobals(this.pdfManager));
  }
};
var BasePdfManager = class {
  constructor({ docBaseUrl: e2, docId: t2, enableXfa: a2, evaluatorOptions: r2, handler: i2, password: n2 }) {
    this._docBaseUrl = (function parseDocBaseUrl(e3) {
      if (e3) {
        const t3 = createValidAbsoluteUrl(e3);
        if (t3) return t3.href;
        warn(`Invalid absolute docBaseUrl: "${e3}".`);
      }
      return null;
    })(e2);
    this._docId = t2;
    this._password = n2;
    this.enableXfa = a2;
    r2.isOffscreenCanvasSupported &&= FeatureTest.isOffscreenCanvasSupported;
    r2.isImageDecoderSupported &&= FeatureTest.isImageDecoderSupported;
    this.evaluatorOptions = Object.freeze(r2);
    ImageResizer.setOptions(r2);
    JpegStream.setOptions(r2);
    OperatorList.setOptions(r2);
    const s2 = { ...r2, handler: i2 };
    JpxImage.setOptions(s2);
    IccColorSpace.setOptions(s2);
    CmykICCBasedCS.setOptions(s2);
  }
  get docId() {
    return this._docId;
  }
  get password() {
    return this._password;
  }
  get docBaseUrl() {
    return this._docBaseUrl;
  }
  ensureDoc(e2, t2) {
    return this.ensure(this.pdfDocument, e2, t2);
  }
  ensureXRef(e2, t2) {
    return this.ensure(this.pdfDocument.xref, e2, t2);
  }
  ensureCatalog(e2, t2) {
    return this.ensure(this.pdfDocument.catalog, e2, t2);
  }
  getPage(e2) {
    return this.pdfDocument.getPage(e2);
  }
  fontFallback(e2, t2) {
    return this.pdfDocument.fontFallback(e2, t2);
  }
  cleanup(e2 = false) {
    return this.pdfDocument.cleanup(e2);
  }
  async ensure(e2, t2, a2) {
    unreachable("Abstract method `ensure` called");
  }
  requestRange(e2, t2) {
    unreachable("Abstract method `requestRange` called");
  }
  requestLoadedStream(e2 = false) {
    unreachable("Abstract method `requestLoadedStream` called");
  }
  sendProgressiveData(e2) {
    unreachable("Abstract method `sendProgressiveData` called");
  }
  updatePassword(e2) {
    this._password = e2;
  }
  terminate(e2) {
    unreachable("Abstract method `terminate` called");
  }
};
var LocalPdfManager = class extends BasePdfManager {
  constructor(e2) {
    super(e2);
    const t2 = new Stream(e2.source);
    this.pdfDocument = new PDFDocument(this, t2);
    this._loadedStreamPromise = Promise.resolve(t2);
  }
  async ensure(e2, t2, a2) {
    const r2 = e2[t2];
    return "function" == typeof r2 ? r2.apply(e2, a2) : r2;
  }
  requestRange(e2, t2) {
    return Promise.resolve();
  }
  requestLoadedStream(e2 = false) {
    return this._loadedStreamPromise;
  }
  terminate(e2) {
  }
};
var NetworkPdfManager = class extends BasePdfManager {
  constructor(e2) {
    super(e2);
    this.streamManager = new ChunkedStreamManager(e2.source, { msgHandler: e2.handler, length: e2.length, disableAutoFetch: e2.disableAutoFetch, rangeChunkSize: e2.rangeChunkSize });
    this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
  }
  async ensure(e2, t2, a2) {
    try {
      const r2 = e2[t2];
      return "function" == typeof r2 ? r2.apply(e2, a2) : r2;
    } catch (r2) {
      if (!(r2 instanceof MissingDataException)) throw r2;
      await this.requestRange(r2.begin, r2.end);
      return this.ensure(e2, t2, a2);
    }
  }
  requestRange(e2, t2) {
    return this.streamManager.requestRange(e2, t2);
  }
  requestLoadedStream(e2 = false) {
    return this.streamManager.requestAllChunks(e2);
  }
  sendProgressiveData(e2) {
    this.streamManager.onReceiveData({ chunk: e2 });
  }
  terminate(e2) {
    this.streamManager.abort(e2);
  }
};
var Ac = 1;
var kc = 2;
var Cc = 1;
var vc = 2;
var Fc = 3;
var Ic = 4;
var Tc = 5;
var Oc = 6;
var Mc = 7;
var Dc = 8;
function onFn() {
}
function wrapReason(e2) {
  if (e2 instanceof AbortException || e2 instanceof InvalidPDFException || e2 instanceof PasswordException || e2 instanceof ResponseException || e2 instanceof UnknownErrorException) return e2;
  e2 instanceof Error || "object" == typeof e2 && null !== e2 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  switch (e2.name) {
    case "AbortException":
      return new AbortException(e2.message);
    case "InvalidPDFException":
      return new InvalidPDFException(e2.message);
    case "PasswordException":
      return new PasswordException(e2.message, e2.code);
    case "ResponseException":
      return new ResponseException(e2.message, e2.status, e2.missing);
    case "UnknownErrorException":
      return new UnknownErrorException(e2.message, e2.details);
  }
  return new UnknownErrorException(e2.message, e2.toString());
}
var MessageHandler = class {
  #Je = new AbortController();
  constructor(e2, t2, a2) {
    this.sourceName = e2;
    this.targetName = t2;
    this.comObj = a2;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = /* @__PURE__ */ Object.create(null);
    this.streamControllers = /* @__PURE__ */ Object.create(null);
    this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
    this.actionHandler = /* @__PURE__ */ Object.create(null);
    a2.addEventListener("message", this.#Ye.bind(this), { signal: this.#Je.signal });
  }
  #Ye({ data: e2 }) {
    if (e2.targetName !== this.sourceName) return;
    if (e2.stream) {
      this.#Ze(e2);
      return;
    }
    if (e2.callback) {
      const t3 = e2.callbackId, a2 = this.callbackCapabilities[t3];
      if (!a2) throw new Error(`Cannot resolve callback ${t3}`);
      delete this.callbackCapabilities[t3];
      if (e2.callback === Ac) a2.resolve(e2.data);
      else {
        if (e2.callback !== kc) throw new Error("Unexpected callback case");
        a2.reject(wrapReason(e2.reason));
      }
      return;
    }
    const t2 = this.actionHandler[e2.action];
    if (!t2) throw new Error(`Unknown action from worker: ${e2.action}`);
    if (e2.callbackId) {
      const a2 = this.sourceName, r2 = e2.sourceName, i2 = this.comObj;
      Promise.try(t2, e2.data).then((function(t3) {
        i2.postMessage({ sourceName: a2, targetName: r2, callback: Ac, callbackId: e2.callbackId, data: t3 });
      }), (function(t3) {
        i2.postMessage({ sourceName: a2, targetName: r2, callback: kc, callbackId: e2.callbackId, reason: wrapReason(t3) });
      }));
    } else e2.streamId ? this.#Qe(e2) : t2(e2.data);
  }
  on(e2, t2) {
    const a2 = this.actionHandler;
    if (a2[e2]) throw new Error(`There is already an actionName called "${e2}"`);
    a2[e2] = t2;
  }
  send(e2, t2, a2) {
    this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, data: t2 }, a2);
  }
  sendWithPromise(e2, t2, a2) {
    const r2 = this.callbackId++, i2 = Promise.withResolvers();
    this.callbackCapabilities[r2] = i2;
    try {
      this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: e2, callbackId: r2, data: t2 }, a2);
    } catch (e3) {
      i2.reject(e3);
    }
    return i2.promise;
  }
  sendWithStream(e2, t2, a2, r2) {
    const i2 = this.streamId++, n2 = this.sourceName, s2 = this.targetName, o2 = this.comObj;
    return new ReadableStream({ start: (a3) => {
      const c2 = Promise.withResolvers();
      this.streamControllers[i2] = { controller: a3, startCall: c2, pullCall: null, cancelCall: null, isClosed: false };
      o2.postMessage({ sourceName: n2, targetName: s2, action: e2, streamId: i2, data: t2, desiredSize: a3.desiredSize }, r2);
      return c2.promise;
    }, pull: (e3) => {
      const t3 = Promise.withResolvers();
      this.streamControllers[i2].pullCall = t3;
      o2.postMessage({ sourceName: n2, targetName: s2, stream: Oc, streamId: i2, desiredSize: e3.desiredSize });
      return t3.promise;
    }, cancel: (e3) => {
      assert(e3 instanceof Error, "cancel must have a valid reason");
      const t3 = Promise.withResolvers();
      this.streamControllers[i2].cancelCall = t3;
      this.streamControllers[i2].isClosed = true;
      o2.postMessage({ sourceName: n2, targetName: s2, stream: Cc, streamId: i2, reason: wrapReason(e3) });
      return t3.promise;
    } }, a2);
  }
  #Qe(e2) {
    const t2 = e2.streamId, a2 = this.sourceName, r2 = e2.sourceName, i2 = this.comObj, n2 = this, s2 = this.actionHandler[e2.action], o2 = { enqueue(e3, n3 = 1, s3) {
      if (this.isCancelled) return;
      const o3 = this.desiredSize;
      this.desiredSize -= n3;
      if (o3 > 0 && this.desiredSize <= 0) {
        this.sinkCapability = Promise.withResolvers();
        this.ready = this.sinkCapability.promise;
      }
      i2.postMessage({ sourceName: a2, targetName: r2, stream: Ic, streamId: t2, chunk: e3 }, s3);
    }, close() {
      if (!this.isCancelled) {
        this.isCancelled = true;
        i2.postMessage({ sourceName: a2, targetName: r2, stream: Fc, streamId: t2 });
        delete n2.streamSinks[t2];
      }
    }, error(e3) {
      assert(e3 instanceof Error, "error must have a valid reason");
      if (!this.isCancelled) {
        this.isCancelled = true;
        i2.postMessage({ sourceName: a2, targetName: r2, stream: Tc, streamId: t2, reason: wrapReason(e3) });
      }
    }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: false, desiredSize: e2.desiredSize, ready: null };
    o2.sinkCapability.resolve();
    o2.ready = o2.sinkCapability.promise;
    this.streamSinks[t2] = o2;
    Promise.try(s2, e2.data, o2).then((function() {
      i2.postMessage({ sourceName: a2, targetName: r2, stream: Dc, streamId: t2, success: true });
    }), (function(e3) {
      i2.postMessage({ sourceName: a2, targetName: r2, stream: Dc, streamId: t2, reason: wrapReason(e3) });
    }));
  }
  #Ze(e2) {
    const t2 = e2.streamId, a2 = this.sourceName, r2 = e2.sourceName, i2 = this.comObj, n2 = this.streamControllers[t2], s2 = this.streamSinks[t2];
    switch (e2.stream) {
      case Dc:
        e2.success ? n2.startCall.resolve() : n2.startCall.reject(wrapReason(e2.reason));
        break;
      case Mc:
        e2.success ? n2.pullCall.resolve() : n2.pullCall.reject(wrapReason(e2.reason));
        break;
      case Oc:
        if (!s2) {
          i2.postMessage({ sourceName: a2, targetName: r2, stream: Mc, streamId: t2, success: true });
          break;
        }
        s2.desiredSize <= 0 && e2.desiredSize > 0 && s2.sinkCapability.resolve();
        s2.desiredSize = e2.desiredSize;
        Promise.try(s2.onPull || onFn).then((function() {
          i2.postMessage({ sourceName: a2, targetName: r2, stream: Mc, streamId: t2, success: true });
        }), (function(e3) {
          i2.postMessage({ sourceName: a2, targetName: r2, stream: Mc, streamId: t2, reason: wrapReason(e3) });
        }));
        break;
      case Ic:
        assert(n2, "enqueue should have stream controller");
        if (n2.isClosed) break;
        n2.controller.enqueue(e2.chunk);
        break;
      case Fc:
        assert(n2, "close should have stream controller");
        if (n2.isClosed) break;
        n2.isClosed = true;
        n2.controller.close();
        this.#et(n2, t2);
        break;
      case Tc:
        assert(n2, "error should have stream controller");
        n2.controller.error(wrapReason(e2.reason));
        this.#et(n2, t2);
        break;
      case vc:
        e2.success ? n2.cancelCall.resolve() : n2.cancelCall.reject(wrapReason(e2.reason));
        this.#et(n2, t2);
        break;
      case Cc:
        if (!s2) break;
        const o2 = wrapReason(e2.reason);
        Promise.try(s2.onCancel || onFn, o2).then((function() {
          i2.postMessage({ sourceName: a2, targetName: r2, stream: vc, streamId: t2, success: true });
        }), (function(e3) {
          i2.postMessage({ sourceName: a2, targetName: r2, stream: vc, streamId: t2, reason: wrapReason(e3) });
        }));
        s2.sinkCapability.reject(o2);
        s2.isCancelled = true;
        delete this.streamSinks[t2];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  }
  async #et(e2, t2) {
    await Promise.allSettled([e2.startCall?.promise, e2.pullCall?.promise, e2.cancelCall?.promise]);
    delete this.streamControllers[t2];
  }
  destroy() {
    this.#Je?.abort();
    this.#Je = null;
  }
};
async function writeObject(e2, t2, a2, { encrypt: r2 = null }) {
  const i2 = r2?.createCipherTransform(e2.num, e2.gen);
  a2.push(`${e2.num} ${e2.gen} obj
`);
  t2 instanceof Dict ? await writeDict(t2, a2, i2) : t2 instanceof BaseStream ? await writeStream(t2, a2, i2) : (Array.isArray(t2) || ArrayBuffer.isView(t2)) && await writeArray(t2, a2, i2);
  a2.push("\nendobj\n");
}
async function writeDict(e2, t2, a2) {
  t2.push("<<");
  for (const r2 of e2.getKeys()) {
    t2.push(` /${escapePDFName(r2)} `);
    await writeValue(e2.getRaw(r2), t2, a2);
  }
  t2.push(">>");
}
async function writeStream(e2, t2, a2) {
  let r2 = e2.getBytes();
  const { dict: i2 } = e2, [n2, s2] = await Promise.all([i2.getAsync("Filter"), i2.getAsync("DecodeParms")]), o2 = isName(Array.isArray(n2) ? await i2.xref.fetchIfRefAsync(n2[0]) : n2, "FlateDecode");
  if (r2.length >= 256 || o2) try {
    const e3 = new CompressionStream("deflate"), t3 = e3.writable.getWriter();
    await t3.ready;
    t3.write(r2).then((async () => {
      await t3.ready;
      await t3.close();
    })).catch((() => {
    }));
    const a3 = await new Response(e3.readable).arrayBuffer();
    r2 = new Uint8Array(a3);
    let c3, l2;
    if (n2) {
      if (!o2) {
        c3 = Array.isArray(n2) ? [Name.get("FlateDecode"), ...n2] : [Name.get("FlateDecode"), n2];
        s2 && (l2 = Array.isArray(s2) ? [null, ...s2] : [null, s2]);
      }
    } else c3 = Name.get("FlateDecode");
    c3 && i2.set("Filter", c3);
    l2 && i2.set("DecodeParms", l2);
  } catch (e3) {
    info(`writeStream - cannot compress data: "${e3}".`);
  }
  let c2 = bytesToString(r2);
  a2 && (c2 = a2.encryptString(c2));
  i2.set("Length", c2.length);
  await writeDict(i2, t2, a2);
  t2.push(" stream\n", c2, "\nendstream");
}
async function writeArray(e2, t2, a2) {
  t2.push("[");
  let r2 = true;
  for (const i2 of e2) {
    r2 ? r2 = false : t2.push(" ");
    await writeValue(i2, t2, a2);
  }
  t2.push("]");
}
async function writeValue(e2, t2, a2) {
  if (e2 instanceof Name) t2.push(`/${escapePDFName(e2.name)}`);
  else if (e2 instanceof Ref) t2.push(`${e2.num} ${e2.gen} R`);
  else if (Array.isArray(e2) || ArrayBuffer.isView(e2)) await writeArray(e2, t2, a2);
  else if ("string" == typeof e2) {
    a2 && (e2 = a2.encryptString(e2));
    t2.push(`(${escapeString(e2)})`);
  } else "number" == typeof e2 ? t2.push(numberToString(e2)) : "boolean" == typeof e2 ? t2.push(e2.toString()) : e2 instanceof Dict ? await writeDict(e2, t2, a2) : e2 instanceof BaseStream ? await writeStream(e2, t2, a2) : null === e2 ? t2.push("null") : warn(`Unhandled value in writer: ${typeof e2}, please file a bug.`);
}
function writeInt(e2, t2, a2, r2) {
  for (let i2 = t2 + a2 - 1; i2 > a2 - 1; i2--) {
    r2[i2] = 255 & e2;
    e2 >>= 8;
  }
  return a2 + t2;
}
function writeString(e2, t2, a2) {
  const r2 = e2.length;
  for (let i2 = 0; i2 < r2; i2++) a2[t2 + i2] = 255 & e2.charCodeAt(i2);
  return t2 + r2;
}
function updateXFA({ xfaData: e2, xfaDatasetsRef: t2, changes: a2, xref: r2 }) {
  if (null === e2) {
    e2 = (function writeXFADataForAcroform(e3, t3) {
      const a3 = new SimpleXMLParser({ hasAttributes: true }).parseFromString(e3);
      for (const { xfa: e4 } of t3) {
        if (!e4) continue;
        const { path: t4, value: r4 } = e4;
        if (!t4) continue;
        const i3 = parseXFAPath(t4);
        let n2 = a3.documentElement.searchNode(i3, 0);
        !n2 && i3.length > 1 && (n2 = a3.documentElement.searchNode([i3.at(-1)], 0));
        n2 ? n2.childNodes = Array.isArray(r4) ? r4.map(((e5) => new SimpleDOMNode("value", e5))) : [new SimpleDOMNode("#text", r4)] : warn(`Node not found for path: ${t4}`);
      }
      const r3 = [];
      a3.documentElement.dump(r3);
      return r3.join("");
    })(r2.fetchIfRef(t2).getString(), a2);
  }
  const i2 = new StringStream(e2);
  i2.dict = new Dict(r2);
  i2.dict.setIfName("Type", "EmbeddedFile");
  a2.put(t2, { data: i2 });
}
function getIndexes(e2) {
  const t2 = [];
  for (const { ref: a2 } of e2) a2.num === t2.at(-2) + t2.at(-1) ? t2[t2.length - 1] += 1 : t2.push(a2.num, 1);
  return t2;
}
function computeIDs(e2, t2, a2) {
  if (Array.isArray(t2.fileIds) && t2.fileIds.length > 0) {
    const r2 = (function computeMD5(e3, t3) {
      const a3 = Math.floor(Date.now() / 1e3), r3 = t3.filename || "", i2 = [a3.toString(), r3, e3.toString(), ...t3.infoMap.values()], n2 = Math.sumPrecise(i2.map(((e4) => e4.length))), s2 = new Uint8Array(n2);
      let o2 = 0;
      for (const e4 of i2) o2 = writeString(e4, o2, s2);
      return bytesToString(calculateMD5(s2, 0, s2.length));
    })(e2, t2);
    a2.set("ID", [t2.fileIds[0], r2]);
  }
}
async function incrementalUpdate({ originalData: e2, xrefInfo: t2, changes: a2, xref: r2 = null, hasXfa: i2 = false, xfaDatasetsRef: n2 = null, hasXfaDatasetsEntry: s2 = false, needAppearances: o2, acroFormRef: c2 = null, acroForm: l2 = null, xfaData: h2 = null, useXrefStream: u2 = false }) {
  await (async function updateAcroform({ xref: e3, acroForm: t3, acroFormRef: a3, hasXfa: r3, hasXfaDatasetsEntry: i3, xfaDatasetsRef: n3, needAppearances: s3, changes: o3 }) {
    !r3 || i3 || n3 || warn("XFA - Cannot save it");
    if (!s3 && (!r3 || !n3 || i3)) return;
    const c3 = t3.clone();
    if (r3 && !i3) {
      const e4 = t3.get("XFA").slice();
      e4.splice(2, 0, "datasets");
      e4.splice(3, 0, n3);
      c3.set("XFA", e4);
    }
    s3 && c3.set("NeedAppearances", true);
    o3.put(a3, { data: c3 });
  })({ xref: r2, acroForm: l2, acroFormRef: c2, hasXfa: i2, hasXfaDatasetsEntry: s2, xfaDatasetsRef: n2, needAppearances: o2, changes: a2 });
  i2 && updateXFA({ xfaData: h2, xfaDatasetsRef: n2, changes: a2, xref: r2 });
  const d2 = (function getTrailerDict(e3, t3, a3) {
    const r3 = new Dict(null);
    r3.set("Prev", e3.startXRef);
    const i3 = e3.newRef;
    if (a3) {
      t3.put(i3, { data: "" });
      r3.set("Size", i3.num + 1);
      r3.setIfName("Type", "XRef");
    } else r3.set("Size", i3.num);
    null !== e3.rootRef && r3.set("Root", e3.rootRef);
    null !== e3.infoRef && r3.set("Info", e3.infoRef);
    null !== e3.encryptRef && r3.set("Encrypt", e3.encryptRef);
    return r3;
  })(t2, a2, u2), f2 = [], g2 = await (async function writeChanges(e3, t3, a3 = []) {
    const r3 = [];
    for (const [i3, { data: n3 }] of e3.items()) if (null !== n3 && "string" != typeof n3) {
      await writeObject(i3, n3, a3, t3);
      r3.push({ ref: i3, data: a3.join("") });
      a3.length = 0;
    } else r3.push({ ref: i3, data: n3 });
    return r3.sort(((e4, t4) => e4.ref.num - t4.ref.num));
  })(a2, r2, f2);
  let p2 = e2.length;
  const m2 = e2.at(-1);
  if (10 !== m2 && 13 !== m2) {
    f2.push("\n");
    p2 += 1;
  }
  for (const { data: e3 } of g2) null !== e3 && f2.push(e3);
  await (u2 ? (async function getXRefStreamTable(e3, t3, a3, r3, i3) {
    const n3 = [];
    let s3 = 0, o3 = 0;
    for (const { ref: e4, data: r4 } of a3) {
      let a4;
      s3 = Math.max(s3, t3);
      if (null !== r4) {
        a4 = Math.min(e4.gen, 65535);
        n3.push([1, t3, a4]);
        t3 += r4.length;
      } else {
        a4 = Math.min(e4.gen + 1, 65535);
        n3.push([0, 0, a4]);
      }
      o3 = Math.max(o3, a4);
    }
    r3.set("Index", getIndexes(a3));
    const c3 = [1, getSizeInBytes(s3), getSizeInBytes(o3)];
    r3.set("W", c3);
    computeIDs(t3, e3, r3);
    const l3 = Math.sumPrecise(c3), h3 = new Uint8Array(l3 * n3.length), u3 = new Stream(h3);
    u3.dict = r3;
    let d3 = 0;
    for (const [e4, t4, a4] of n3) {
      d3 = writeInt(e4, c3[0], d3, h3);
      d3 = writeInt(t4, c3[1], d3, h3);
      d3 = writeInt(a4, c3[2], d3, h3);
    }
    await writeObject(e3.newRef, u3, i3, {});
    i3.push("startxref\n", t3.toString(), "\n%%EOF\n");
  })(t2, p2, g2, d2, f2) : (async function getXRefTable(e3, t3, a3, r3, i3) {
    i3.push("xref\n");
    const n3 = getIndexes(a3);
    let s3 = 0;
    for (const { ref: e4, data: r4 } of a3) {
      if (e4.num === n3[s3]) {
        i3.push(`${n3[s3]} ${n3[s3 + 1]}
`);
        s3 += 2;
      }
      if (null !== r4) {
        i3.push(`${t3.toString().padStart(10, "0")} ${Math.min(e4.gen, 65535).toString().padStart(5, "0")} n\r
`);
        t3 += r4.length;
      } else i3.push(`0000000000 ${Math.min(e4.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
    }
    computeIDs(t3, e3, r3);
    i3.push("trailer\n");
    await writeDict(r3, i3);
    i3.push("\nstartxref\n", t3.toString(), "\n%%EOF\n");
  })(t2, p2, g2, d2, f2));
  const b2 = e2.length + Math.sumPrecise(f2.map(((e3) => e3.length))), y2 = new Uint8Array(b2);
  y2.set(e2);
  let w2 = e2.length;
  for (const e3 of f2) w2 = writeString(e3, w2, y2);
  return y2;
}
var PDFWorkerStream = class {
  constructor(e2) {
    this._msgHandler = e2;
    this._contentLength = null;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }
  getFullReader() {
    assert(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
    return this._fullRequestReader;
  }
  getRangeReader(e2, t2) {
    const a2 = new PDFWorkerStreamRangeReader(e2, t2, this._msgHandler);
    this._rangeRequestReaders.push(a2);
    return a2;
  }
  cancelAllRequests(e2) {
    this._fullRequestReader?.cancel(e2);
    for (const t2 of this._rangeRequestReaders.slice(0)) t2.cancel(e2);
  }
};
var PDFWorkerStreamReader = class {
  constructor(e2) {
    this._msgHandler = e2;
    this.onProgress = null;
    this._contentLength = null;
    this._isRangeSupported = false;
    this._isStreamingSupported = false;
    const t2 = this._msgHandler.sendWithStream("GetReader");
    this._reader = t2.getReader();
    this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then(((e3) => {
      this._isStreamingSupported = e3.isStreamingSupported;
      this._isRangeSupported = e3.isRangeSupported;
      this._contentLength = e3.contentLength;
    }));
  }
  get headersReady() {
    return this._headersReady;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  async read() {
    const { value: e2, done: t2 } = await this._reader.read();
    return t2 ? { value: void 0, done: true } : { value: e2.buffer, done: false };
  }
  cancel(e2) {
    this._reader.cancel(e2);
  }
};
var PDFWorkerStreamRangeReader = class {
  constructor(e2, t2, a2) {
    this._msgHandler = a2;
    this.onProgress = null;
    const r2 = this._msgHandler.sendWithStream("GetRangeReader", { begin: e2, end: t2 });
    this._reader = r2.getReader();
  }
  get isStreamingSupported() {
    return false;
  }
  async read() {
    const { value: e2, done: t2 } = await this._reader.read();
    return t2 ? { value: void 0, done: true } : { value: e2.buffer, done: false };
  }
  cancel(e2) {
    this._reader.cancel(e2);
  }
};
var WorkerTask = class {
  constructor(e2) {
    this.name = e2;
    this.terminated = false;
    this._capability = Promise.withResolvers();
  }
  get finished() {
    return this._capability.promise;
  }
  finish() {
    this._capability.resolve();
  }
  terminate() {
    this.terminated = true;
  }
  ensureNotTerminated() {
    if (this.terminated) throw new Error("Worker task was terminated");
  }
};
var _WorkerMessageHandler = class _WorkerMessageHandler {
  static setup(e2, t2) {
    let a2 = false;
    e2.on("test", ((t3) => {
      if (!a2) {
        a2 = true;
        e2.send("test", t3 instanceof Uint8Array);
      }
    }));
    e2.on("configure", ((e3) => {
      !(function setVerbosityLevel(e4) {
        Number.isInteger(e4) && (da = e4);
      })(e3.verbosity);
    }));
    e2.on("GetDocRequest", ((e3) => this.createDocumentHandler(e3, t2)));
  }
  static createDocumentHandler(e2, t2) {
    let a2, r2 = false, i2 = null;
    const n2 = /* @__PURE__ */ new Set(), s2 = getVerbosityLevel(), { docId: o2, apiVersion: c2 } = e2, l2 = "5.4.54";
    if (c2 !== l2) throw new Error(`The API version "${c2}" does not match the Worker version "${l2}".`);
    const buildMsg = (e3, t3) => `The \`${e3}.prototype\` contains unexpected enumerable property "${t3}", thus breaking e.g. \`for...in\` iteration of ${e3}s.`;
    for (const e3 in {}) throw new Error(buildMsg("Object", e3));
    for (const e3 in []) throw new Error(buildMsg("Array", e3));
    const h2 = o2 + "_worker";
    let u2 = new MessageHandler(h2, o2, t2);
    function ensureNotTerminated() {
      if (r2) throw new Error("Worker was terminated");
    }
    function startWorkerTask(e3) {
      n2.add(e3);
    }
    function finishWorkerTask(e3) {
      e3.finish();
      n2.delete(e3);
    }
    async function loadDocument(e3) {
      await a2.ensureDoc("checkHeader");
      await a2.ensureDoc("parseStartXRef");
      await a2.ensureDoc("parse", [e3]);
      await a2.ensureDoc("checkFirstPage", [e3]);
      await a2.ensureDoc("checkLastPage", [e3]);
      const t3 = await a2.ensureDoc("isPureXfa");
      if (t3) {
        const e4 = new WorkerTask("loadXfaResources");
        startWorkerTask(e4);
        await a2.ensureDoc("loadXfaResources", [u2, e4]);
        finishWorkerTask(e4);
      }
      const [r3, i3] = await Promise.all([a2.ensureDoc("numPages"), a2.ensureDoc("fingerprints")]);
      return { numPages: r3, fingerprints: i3, htmlForXfa: t3 ? await a2.ensureDoc("htmlForXfa") : null };
    }
    function setupDoc(e3) {
      function onSuccess(e4) {
        ensureNotTerminated();
        u2.send("GetDoc", { pdfInfo: e4 });
      }
      function onFailure(e4) {
        ensureNotTerminated();
        if (e4 instanceof PasswordException) {
          const t3 = new WorkerTask(`PasswordException: response ${e4.code}`);
          startWorkerTask(t3);
          u2.sendWithPromise("PasswordRequest", e4).then((function({ password: e5 }) {
            finishWorkerTask(t3);
            a2.updatePassword(e5);
            pdfManagerReady();
          })).catch((function() {
            finishWorkerTask(t3);
            u2.send("DocException", e4);
          }));
        } else u2.send("DocException", wrapReason(e4));
      }
      function pdfManagerReady() {
        ensureNotTerminated();
        loadDocument(false).then(onSuccess, (function(e4) {
          ensureNotTerminated();
          e4 instanceof XRefParseException ? a2.requestLoadedStream().then((function() {
            ensureNotTerminated();
            loadDocument(true).then(onSuccess, onFailure);
          })) : onFailure(e4);
        }));
      }
      ensureNotTerminated();
      (async function getPdfManager({ data: e4, password: t3, disableAutoFetch: a3, rangeChunkSize: r3, length: n3, docBaseUrl: s3, enableXfa: c3, evaluatorOptions: l3 }) {
        const h3 = { source: null, disableAutoFetch: a3, docBaseUrl: s3, docId: o2, enableXfa: c3, evaluatorOptions: l3, handler: u2, length: n3, password: t3, rangeChunkSize: r3 };
        if (e4) {
          h3.source = e4;
          return new LocalPdfManager(h3);
        }
        const d2 = new PDFWorkerStream(u2), f2 = d2.getFullReader(), g2 = Promise.withResolvers();
        let p2, m2 = [], b2 = 0;
        f2.headersReady.then((function() {
          if (f2.isRangeSupported) {
            h3.source = d2;
            h3.length = f2.contentLength;
            h3.disableAutoFetch ||= f2.isStreamingSupported;
            p2 = new NetworkPdfManager(h3);
            for (const e5 of m2) p2.sendProgressiveData(e5);
            m2 = [];
            g2.resolve(p2);
            i2 = null;
          }
        })).catch((function(e5) {
          g2.reject(e5);
          i2 = null;
        }));
        new Promise((function(e5, t4) {
          const readChunk = function({ value: e6, done: a4 }) {
            try {
              ensureNotTerminated();
              if (a4) {
                if (!p2) {
                  const e7 = arrayBuffersToBytes(m2);
                  m2 = [];
                  n3 && e7.length !== n3 && warn("reported HTTP length is different from actual");
                  h3.source = e7;
                  p2 = new LocalPdfManager(h3);
                  g2.resolve(p2);
                }
                i2 = null;
                return;
              }
              b2 += e6.byteLength;
              f2.isStreamingSupported || u2.send("DocProgress", { loaded: b2, total: Math.max(b2, f2.contentLength || 0) });
              p2 ? p2.sendProgressiveData(e6) : m2.push(e6);
              f2.read().then(readChunk, t4);
            } catch (e7) {
              t4(e7);
            }
          };
          f2.read().then(readChunk, t4);
        })).catch((function(e5) {
          g2.reject(e5);
          i2 = null;
        }));
        i2 = (e5) => {
          d2.cancelAllRequests(e5);
        };
        return g2.promise;
      })(e3).then((function(e4) {
        if (r2) {
          e4.terminate(new AbortException("Worker was terminated."));
          throw new Error("Worker was terminated");
        }
        a2 = e4;
        a2.requestLoadedStream(true).then(((e5) => {
          u2.send("DataLoaded", { length: e5.bytes.byteLength });
        }));
      })).then(pdfManagerReady, onFailure);
    }
    u2.on("GetPage", (function(e3) {
      return a2.getPage(e3.pageIndex).then((function(e4) {
        return Promise.all([a2.ensure(e4, "rotate"), a2.ensure(e4, "ref"), a2.ensure(e4, "userUnit"), a2.ensure(e4, "view")]).then((function([e5, t3, a3, r3]) {
          return { rotate: e5, ref: t3, refStr: t3?.toString() ?? null, userUnit: a3, view: r3 };
        }));
      }));
    }));
    u2.on("GetPageIndex", (function(e3) {
      const t3 = Ref.get(e3.num, e3.gen);
      return a2.ensureCatalog("getPageIndex", [t3]);
    }));
    u2.on("GetDestinations", (function(e3) {
      return a2.ensureCatalog("destinations");
    }));
    u2.on("GetDestination", (function(e3) {
      return a2.ensureCatalog("getDestination", [e3.id]);
    }));
    u2.on("GetPageLabels", (function(e3) {
      return a2.ensureCatalog("pageLabels");
    }));
    u2.on("GetPageLayout", (function(e3) {
      return a2.ensureCatalog("pageLayout");
    }));
    u2.on("GetPageMode", (function(e3) {
      return a2.ensureCatalog("pageMode");
    }));
    u2.on("GetViewerPreferences", (function(e3) {
      return a2.ensureCatalog("viewerPreferences");
    }));
    u2.on("GetOpenAction", (function(e3) {
      return a2.ensureCatalog("openAction");
    }));
    u2.on("GetAttachments", (function(e3) {
      return a2.ensureCatalog("attachments");
    }));
    u2.on("GetDocJSActions", (function(e3) {
      return a2.ensureCatalog("jsActions");
    }));
    u2.on("GetPageJSActions", (function({ pageIndex: e3 }) {
      return a2.getPage(e3).then(((e4) => a2.ensure(e4, "jsActions")));
    }));
    u2.on("GetOutline", (function(e3) {
      return a2.ensureCatalog("documentOutline");
    }));
    u2.on("GetOptionalContentConfig", (function(e3) {
      return a2.ensureCatalog("optionalContentConfig");
    }));
    u2.on("GetPermissions", (function(e3) {
      return a2.ensureCatalog("permissions");
    }));
    u2.on("GetMetadata", (function(e3) {
      return Promise.all([a2.ensureDoc("documentInfo"), a2.ensureCatalog("metadata")]);
    }));
    u2.on("GetMarkInfo", (function(e3) {
      return a2.ensureCatalog("markInfo");
    }));
    u2.on("GetData", (function(e3) {
      return a2.requestLoadedStream().then(((e4) => e4.bytes));
    }));
    u2.on("GetAnnotations", (function({ pageIndex: e3, intent: t3 }) {
      return a2.getPage(e3).then((function(a3) {
        const r3 = new WorkerTask(`GetAnnotations: page ${e3}`);
        startWorkerTask(r3);
        return a3.getAnnotationsData(u2, r3, t3).then(((e4) => {
          finishWorkerTask(r3);
          return e4;
        }), ((e4) => {
          finishWorkerTask(r3);
          throw e4;
        }));
      }));
    }));
    u2.on("GetFieldObjects", (function(e3) {
      return a2.ensureDoc("fieldObjects").then(((e4) => e4?.allFields || null));
    }));
    u2.on("HasJSActions", (function(e3) {
      return a2.ensureDoc("hasJSActions");
    }));
    u2.on("GetCalculationOrderIds", (function(e3) {
      return a2.ensureDoc("calculationOrderIds");
    }));
    u2.on("SaveDocument", (async function({ isPureXfa: e3, numPages: t3, annotationStorage: r3, filename: i3 }) {
      const n3 = [a2.requestLoadedStream(), a2.ensureCatalog("acroForm"), a2.ensureCatalog("acroFormRef"), a2.ensureDoc("startXRef"), a2.ensureDoc("xref"), a2.ensureDoc("linearization"), a2.ensureCatalog("structTreeRoot")], s3 = new RefSetCache(), o3 = [], c3 = e3 ? null : getNewAnnotationsMap(r3), [l3, h3, d2, f2, g2, p2, m2] = await Promise.all(n3), b2 = g2.trailer.getRaw("Root") || null;
      let y2;
      if (c3) {
        m2 ? await m2.canUpdateStructTree({ pdfManager: a2, newAnnotationsByPage: c3 }) && (y2 = m2) : await StructTreeRoot.canCreateStructureTree({ catalogRef: b2, pdfManager: a2, newAnnotationsByPage: c3 }) && (y2 = null);
        const e4 = AnnotationFactory.generateImages(r3.values(), g2, a2.evaluatorOptions.isOffscreenCanvasSupported), t4 = void 0 === y2 ? o3 : [];
        for (const [r4, i4] of c3) t4.push(a2.getPage(r4).then(((t5) => {
          const a3 = new WorkerTask(`Save (editor): page ${r4}`);
          startWorkerTask(a3);
          return t5.saveNewAnnotations(u2, a3, i4, e4, s3).finally((function() {
            finishWorkerTask(a3);
          }));
        })));
        null === y2 ? o3.push(Promise.all(t4).then((async () => {
          await StructTreeRoot.createStructureTree({ newAnnotationsByPage: c3, xref: g2, catalogRef: b2, pdfManager: a2, changes: s3 });
        }))) : y2 && o3.push(Promise.all(t4).then((async () => {
          await y2.updateStructureTree({ newAnnotationsByPage: c3, pdfManager: a2, changes: s3 });
        })));
      }
      if (e3) o3.push(a2.ensureDoc("serializeXfaData", [r3]));
      else for (let e4 = 0; e4 < t3; e4++) o3.push(a2.getPage(e4).then((function(t4) {
        const a3 = new WorkerTask(`Save: page ${e4}`);
        startWorkerTask(a3);
        return t4.save(u2, a3, r3, s3).finally((function() {
          finishWorkerTask(a3);
        }));
      })));
      const w2 = await Promise.all(o3);
      let x2 = null;
      if (e3) {
        x2 = w2[0];
        if (!x2) return l3.bytes;
      } else if (0 === s3.size) return l3.bytes;
      const S2 = d2 && h3 instanceof Dict && s3.values().some(((e4) => e4.needAppearances)), k2 = h3 instanceof Dict && h3.get("XFA") || null;
      let C2 = null, v2 = false;
      if (Array.isArray(k2)) {
        for (let e4 = 0, t4 = k2.length; e4 < t4; e4 += 2) if ("datasets" === k2[e4]) {
          C2 = k2[e4 + 1];
          v2 = true;
        }
        null === C2 && (C2 = g2.getNewTemporaryRef());
      } else k2 && warn("Unsupported XFA type.");
      let F2 = /* @__PURE__ */ Object.create(null);
      if (g2.trailer) {
        const e4 = /* @__PURE__ */ new Map(), t4 = g2.trailer.get("Info") || null;
        if (t4 instanceof Dict) for (const [a3, r4] of t4) "string" == typeof r4 && e4.set(a3, stringToPDFString(r4));
        F2 = { rootRef: b2, encryptRef: g2.trailer.getRaw("Encrypt") || null, newRef: g2.getNewTemporaryRef(), infoRef: g2.trailer.getRaw("Info") || null, infoMap: e4, fileIds: g2.trailer.get("ID") || null, startXRef: p2 ? f2 : g2.lastXRefStreamPos ?? f2, filename: i3 };
      }
      return incrementalUpdate({ originalData: l3.bytes, xrefInfo: F2, changes: s3, xref: g2, hasXfa: !!k2, xfaDatasetsRef: C2, hasXfaDatasetsEntry: v2, needAppearances: S2, acroFormRef: d2, acroForm: h3, xfaData: x2, useXrefStream: isDict(g2.topDict, "XRef") }).finally((() => {
        g2.resetNewTemporaryRef();
      }));
    }));
    u2.on("GetOperatorList", (function(e3, t3) {
      const r3 = e3.pageIndex;
      a2.getPage(r3).then((function(a3) {
        const i3 = new WorkerTask(`GetOperatorList: page ${r3}`);
        startWorkerTask(i3);
        const n3 = s2 >= Ae ? Date.now() : 0;
        a3.getOperatorList({ handler: u2, sink: t3, task: i3, intent: e3.intent, cacheKey: e3.cacheKey, annotationStorage: e3.annotationStorage, modifiedIds: e3.modifiedIds }).then((function(e4) {
          finishWorkerTask(i3);
          n3 && info(`page=${r3 + 1} - getOperatorList: time=${Date.now() - n3}ms, len=${e4.length}`);
          t3.close();
        }), (function(e4) {
          finishWorkerTask(i3);
          i3.terminated || t3.error(e4);
        }));
      }));
    }));
    u2.on("GetTextContent", (function(e3, t3) {
      const { pageIndex: r3, includeMarkedContent: i3, disableNormalization: n3 } = e3;
      a2.getPage(r3).then((function(e4) {
        const a3 = new WorkerTask("GetTextContent: page " + r3);
        startWorkerTask(a3);
        const o3 = s2 >= Ae ? Date.now() : 0;
        e4.extractTextContent({ handler: u2, task: a3, sink: t3, includeMarkedContent: i3, disableNormalization: n3 }).then((function() {
          finishWorkerTask(a3);
          o3 && info(`page=${r3 + 1} - getTextContent: time=` + (Date.now() - o3) + "ms");
          t3.close();
        }), (function(e5) {
          finishWorkerTask(a3);
          a3.terminated || t3.error(e5);
        }));
      }));
    }));
    u2.on("GetStructTree", (function(e3) {
      return a2.getPage(e3.pageIndex).then(((e4) => a2.ensure(e4, "getStructTree")));
    }));
    u2.on("FontFallback", (function(e3) {
      return a2.fontFallback(e3.id, u2);
    }));
    u2.on("Cleanup", (function(e3) {
      return a2.cleanup(true);
    }));
    u2.on("Terminate", (function(e3) {
      r2 = true;
      const t3 = [];
      if (a2) {
        a2.terminate(new AbortException("Worker was terminated."));
        const e4 = a2.cleanup();
        t3.push(e4);
        a2 = null;
      } else clearGlobalCaches();
      i2?.(new AbortException("Worker was terminated."));
      for (const e4 of n2) {
        t3.push(e4.finished);
        e4.terminate();
      }
      return Promise.all(t3).then((function() {
        u2.destroy();
        u2 = null;
      }));
    }));
    u2.on("Ready", (function(t3) {
      setupDoc(e2);
      e2 = null;
    }));
    return h2;
  }
  static initializeFromPort(e2) {
    const t2 = new MessageHandler("worker", "main", e2);
    this.setup(t2, e2);
    t2.send("ready", null);
  }
};
"undefined" == typeof window && !e && "undefined" != typeof self && "function" == typeof self.postMessage && "onmessage" in self && _WorkerMessageHandler.initializeFromPort(self);
var WorkerMessageHandler = _WorkerMessageHandler;
globalThis.pdfjsWorker = { WorkerMessageHandler };
export {
  WorkerMessageHandler
};
//# sourceMappingURL=pdfjs-dist_build_pdf__worker__min__mjs.js.map
